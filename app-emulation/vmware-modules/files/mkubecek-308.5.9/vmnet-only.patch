--- a/vmnet-only/bridge.c	2022-07-20 18:06:05.030334001 +0300
+++ b/vmnet-only/bridge.c	2022-07-19 23:13:22.489742082 +0300
@@ -65,7 +65,7 @@
 #endif
 
 #if LOGLEVEL >= 4
-static struct timeval vnetTime;
+static u64 vnetTime;
 #endif
 
 typedef struct VNetBridge VNetBridge;
@@ -636,7 +636,7 @@
 	 unsigned long flags;
 	 int i;
 
-	 refcount_inc(&clone->users);
+	 clone = skb_get(clone);
 
 	 clone->dev = dev;
 	 clone->protocol = eth_type_trans(clone, dev);
@@ -694,9 +694,9 @@
           * not do it, or netif_rx_ni() will deadlock on the cli() lock --hpreg
           */
 
-	 netif_rx_ni(clone);
+	 compat_netif_rx_ni(clone);
 #	 if LOGLEVEL >= 4
-	 do_gettimeofday(&vnetTime);
+	 vnetTime = ktime_get_ns();
 #	 endif
       }
    }
@@ -813,10 +813,14 @@
 {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 22)
 #  if defined(CONFIG_WIRELESS_EXT)
-   return dev->ieee80211_ptr != NULL || dev->wireless_handlers != NULL;
-#  else
-   return dev->ieee80211_ptr != NULL;
+   if (dev->wireless_handlers)
+      return true;
 #  endif
+#  if IS_ENABLED(CONFIG_CFG80211)
+   if (dev->ieee80211_ptr)
+      return true;
+#  endif
+   return false;
 #elif defined(CONFIG_WIRELESS_EXT)
    return dev->wireless_handlers != NULL;
 #elif !defined(CONFIG_NET_RADIO)
@@ -1661,12 +1665,11 @@
 
 #  if LOGLEVEL >= 4
    {
-      struct timeval now;
-      do_gettimeofday(&now);
+      u64 now;
+
+      now = ktime_get_ns();
       LOG(3, (KERN_DEBUG "bridge-%s: time %d\n",
-	      bridge->name,
-	      (int)((now.tv_sec * 1000000 + now.tv_usec)
-                    - (vnetTime.tv_sec * 1000000 + vnetTime.tv_usec))));
+	      bridge->name, (int)((now - vnetTime) / NSEC_PER_USEC)));
    }
 #  endif
 
--- a/vmnet-only/compat_compiler.h	1970-01-01 03:00:00.000000000 +0300
+++ b/vmnet-only/compat_compiler.h	2022-07-19 23:13:22.489742082 +0300
@@ -0,0 +1,15 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __COMPAT_COMPILER_H__
+#define __COMPAT_COMPILER_H__
+
+#ifndef fallthrough
+#ifndef __has_attribute
+	#define fallthrough do {} while (0)
+#elif __has_attribute(__fallthrough__)
+	#define fallthrough __attribute__((__fallthrough__))
+#else
+	#define fallthrough do {} while (0)
+#endif /* __has_attribute */
+#endif /* fallthrough */
+
+#endif /* __COMPAT_COMPILER_H__ */
--- a/vmnet-only/compat_mmap_lock.h	1970-01-01 03:00:00.000000000 +0300
+++ b/vmnet-only/compat_mmap_lock.h	2022-07-19 23:13:22.489742082 +0300
@@ -0,0 +1,34 @@
+#ifndef __COMPAT_MMAP_LOCK_H__
+#define __COMPAT_MMAP_LOCK_H__
+
+#include <linux/mm.h>
+
+/*
+ * In 5.8-rc1, mmap locking was reworked to use wrappers around mmap_sem
+ * (which was also renamed to mmap_lock). All code is now supposed to use
+ * these wrappers as the internal implementation of the lock may change in
+ * the future.
+ *
+ * Check also _LINUX_MMAP_LOCK_H to handle possible backports to distribution
+ * pre-5.8 kernel. This macro is defined in <linux/mmap_lock.h> which is also
+ * included in <linux/mm.h> since the commit introducing the wrappers so that
+ * we should have it defined in any kernel providing the new API.
+ */
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 8, 0)) || defined(_LINUX_MMAP_LOCK_H)
+#include <linux/mmap_lock.h>
+#else
+
+static inline void mmap_read_lock(struct mm_struct *mm)
+{
+	down_read(&mm->mmap_sem);
+}
+
+static inline void mmap_read_unlock(struct mm_struct *mm)
+{
+	up_read(&mm->mmap_sem);
+}
+
+#endif /* 5.8.0 */
+
+#endif /* __COMPAT_MMAP_LOCK_H__ */
--- a/vmnet-only/compat_netdevice.h	2022-07-20 18:06:03.123650207 +0300
+++ b/vmnet-only/compat_netdevice.h	2022-07-19 23:13:22.489742082 +0300
@@ -48,19 +48,6 @@
 #   define net_device device
 #endif
 
-/* it looks like these have been removed from the kernel 3.1
- * probably because the "transition" is considered complete.
- * so to keep this source compatible we just redefine them like they were
- * previously
- */
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 1, 0)
-#define HAVE_ALLOC_NETDEV		/* feature macro: alloc_xxxdev
-					   functions are available. */
-#define HAVE_FREE_NETDEV		/* free_netdev() */
-#define HAVE_NETDEV_PRIV		/* netdev_priv() */
-#define HAVE_NETIF_QUEUE
-#define HAVE_NET_DEVICE_OPS
-#endif
 
 /*
  * SET_MODULE_OWNER appeared sometime during 2.3.x. It was setting
@@ -357,4 +344,13 @@
 #define compat_netif_trans_update(d) do { (d)->trans_start = jiffies; } while (0)
 #endif
 
+static inline int compat_netif_rx_ni(struct sk_buff *skb)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 18, 0)
+	return netif_rx(skb);
+#else
+	return netif_rx_ni(skb);
+#endif
+}
+
 #endif /* __COMPAT_NETDEVICE_H__ */
--- a/vmnet-only/driver.c	2018-01-09 10:13:22.000000000 +0300
+++ b/vmnet-only/driver.c	2022-07-19 23:13:22.489742082 +0300
@@ -38,6 +38,7 @@
 #include "compat_sock.h"
 #include <linux/kdev_t.h>
 #include <linux/mutex.h>
+#include "compat_compiler.h"
 
 #define __KERNEL_SYSCALLS__
 #include <asm/io.h>
@@ -971,7 +972,7 @@
          }
          /* Should we require verFromUser == VNET_API_VERSION? */
       }
-      /* fall thru */
+      fallthrough;
 
    case SIOCGETAPIVERSION:
       retval = put_user(VNET_API_VERSION, (uint32 *)ioarg) ?  -EFAULT : 0;
--- a/vmnet-only/hub.c	2018-01-09 10:13:21.000000000 +0300
+++ b/vmnet-only/hub.c	2022-07-19 23:13:22.489742082 +0300
@@ -234,7 +234,7 @@
  */
 
 VNetJack *
-VNetHub_AllocPvn(uint8 id[]) // IN: the PVN ID to alloc on
+VNetHub_AllocPvn(uint8 id[VNET_PVN_ID_LEN]) // IN: the PVN ID to alloc on
 {
    return VNetHubAlloc(TRUE, -1, id);
 }
@@ -258,7 +258,7 @@
 VNetJack *
 VNetHubAlloc(Bool allocPvn, // IN: TRUE for PVN, FALSE for vnet
 	     int hubNum,    // IN: vnet # to use (-1 if allocPvn == TRUE)
-	     uint8 id[])    // IN: PVN ID to use (NULL if allocPvn == FALSE)
+	     uint8 id[VNET_PVN_ID_LEN])    // IN: PVN ID to use (NULL if allocPvn == FALSE)
 {
    VNetHub *hub;
    VNetJack *jack;
--- a/vmnet-only/Makefile	2022-07-20 18:06:03.013649219 +0300
+++ b/vmnet-only/Makefile	2022-07-19 23:13:22.489742082 +0300
@@ -49,10 +49,10 @@
 ifdef LINUXINCLUDE
 HEADER_DIR = $(LINUXINCLUDE)
 else
-HEADER_DIR = $(KERNEL_DIR)
+HEADER_DIR = /lib/modules/$(VM_UNAME)/build/include
 endif
 
-BUILD_DIR = $(KBUILD_OUTPUT)
+BUILD_DIR = $(HEADER_DIR)/..
 
 DRIVER := vmnet
 PRODUCT := @@PRODUCT@@
@@ -106,8 +106,6 @@
 VM_CC := $(CC)
 export VM_CC
 
-MAKEOVERRIDES := $(filter-out CC=%,$(MAKEOVERRIDES))
-
 #
 # Define a setup target that gets built before the actual driver.
 # This target may not be used at all, but if it is then it will be defined
--- a/vmnet-only/Makefile.kernel	2022-07-20 18:06:03.076983121 +0300
+++ b/vmnet-only/Makefile.kernel	2022-07-19 23:13:22.489742082 +0300
@@ -19,7 +19,7 @@
 
 INCLUDE := -I$(SRCROOT)
 
-EXTRA_CFLAGS := $(CC_OPTS) $(INCLUDE) $(LINUXINCLUDE)
+EXTRA_CFLAGS := $(CC_OPTS) $(INCLUDE)
 EXTRA_CFLAGS += $(call vm_check_build, $(SRCROOT)/netdev_has_net.c,-DVMW_NETDEV_HAS_NET, )
 EXTRA_CFLAGS += $(call vm_check_build, $(SRCROOT)/netdev_has_dev_net.c,-DVMW_NETDEV_HAS_DEV_NET, )
 EXTRA_CFLAGS += $(call vm_check_build, $(SRCROOT)/nfhook_uses_skb.c,-DVMW_NFHOOK_USES_SKB, )
@@ -35,6 +35,6 @@
 ####
 
 clean:
-	rm -rf $(DRIVER).o $(DRIVER).mod.o $(DRIVER).mod.c $(DRIVER).ko \
+	rm -rf $(DRIVER).o $(DRIVER).mod.o $(DRIVER).mod.c $(DRIVER).ko .cache.mk \
 	       .tmp_versions Module.symvers Modules.symvers Module.markers \
 	       modules.order $($(DRIVER)-y) .*.cmd .*.o.flags
--- a/vmnet-only/netif.c	2018-01-09 10:13:21.000000000 +0300
+++ b/vmnet-only/netif.c	2022-07-19 23:13:22.493075446 +0300
@@ -65,6 +65,19 @@
 static int  VNetNetIfProcRead(char *page, char **start, off_t off,
                               int count, int *eof, void *data);
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 0)
+static void
+__dev_addr_set(struct net_device *dev, const void *addr, size_t len)
+{
+	memcpy(dev->dev_addr, addr, len);
+}
+
+static void dev_addr_set(struct net_device *dev, const u8 *addr)
+{
+	__dev_addr_set(dev, addr, dev->addr_len);
+}
+#endif
+
 /*
  *----------------------------------------------------------------------
  *
@@ -219,7 +232,7 @@
 
    memset(&netIf->stats, 0, sizeof netIf->stats);
 
-   memcpy(dev->dev_addr, netIf->port.paddr, sizeof netIf->port.paddr);
+   __dev_addr_set(dev, netIf->port.paddr, sizeof(netIf->port.paddr));
 
    if (register_netdev(dev) != 0) {
       LOG(0, (KERN_NOTICE "%s: could not register network device\n",
@@ -311,7 +324,7 @@
    /* send to the host interface */
    skb->dev = netIf->dev;
    skb->protocol = eth_type_trans(skb, netIf->dev);
-   netif_rx_ni(skb);
+   compat_netif_rx_ni(skb);
    netIf->stats.rx_packets++;
 
    return;
@@ -498,7 +511,7 @@
       return -EINVAL;
    }
    memcpy(netIf->port.paddr, addr->sa_data, dev->addr_len);
-   memcpy(dev->dev_addr, addr->sa_data, dev->addr_len);
+   dev_addr_set(dev, addr->sa_data);
    return 0;
 }
 
--- a/vmnet-only/procfs.c	2022-07-20 18:06:05.773674012 +0300
+++ b/vmnet-only/procfs.c	2022-07-19 23:13:22.493075446 +0300
@@ -137,6 +137,7 @@
 }
 
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 18, 0)
 /*
  *----------------------------------------------------------------------
  *
@@ -161,20 +162,21 @@
 }
 
 /* Our procfs callbacks.  We only need to specialize open. */
-#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 6, 0)
+#ifdef DEFINE_PROC_SHOW_ATTRIBUTE
+static const struct proc_ops fops = {
+   .proc_open    = VNetProcOpen,
+   .proc_read    = seq_read,
+   .proc_lseek   = seq_lseek,
+   .proc_release = single_release,
+};
+#else
 static struct file_operations fops = {
    .open    = VNetProcOpen,
    .read    = seq_read,
    .llseek  = seq_lseek,
    .release = single_release,
 };
-#else
-static struct proc_ops fops = {
-   .proc_open    = VNetProcOpen,
-   .proc_read    = seq_read,
-   .proc_lseek   = seq_lseek,
-   .proc_release = single_release,
-};
+#endif
 #endif
 #endif
 
@@ -212,7 +214,12 @@
       } else {
          ent->data   = data;
          ent->fn     = fn;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 18, 0)
+         ent->pde    = proc_create_single_data(name, mode, parent->pde,
+                                               VNetProcShow, ent);
+#else
          ent->pde    = proc_create_data(name, mode, parent->pde, &fops, ent);
+#endif
       }
       if (ent->pde != NULL) {
          *ret = ent;
--- a/vmnet-only/smac.c	2018-01-09 10:13:21.000000000 +0300
+++ b/vmnet-only/smac.c	2022-07-19 23:13:22.493075446 +0300
@@ -4119,7 +4119,7 @@
 
 void SMACINT
 SMAC_SetMac(SMACState *state,  // IN: state to update
-	    uint8 *mac)        // IN: pointer to host adapter's MAC
+	    const uint8 *mac)  // IN: pointer to host adapter's MAC
 {
    VNETKdPrintCall(("SMAC_SetMac"));
    ASSERT(state);
--- a/vmnet-only/smac.h	2018-01-09 10:13:21.000000000 +0300
+++ b/vmnet-only/smac.h	2022-07-19 23:13:22.493075446 +0300
@@ -72,7 +72,7 @@
 void SMACINT
 SMAC_InitState(struct SMACState **ptr);           // IN: state to alloc/init
 void SMACINT
-SMAC_SetMac(struct SMACState *state, uint8 *mac); // IN: state, and host MAC
+SMAC_SetMac(struct SMACState *state, const uint8 *mac); // IN: state, and host MAC
 void SMACINT
 SMAC_CleanupState(struct SMACState **ptr);        // IN: state to cleanup/dealloc
 
--- a/vmnet-only/userif.c	2022-07-20 18:06:05.723673563 +0300
+++ b/vmnet-only/userif.c	2022-07-19 23:13:22.493075446 +0300
@@ -47,6 +47,7 @@
 
 #include "vnetInt.h"
 #include "compat_skbuff.h"
+#include "compat_mmap_lock.h"
 #include "vmnetInt.h"
 #include "vm_atomic.h"
 #include "vm_assert.h"
@@ -84,16 +85,66 @@
 extern unsigned int  vnet_max_qlen;
 
 #if COMPAT_LINUX_VERSION_CHECK_LT(3, 2, 0)
-#   define compat_kmap(page) kmap(page)
-#   define compat_kunmap(page) kunmap(page)
-#elif COMPAT_LINUX_VERSION_CHECK_LT(5, 4, 0)
-#   define compat_kmap(page) kmap((page).p)
-#   define compat_kunmap(page) kunmap((page).p)
+#   define compat_kmap_frag(frag) kmap((frag)->page)
+#   define compat_kunmap_frag(page) kunmap((frag)->page)
 #else
-#   define compat_kmap(page) kmap(page)
-#   define compat_kunmap(page) kunmap(page)
+#   define compat_kmap_frag(frag) kmap(skb_frag_page(frag))
+#   define compat_kunmap_frag(frag) kunmap(skb_frag_page(frag))
 #endif
 
+static unsigned int compat_skb_frag_size(const skb_frag_t *frag)
+{
+#if COMPAT_LINUX_VERSION_CHECK_LT(3, 2, 0)
+	return frag->size;
+#else
+	return skb_frag_size(frag);
+#endif
+}
+
+static unsigned int compat_skb_frag_off(const skb_frag_t *frag)
+{
+#if COMPAT_LINUX_VERSION_CHECK_LT(5, 4, 0) && \
+	!(defined(CONFIG_SUSE_VERSION) && CONFIG_SUSE_VERSION == 15 && \
+	  defined(CONFIG_SUSE_PATCHLEVEL) && CONFIG_SUSE_PATCHLEVEL >= 2)
+	return frag->page_offset;
+#else
+	return skb_frag_off(frag);
+#endif
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 0, 0) && defined(VERIFY_WRITE)
+	#define write_access_ok(addr, size) access_ok(VERIFY_WRITE, addr, size)
+#else
+	#define write_access_ok(addr, size) access_ok(addr, size)
+#endif
+
+#if COMPAT_LINUX_VERSION_CHECK_LT(5, 10, 0)
+static inline unsigned int
+compat_csum_and_copy_to_user(const void *src, void __user *dst, int len,
+			     int *err)
+{
+	return csum_and_copy_to_user(src, dst, len, 0, err);
+}
+#else
+static inline unsigned int
+compat_csum_and_copy_to_user(const void *src, void __user *dst, int len,
+			     int *err)
+{
+	unsigned int csum;
+
+#if COMPAT_LINUX_VERSION_CHECK_LT(5, 19, 0)
+	csum = csum_and_copy_to_user(src, dst, len);
+#else
+	csum = csum_partial(src, len, ~0U);
+	if (copy_to_user(dst, src, len))
+		csum = 0;
+#endif /* 5.19 */
+
+	*err = (csum == 0 ? -EFAULT : 0);
+	return csum;
+}
+#endif /* 5.10 */
+
 /*
  *-----------------------------------------------------------------------------
  *
@@ -118,7 +169,7 @@
    struct page *page = NULL;
    int retval;
 
-   down_read(&current->mm->mmap_sem);
+   mmap_read_lock(current->mm);
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0)
    retval = get_user_pages(addr, 1, FOLL_WRITE, &page, NULL);
 #elif LINUX_VERSION_CODE >= KERNEL_VERSION(4, 6, 0)
@@ -127,7 +178,7 @@
    retval = get_user_pages(current, current->mm, addr,
                            1, 1, 0, &page, NULL);
 #endif
-   up_read(&current->mm->mmap_sem);
+   mmap_read_unlock(current->mm);
 
    if (retval != 1) {
       return NULL;
@@ -160,11 +211,7 @@
                  struct page **p, // OUT: locked page
                  void **ptr)      // OUT: kernel mapped pointer
 {
-#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 0, 0)
-   if (!access_ok(VERIFY_WRITE, (void *)uAddr, size) ||
-#else
-   if (!access_ok((void *)uAddr, size) ||
-#endif
+   if (!write_access_ok((void *)uAddr, size) ||
        (((uAddr + size - 1) & ~(PAGE_SIZE - 1)) !=
         (uAddr & ~(PAGE_SIZE - 1)))) {
       return -EINVAL;
@@ -592,7 +639,7 @@
       return -EINVAL;
    }
 
-   csum = csum_and_copy_to_user(skb->data + offset, curr, len, 0, &err);
+   csum = compat_csum_and_copy_to_user(skb->data + offset, curr, len, &err);
    if (err) {
       return err;
    }
@@ -601,35 +648,21 @@
    for (frag = skb_shinfo(skb)->frags;
 	frag != skb_shinfo(skb)->frags + skb_shinfo(skb)->nr_frags;
 	frag++) {
-#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0)
-      if (frag->size > 0) {
-#else
-      if (skb_frag_size(frag) > 0) {
-#endif
+      if (compat_skb_frag_size(frag) > 0) {
 	 unsigned int tmpCsum;
 	 const void *vaddr;
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0)
-	 vaddr = compat_kmap(frag->page);
-	 tmpCsum = csum_and_copy_to_user(vaddr + frag->page_offset,
-					 curr, frag->size, 0, &err);
-	 compat_kunmap(frag->page);
-#else
-	 vaddr = compat_kmap(skb_frag_page(frag));
-	 tmpCsum = csum_and_copy_to_user(vaddr + skb_frag_off(frag),
-					 curr, skb_frag_size(frag), 0, &err);
-	 compat_kunmap(skb_frag_page(frag));
-#endif
+	 vaddr = compat_kmap_frag(frag);
+	 tmpCsum = compat_csum_and_copy_to_user(vaddr + compat_skb_frag_off(frag),
+						curr, compat_skb_frag_size(frag),
+						&err);
+	 compat_kunmap_frag(frag);
 
 	 if (err) {
 	    return err;
 	 }
 	 csum = csum_block_add(csum, tmpCsum, curr - buf);
-#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0)
-	 curr += frag->size;
-#else
-	 curr += skb_frag_size(frag);
-#endif
+	 curr += compat_skb_frag_size(frag);
       }
    }
 
--- a/vmnet-only/vm_device_version.h	2022-07-20 18:06:03.710322144 +0300
+++ b/vmnet-only/vm_device_version.h	2022-07-19 23:13:22.493075446 +0300
@@ -35,6 +35,8 @@
 #endif
 #endif
 
+#include <linux/pci_ids.h>
+
 /* LSILogic 53C1030 Parallel SCSI controller
  * LSILogic SAS1068 SAS controller
  */
@@ -53,9 +55,10 @@
  *    VMware HD Audio codec
  *    VMware HD Audio controller
  */
-#ifndef PCI_VENDOR_ID_VMWARE                    
+#ifndef PCI_VENDOR_ID_VMWARE
 #define PCI_VENDOR_ID_VMWARE                    0x15AD
 #endif
+
 #define PCI_DEVICE_ID_VMWARE_SVGA2              0x0405
 #define PCI_DEVICE_ID_VMWARE_SVGA               0x0710
 #define PCI_DEVICE_ID_VMWARE_VGA                0x0711
@@ -72,7 +75,11 @@
 #define PCI_DEVICE_ID_VMWARE_1394               0x0780
 #define PCI_DEVICE_ID_VMWARE_BRIDGE             0x0790
 #define PCI_DEVICE_ID_VMWARE_ROOTPORT           0x07A0
+
+#ifndef PCI_DEVICE_ID_VMWARE_VMXNET3
 #define PCI_DEVICE_ID_VMWARE_VMXNET3            0x07B0
+#endif
+
 #define PCI_DEVICE_ID_VMWARE_PVSCSI             0x07C0
 #define PCI_DEVICE_ID_VMWARE_82574              0x07D0
 #define PCI_DEVICE_ID_VMWARE_AHCI               0x07E0
--- a/vmnet-only/vmnetInt.h	2022-07-20 18:06:04.256993721 +0300
+++ b/vmnet-only/vmnetInt.h	2022-07-19 23:12:04.082355989 +0300
@@ -82,7 +82,7 @@
                                                 PF_NETLINK, _pri, &vmnet_proto, 1)
 #elif defined(VMW_NETDEV_HAS_NET)
 #   define compat_sk_alloc(_bri, _pri) sk_alloc(&init_net, \
-                                                PF_NETLINK, _pri, &vmnet_proto, 0)
+                                                PF_NETLINK, _pri, &vmnet_proto)
 #else
 #   define compat_sk_alloc(_bri, _pri) sk_alloc(PF_NETLINK, _pri, &vmnet_proto, 1)
 #endif
