From 0494120fbbbb46a27e889e2f30de0fbf544c9daa Mon Sep 17 00:00:00 2001
From: JaimeIvanCervantes <jimmycc80@hotmail.com>
Date: Thu, 15 Jun 2017 11:50:24 -0700
Subject: [PATCH] multi_convolution: Fix for incorrect template parameter type
 when using unsigned int N for TinyVector SIZE. Using int M instead. (Fixes
 #414)

---
 include/vigra/multi_convolution.hxx | 56 ++++++++++++++---------------
 1 file changed, 28 insertions(+), 28 deletions(-)

diff --git a/include/vigra/multi_convolution.hxx b/include/vigra/multi_convolution.hxx
index 1b5efa740..d282955c0 100644
--- a/include/vigra/multi_convolution.hxx
+++ b/include/vigra/multi_convolution.hxx
@@ -1422,28 +1422,28 @@ gaussianSmoothMultiArray(MultiArrayView<N, T1, S1> const & source,
     \code
     namespace vigra {
         // pass filter scale explicitly
-        template <unsigned int N, class T1, class S1,
+        template <unsigned int N, int M, class T1, class S1,
                   class T2, class S2>
         void
         gaussianGradientMultiArray(MultiArrayView<N, T1, S1> const & source,
-                                   MultiArrayView<N, TinyVector<T2, N>, S2> dest,
+                                   MultiArrayView<N, TinyVector<T2, M>, S2> dest,
                                    double sigma,
                                    ConvolutionOptions<N> opt = ConvolutionOptions<N>());
 
         // pass filter scale(s) in option object
-        template <unsigned int N, class T1, class S1,
+        template <unsigned int N, int M, class T1, class S1,
                                   class T2, class S2>
         void
         gaussianGradientMultiArray(MultiArrayView<N, T1, S1> const & source,
-                                   MultiArrayView<N, TinyVector<T2, N>, S2> dest,
+                                   MultiArrayView<N, TinyVector<T2, M>, S2> dest,
                                    ConvolutionOptions<N> opt);
 
         // likewise, but execute algorithm in parallel
-        template <unsigned int N, class T1, class S1,
+        template <unsigned int N, int M, class T1, class S1,
                                   class T2, class S2>
         void
         gaussianGradientMultiArray(MultiArrayView<N, T1, S1> const & source,
-                                   MultiArrayView<N, TinyVector<T2, N>, S2> dest,
+                                   MultiArrayView<N, TinyVector<T2, M>, S2> dest,
                                    BlockwiseConvolutionOptions<N> opt);
     }
     \endcode
@@ -1586,11 +1586,11 @@ gaussianGradientMultiArray(triple<SrcIterator, SrcShape, SrcAccessor> const & so
                                 dest.first, dest.second, sigma, opt );
 }
 
-template <unsigned int N, class T1, class S1,
+template <unsigned int N, int M, class T1, class S1,
                           class T2, class S2>
 inline void
 gaussianGradientMultiArray(MultiArrayView<N, T1, S1> const & source,
-                           MultiArrayView<N, TinyVector<T2, N>, S2> dest,
+                           MultiArrayView<N, TinyVector<T2, M>, S2> dest,
                            ConvolutionOptions<N> opt )
 {
     if(opt.to_point != typename MultiArrayShape<N>::type())
@@ -1610,11 +1610,11 @@ gaussianGradientMultiArray(MultiArrayView<N, T1, S1> const & source,
                                 destMultiArray(dest), opt );
 }
 
-template <unsigned int N, class T1, class S1,
+template <unsigned int N, int M, class T1, class S1,
           class T2, class S2>
 inline void
 gaussianGradientMultiArray(MultiArrayView<N, T1, S1> const & source,
-                           MultiArrayView<N, TinyVector<T2, N>, S2> dest,
+                           MultiArrayView<N, TinyVector<T2, M>, S2> dest,
                            double sigma,
                            ConvolutionOptions<N> opt = ConvolutionOptions<N>())
 {
@@ -1629,7 +1629,7 @@ gaussianGradientMultiArray(MultiArrayView<N, T1, S1> const & source,
 
 namespace detail {
 
-template <unsigned int N, class T1, class S1,
+template <unsigned int N, int M, class T1, class S1,
                           class T2, class S2>
 void
 gaussianGradientMagnitudeImpl(MultiArrayView<N+1, T1, S1> const & src,
@@ -1653,7 +1653,7 @@ gaussianGradientMagnitudeImpl(MultiArrayView<N+1, T1, S1> const & src,
     dest.init(0.0);
 
     typedef typename NumericTraits<T1>::RealPromote TmpType;
-    MultiArray<N, TinyVector<TmpType, N> > grad(dest.shape());
+    MultiArray<N, TinyVector<TmpType, M> > grad(dest.shape());
 
     using namespace multi_math;
 
@@ -1767,19 +1767,19 @@ gaussianGradientMagnitude(MultiArrayView<N+1, Multiband<T1>, S1> const & src,
     \code
     namespace vigra {
         // execute algorithm sequentially
-        template <unsigned int N, class T1, class S1,
+        template <unsigned int N, int M, class T1, class S1,
                                   class T2, class S2>
         void
         symmetricGradientMultiArray(MultiArrayView<N, T1, S1> const & source,
-                                    MultiArrayView<N, TinyVector<T2, N>, S2> dest,
+                                    MultiArrayView<N, TinyVector<T2, M>, S2> dest,
                                     ConvolutionOptions<N> opt = ConvolutionOptions<N>());
 
         // execute algorithm in parallel
-        template <unsigned int N, class T1, class S1,
+        template <unsigned int N, int M, class T1, class S1,
                                   class T2, class S2>
         void
         symmetricGradientMultiArray(MultiArrayView<N, T1, S1> const & source,
-                                    MultiArrayView<N, TinyVector<T2, N>, S2> dest,
+                                    MultiArrayView<N, TinyVector<T2, M>, S2> dest,
                                     BlockwiseConvolutionOptions<N> opt);
     }
     \endcode
@@ -1891,11 +1891,11 @@ symmetricGradientMultiArray(triple<SrcIterator, SrcShape, SrcAccessor> const & s
                                 dest.first, dest.second, opt);
 }
 
-template <unsigned int N, class T1, class S1,
+template <unsigned int N, int M, class T1, class S1,
                           class T2, class S2>
 inline void
 symmetricGradientMultiArray(MultiArrayView<N, T1, S1> const & source,
-                            MultiArrayView<N, TinyVector<T2, N>, S2> dest,
+                            MultiArrayView<N, TinyVector<T2, M>, S2> dest,
                             ConvolutionOptions<N> opt = ConvolutionOptions<N>())
 {
     if(opt.to_point != typename MultiArrayShape<N>::type())
@@ -2211,27 +2211,27 @@ laplacianOfGaussianMultiArray(MultiArrayView<N, T1, S1> const & source,
                                      ConvolutionOptions<N> opt = ConvolutionOptions<N>());
 
         // pass input vector field as an array of vectors
-        template <unsigned int N, class T1, class S1,
+        template <unsigned int N, int M, class T1, class S1,
                                   class T2, class S2>
         void
-        gaussianDivergenceMultiArray(MultiArrayView<N, TinyVector<T1, N>, S1> const & vectorField,
+        gaussianDivergenceMultiArray(MultiArrayView<N, TinyVector<T1, M>, S1> const & vectorField,
                                      MultiArrayView<N, T2, S2> divergence,
                                      ConvolutionOptions<N> const & opt);
 
-        template <unsigned int N, class T1, class S1,
+        template <unsigned int N, int M, class T1, class S1,
                                   class T2, class S2>
         void
-        gaussianDivergenceMultiArray(MultiArrayView<N, TinyVector<T1, N>, S1> const & vectorField,
+        gaussianDivergenceMultiArray(MultiArrayView<N, TinyVector<T1, M>, S1> const & vectorField,
                                      MultiArrayView<N, T2, S2> divergence,
                                      double sigma,
                                      ConvolutionOptions<N> opt = ConvolutionOptions<N>());
 
         // pass input vector field as an array of vectors and
         // execute algorithm in parallel
-        template <unsigned int N, class T1, class S1,
+        template <unsigned int N, int M, class T1, class S1,
                                   class T2, class S2>
         void
-        gaussianDivergenceMultiArray(MultiArrayView<N, TinyVector<T1, N>, S1> const & vectorField,
+        gaussianDivergenceMultiArray(MultiArrayView<N, TinyVector<T1, M>, S1> const & vectorField,
                                      MultiArrayView<N, T2, S2> divergence,
                                      BlockwiseConvolutionOptions<N> const & opt);
     }
@@ -2321,10 +2321,10 @@ gaussianDivergenceMultiArray(Iterator vectorField, Iterator vectorFieldEnd,
     gaussianDivergenceMultiArray(vectorField, vectorFieldEnd, divergence, opt.stdDev(sigma));
 }
 
-template <unsigned int N, class T1, class S1,
+template <unsigned int N, int M, class T1, class S1,
                           class T2, class S2>
 inline void
-gaussianDivergenceMultiArray(MultiArrayView<N, TinyVector<T1, N>, S1> const & vectorField,
+gaussianDivergenceMultiArray(MultiArrayView<N, TinyVector<T1, M>, S1> const & vectorField,
                              MultiArrayView<N, T2, S2> divergence,
                              ConvolutionOptions<N> const & opt)
 {
@@ -2335,10 +2335,10 @@ gaussianDivergenceMultiArray(MultiArrayView<N, TinyVector<T1, N>, S1> const & ve
     gaussianDivergenceMultiArray(field.begin(), field.end(), divergence, opt);
 }
 
-template <unsigned int N, class T1, class S1,
+template <unsigned int N, int M, class T1, class S1,
                           class T2, class S2>
 inline void
-gaussianDivergenceMultiArray(MultiArrayView<N, TinyVector<T1, N>, S1> const & vectorField,
+gaussianDivergenceMultiArray(MultiArrayView<N, TinyVector<T1, M>, S1> const & vectorField,
                              MultiArrayView<N, T2, S2> divergence,
                              double sigma,
                              ConvolutionOptions<N> opt = ConvolutionOptions<N>())
