--- a/.gitmodules	2023-04-24 18:52:26.000000000 -0000
+++ b/.gitmodules	2023-06-06 21:08:40.620000000 -0000
@@ -82,9 +82,6 @@
 [submodule "Telegram/ThirdParty/jemalloc"]
 	path = Telegram/ThirdParty/jemalloc
 	url = https://github.com/jemalloc/jemalloc
-[submodule "Telegram/ThirdParty/dispatch"]
-	path = Telegram/ThirdParty/dispatch
-	url = https://github.com/apple/swift-corelibs-libdispatch
 [submodule "Telegram/ThirdParty/plasma-wayland-protocols"]
 	path = Telegram/ThirdParty/plasma-wayland-protocols
 	url = https://github.com/KDE/plasma-wayland-protocols.git
--- a/Telegram/lib_crl/CMakeLists.txt	2023-02-08 09:17:40.000000000 -0000
+++ b/Telegram/lib_crl/CMakeLists.txt	2023-06-06 21:12:52.140000000 -0000
@@ -67,14 +67,14 @@
     ${src_loc}
 )
 
-if (TARGET desktop-app::external_dispatch)
+if (LINUX)
     target_link_libraries(lib_crl
     PUBLIC
-        desktop-app::external_dispatch
+        pthread
     )
 endif()
 
-if (build_macstore OR TARGET desktop-app::external_dispatch)
+if (build_macstore OR LINUX)
     target_compile_definitions(lib_crl
     PUBLIC
         CRL_USE_COMMON_QUEUE
--- a/Telegram/ThirdParty/dispatch/cmake/config.h.in	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/cmake/config.h.in	1970-01-01 00:00:00.000000000 -0000
@@ -1,259 +0,0 @@
-
-/* Define if building pthread work queues from source */
-#cmakedefine01 DISPATCH_USE_INTERNAL_WORKQUEUE
-
-/* Enable usage of thread local storage via _Thread_local */
-#cmakedefine01 DISPATCH_USE_THREAD_LOCAL_STORAGE
-
-/* Define to 1 if you have the declaration of `CLOCK_MONOTONIC', and to 0 if
-   you don't. */
-#cmakedefine01 HAVE_DECL_CLOCK_MONOTONIC
-
-/* Define to 1 if you have the declaration of `CLOCK_REALTIME', and to 0 if
-   you don't. */
-#cmakedefine01 HAVE_DECL_CLOCK_REALTIME
-
-/* Define to 1 if you have the declaration of `CLOCK_UPTIME', and to 0 if you
-   don't. */
-#cmakedefine01 HAVE_DECL_CLOCK_UPTIME
-
-/* Define to 1 if you have the declaration of `CLOCK_UPTIME_FAST', and to 0 if
-   you don't. */
-#cmakedefine01 HAVE_DECL_CLOCK_UPTIME_FAST
-
-/* Define to 1 if you have the declaration of `CLOCK_MONOTONIC_COARSE', and to
-   0 if you don't. */
-#cmakedefine01 HAVE_CLOCK_MONOTONIC_COARSE
-
-/* Define to 1 if you have the declaration of `FD_COPY', and to 0 if you
-   don't. */
-#cmakedefine01 HAVE_DECL_FD_COPY
-
-/* Define to 1 if you have the declaration of `NOTE_LOWAT', and to 0 if you
-   don't. */
-#cmakedefine01 HAVE_DECL_NOTE_LOWAT
-
-/* Define to 1 if you have the declaration of `NOTE_NONE', and to 0 if you
-   don't. */
-#cmakedefine01 HAVE_DECL_NOTE_NONE
-
-/* Define to 1 if you have the declaration of `NOTE_REAP', and to 0 if you
-   don't. */
-#cmakedefine01 HAVE_DECL_NOTE_REAP
-
-/* Define to 1 if you have the declaration of `NOTE_REVOKE', and to 0 if you
-   don't. */
-#cmakedefine01 HAVE_DECL_NOTE_REVOKE
-
-/* Define to 1 if you have the declaration of `NOTE_SIGNAL', and to 0 if you
-   don't. */
-#cmakedefine01 HAVE_DECL_NOTE_SIGNAL
-
-/* Define to 1 if you have the declaration of `POSIX_SPAWN_START_SUSPENDED',
-   and to 0 if you don't. */
-#cmakedefine01 HAVE_DECL_POSIX_SPAWN_START_SUSPENDED
-
-/* Define to 1 if you have the declaration of `program_invocation_short_name',
-   and to 0 if you don't. */
-#cmakedefine01 HAVE_DECL_PROGRAM_INVOCATION_SHORT_NAME
-
-/* Define to 1 if you have the declaration of `SIGEMT', and to 0 if you don't.
-   */
-#cmakedefine01 HAVE_DECL_SIGEMT
-
-/* Define to 1 if you have the declaration of `VQ_DESIRED_DISK', and to 0 if
-   you don't. */
-#cmakedefine01 HAVE_DECL_VQ_DESIRED_DISK
-
-/* Define to 1 if you have the declaration of `VQ_NEARLOWDISK', and to 0 if
-   you don't. */
-#cmakedefine01 HAVE_DECL_VQ_NEARLOWDISK
-
-/* Define to 1 if you have the declaration of `VQ_QUOTA', and to 0 if you
-   don't. */
-#cmakedefine01 HAVE_DECL_VQ_QUOTA
-
-/* Define to 1 if you have the declaration of `VQ_UPDATE', and to 0 if you
-   don't. */
-#cmakedefine01 HAVE_DECL_VQ_UPDATE
-
-/* Define to 1 if you have the declaration of `VQ_VERYLOWDISK', and to 0 if
-   you don't. */
-#cmakedefine01 HAVE_DECL_VQ_VERYLOWDISK
-
-/* Define to 1 if you have the declaration of `VQ_FREE_SPACE_CHANGE', and to 0 if
-   you don't. */
-#cmakedefine01 HAVE_DECL_VQ_FREE_SPACE_CHANGE
-
-/* Define to 1 if you have the <dlfcn.h> header file. */
-#cmakedefine01 HAVE_DLFCN_H
-
-/* Define to 1 if you have the <fcntl.h> header file. */
-#cmakedefine01 HAVE_FCNTL_H
-
-/* Define to 1 if you have the `getprogname' function. */
-#cmakedefine01 HAVE_GETPROGNAME
-
-/* Define to 1 if you have the <inttypes.h> header file. */
-#cmakedefine01 HAVE_INTTYPES_H
-
-/* Define if Apple leaks program is present */
-#cmakedefine HAVE_LEAKS
-
-/* Define to 1 if you have the <libkern/OSAtomic.h> header file. */
-#cmakedefine HAVE_LIBKERN_OSATOMIC_H
-
-/* Define to 1 if you have the <libkern/OSCrossEndian.h> header file. */
-#cmakedefine HAVE_LIBKERN_OSCROSSENDIAN_H
-
-/* Define to 1 if you have the <libproc_internal.h> header file. */
-#cmakedefine HAVE_LIBPROC_INTERNAL_H
-
-/* Define if mach is present */
-#cmakedefine HAVE_MACH
-
-/* Define to 1 if you have the `mach_absolute_time' function. */
-#cmakedefine HAVE_MACH_ABSOLUTE_TIME
-
-/* Define to 1 if you have the `mach_approximate_time' function. */
-#cmakedefine HAVE_MACH_APPROXIMATE_TIME
-
-/* Define to 1 if you have the `mach_port_construct' function. */
-#cmakedefine HAVE_MACH_PORT_CONSTRUCT
-
-/* Define to 1 if you have the `malloc_create_zone' function. */
-#cmakedefine HAVE_MALLOC_CREATE_ZONE
-
-/* Define to 1 if you have the <malloc/malloc.h> header file. */
-#cmakedefine HAVE_MALLOC_MALLOC_H
-
-/* Define to 1 if you have the <memory.h> header file. */
-#cmakedefine01 HAVE_MEMORY_H
-
-/* Define if __builtin_trap marked noreturn */
-#cmakedefine01 HAVE_NORETURN_BUILTIN_TRAP
-
-/* Define if you have the Objective-C runtime */
-#cmakedefine HAVE_OBJC
-
-/* Define to 1 if you have the `posix_fadvise' function. */
-#cmakedefine HAVE_POSIX_FADVISE
-
-/* Define to 1 if you have the `posix_spawnp' function. */
-#cmakedefine HAVE_POSIX_SPAWNP
-
-/* Define to 1 if you have the `pthread_key_init_np' function. */
-#cmakedefine HAVE_PTHREAD_KEY_INIT_NP
-
-/* Define to 1 if you have the `pthread_attr_setcpupercent_np' function. */
-#cmakedefine HAVE_PTHREAD_ATTR_SETCPUPERCENT_NP
-
-/* Define to 1 if you have the <pthread_machdep.h> header file. */
-#cmakedefine HAVE_PTHREAD_MACHDEP_H
-
-/* Define to 1 if you have the `pthread_main_np' function. */
-#cmakedefine01 HAVE_PTHREAD_MAIN_NP
-
-/* Define to 1 if you have the `pthread_yield_np' function. */
-#cmakedefine01 HAVE_PTHREAD_YIELD_NP
-
-/* Define to 1 if you have the <pthread_np.h> header file. */
-#cmakedefine01 HAVE_PTHREAD_NP_H
-
-/* Define to 1 if you have the <pthread/qos.h> header file. */
-#cmakedefine HAVE_PTHREAD_QOS_H
-
-/* Define if pthread work queues are present */
-#cmakedefine01 HAVE_PTHREAD_WORKQUEUES
-
-/* Define to 1 if you have the <pthread_workqueue.h> header file. */
-#cmakedefine HAVE_PTHREAD_WORKQUEUE_H
-
-/* Define to 1 if you have the <pthread/workqueue_private.h> header file. */
-#cmakedefine HAVE_PTHREAD_WORKQUEUE_PRIVATE_H
-
-/* Define to 1 if you have the <stdint.h> header file. */
-#cmakedefine01 HAVE_STDINT_H
-
-/* Define to 1 if you have the <stdlib.h> header file. */
-#cmakedefine01 HAVE_STDLIB_H
-
-/* Define to 1 if you have the <strings.h> header file. */
-#cmakedefine01 HAVE_STRINGS_H
-
-/* Define to 1 if you have the <string.h> header file. */
-#cmakedefine01 HAVE_STRING_H
-
-/* Define to 1 if you have the `strlcpy' function. */
-#cmakedefine01 HAVE_STRLCPY
-
-/* Define if building for Swift */
-#undef HAVE_SWIFT
-
-/* Define to 1 if you have the `sysconf' function. */
-#cmakedefine01 HAVE_SYSCONF
-
-/* Define to 1 if you have the <sys/guarded.h> header file. */
-#cmakedefine HAVE_SYS_GUARDED_H
-
-/* Define to 1 if you have the <sys/stat.h> header file. */
-#cmakedefine01 HAVE_SYS_STAT_H
-
-/* Define to 1 if you have the <sys/types.h> header file. */
-#cmakedefine01 HAVE_SYS_TYPES_H
-
-/* Define to 1 if you have the <TargetConditionals.h> header file. */
-#cmakedefine HAVE_TARGETCONDITIONALS_H
-
-/* Define to 1 if you have the `_pthread_workqueue_init' function. */
-#cmakedefine HAVE__PTHREAD_WORKQUEUE_INIT
-
-/* Define to use non-portable pthread TSD optimizations for Mac OS X) */
-#cmakedefine USE_APPLE_TSD_OPTIMIZATIONS
-
-/* Define to tag libdispatch_init as a constructor */
-#cmakedefine01 USE_LIBDISPATCH_INIT_CONSTRUCTOR
-
-/* Define to use Mach semaphores */
-#cmakedefine USE_MACH_SEM
-
-/* Define to use POSIX semaphores */
-#cmakedefine01 USE_POSIX_SEM
-
-/* Enable extensions on AIX 3, Interix.  */
-#ifndef _ALL_SOURCE
-#cmakedefine01 _ALL_SOURCE
-#endif
-/* Enable GNU extensions on systems that have them.  */
-#ifndef _GNU_SOURCE
-#cmakedefine _GNU_SOURCE
-#endif
-/* Enable threading extensions on Solaris.  */
-#ifndef _POSIX_PTHREAD_SEMANTICS
-#cmakedefine01 _POSIX_PTHREAD_SEMANTICS
-#endif
-/* Enable extensions on HP NonStop.  */
-#ifndef _TANDEM_SOURCE
-#cmakedefine01 _TANDEM_SOURCE
-#endif
-/* Enable general extensions on Solaris.  */
-#ifndef __EXTENSIONS__
-#cmakedefine01 __EXTENSIONS__
-#endif
-
-
-/* Version number of package */
-#define VERSION "${PROJECT_VERSION}"
-
-/* Define to 1 if on MINIX. */
-#cmakedefine _MINIX
-
-/* Define to 2 if the system does not provide POSIX.1 features except with
-   this defined. */
-#cmakedefine _POSIX_1_SOURCE
-
-/* Define to 1 if you need to in order for `stat' and other things to work. */
-#cmakedefine _POSIX_SOURCE
-
-/* Define if using Darwin $NOCANCEL */
-#cmakedefine __DARWIN_NON_CANCELABLE
--- a/Telegram/ThirdParty/dispatch/cmake/modules/ClangClCompileRules.cmake	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/cmake/modules/ClangClCompileRules.cmake	1970-01-01 00:00:00.000000000 -0000
@@ -1,5 +0,0 @@
-
-# clang-cl interprets paths starting with /U as macro undefines, so we need to
-# put a -- before the input file path to force it to be treated as a path.
-string(REPLACE "-c <SOURCE>" "-c -- <SOURCE>" CMAKE_C_COMPILE_OBJECT "${CMAKE_C_COMPILE_OBJECT}")
-string(REPLACE "-c <SOURCE>" "-c -- <SOURCE>" CMAKE_CXX_COMPILE_OBJECT "${CMAKE_CXX_COMPILE_OBJECT}")
--- a/Telegram/ThirdParty/dispatch/cmake/modules/CMakeLists.txt	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/cmake/modules/CMakeLists.txt	1970-01-01 00:00:00.000000000 -0000
@@ -1,7 +0,0 @@
-
-set(DISPATCH_EXPORTS_FILE ${CMAKE_CURRENT_BINARY_DIR}/dispatchExports.cmake)
-configure_file(dispatchConfig.cmake.in
-  ${CMAKE_CURRENT_BINARY_DIR}/dispatchConfig.cmake)
-
-get_property(DISPATCH_EXPORTS GLOBAL PROPERTY DISPATCH_EXPORTS)
-export(TARGETS ${DISPATCH_EXPORTS} FILE ${DISPATCH_EXPORTS_FILE})
--- a/Telegram/ThirdParty/dispatch/cmake/modules/DispatchAppleOptions.cmake	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/cmake/modules/DispatchAppleOptions.cmake	1970-01-01 00:00:00.000000000 -0000
@@ -1,43 +0,0 @@
-
-set(WITH_APPLE_PTHREAD_SOURCE "" CACHE PATH "Path to Apple's libpthread")
-set(WITH_APPLE_LIBPLATFORM_SOURCE "" CACHE PATH "Path to Apple's libplatform")
-set(WITH_APPLE_LIBCLOSURE_SOURCE "" CACHE PATH "Path to Apple's libclosure")
-set(WITH_APPLE_XNU_SOURCE "" CACHE PATH "Path to Apple's XNU")
-set(WITH_APPLE_OBJC4_SOURCE "" CACHE PATH "Path to Apple's ObjC4")
-
-if(WITH_APPLE_PTHREAD_SOURCE)
-  include_directories(SYSTEM "${WITH_APPLE_PTHREAD_SOURCE}")
-endif()
-if(WITH_APPLE_LIBPLATFORM_SOURCE)
-  include_directories(SYSTEM "${WITH_APPLE_LIBPLATFORM_SOURCE}/include")
-endif()
-if(WITH_APPLE_LIBCLOSURE_SOURCE)
-  include_directories(SYSTEM "${WITH_APPLE_LIBCLOSURE_SOURCE}")
-endif()
-if(WITH_APPLE_XNU_SOURCE)
-  # FIXME(compnerd) this should use -idirafter
-  include_directories("${WITH_APPLE_XNU_SOURCE}/libkern")
-  include_directories(SYSTEM
-                        "${WITH_APPLE_XNU_SOURCE}/bsd"
-                        "${WITH_APPLE_XNU_SOURCE}/libsyscall"
-                        "${WITH_APPLE_XNU_SOURCE}/libsyscall/wrappers/libproc")
-
-  # hack for xnu/bsd/sys/event.h EVFILT_SOCK declaration
-  add_definitions(-DPRIVATE=1)
-endif()
-
-if(IS_DIRECTORY "/System/Library/Frameworks/System.framework/PrivateHeaders")
-  include_directories(SYSTEM
-                        "/System/Library/Frameworks/System.framework/PrivateHeaders")
-endif()
-
-option(ENABLE_APPLE_TSD_OPTIMIZATIONS "use non-portable pthread TSD optimizations" OFF)
-if(ENABLE_APPLE_TSD_OPTIMIZATIONS)
-  set(USE_APPLE_TSD_OPTIMIZATIONS 1)
-else()
-  set(USE_APPLE_TSD_OPTIMIZATIONS 0)
-endif()
-
-# TODO(compnerd) link in libpthread headers
-
-
--- a/Telegram/ThirdParty/dispatch/cmake/modules/DispatchCompilerWarnings.cmake	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/cmake/modules/DispatchCompilerWarnings.cmake	1970-01-01 00:00:00.000000000 -0000
@@ -1,76 +0,0 @@
-
-if("${CMAKE_C_SIMULATE_ID}" STREQUAL "MSVC")
-  # TODO: someone needs to provide the msvc equivalent warning flags
-else()
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Werror>)
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wall>)
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wextra>)
-
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Warray-bounds-pointer-arithmetic>)
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wassign-enum>)
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Watomic-properties>)
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wcomma>)
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wconditional-uninitialized>)
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wconversion>)
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wcovered-switch-default>)
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wdate-time>)
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wdeprecated>)
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wdocumentation>)
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wdouble-promotion>)
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wduplicate-enum>)
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wexpansion-to-defined>)
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wfloat-equal>)
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Widiomatic-parentheses>)
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Winfinite-recursion>)
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wmissing-prototypes>)
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wnewline-eof>)
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wnullable-to-nonnull-conversion>)
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wobjc-interface-ivars>)
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wover-aligned>)
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wpacked>)
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wpointer-arith>)
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wselector>)
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wshadow>)
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wshorten-64-to-32>)
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wsign-conversion>)
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wstatic-in-inline>)
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wsuper-class-method-mismatch>)
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wswitch>)
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wunguarded-availability>)
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wunreachable-code>)
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wunused>)
-
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wno-unknown-warning-option>)
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wno-trigraphs>)
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wno-four-char-constants>)
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wno-disabled-macro-expansion>)
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wno-pedantic>)
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wno-bad-function-cast>)
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wno-c++-compat>)
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wno-c++98-compat>)
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wno-c++98-compat-pedantic>)
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wno-cast-align>)
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wno-cast-qual>)
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wno-documentation-unknown-command>)
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wno-format-nonliteral>)
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wno-missing-variable-declarations>)
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wno-old-style-cast>)
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wno-padded>)
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wno-reserved-id-macro>)
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wno-shift-sign-overflow>)
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wno-undef>)
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wno-unreachable-code-aggressive>)
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wno-unused-macros>)
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wno-used-but-marked-unused>)
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wno-void-pointer-to-int-cast>)
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wno-vla>)
-
-  if(CMAKE_SYSTEM_NAME STREQUAL Android)
-    add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wno-incompatible-function-pointer-types>)
-    add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wno-implicit-function-declaration>)
-    add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wno-conversion>)
-    add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wno-int-conversion>)
-    add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wno-shorten-64-to-32>)
-  endif()
-  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Wno-error=assign-enum>)
-endif()
--- a/Telegram/ThirdParty/dispatch/cmake/modules/dispatchConfig.cmake.in	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/cmake/modules/dispatchConfig.cmake.in	1970-01-01 00:00:00.000000000 -0000
@@ -1,7 +0,0 @@
-
-set(DISPATCH_HAS_SWIFT_SDK_OVERLAY @ENABLE_SWIFT@)
-
-if(NOT TARGET dispatch)
-  include(@DISPATCH_EXPORTS_FILE@)
-endif()
-
--- a/Telegram/ThirdParty/dispatch/cmake/modules/DispatchSanitization.cmake	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/cmake/modules/DispatchSanitization.cmake	1970-01-01 00:00:00.000000000 -0000
@@ -1,44 +0,0 @@
-
-set(DISPATCH_USE_SANITIZER "" CACHE STRING
-    "Define the sanitizer used to build binaries and tests.")
-
-if(CMAKE_SYSTEM_NAME STREQUAL Darwin AND DISPATCH_USE_SANITIZER)
-  message(FATAL_ERROR "building libdispatch with sanitization is not supported on Darwin")
-endif()
-
-if(DISPATCH_USE_SANITIZER)
-  # TODO(compnerd) ensure that the compiler supports these options before adding
-  # them.  At the moment, assume that this will just be used with a GNU
-  # compatible driver and that the options are spelt correctly in light of that.
-  add_compile_options("-fno-omit-frame-pointer")
-  if(CMAKE_BUILD_TYPE MATCHES "Debug")
-    add_compile_options("-O1")
-  elseif(NOT CMAKE_BUILD_TYPE MATCHES "Debug" AND
-         NOT CMAKE_BUILD_TYPE MATCHES "RelWithDebInfo")
-    add_compile_options("-gline-tables-only")
-  endif()
-
-  if(LLVM_USE_SANITIZER STREQUAL "Address")
-    add_compile_options("-fsanitize=address")
-  elseif(DISPATCH_USE_SANITIZER MATCHES "Memory(WithOrigins)?")
-    add_compile_options("-fsanitize=memory")
-    if(DISPATCH_USE_SANITIZER STREQUAL "MemoryWithOrigins")
-    add_compile_options("-fsanitize-memory-track-origins")
-    endif()
-  elseif(DISPATCH_USE_SANITIZER STREQUAL "Undefined")
-    add_compile_options("-fsanitize=undefined")
-    add_compile_options("-fno-sanitize=vptr,function")
-    add_compile_options("-fno-sanitize-recover=all")
-  elseif(DISPATCH_USE_SANITIZER STREQUAL "Thread")
-    add_compile_options("-fsanitize=thread")
-  elseif(DISPATCH_USE_SANITIZER STREQUAL "Address;Undefined" OR
-         DISPATCH_USE_SANITIZER STREQUAL "Undefined;Address")
-    add_compile_options("-fsanitize=address,undefined")
-    add_compile_options("-fno-sanitize=vptr,function")
-    add_compile_options("-fno-sanitize-recover=all")
-  elseif(DISPATCH_USE_SANITIZER STREQUAL "Leaks")
-    add_compile_options("-fsanitize=leak")
-  else()
-    message(FATAL_ERROR "unsupported value of DISPATCH_USE_SANITIZER: ${DISPATCH_USE_SANITIZER}")
-  endif()
-endif()
--- a/Telegram/ThirdParty/dispatch/cmake/modules/DispatchWindowsSupport.cmake	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/cmake/modules/DispatchWindowsSupport.cmake	1970-01-01 00:00:00.000000000 -0000
@@ -1,74 +0,0 @@
-
-function(dispatch_windows_arch_spelling arch var)
-  if(${arch} STREQUAL i686)
-    set(${var} x86 PARENT_SCOPE)
-  elseif(${arch} STREQUAL x86_64 OR ${arch} STREQUAL AMD64)
-    set(${var} x64 PARENT_SCOPE)
-  elseif(${arch} STREQUAL armv7)
-    set(${var} arm PARENT_SCOPE)
-  elseif(${arch} STREQUAL aarch64)
-    set(${var} arm64 PARENT_SCOPE)
-  else()
-    message(FATAL_ERROR "do not know MSVC spelling for ARCH: `${arch}`")
-  endif()
-endfunction()
-
-function(dispatch_verify_windows_environment_variables)
-  set(VCToolsInstallDir $ENV{VCToolsInstallDir})
-  set(UniversalCRTSdkDir $ENV{UniversalCRTSdkDir})
-  set(UCRTVersion $ENV{UCRTVersion})
-
-  if("${VCToolsInstallDir}" STREQUAL "")
-    message(SEND_ERROR "VCToolsInstallDir environment variable must be set")
-  endif()
-  if("${UniversalCRTSdkDir}" STREQUAL "")
-    message(SEND_ERROR "UniversalCRTSdkDir environment variable must be set")
-  endif()
-  if("${UCRTVersion}" STREQUAL "")
-    message(SEND_ERROR "UCRTVersion environment variable must be set")
-  endif()
-endfunction()
-
-function(dispatch_windows_include_for_arch arch var)
-  dispatch_verify_windows_environment_variables()
-
-  set(paths
-        "$ENV{VCToolsInstallDir}/include"
-        "$ENV{UniversalCRTSdkDir}/Include/$ENV{UCRTVersion}/ucrt"
-        "$ENV{UniversalCRTSdkDir}/Include/$ENV{UCRTVersion}/shared"
-        "$ENV{UniversalCRTSdkDir}/Include/$ENV{UCRTVersion}/um")
-  set(${var} ${paths} PARENT_SCOPE)
-endfunction()
-
-function(dispatch_windows_lib_for_arch arch var)
-  dispatch_verify_windows_environment_variables()
-  dispatch_windows_arch_spelling(${arch} ARCH)
-
-  set(paths)
-  if(${ARCH} STREQUAL x86)
-    list(APPEND paths "$ENV{VCToolsInstallDir}/Lib")
-  else()
-    list(APPEND paths "$ENV{VCToolsInstallDir}/Lib/${ARCH}")
-  endif()
-  list(APPEND paths
-          "$ENV{UniversalCRTSdkDir}/Lib/$ENV{UCRTVersion}/ucrt/${ARCH}"
-          "$ENV{UniversalCRTSdkDir}/Lib/$ENV{UCRTVersion}/um/${ARCH}")
-  set(${var} ${paths} PARENT_SCOPE)
-endfunction()
-
-function(dispatch_windows_generate_sdk_vfs_overlay flags)
-  dispatch_verify_windows_environment_variables()
-
-  get_filename_component(VCToolsInstallDir $ENV{VCToolsInstallDir} ABSOLUTE)
-  get_filename_component(UniversalCRTSdkDir $ENV{UniversalCRTSdkDir} ABSOLUTE)
-  set(UCRTVersion $ENV{UCRTVersion})
-
-  # TODO(compnerd) use a target to avoid re-creating this file all the time
-  configure_file("${PROJECT_SOURCE_DIR}/utils/WindowsSDKVFSOverlay.yaml.in"
-                 "${PROJECT_BINARY_DIR}/windows-sdk-vfs-overlay.yaml"
-                 @ONLY)
-
-  set(${flags}
-      -ivfsoverlay;"${PROJECT_BINARY_DIR}/windows-sdk-vfs-overlay.yaml"
-      PARENT_SCOPE)
-endfunction()
--- a/Telegram/ThirdParty/dispatch/cmake/modules/DTrace.cmake	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/cmake/modules/DTrace.cmake	1970-01-01 00:00:00.000000000 -0000
@@ -1,26 +0,0 @@
-
-function(dtrace_usdt_probe script)
-  set(options)
-  set(single_parameter_options TARGET_NAME OUTPUT_SOURCES)
-  set(multiple_parameter_options)
-
-  cmake_parse_arguments("" "${options}" "${single_parameter_options}" "${multiple_parameter_options}" ${ARGN})
-
-  get_filename_component(script_we ${script} NAME_WE)
-
-  add_custom_command(OUTPUT
-                       ${CMAKE_CURRENT_BINARY_DIR}/${script_we}.h
-                     COMMAND
-                       ${dtrace_EXECUTABLE} -h -s ${script} -o ${CMAKE_CURRENT_BINARY_DIR}/${script_we}.h
-                     DEPENDS
-                       ${script})
-  add_custom_target(dtrace-usdt-header-${script_we}
-                    DEPENDS
-                      ${CMAKE_CURRENT_BINARY_DIR}/${script_we}.h)
-  if(_TARGET_NAME)
-    set(${_TARGET_NAME} dtrace-usdt-header-${script_we} PARENT_SCOPE)
-  endif()
-  if(_OUTPUT_SOURCES)
-    set(${_OUTPUT_SOURCES} ${CMAKE_CURRENT_BINARY_DIR}/${script_we}.h PARENT_SCOPE)
-  endif()
-endfunction()
--- a/Telegram/ThirdParty/dispatch/cmake/modules/FindBlocksRuntime.cmake	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/cmake/modules/FindBlocksRuntime.cmake	1970-01-01 00:00:00.000000000 -0000
@@ -1,48 +0,0 @@
-#.rst:
-# FindBlocksRuntime
-# -----------------
-#
-# Find libBlocksRuntime library and headers.
-#
-# The module defines the following variables:
-#
-# ##
-#
-# BlocksRuntime_FOUND        - true if libBlocksRuntime was found
-# BlocksRuntime_INCLUDE_DIR  - include search path
-# BlocksRuntime_LIBRARIES    - libraries to link
-
-if(BlocksRuntime_INCLUDE_DIR AND BlocksRuntime_LIBRARIES)
-  set(BlocksRuntime_FOUND TRUE)
-else()
-  find_path(BlocksRuntime_INCLUDE_DIR
-            NAMES
-              Blocks.h
-            HINTS
-              ${CMAKE_INSTALL_FULL_INCLUDEDIR})
-  find_library(BlocksRuntime_LIBRARIES
-               NAMES
-                 BlocksRuntime libBlocksRuntime
-               HINTS
-                 ${CMAKE_INSTALL_FULL_LIBDIR})
-
-  include(FindPackageHandleStandardArgs)
-  find_package_handle_standard_args(BlocksRuntime
-                                    REQUIRED_VARS
-                                      BlocksRuntime_LIBRARIES
-                                      BlocksRuntime_INCLUDE_DIR)
-
-  mark_as_advanced(BlocksRuntime_LIBRARIES BlocksRuntime_INCLUDE_DIR)
-endif()
-
-if(BlocksRuntime_FOUND)
-  if(NOT TARGET BlocksRuntime::BlocksRuntime)
-    add_library(BlocksRuntime::BlocksRuntime UNKNOWN IMPORTED)
-    set_target_properties(BlocksRuntime::BlocksRuntime
-                          PROPERTIES
-                            IMPORTED_LOCATION
-                              ${BlocksRuntime_LIBRARIES}
-                            INTERFACE_INCLUDE_DIRECTORIES
-                              ${BlocksRuntime_INCLUDE_DIR})
-  endif()
-endif()
--- a/Telegram/ThirdParty/dispatch/cmake/modules/FindLibRT.cmake	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/cmake/modules/FindLibRT.cmake	1970-01-01 00:00:00.000000000 -0000
@@ -1,39 +0,0 @@
-#.rst:
-# FindLibRT
-# ---------
-#
-# Find librt library and headers.
-#
-# The mdoule defines the following variables:
-#
-# ::
-#
-# LibRT_FOUND       - true if librt was found
-# LibRT_INCLUDE_DIR - include search path
-# LibRT_LIBRARIES   - libraries to link
-
-if(UNIX)
-  find_path(LibRT_INCLUDE_DIR
-            NAMES
-              time.h)
-  find_library(LibRT_LIBRARIES rt)
-
-  include(FindPackageHandleStandardArgs)
-  find_package_handle_standard_args(LibRT
-                                    REQUIRED_VARS
-                                      LibRT_LIBRARIES
-                                      LibRT_INCLUDE_DIR)
-
-  if(LibRT_FOUND)
-    if(NOT TARGET RT::rt)
-      add_library(RT::rt UNKNOWN IMPORTED)
-      set_target_properties(RT::rt
-                            PROPERTIES
-                              IMPORTED_LOCATION ${LibRT_LIBRARIES}
-                              INTERFACE_INCLUDE_DIRECTORIES ${LibRT_INCLUDE_DIR})
-    endif()
-  endif()
-
-  mark_as_advanced(LibRT_LIBRARIES LibRT_INCLUDE_DIR)
-endif()
-
--- a/Telegram/ThirdParty/dispatch/cmake/modules/SwiftSupport.cmake	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/cmake/modules/SwiftSupport.cmake	1970-01-01 00:00:00.000000000 -0000
@@ -1,41 +0,0 @@
-
-# Returns the current achitecture name in a variable
-#
-# Usage:
-#   get_swift_host_arch(result_var_name)
-#
-# If the current architecture is supported by Swift, sets ${result_var_name}
-# with the sanitized host architecture name derived from CMAKE_SYSTEM_PROCESSOR.
-function(get_swift_host_arch result_var_name)
-  if("${CMAKE_SYSTEM_PROCESSOR}" STREQUAL "x86_64")
-    set("${result_var_name}" "x86_64" PARENT_SCOPE)
-  elseif ("${CMAKE_SYSTEM_PROCESSOR}" MATCHES "AArch64|aarch64|arm64")
-    if(CMAKE_SYSTEM_NAME MATCHES Darwin)
-      set("${result_var_name}" "arm64" PARENT_SCOPE)
-    else()
-      set("${result_var_name}" "aarch64" PARENT_SCOPE)
-    endif()
-  elseif("${CMAKE_SYSTEM_PROCESSOR}" STREQUAL "ppc64")
-    set("${result_var_name}" "powerpc64" PARENT_SCOPE)
-  elseif("${CMAKE_SYSTEM_PROCESSOR}" STREQUAL "ppc64le")
-    set("${result_var_name}" "powerpc64le" PARENT_SCOPE)
-  elseif("${CMAKE_SYSTEM_PROCESSOR}" STREQUAL "s390x")
-    set("${result_var_name}" "s390x" PARENT_SCOPE)
-  elseif("${CMAKE_SYSTEM_PROCESSOR}" STREQUAL "armv6l")
-    set("${result_var_name}" "armv6" PARENT_SCOPE)
-  elseif("${CMAKE_SYSTEM_PROCESSOR}" STREQUAL "armv7-a")
-    set("${result_var_name}" "armv7" PARENT_SCOPE)
-  elseif("${CMAKE_SYSTEM_PROCESSOR}" STREQUAL "armv7l")
-    set("${result_var_name}" "armv7" PARENT_SCOPE)
-  elseif("${CMAKE_SYSTEM_PROCESSOR}" STREQUAL "AMD64")
-    set("${result_var_name}" "x86_64" PARENT_SCOPE)
-  elseif("${CMAKE_SYSTEM_PROCESSOR}" STREQUAL "IA64")
-    set("${result_var_name}" "itanium" PARENT_SCOPE)
-  elseif("${CMAKE_SYSTEM_PROCESSOR}" STREQUAL "x86")
-    set("${result_var_name}" "i686" PARENT_SCOPE)
-  elseif("${CMAKE_SYSTEM_PROCESSOR}" STREQUAL "i686")
-    set("${result_var_name}" "i686" PARENT_SCOPE)
-  else()
-    message(FATAL_ERROR "Unrecognized architecture on host system: ${CMAKE_SYSTEM_PROCESSOR}")
-  endif()
-endfunction()
--- a/Telegram/ThirdParty/dispatch/CMakeLists.txt	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/CMakeLists.txt	1970-01-01 00:00:00.000000000 -0000
@@ -1,312 +0,0 @@
-
-cmake_minimum_required(VERSION 3.15.1)
-
-list(APPEND CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/cmake/modules)
-
-# NOTE(compnerd) enable CMP0091 - select MSVC runtime based on
-# CMAKE_MSVC_RUNTIME_LIBRARY.  Requires CMake 3.15 or newer.
-if(POLICY CMP0091)
-  cmake_policy(SET CMP0091 NEW)
-endif()
-
-project(dispatch
-  VERSION 1.3
-  LANGUAGES C CXX)
-
-if("${CMAKE_C_SIMULATE_ID}" STREQUAL "MSVC")
-  include(ClangClCompileRules)
-endif()
-
-if(CMAKE_SYSTEM_NAME STREQUAL Windows)
-  include(DispatchWindowsSupport)
-  dispatch_windows_arch_spelling(${CMAKE_SYSTEM_PROCESSOR} DISPATCH_MSVC_ARCH)
-  dispatch_windows_include_for_arch(${DISPATCH_MSVC_ARCH} DISPATCH_INCLUDES)
-  include_directories(BEFORE SYSTEM ${DISPATCH_INCLUDES})
-  dispatch_windows_lib_for_arch(${CMAKE_SYSTEM_PROCESSOR} DISPATCH_LIBDIR)
-  link_directories(${DISPATCH_LIBDIR})
-
-  include(CheckCSourceCompiles)
-  check_c_source_compiles([=[
-#include <Windows.h>
-int main(int argc, char *argv[]) {
-  switch ((LOGICAL_PROCESSOR_RELATIONSHIP)0) {
-  case RelationProcessorDie:
-  case RelationNumaNodeEx:
-    return 0;
-  }
-  return 0;
-}
-]=] DISPATCH_HAVE_EXTENDED_SLPI_20348)
-  if(DISPATCH_HAVE_EXTENDED_SLPI_20348)
-    add_compile_definitions(DISPATCH_HAVE_EXTENDED_SLPI_20348)
-  endif()
-
-  check_c_source_compiles([=[
-#include <Windows.h>
-int main(int argc, char *argv[]) {
-  switch ((LOGICAL_PROCESSOR_RELATIONSHIP)0) {
-  case RelationProcessorModule:
-    return 0;
-  }
-  return 0;
-}
-]=] DISPATCH_HAVE_EXTENDED_SLPI_22000)
-  if(DISPATCH_HAVE_EXTENDED_SLPI_22000)
-    add_compile_definitions(DISPATCH_HAVE_EXTENDED_SLPI_22000)
-  endif()
-endif()
-
-set(CMAKE_C_STANDARD 11)
-set(CMAKE_C_STANDARD_REQUIRED YES)
-
-set(CMAKE_CXX_STANDARD 11)
-
-set(CMAKE_C_VISIBILITY_PRESET hidden)
-set(CMAKE_C_VISIBILITY_INLINES_HIDDEN YES)
-
-# NOTE(compnerd) this is a horrible workaround for Windows to ensure that the
-# tests can run as there is no rpath equivalent and `PATH` is used to lookup the
-# libraries.
-set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR})
-set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR})
-
-set(CMAKE_THREAD_PREFER_PTHREAD TRUE)
-set(THREADS_PREFER_PTHREAD_FLAG TRUE)
-find_package(Threads REQUIRED)
-
-include(CheckCCompilerFlag)
-include(CheckCSourceCompiles)
-include(CheckFunctionExists)
-include(CheckIncludeFiles)
-include(CheckLibraryExists)
-include(CheckSymbolExists)
-include(GNUInstallDirs)
-include(CTest)
-
-include(DispatchAppleOptions)
-include(DispatchSanitization)
-include(DispatchCompilerWarnings)
-include(DTrace)
-include(SwiftSupport)
-
-# NOTE(abdulras) this is the CMake supported way to control whether we generate
-# shared or static libraries.  This impacts the behaviour of `add_library` in
-# what type of library it generates.
-option(BUILD_SHARED_LIBS "build shared libraries" ON)
-
-option(DISPATCH_ENABLE_ASSERTS "enable debug assertions" FALSE)
-
-option(ENABLE_DISPATCH_INIT_CONSTRUCTOR "enable libdispatch_init as a constructor" ON)
-set(USE_LIBDISPATCH_INIT_CONSTRUCTOR ${ENABLE_DISPATCH_INIT_CONSTRUCTOR})
-
-option(ENABLE_DTRACE "enable dtrace support" "")
-
-if(CMAKE_SYSTEM_NAME STREQUAL Darwin OR CMAKE_SYSTEM_NAME STREQUAL FreeBSD)
-  set(ENABLE_INTERNAL_PTHREAD_WORKQUEUES_DEFAULT OFF)
-else()
-  set(ENABLE_INTERNAL_PTHREAD_WORKQUEUES_DEFAULT ON)
-endif()
-option(ENABLE_INTERNAL_PTHREAD_WORKQUEUES "use libdispatch's own implementation of pthread workqueues" ${ENABLE_INTERNAL_PTHREAD_WORKQUEUES_DEFAULT})
-if(ENABLE_INTERNAL_PTHREAD_WORKQUEUES)
-  set(DISPATCH_USE_INTERNAL_WORKQUEUE 1)
-  set(HAVE_PTHREAD_WORKQUEUES 0)
-else()
-  check_include_files(pthread/workqueue_private.h HAVE_PTHREAD_WORKQUEUE_PRIVATE_H)
-  if(HAVE_PTHREAD_WORKQUEUE_PRIVATE_H)
-    set(HAVE_PTHREAD_WORKQUEUES 1)
-    set(DISPATCH_USE_INTERNAL_WORKQUEUE 0)
-  else()
-    set(HAVE_PTHREAD_WORKQUEUES 0)
-    set(DISPATCH_USE_INTERNAL_WORKQUEUE 1)
-  endif()
-endif()
-
-option(INSTALL_PRIVATE_HEADERS "installs private headers in the same location as the public ones" OFF)
-
-option(ENABLE_SWIFT "enable libdispatch swift overlay" OFF)
-if(ENABLE_SWIFT)
-  enable_language(Swift)
-endif()
-
-option(ENABLE_THREAD_LOCAL_STORAGE "enable usage of thread local storage via _Thread_local" ON)
-set(DISPATCH_USE_THREAD_LOCAL_STORAGE ${ENABLE_THREAD_LOCAL_STORAGE})
-
-
-check_symbol_exists(__GNU_LIBRARY__ "features.h" _GNU_SOURCE)
-if(_GNU_SOURCE)
-  set(CMAKE_REQUIRED_DEFINITIONS ${CMAKE_REQUIRED_DEFINITIONS} -D_GNU_SOURCE)
-endif()
-
-check_c_source_compiles("void __attribute__((__noreturn__)) main() { __builtin_trap(); }"
-                        __BUILTIN_TRAP)
-if(__BUILTIN_TRAP)
-  set(HAVE_NORETURN_BUILTIN_TRAP 1)
-endif()
-
-if(NOT CMAKE_SYSTEM_NAME STREQUAL Android)
-  find_package(LibRT)
-endif()
-
-check_function_exists(_pthread_workqueue_init HAVE__PTHREAD_WORKQUEUE_INIT)
-check_function_exists(getprogname HAVE_GETPROGNAME)
-check_function_exists(mach_absolute_time HAVE_MACH_ABSOLUTE_TIME)
-check_function_exists(mach_approximate_time HAVE_MACH_APPROXIMATE_TIME)
-check_function_exists(mach_port_construct HAVE_MACH_PORT_CONSTRUCT)
-check_function_exists(malloc_create_zone HAVE_MALLOC_CREATE_ZONE)
-check_function_exists(posix_fadvise HAVE_POSIX_FADVISE)
-check_function_exists(posix_spawnp HAVE_POSIX_SPAWNP)
-check_function_exists(pthread_key_init_np HAVE_PTHREAD_KEY_INIT_NP)
-check_function_exists(pthread_attr_setcpupercent_np HAVE_PTHREAD_ATTR_SETCPUPERCENT_NP)
-check_function_exists(pthread_yield_np HAVE_PTHREAD_YIELD_NP)
-check_function_exists(pthread_main_np HAVE_PTHREAD_MAIN_NP)
-check_function_exists(pthread_workqueue_setdispatch_np HAVE_PTHREAD_WORKQUEUE_SETDISPATCH_NP)
-check_function_exists(strlcpy HAVE_STRLCPY)
-check_function_exists(sysconf HAVE_SYSCONF)
-check_function_exists(arc4random HAVE_ARC4RANDOM)
-
-check_include_files("TargetConditionals.h" HAVE_TARGETCONDITIONALS_H)
-check_include_files("dlfcn.h" HAVE_DLFCN_H)
-check_include_files("fcntl.h" HAVE_FCNTL_H)
-check_include_files("inttypes.h" HAVE_INTTYPES_H)
-check_include_files("libkern/OSAtomic.h" HAVE_LIBKERN_OSATOMIC_H)
-check_include_files("libkern/OSCrossEndian.h" HAVE_LIBKERN_OSCROSSENDIAN_H)
-check_include_files("libproc_internal.h" HAVE_LIBPROC_INTERNAL_H)
-check_include_files("mach/mach.h" HAVE_MACH)
-if(HAVE_MACH)
-  set(__DARWIN_NON_CANCELABLE 1)
-else()
-  set(__DARWIN_NON_CANCELABLE 0)
-endif()
-check_include_files("malloc/malloc.h" HAVE_MALLOC_MALLOC_H)
-check_include_files("memory.h" HAVE_MEMORY_H)
-check_include_files("pthread/qos.h" HAVE_PTHREAD_QOS_H)
-check_include_files("pthread/workqueue_private.h" HAVE_PTHREAD_WORKQUEUE_PRIVATE_H)
-check_include_files("pthread_machdep.h" HAVE_PTHREAD_MACHDEP_H)
-check_include_files("pthread_np.h" HAVE_PTHREAD_NP_H)
-check_include_files("pthread_workqueue.h" HAVE_PTHREAD_WORKQUEUE_H)
-check_include_files("stdint.h" HAVE_STDINT_H)
-check_include_files("stdlib.h" HAVE_STDLIB_H)
-check_include_files("string.h" HAVE_STRING_H)
-check_include_files("strings.h" HAVE_STRINGS_H)
-check_include_files("sys/guarded.h" HAVE_SYS_GUARDED_H)
-check_include_files("sys/stat.h" HAVE_SYS_STAT_H)
-check_include_files("sys/types.h" HAVE_SYS_TYPES_H)
-check_include_files("objc/objc-internal.h" HAVE_OBJC)
-
-if(HAVE_MACH)
-  set(USE_MACH_SEM 1)
-else()
-  set(USE_MACH_SEM 0)
-endif()
-if(CMAKE_SYSTEM_NAME STREQUAL Windows)
-  add_compile_definitions($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:USE_WIN32_SEM>)
-endif()
-check_library_exists(pthread sem_init "" USE_POSIX_SEM)
-# NOTE: android has not always provided a libpthread, but uses the pthreads API
-if(CMAKE_SYSTEM_NAME STREQUAL Android)
-  set(USE_POSIX_SEM 1)
-endif()
-
-check_symbol_exists(CLOCK_UPTIME "time.h" HAVE_DECL_CLOCK_UPTIME)
-check_symbol_exists(CLOCK_UPTIME_FAST "time.h" HAVE_DECL_CLOCK_UPTIME_FAST)
-check_symbol_exists(CLOCK_MONOTONIC "time.h" HAVE_DECL_CLOCK_MONOTONIC)
-check_symbol_exists(CLOCK_REALTIME "time.h" HAVE_DECL_CLOCK_REALTIME)
-check_symbol_exists(CLOCK_MONOTONIC_COARSE "time.h" HAVE_DECL_CLOCK_MONOTONIC_COARSE)
-check_symbol_exists(FD_COPY "sys/select.h" HAVE_DECL_FD_COPY)
-check_symbol_exists(NOTE_LOWAT "sys/event.h" HAVE_DECL_NOTE_LOWAT)
-check_symbol_exists(NOTE_NONE "sys/event.h" HAVE_DECL_NOTE_NONE)
-check_symbol_exists(NOTE_REAP "sys/event.h" HAVE_DECL_NOTE_REAP)
-check_symbol_exists(NOTE_REVOKE "sys/event.h" HAVE_DECL_NOTE_REVOKE)
-check_symbol_exists(NOTE_SIGNAL "sys/event.h" HAVE_DECL_NOTE_SIGNAL)
-check_symbol_exists(POSIX_SPAWN_START_SUSPENDED "sys/spawn.h" HAVE_DECL_POSIX_SPAWN_START_SUSPENDED)
-check_symbol_exists(SIGEMT "signal.h" HAVE_DECL_SIGEMT)
-check_symbol_exists(VQ_DESIRED_DISK "sys/mount.h" HAVE_DECL_VQ_DESIRED_DISK)
-check_symbol_exists(VQ_NEARLOWDISK "sys/mount.h" HAVE_DECL_VQ_NEARLOWDISK)
-check_symbol_exists(VQ_QUOTA "sys/mount.h" HAVE_DECL_VQ_QUOTA)
-check_symbol_exists(VQ_UPDATE "sys/mount.h" HAVE_DECL_VQ_UPDATE)
-check_symbol_exists(VQ_VERYLOWDISK "sys/mount.h" HAVE_DECL_VQ_VERYLOWDISK)
-check_symbol_exists(VQ_FREE_SPACE_CHANGE "sys/mount.h" HAVE_DECL_VQ_FREE_SPACE_CHANGE)
-check_symbol_exists(strlcpy "string.h" HAVE_STRLCPY)
-check_symbol_exists(program_invocation_name "errno.h" HAVE_DECL_PROGRAM_INVOCATION_SHORT_NAME)
-if (HAVE_DECL_PROGRAM_INVOCATION_SHORT_NAME)
-  add_compile_definitions($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:_GNU_SOURCE=1>)
-endif()
-check_symbol_exists(__printflike "bsd/sys/cdefs.h" HAVE_PRINTFLIKE)
-
-if(CMAKE_SYSTEM_NAME STREQUAL Android)
-  set(ENABLE_DTRACE_DEFAULT OFF)
-endif()
-
-if(CMAKE_SYSTEM_NAME STREQUAL FreeBSD)
-  add_compile_definitions($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:_WITH_DPRINTF>)
-endif()
-
-if(ENABLE_DTRACE)
-  find_program(dtrace_EXECUTABLE dtrace)
-  if(NOT dtrace_EXECUTABLE AND NOT ENABLE_DTRACE STREQUAL "")
-    message(FATAL_ERROR "dtrace not found but explicitly requested")
-  endif()
-endif()
-
-if(dtrace_EXECUTABLE)
-  add_compile_definitions($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:DISPATCH_USE_DTRACE=1>)
-else()
-  add_compile_definitions($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:DISPATCH_USE_DTRACE=0>)
-endif()
-
-find_program(leaks_EXECUTABLE leaks)
-if(leaks_EXECUTABLE)
-  set(HAVE_LEAKS TRUE)
-endif()
-
-
-if(CMAKE_SYSTEM_NAME STREQUAL Darwin)
-  add_custom_command(OUTPUT
-                       "${PROJECT_SOURCE_DIR}/dispatch/module.modulemap"
-                       "${PROJECT_SOURCE_DIR}/private/module.modulemap"
-                     COMMAND
-                       ${CMAKE_COMMAND} -E copy_if_different "${PROJECT_SOURCE_DIR}/dispatch/darwin/module.modulemap" "${PROJECT_SOURCE_DIR}/dispatch/module.modulemap"
-                     COMMAND
-                       ${CMAKE_COMMAND} -E copy_if_different "${PROJECT_SOURCE_DIR}/private/darwin/module.modulemap" "${PROJECT_SOURCE_DIR}/private/module.modulemap")
-else()
-  add_custom_command(OUTPUT
-                       "${PROJECT_SOURCE_DIR}/dispatch/module.modulemap"
-                       "${PROJECT_SOURCE_DIR}/private/module.modulemap"
-                     COMMAND
-                       ${CMAKE_COMMAND} -E copy_if_different "${PROJECT_SOURCE_DIR}/dispatch/generic/module.modulemap" "${PROJECT_SOURCE_DIR}/dispatch/module.modulemap"
-                     COMMAND
-                       ${CMAKE_COMMAND} -E copy_if_different "${PROJECT_SOURCE_DIR}/private/generic/module.modulemap" "${PROJECT_SOURCE_DIR}/private/module.modulemap")
-endif()
-add_custom_target(module-maps ALL
-                  DEPENDS
-                     "${PROJECT_SOURCE_DIR}/dispatch/module.modulemap"
-                     "${PROJECT_SOURCE_DIR}/private/module.modulemap")
-
-configure_file("${PROJECT_SOURCE_DIR}/cmake/config.h.in"
-               "${PROJECT_BINARY_DIR}/config/config_ac.h")
-add_compile_definitions($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:HAVE_CONFIG_H>)
-
-
-if(ENABLE_SWIFT)
-  set(INSTALL_TARGET_DIR "${CMAKE_INSTALL_LIBDIR}/swift$<$<NOT:$<BOOL:${BUILD_SHARED_LIBS}>>:_static>/$<LOWER_CASE:${CMAKE_SYSTEM_NAME}>" CACHE PATH "Path where the libraries will be installed")
-  set(INSTALL_DISPATCH_HEADERS_DIR "${CMAKE_INSTALL_LIBDIR}/swift$<$<NOT:$<BOOL:${BUILD_SHARED_LIBS}>>:_static>/dispatch" CACHE PATH "Path where the headers will be installed for libdispatch")
-  set(INSTALL_BLOCK_HEADERS_DIR "${CMAKE_INSTALL_LIBDIR}/swift$<$<NOT:$<BOOL:${BUILD_SHARED_LIBS}>>:_static>/Block" CACHE PATH "Path where the headers will be installed for the blocks runtime")
-  set(INSTALL_OS_HEADERS_DIR "${CMAKE_INSTALL_LIBDIR}/swift$<$<NOT:$<BOOL:${BUILD_SHARED_LIBS}>>:_static>/os" CACHE PATH "Path where the os/ headers will be installed")
-else()
-  set(INSTALL_TARGET_DIR "${CMAKE_INSTALL_LIBDIR}" CACHE PATH "Path where the libraries will be installed")
-  set(INSTALL_DISPATCH_HEADERS_DIR "include/dispatch" CACHE PATH "Path where the headers will be installed")
-  set(INSTALL_BLOCK_HEADERS_DIR "include" CACHE PATH "Path where the headers will be installed for the blocks runtime")
-  set(INSTALL_OS_HEADERS_DIR "include/os" CACHE PATH "Path where the headers will be installed")
-endif()
-
-
-add_subdirectory(dispatch)
-add_subdirectory(man)
-add_subdirectory(os)
-add_subdirectory(private)
-add_subdirectory(src)
-if(BUILD_TESTING)
-  add_subdirectory(tests)
-endif()
-
-add_subdirectory(cmake/modules)
--- a/Telegram/ThirdParty/dispatch/config/config.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/config/config.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,271 +0,0 @@
-/* config/config.h.  Generated from config.h.in by configure.  */
-/* config/config.h.in.  Generated from configure.ac by autoheader.  */
-
-/* Define to 1 if you have the declaration of `CLOCK_MONOTONIC', and to 0 if
-   you don't. */
-#define HAVE_DECL_CLOCK_MONOTONIC 0
-
-/* Define to 1 if you have the declaration of `CLOCK_REALTIME', and to 0 if
-   you don't. */
-#define CLOCK_REALTIME 0
-
-/* Define to 1 if you have the declaration of `CLOCK_UPTIME', and to 0 if you
-   don't. */
-#define HAVE_DECL_CLOCK_UPTIME 0
-
-/* Define to 1 if you have the declaration of `HAVE_DECL_CLOCK_UPTIME_FAST',
-    and to 0 if you don't. */
-#define HAVE_DECL_CLOCK_UPTIME_FAST 0
-
-/* Define to 1 if you have the declaration of `FD_COPY', and to 0 if you
-   don't. */
-#define HAVE_DECL_FD_COPY 1
-
-/* Define to 1 if you have the declaration of `NOTE_LOWAT', and to 0 if you
-   don't. */
-#define HAVE_DECL_NOTE_LOWAT 1
-
-/* Define to 1 if you have the declaration of `NOTE_NONE', and to 0 if you
-   don't. */
-#define HAVE_DECL_NOTE_NONE 1
-
-/* Define to 1 if you have the declaration of `NOTE_REAP', and to 0 if you
-   don't. */
-#define HAVE_DECL_NOTE_REAP 1
-
-/* Define to 1 if you have the declaration of `NOTE_REVOKE', and to 0 if you
-   don't. */
-#define HAVE_DECL_NOTE_REVOKE 1
-
-/* Define to 1 if you have the declaration of `NOTE_SIGNAL', and to 0 if you
-   don't. */
-#define HAVE_DECL_NOTE_SIGNAL 1
-
-/* Define to 1 if you have the declaration of `POSIX_SPAWN_START_SUSPENDED',
-   and to 0 if you don't. */
-#define HAVE_DECL_POSIX_SPAWN_START_SUSPENDED 1
-
-/* Define to 1 if you have the declaration of `program_invocation_short_name',
-   and to 0 if you don't. */
-#define HAVE_DECL_PROGRAM_INVOCATION_SHORT_NAME 0
-
-/* Define to 1 if you have the declaration of `SIGEMT', and to 0 if you don't.
-   */
-#define HAVE_DECL_SIGEMT 1
-
-/* Define to 1 if you have the declaration of `VQ_UPDATE', and to 0 if you
-   don't. */
-#define HAVE_DECL_VQ_UPDATE 1
-
-/* Define to 1 if you have the declaration of `VQ_VERYLOWDISK', and to 0 if
-   you don't. */
-#define HAVE_DECL_VQ_VERYLOWDISK 1
-
-/* Define to 1 if you have the declaration of `VQ_QUOTA', and to 0 if
- you don't. */
-#define HAVE_DECL_VQ_QUOTA 1
-
-/* Define to 1 if you have the declaration of `VQ_NEARLOWDISK', and to 0 if
-   you don't. */
-#define HAVE_DECL_VQ_NEARLOWDISK 1
-
-/* Define to 1 if you have the declaration of `VQ_DESIRED_DISK', and to 0 if
- you don't. */
-#define HAVE_DECL_VQ_DESIRED_DISK 1
-
-/* Define to 1 if you have the declaration of `VQ_FREE_SPACE_CHANGE', and to 0 if
-   you don't. */
-#define HAVE_DECL_VQ_FREE_SPACE_CHANGE 1
-
-/* Define to 1 if you have the <dlfcn.h> header file. */
-#define HAVE_DLFCN_H 1
-
-/* Define to 1 if you have the <fcntl.h> header file. */
-#define HAVE_FCNTL_H 1
-
-/* Define to 1 if you have the `getprogname' function. */
-#define HAVE_GETPROGNAME 1
-
-/* Define to 1 if you have the <inttypes.h> header file. */
-#define HAVE_INTTYPES_H 1
-
-/* Define if Apple leaks program is present */
-#define HAVE_LEAKS 1
-
-/* Define to 1 if you have the <libkern/OSAtomic.h> header file. */
-#define HAVE_LIBKERN_OSATOMIC_H 1
-
-/* Define to 1 if you have the <libkern/OSCrossEndian.h> header file. */
-#define HAVE_LIBKERN_OSCROSSENDIAN_H 1
-
-/* Define to 1 if you have the <libproc_internal.h> header file. */
-#define HAVE_LIBPROC_INTERNAL_H 1
-
-/* Define if mach is present */
-#define HAVE_MACH 1
-
-/* Define to 1 if you have the `mach_absolute_time' function. */
-#define HAVE_MACH_ABSOLUTE_TIME 1
-
-/* Define to 1 if you have the `mach_approximate_time' function. */
-#define HAVE_MACH_APPROXIMATE_TIME 1
-
-/* Define to 1 if you have the `malloc_create_zone' function. */
-#define HAVE_MALLOC_CREATE_ZONE 1
-
-/* Define to 1 if you have the <malloc/malloc.h> header file. */
-#define HAVE_MALLOC_MALLOC_H 1
-
-/* Define to 1 if you have the <memory.h> header file. */
-#define HAVE_MEMORY_H 1
-
-/* Define if __builtin_trap marked noreturn */
-#define HAVE_NORETURN_BUILTIN_TRAP 1
-
-/* Define if you have the Objective-C runtime */
-#define HAVE_OBJC 1
-
-/* Define to 1 if you have the `pthread_key_init_np' function. */
-#define HAVE_PTHREAD_KEY_INIT_NP 1
-
-/* Define to 1 if you have the `pthread_attr_setcpupercent_np' function. */
-#define HAVE_PTHREAD_ATTR_SETCPUPERCENT_NP 1
-
-/* Define to 1 if you have the <pthread_machdep.h> header file. */
-#define HAVE_PTHREAD_MACHDEP_H 1
-
-/* Define to 1 if you have the `pthread_main_np' function. */
-#define HAVE_PTHREAD_MAIN_NP 1
-
-/* Define to 1 if you have the `pthread_yield_np' function. */
-#define HAVE_PTHREAD_YIELD_NP 1
-
-/* Define to 1 if you have the <pthread_np.h> header file. */
-/* #undef HAVE_PTHREAD_NP_H */
-
-/* Define to 1 if you have the <pthread/qos.h> header file. */
-#define HAVE_PTHREAD_QOS_H 1
-
-/* Define if pthread work queues are present */
-#define HAVE_PTHREAD_WORKQUEUES 1
-
-/* Define to 1 if you have the <pthread_workqueue.h> header file. */
-#define HAVE_PTHREAD_WORKQUEUE_H 1
-
-/* Define to 1 if you have the <pthread/workqueue_private.h> header file. */
-#define HAVE_PTHREAD_WORKQUEUE_PRIVATE_H 1
-
-/* Define to 1 if you have the <stdint.h> header file. */
-#define HAVE_STDINT_H 1
-
-/* Define to 1 if you have the <stdlib.h> header file. */
-#define HAVE_STDLIB_H 1
-
-/* Define to 1 if you have the <strings.h> header file. */
-#define HAVE_STRINGS_H 1
-
-/* Define to 1 if you have the <string.h> header file. */
-#define HAVE_STRING_H 1
-
-/* Define to 1 if you have the `sysconf' function. */
-#define HAVE_SYSCONF 1
-
-/* Define to 1 if you have the <sys/cdefs.h> header file. */
-#define HAVE_SYS_CDEFS_H 1
-
-/* Define to 1 if you have the <sys/guarded.h> header file. */
-#define HAVE_SYS_GUARDED_H 1
-
-/* Define to 1 if you have the <sys/stat.h> header file. */
-#define HAVE_SYS_STAT_H 1
-
-/* Define to 1 if you have the <sys/types.h> header file. */
-#define HAVE_SYS_TYPES_H 1
-
-/* Define to 1 if you have the <TargetConditionals.h> header file. */
-#define HAVE_TARGETCONDITIONALS_H 1
-
-/* Define to 1 if you have the <unistd.h> header file. */
-#define HAVE_UNISTD_H 1
-
-/* Define to 1 if you have the `_pthread_workqueue_init' function. */
-#define HAVE__PTHREAD_WORKQUEUE_INIT 1
-
-/* Define to the sub-directory where libtool stores uninstalled libraries. */
-#define LT_OBJDIR ".libs/"
-
-/* Name of package */
-#define PACKAGE "libdispatch"
-
-/* Define to the address where bug reports for this package should be sent. */
-#define PACKAGE_BUGREPORT "libdispatch@macosforge.org"
-
-/* Define to the full name of this package. */
-#define PACKAGE_NAME "libdispatch"
-
-/* Define to the full name and version of this package. */
-#define PACKAGE_STRING "libdispatch 1.3"
-
-/* Define to the one symbol short name of this package. */
-#define PACKAGE_TARNAME "libdispatch"
-
-/* Define to the home page for this package. */
-#define PACKAGE_URL "http://libdispatch.macosforge.org"
-
-/* Define to the version of this package. */
-#define PACKAGE_VERSION "1.3"
-
-/* Define to 1 if you have the ANSI C header files. */
-#define STDC_HEADERS 1
-
-/* Define to use non-portable pthread TSD optimizations for Mac OS X) */
-#define USE_APPLE_TSD_OPTIMIZATIONS 1
-
-/* Define to tag libdispatch_init as a constructor */
-/* #undef USE_LIBDISPATCH_INIT_CONSTRUCTOR */
-
-/* Define to use Mach semaphores */
-#define USE_MACH_SEM 1
-
-/* Define to use POSIX semaphores */
-/* #undef USE_POSIX_SEM */
-
-/* Enable extensions on AIX 3, Interix.  */
-#ifndef _ALL_SOURCE
-# define _ALL_SOURCE 1
-#endif
-/* Enable GNU extensions on systems that have them.  */
-#ifndef _GNU_SOURCE
-# define _GNU_SOURCE 1
-#endif
-/* Enable threading extensions on Solaris.  */
-#ifndef _POSIX_PTHREAD_SEMANTICS
-# define _POSIX_PTHREAD_SEMANTICS 1
-#endif
-/* Enable extensions on HP NonStop.  */
-#ifndef _TANDEM_SOURCE
-# define _TANDEM_SOURCE 1
-#endif
-/* Enable general extensions on Solaris.  */
-#ifndef __EXTENSIONS__
-# define __EXTENSIONS__ 1
-#endif
-
-
-/* Version number of package */
-#define VERSION "1.3"
-
-/* Define to 1 if on MINIX. */
-/* #undef _MINIX */
-
-/* Define to 2 if the system does not provide POSIX.1 features except with
-   this defined. */
-/* #undef _POSIX_1_SOURCE */
-
-/* Define to 1 if you need to in order for `stat' and other things to work. */
-/* #undef _POSIX_SOURCE */
-
-/* Define if using Darwin $NOCANCEL */
-#define __DARWIN_NON_CANCELABLE 1
-
-#define HAVE_STRLCPY 1
--- a/Telegram/ThirdParty/dispatch/CONTRIBUTING.md	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/CONTRIBUTING.md	1970-01-01 00:00:00.000000000 -0000
@@ -1,10 +0,0 @@
-By submitting a pull request, you represent that you have the right to license
-your contribution to Apple and the community, and agree by submitting the patch
-that your contributions are licensed under the [Swift
-license](https://swift.org/LICENSE.txt).
-
----
-
-Before submitting the pull request, please make sure you have tested your
-changes and that they follow the Swift project [guidelines for contributing
-code](https://swift.org/contributing/#contributing-code).
--- a/Telegram/ThirdParty/dispatch/dispatch/base.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/dispatch/base.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,326 +0,0 @@
-/*
- * Copyright (c) 2008-2012 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#ifndef __DISPATCH_BASE__
-#define __DISPATCH_BASE__
-
-#ifndef __DISPATCH_INDIRECT__
-#error "Please #include <dispatch/dispatch.h> instead of this file directly."
-#endif
-
-#ifndef __has_builtin
-#define __has_builtin(x) 0
-#endif
-#ifndef __has_include
-#define __has_include(x) 0
-#endif
-#ifndef __has_feature
-#define __has_feature(x) 0
-#endif
-#ifndef __has_attribute
-#define __has_attribute(x) 0
-#endif
-#ifndef __has_extension
-#define __has_extension(x) 0
-#endif
-
-#if __GNUC__
-#define DISPATCH_NORETURN __attribute__((__noreturn__))
-#define DISPATCH_NOTHROW __attribute__((__nothrow__))
-#define DISPATCH_NONNULL1 __attribute__((__nonnull__(1)))
-#define DISPATCH_NONNULL2 __attribute__((__nonnull__(2)))
-#define DISPATCH_NONNULL3 __attribute__((__nonnull__(3)))
-#define DISPATCH_NONNULL4 __attribute__((__nonnull__(4)))
-#define DISPATCH_NONNULL5 __attribute__((__nonnull__(5)))
-#define DISPATCH_NONNULL6 __attribute__((__nonnull__(6)))
-#define DISPATCH_NONNULL7 __attribute__((__nonnull__(7)))
-#if __clang__ && __clang_major__ < 3
-// rdar://problem/6857843
-#define DISPATCH_NONNULL_ALL
-#else
-#define DISPATCH_NONNULL_ALL __attribute__((__nonnull__))
-#endif
-#define DISPATCH_SENTINEL __attribute__((__sentinel__))
-#define DISPATCH_PURE __attribute__((__pure__))
-#define DISPATCH_CONST __attribute__((__const__))
-#define DISPATCH_WARN_RESULT __attribute__((__warn_unused_result__))
-#define DISPATCH_MALLOC __attribute__((__malloc__))
-#define DISPATCH_ALWAYS_INLINE __attribute__((__always_inline__))
-#define DISPATCH_UNAVAILABLE __attribute__((__unavailable__))
-#define DISPATCH_UNAVAILABLE_MSG(msg) __attribute__((__unavailable__(msg)))
-#elif defined(_MSC_VER)
-#define DISPATCH_NORETURN __declspec(noreturn)
-#define DISPATCH_NOTHROW __declspec(nothrow)
-#define DISPATCH_NONNULL1
-#define DISPATCH_NONNULL2
-#define DISPATCH_NONNULL3
-#define DISPATCH_NONNULL4
-#define DISPATCH_NONNULL5
-#define DISPATCH_NONNULL6
-#define DISPATCH_NONNULL7
-#define DISPATCH_NONNULL_ALL
-#define DISPATCH_SENTINEL
-#define DISPATCH_PURE
-#define DISPATCH_CONST
-#if (_MSC_VER >= 1700)
-#define DISPATCH_WARN_RESULT _Check_return_
-#else
-#define DISPATCH_WARN_RESULT
-#endif
-#define DISPATCH_MALLOC
-#define DISPATCH_ALWAYS_INLINE __forceinline
-#define DISPATCH_UNAVAILABLE
-#define DISPATCH_UNAVAILABLE_MSG(msg)
-#else
-/*! @parseOnly */
-#define DISPATCH_NORETURN
-/*! @parseOnly */
-#define DISPATCH_NOTHROW
-/*! @parseOnly */
-#define DISPATCH_NONNULL1
-/*! @parseOnly */
-#define DISPATCH_NONNULL2
-/*! @parseOnly */
-#define DISPATCH_NONNULL3
-/*! @parseOnly */
-#define DISPATCH_NONNULL4
-/*! @parseOnly */
-#define DISPATCH_NONNULL5
-/*! @parseOnly */
-#define DISPATCH_NONNULL6
-/*! @parseOnly */
-#define DISPATCH_NONNULL7
-/*! @parseOnly */
-#define DISPATCH_NONNULL_ALL
-/*! @parseOnly */
-#define DISPATCH_SENTINEL
-/*! @parseOnly */
-#define DISPATCH_PURE
-/*! @parseOnly */
-#define DISPATCH_CONST
-/*! @parseOnly */
-#define DISPATCH_WARN_RESULT
-/*! @parseOnly */
-#define DISPATCH_MALLOC
-/*! @parseOnly */
-#define DISPATCH_ALWAYS_INLINE
-/*! @parseOnly */
-#define DISPATCH_UNAVAILABLE
-/*! @parseOnly */
-#define DISPATCH_UNAVAILABLE_MSG(msg)
-#endif
-
-#if defined(__cplusplus)
-# if __cplusplus >= 201703L
-#  define DISPATCH_FALLTHROUGH [[fallthrough]]
-# elif __cplusplus >= 201103L
-#  if defined(__clang__)
-#   define DISPATCH_FALLTHROUGH [[clang::fallthrough]]
-#  elif defined(__GNUC__) && __GNUC__ >= 7
-#   define DISPATCH_FALLTHROUGH [[gnu::fallthrough]]
-#  else
-#   define DISPATCH_FALLTHROUGH
-#  endif
-# else
-#  define DISPATCH_FALLTHROUGH
-# endif
-#elif defined(__GNUC__) && __GNUC__ >= 7
-# define DISPATCH_FALLTHROUGH __attribute__((__fallthrough__))
-#elif defined(__clang__)
-# if __has_attribute(fallthrough) && __clang_major__ >= 5
-#  define DISPATCH_FALLTHROUGH __attribute__((__fallthrough__))
-# else
-#  define DISPATCH_FALLTHROUGH
-# endif
-#else
-# define DISPATCH_FALLTHROUGH
-#endif
-
-
-#ifdef __linux__
-#define DISPATCH_LINUX_UNAVAILABLE() \
-		DISPATCH_UNAVAILABLE_MSG( \
-		"This interface is unavailable on linux systems")
-#else
-#define DISPATCH_LINUX_UNAVAILABLE()
-#endif
-
-#ifdef __FreeBSD__
-#define DISPATCH_FREEBSD_UNAVAILABLE() \
-		DISPATCH_UNAVAILABLE_MSG( \
-		"This interface is unavailable on FreeBSD systems")
-#else
-#define DISPATCH_FREEBSD_UNAVAILABLE()
-#endif
-
-#ifndef DISPATCH_ALIAS_V2
-#if TARGET_OS_MAC
-#define DISPATCH_ALIAS_V2(sym)	 __asm__("_" #sym "$V2")
-#else
-#define DISPATCH_ALIAS_V2(sym)
-#endif
-#endif
-
-#if defined(_WIN32)
-#if defined(__DISPATCH_BUILDING_DISPATCH__)
-#if defined(__cplusplus)
-#define DISPATCH_EXPORT extern "C" __declspec(dllexport)
-#else
-#define DISPATCH_EXPORT extern __declspec(dllexport)
-#endif
-#else
-#if defined(__cplusplus)
-#define DISPATCH_EXPORT extern "C" __declspec(dllimport)
-#else
-#define DISPATCH_EXPORT extern __declspec(dllimport)
-#endif
-#endif
-#elif __GNUC__
-#define DISPATCH_EXPORT extern __attribute__((visibility("default")))
-#else
-#define DISPATCH_EXPORT extern
-#endif
-
-#if __GNUC__
-#define DISPATCH_INLINE static __inline__
-#else
-#define DISPATCH_INLINE static inline
-#endif
-
-#if __GNUC__
-#define DISPATCH_EXPECT(x, v) __builtin_expect((x), (v))
-#define dispatch_compiler_barrier()  __asm__ __volatile__("" ::: "memory")
-#else
-#define DISPATCH_EXPECT(x, v) (x)
-#define dispatch_compiler_barrier()  do { } while (0)
-#endif
-
-#if __has_attribute(not_tail_called)
-#define DISPATCH_NOT_TAIL_CALLED __attribute__((__not_tail_called__))
-#else
-#define DISPATCH_NOT_TAIL_CALLED
-#endif
-
-#if __has_builtin(__builtin_assume)
-#define DISPATCH_COMPILER_CAN_ASSUME(expr) __builtin_assume(expr)
-#else
-#define DISPATCH_COMPILER_CAN_ASSUME(expr) ((void)(expr))
-#endif
-
-#if __has_attribute(noescape)
-#define DISPATCH_NOESCAPE __attribute__((__noescape__))
-#else
-#define DISPATCH_NOESCAPE
-#endif
-
-#if __has_attribute(cold)
-#define DISPATCH_COLD __attribute__((__cold__))
-#else
-#define DISPATCH_COLD
-#endif
-
-#if __has_feature(assume_nonnull)
-#define DISPATCH_ASSUME_NONNULL_BEGIN _Pragma("clang assume_nonnull begin")
-#define DISPATCH_ASSUME_NONNULL_END   _Pragma("clang assume_nonnull end")
-#else
-#define DISPATCH_ASSUME_NONNULL_BEGIN
-#define DISPATCH_ASSUME_NONNULL_END
-#endif
-
-#if !__has_feature(nullability)
-#ifndef _Nullable
-#define _Nullable
-#endif
-#ifndef _Nonnull
-#define _Nonnull
-#endif
-#ifndef _Null_unspecified
-#define _Null_unspecified
-#endif
-#endif
-
-#ifndef DISPATCH_RETURNS_RETAINED_BLOCK
-#if __has_attribute(ns_returns_retained)
-#define DISPATCH_RETURNS_RETAINED_BLOCK __attribute__((__ns_returns_retained__))
-#else
-#define DISPATCH_RETURNS_RETAINED_BLOCK
-#endif
-#endif
-
-#if __has_feature(objc_fixed_enum) || __has_extension(cxx_strong_enums) || defined(_WIN32)
-#define DISPATCH_ENUM(name, type, ...) \
-		typedef enum : type { __VA_ARGS__ } name##_t
-#else
-#define DISPATCH_ENUM(name, type, ...) \
-		enum { __VA_ARGS__ }; typedef type name##_t
-#endif
-
-#if __has_feature(enumerator_attributes)
-#define DISPATCH_ENUM_API_AVAILABLE(...) API_AVAILABLE(__VA_ARGS__)
-#define DISPATCH_ENUM_API_DEPRECATED(...) API_DEPRECATED(__VA_ARGS__)
-#define DISPATCH_ENUM_API_DEPRECATED_WITH_REPLACEMENT(...) \
-		API_DEPRECATED_WITH_REPLACEMENT(__VA_ARGS__)
-#else
-#define DISPATCH_ENUM_API_AVAILABLE(...)
-#define DISPATCH_ENUM_API_DEPRECATED(...)
-#define DISPATCH_ENUM_API_DEPRECATED_WITH_REPLACEMENT(...)
-#endif
-
-#if defined(SWIFT_SDK_OVERLAY_DISPATCH_EPOCH) && \
-		SWIFT_SDK_OVERLAY_DISPATCH_EPOCH >= 2
-#define DISPATCH_SWIFT3_OVERLAY 1
-#else
-#define DISPATCH_SWIFT3_OVERLAY 0
-#endif // SWIFT_SDK_OVERLAY_DISPATCH_EPOCH >= 2
-
-#if __has_feature(attribute_availability_swift)
-#define DISPATCH_SWIFT_UNAVAILABLE(_msg) \
-		__attribute__((__availability__(swift, unavailable, message=_msg)))
-#else
-#define DISPATCH_SWIFT_UNAVAILABLE(_msg)
-#endif
-
-#if DISPATCH_SWIFT3_OVERLAY
-#define DISPATCH_SWIFT3_UNAVAILABLE(_msg) DISPATCH_SWIFT_UNAVAILABLE(_msg)
-#else
-#define DISPATCH_SWIFT3_UNAVAILABLE(_msg)
-#endif
-
-#if __has_attribute(swift_private)
-#define DISPATCH_REFINED_FOR_SWIFT __attribute__((__swift_private__))
-#else
-#define DISPATCH_REFINED_FOR_SWIFT
-#endif
-
-#if __has_attribute(swift_name)
-#define DISPATCH_SWIFT_NAME(_name) __attribute__((__swift_name__(#_name)))
-#else
-#define DISPATCH_SWIFT_NAME(_name)
-#endif
-
-#ifndef __cplusplus
-#define DISPATCH_TRANSPARENT_UNION __attribute__((__transparent_union__))
-#else
-#define DISPATCH_TRANSPARENT_UNION
-#endif
-
-typedef void (*dispatch_function_t)(void *_Nullable);
-
-#endif
--- a/Telegram/ThirdParty/dispatch/dispatch/block.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/dispatch/block.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,428 +0,0 @@
-/*
- * Copyright (c) 2014 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#ifndef __DISPATCH_BLOCK__
-#define __DISPATCH_BLOCK__
-
-#ifndef __DISPATCH_INDIRECT__
-#error "Please #include <dispatch/dispatch.h> instead of this file directly."
-#include <dispatch/base.h> // for HeaderDoc
-#endif
-
-#ifdef __BLOCKS__
-
-/*!
- * @group Dispatch block objects
- */
-
-DISPATCH_ASSUME_NONNULL_BEGIN
-
-__BEGIN_DECLS
-
-/*!
- * @typedef dispatch_block_flags_t
- * Flags to pass to the dispatch_block_create* functions.
- *
- * @const DISPATCH_BLOCK_BARRIER
- * Flag indicating that a dispatch block object should act as a barrier block
- * when submitted to a DISPATCH_QUEUE_CONCURRENT queue.
- * See dispatch_barrier_async() for details.
- * This flag has no effect when the dispatch block object is invoked directly.
- *
- * @const DISPATCH_BLOCK_DETACHED
- * Flag indicating that a dispatch block object should execute disassociated
- * from current execution context attributes such as os_activity_t
- * and properties of the current IPC request (if any). With regard to QoS class,
- * the behavior is the same as for DISPATCH_BLOCK_NO_QOS. If invoked directly,
- * the block object will remove the other attributes from the calling thread for
- * the duration of the block body (before applying attributes assigned to the
- * block object, if any). If submitted to a queue, the block object will be
- * executed with the attributes of the queue (or any attributes specifically
- * assigned to the block object).
- *
- * @const DISPATCH_BLOCK_ASSIGN_CURRENT
- * Flag indicating that a dispatch block object should be assigned the execution
- * context attributes that are current at the time the block object is created.
- * This applies to attributes such as QOS class, os_activity_t and properties of
- * the current IPC request (if any). If invoked directly, the block object will
- * apply these attributes to the calling thread for the duration of the block
- * body. If the block object is submitted to a queue, this flag replaces the
- * default behavior of associating the submitted block instance with the
- * execution context attributes that are current at the time of submission.
- * If a specific QOS class is assigned with DISPATCH_BLOCK_NO_QOS_CLASS or
- * dispatch_block_create_with_qos_class(), that QOS class takes precedence over
- * the QOS class assignment indicated by this flag.
- *
- * @const DISPATCH_BLOCK_NO_QOS_CLASS
- * Flag indicating that a dispatch block object should be not be assigned a QOS
- * class. If invoked directly, the block object will be executed with the QOS
- * class of the calling thread. If the block object is submitted to a queue,
- * this replaces the default behavior of associating the submitted block
- * instance with the QOS class current at the time of submission.
- * This flag is ignored if a specific QOS class is assigned with
- * dispatch_block_create_with_qos_class().
- *
- * @const DISPATCH_BLOCK_INHERIT_QOS_CLASS
- * Flag indicating that execution of a dispatch block object submitted to a
- * queue should prefer the QOS class assigned to the queue over the QOS class
- * assigned to the block (resp. associated with the block at the time of
- * submission). The latter will only be used if the queue in question does not
- * have an assigned QOS class, as long as doing so does not result in a QOS
- * class lower than the QOS class inherited from the queue's target queue.
- * This flag is the default when a dispatch block object is submitted to a queue
- * for asynchronous execution and has no effect when the dispatch block object
- * is invoked directly. It is ignored if DISPATCH_BLOCK_ENFORCE_QOS_CLASS is
- * also passed.
- *
- * @const DISPATCH_BLOCK_ENFORCE_QOS_CLASS
- * Flag indicating that execution of a dispatch block object submitted to a
- * queue should prefer the QOS class assigned to the block (resp. associated
- * with the block at the time of submission) over the QOS class assigned to the
- * queue, as long as doing so will not result in a lower QOS class.
- * This flag is the default when a dispatch block object is submitted to a queue
- * for synchronous execution or when the dispatch block object is invoked
- * directly.
- */
-DISPATCH_ENUM(dispatch_block_flags, unsigned long,
-	DISPATCH_BLOCK_BARRIER
-			DISPATCH_ENUM_API_AVAILABLE(macos(10.10), ios(8.0)) = 0x1,
-	DISPATCH_BLOCK_DETACHED
-			DISPATCH_ENUM_API_AVAILABLE(macos(10.10), ios(8.0)) = 0x2,
-	DISPATCH_BLOCK_ASSIGN_CURRENT
-			DISPATCH_ENUM_API_AVAILABLE(macos(10.10), ios(8.0)) = 0x4,
-	DISPATCH_BLOCK_NO_QOS_CLASS
-			DISPATCH_ENUM_API_AVAILABLE(macos(10.10), ios(8.0)) = 0x8,
-	DISPATCH_BLOCK_INHERIT_QOS_CLASS
-			DISPATCH_ENUM_API_AVAILABLE(macos(10.10), ios(8.0)) = 0x10,
-	DISPATCH_BLOCK_ENFORCE_QOS_CLASS
-			DISPATCH_ENUM_API_AVAILABLE(macos(10.10), ios(8.0)) = 0x20,
-);
-
-/*!
- * @function dispatch_block_create
- *
- * @abstract
- * Create a new dispatch block object on the heap from an existing block and
- * the given flags.
- *
- * @discussion
- * The provided block is Block_copy'ed to the heap and retained by the newly
- * created dispatch block object.
- *
- * The returned dispatch block object is intended to be submitted to a dispatch
- * queue with dispatch_async() and related functions, but may also be invoked
- * directly. Both operations can be performed an arbitrary number of times but
- * only the first completed execution of a dispatch block object can be waited
- * on with dispatch_block_wait() or observed with dispatch_block_notify().
- *
- * If the returned dispatch block object is submitted to a dispatch queue, the
- * submitted block instance will be associated with the QOS class current at the
- * time of submission, unless one of the following flags assigned a specific QOS
- * class (or no QOS class) at the time of block creation:
- *  - DISPATCH_BLOCK_ASSIGN_CURRENT
- *  - DISPATCH_BLOCK_NO_QOS_CLASS
- *  - DISPATCH_BLOCK_DETACHED
- * The QOS class the block object will be executed with also depends on the QOS
- * class assigned to the queue and which of the following flags was specified or
- * defaulted to:
- *  - DISPATCH_BLOCK_INHERIT_QOS_CLASS (default for asynchronous execution)
- *  - DISPATCH_BLOCK_ENFORCE_QOS_CLASS (default for synchronous execution)
- * See description of dispatch_block_flags_t for details.
- *
- * If the returned dispatch block object is submitted directly to a serial queue
- * and is configured to execute with a specific QOS class, the system will make
- * a best effort to apply the necessary QOS overrides to ensure that blocks
- * submitted earlier to the serial queue are executed at that same QOS class or
- * higher.
- *
- * @param flags
- * Configuration flags for the block object.
- * Passing a value that is not a bitwise OR of flags from dispatch_block_flags_t
- * results in NULL being returned.
- *
- * @param block
- * The block to create the dispatch block object from.
- *
- * @result
- * The newly created dispatch block object, or NULL.
- * When not building with Objective-C ARC, must be released with a -[release]
- * message or the Block_release() function.
- */
-API_AVAILABLE(macos(10.10), ios(8.0))
-DISPATCH_EXPORT DISPATCH_NONNULL2 DISPATCH_RETURNS_RETAINED_BLOCK
-DISPATCH_WARN_RESULT DISPATCH_NOTHROW
-dispatch_block_t
-dispatch_block_create(dispatch_block_flags_t flags, dispatch_block_t block);
-
-/*!
- * @function dispatch_block_create_with_qos_class
- *
- * @abstract
- * Create a new dispatch block object on the heap from an existing block and
- * the given flags, and assign it the specified QOS class and relative priority.
- *
- * @discussion
- * The provided block is Block_copy'ed to the heap and retained by the newly
- * created dispatch block object.
- *
- * The returned dispatch block object is intended to be submitted to a dispatch
- * queue with dispatch_async() and related functions, but may also be invoked
- * directly. Both operations can be performed an arbitrary number of times but
- * only the first completed execution of a dispatch block object can be waited
- * on with dispatch_block_wait() or observed with dispatch_block_notify().
- *
- * If invoked directly, the returned dispatch block object will be executed with
- * the assigned QOS class as long as that does not result in a lower QOS class
- * than what is current on the calling thread.
- *
- * If the returned dispatch block object is submitted to a dispatch queue, the
- * QOS class it will be executed with depends on the QOS class assigned to the
- * block, the QOS class assigned to the queue and which of the following flags
- * was specified or defaulted to:
- *  - DISPATCH_BLOCK_INHERIT_QOS_CLASS: default for asynchronous execution
- *  - DISPATCH_BLOCK_ENFORCE_QOS_CLASS: default for synchronous execution
- * See description of dispatch_block_flags_t for details.
- *
- * If the returned dispatch block object is submitted directly to a serial queue
- * and is configured to execute with a specific QOS class, the system will make
- * a best effort to apply the necessary QOS overrides to ensure that blocks
- * submitted earlier to the serial queue are executed at that same QOS class or
- * higher.
- *
- * @param flags
- * Configuration flags for the new block object.
- * Passing a value that is not a bitwise OR of flags from dispatch_block_flags_t
- * results in NULL being returned.
- *
- * @param qos_class
- * A QOS class value:
- *  - QOS_CLASS_USER_INTERACTIVE
- *  - QOS_CLASS_USER_INITIATED
- *  - QOS_CLASS_DEFAULT
- *  - QOS_CLASS_UTILITY
- *  - QOS_CLASS_BACKGROUND
- *  - QOS_CLASS_UNSPECIFIED
- * Passing QOS_CLASS_UNSPECIFIED is equivalent to specifying the
- * DISPATCH_BLOCK_NO_QOS_CLASS flag. Passing any other value results in NULL
- * being returned.
- *
- * @param relative_priority
- * A relative priority within the QOS class. This value is a negative
- * offset from the maximum supported scheduler priority for the given class.
- * Passing a value greater than zero or less than QOS_MIN_RELATIVE_PRIORITY
- * results in NULL being returned.
- *
- * @param block
- * The block to create the dispatch block object from.
- *
- * @result
- * The newly created dispatch block object, or NULL.
- * When not building with Objective-C ARC, must be released with a -[release]
- * message or the Block_release() function.
- */
-API_AVAILABLE(macos(10.10), ios(8.0))
-DISPATCH_EXPORT DISPATCH_NONNULL4 DISPATCH_RETURNS_RETAINED_BLOCK
-DISPATCH_WARN_RESULT DISPATCH_NOTHROW
-dispatch_block_t
-dispatch_block_create_with_qos_class(dispatch_block_flags_t flags,
-		dispatch_qos_class_t qos_class, int relative_priority,
-		dispatch_block_t block);
-
-/*!
- * @function dispatch_block_perform
- *
- * @abstract
- * Create, synchronously execute and release a dispatch block object from the
- * specified block and flags.
- *
- * @discussion
- * Behaves identically to the sequence
- * <code>
- * dispatch_block_t b = dispatch_block_create(flags, block);
- * b();
- * Block_release(b);
- * </code>
- * but may be implemented more efficiently internally by not requiring a copy
- * to the heap of the specified block or the allocation of a new block object.
- *
- * @param flags
- * Configuration flags for the temporary block object.
- * The result of passing a value that is not a bitwise OR of flags from
- * dispatch_block_flags_t is undefined.
- *
- * @param block
- * The block to create the temporary block object from.
- */
-API_AVAILABLE(macos(10.10), ios(8.0))
-DISPATCH_EXPORT DISPATCH_NONNULL2 DISPATCH_NOTHROW
-void
-dispatch_block_perform(dispatch_block_flags_t flags,
-		DISPATCH_NOESCAPE dispatch_block_t block);
-
-/*!
- * @function dispatch_block_wait
- *
- * @abstract
- * Wait synchronously until execution of the specified dispatch block object has
- * completed or until the specified timeout has elapsed.
- *
- * @discussion
- * This function will return immediately if execution of the block object has
- * already completed.
- *
- * It is not possible to wait for multiple executions of the same block object
- * with this interface; use dispatch_group_wait() for that purpose. A single
- * dispatch block object may either be waited on once and executed once,
- * or it may be executed any number of times. The behavior of any other
- * combination is undefined. Submission to a dispatch queue counts as an
- * execution, even if cancellation (dispatch_block_cancel) means the block's
- * code never runs.
- *
- * The result of calling this function from multiple threads simultaneously
- * with the same dispatch block object is undefined, but note that doing so
- * would violate the rules described in the previous paragraph.
- *
- * If this function returns indicating that the specified timeout has elapsed,
- * then that invocation does not count as the one allowed wait.
- *
- * If at the time this function is called, the specified dispatch block object
- * has been submitted directly to a serial queue, the system will make a best
- * effort to apply the necessary QOS overrides to ensure that the block and any
- * blocks submitted earlier to that serial queue are executed at the QOS class
- * (or higher) of the thread calling dispatch_block_wait().
- *
- * @param block
- * The dispatch block object to wait on.
- * The result of passing NULL or a block object not returned by one of the
- * dispatch_block_create* functions is undefined.
- *
- * @param timeout
- * When to timeout (see dispatch_time). As a convenience, there are the
- * DISPATCH_TIME_NOW and DISPATCH_TIME_FOREVER constants.
- *
- * @result
- * Returns zero on success (the dispatch block object completed within the
- * specified timeout) or non-zero on error (i.e. timed out).
- */
-API_AVAILABLE(macos(10.10), ios(8.0))
-DISPATCH_EXPORT DISPATCH_NONNULL1 DISPATCH_NOTHROW
-intptr_t
-dispatch_block_wait(dispatch_block_t block, dispatch_time_t timeout);
-
-/*!
- * @function dispatch_block_notify
- *
- * @abstract
- * Schedule a notification block to be submitted to a queue when the execution
- * of a specified dispatch block object has completed.
- *
- * @discussion
- * This function will submit the notification block immediately if execution of
- * the observed block object has already completed.
- *
- * It is not possible to be notified of multiple executions of the same block
- * object with this interface, use dispatch_group_notify() for that purpose.
- *
- * A single dispatch block object may either be observed one or more times
- * and executed once, or it may be executed any number of times. The behavior
- * of any other combination is undefined. Submission to a dispatch queue
- * counts as an execution, even if cancellation (dispatch_block_cancel) means
- * the block's code never runs.
- *
- * If multiple notification blocks are scheduled for a single block object,
- * there is no defined order in which the notification blocks will be submitted
- * to their associated queues.
- *
- * @param block
- * The dispatch block object to observe.
- * The result of passing NULL or a block object not returned by one of the
- * dispatch_block_create* functions is undefined.
- *
- * @param queue
- * The queue to which the supplied notification block will be submitted when
- * the observed block completes.
- *
- * @param notification_block
- * The notification block to submit when the observed block object completes.
- */
-API_AVAILABLE(macos(10.10), ios(8.0))
-DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW
-void
-dispatch_block_notify(dispatch_block_t block, dispatch_queue_t queue,
-		dispatch_block_t notification_block);
-
-/*!
- * @function dispatch_block_cancel
- *
- * @abstract
- * Asynchronously cancel the specified dispatch block object.
- *
- * @discussion
- * Cancellation causes any future execution of the dispatch block object to
- * return immediately, but does not affect any execution of the block object
- * that is already in progress.
- *
- * Release of any resources associated with the block object will be delayed
- * until execution of the block object is next attempted (or any execution
- * already in progress completes).
- *
- * NOTE: care needs to be taken to ensure that a block object that may be
- *       canceled does not capture any resources that require execution of the
- *       block body in order to be released (e.g. memory allocated with
- *       malloc(3) that the block body calls free(3) on). Such resources will
- *       be leaked if the block body is never executed due to cancellation.
- *
- * @param block
- * The dispatch block object to cancel.
- * The result of passing NULL or a block object not returned by one of the
- * dispatch_block_create* functions is undefined.
- */
-API_AVAILABLE(macos(10.10), ios(8.0))
-DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW
-void
-dispatch_block_cancel(dispatch_block_t block);
-
-/*!
- * @function dispatch_block_testcancel
- *
- * @abstract
- * Tests whether the given dispatch block object has been canceled.
- *
- * @param block
- * The dispatch block object to test.
- * The result of passing NULL or a block object not returned by one of the
- * dispatch_block_create* functions is undefined.
- *
- * @result
- * Non-zero if canceled and zero if not canceled.
- */
-API_AVAILABLE(macos(10.10), ios(8.0))
-DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_WARN_RESULT DISPATCH_PURE
-DISPATCH_NOTHROW
-intptr_t
-dispatch_block_testcancel(dispatch_block_t block);
-
-__END_DECLS
-
-DISPATCH_ASSUME_NONNULL_END
-
-#endif // __BLOCKS__
-
-#endif // __DISPATCH_BLOCK__
--- a/Telegram/ThirdParty/dispatch/dispatch/CMakeLists.txt	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/dispatch/CMakeLists.txt	1970-01-01 00:00:00.000000000 -0000
@@ -1,35 +0,0 @@
-
-install(FILES
-          base.h
-          block.h
-          data.h
-          dispatch.h
-          group.h
-          introspection.h
-          io.h
-          object.h
-          once.h
-          queue.h
-          semaphore.h
-          source.h
-          time.h
-        DESTINATION
-          "${INSTALL_DISPATCH_HEADERS_DIR}")
-if(ENABLE_SWIFT)
-  set(base_dir "${CMAKE_CURRENT_SOURCE_DIR}")
-  if(NOT BUILD_SHARED_LIBS)
-    set(base_dir "${CMAKE_CURRENT_SOURCE_DIR}/generic_static")
-  endif()
-
-  get_filename_component(
-    MODULE_MAP
-    module.modulemap
-    REALPATH
-    BASE_DIR "${base_dir}")
-
-  install(FILES
-            ${MODULE_MAP}
-          DESTINATION
-            "${INSTALL_DISPATCH_HEADERS_DIR}")
-endif()
-
--- a/Telegram/ThirdParty/dispatch/dispatch/darwin/module.modulemap	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/dispatch/darwin/module.modulemap	1970-01-01 00:00:00.000000000 -0000
@@ -1,9 +0,0 @@
-module Dispatch [system] [extern_c] {
-	umbrella header "dispatch.h"
-	export *
-}
-
-module DispatchIntrospection [system] [extern_c] {
-	header "introspection.h"
-	export *
-}
--- a/Telegram/ThirdParty/dispatch/dispatch/data.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/dispatch/data.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,278 +0,0 @@
-/*
- * Copyright (c) 2009-2013 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#ifndef __DISPATCH_DATA__
-#define __DISPATCH_DATA__
-
-#ifndef __DISPATCH_INDIRECT__
-#error "Please #include <dispatch/dispatch.h> instead of this file directly."
-#include <dispatch/base.h> // for HeaderDoc
-#endif
-
-DISPATCH_ASSUME_NONNULL_BEGIN
-
-__BEGIN_DECLS
-
-/*! @header
- * Dispatch data objects describe contiguous or sparse regions of memory that
- * may be managed by the system or by the application.
- * Dispatch data objects are immutable, any direct access to memory regions
- * represented by dispatch objects must not modify that memory.
- */
-
-/*!
- * @typedef dispatch_data_t
- * A dispatch object representing memory regions.
- */
-DISPATCH_DATA_DECL(dispatch_data);
-
-/*!
- * @var dispatch_data_empty
- * @discussion The singleton dispatch data object representing a zero-length
- * memory region.
- */
-#define dispatch_data_empty \
-		DISPATCH_GLOBAL_OBJECT(dispatch_data_t, _dispatch_data_empty)
-API_AVAILABLE(macos(10.7), ios(5.0))
-DISPATCH_EXPORT struct dispatch_data_s _dispatch_data_empty;
-
-/*!
- * @const DISPATCH_DATA_DESTRUCTOR_DEFAULT
- * @discussion The default destructor for dispatch data objects.
- * Used at data object creation to indicate that the supplied buffer should
- * be copied into internal storage managed by the system.
- */
-#define DISPATCH_DATA_DESTRUCTOR_DEFAULT NULL
-
-#ifdef __BLOCKS__
-/*! @parseOnly */
-#define DISPATCH_DATA_DESTRUCTOR_TYPE_DECL(name) \
-	DISPATCH_EXPORT const dispatch_block_t _dispatch_data_destructor_##name
-#else
-#define DISPATCH_DATA_DESTRUCTOR_TYPE_DECL(name) \
-	DISPATCH_EXPORT const dispatch_function_t \
-	_dispatch_data_destructor_##name
-#endif /* __BLOCKS__ */
-
-/*!
- * @const DISPATCH_DATA_DESTRUCTOR_FREE
- * @discussion The destructor for dispatch data objects created from a malloc'd
- * buffer. Used at data object creation to indicate that the supplied buffer
- * was allocated by the malloc() family and should be destroyed with free(3).
- */
-#define DISPATCH_DATA_DESTRUCTOR_FREE (_dispatch_data_destructor_free)
-API_AVAILABLE(macos(10.7), ios(5.0))
-DISPATCH_DATA_DESTRUCTOR_TYPE_DECL(free);
-
-/*!
- * @const DISPATCH_DATA_DESTRUCTOR_MUNMAP
- * @discussion The destructor for dispatch data objects that have been created
- * from buffers that require deallocation with munmap(2).
- */
-#define DISPATCH_DATA_DESTRUCTOR_MUNMAP (_dispatch_data_destructor_munmap)
-API_AVAILABLE(macos(10.9), ios(7.0))
-DISPATCH_DATA_DESTRUCTOR_TYPE_DECL(munmap);
-
-#ifdef __BLOCKS__
-/*!
- * @function dispatch_data_create
- * Creates a dispatch data object from the given contiguous buffer of memory. If
- * a non-default destructor is provided, ownership of the buffer remains with
- * the caller (i.e. the bytes will not be copied). The last release of the data
- * object will result in the invocation of the specified destructor on the
- * specified queue to free the buffer.
- *
- * If the DISPATCH_DATA_DESTRUCTOR_FREE destructor is provided the buffer will
- * be freed via free(3) and the queue argument ignored.
- *
- * If the DISPATCH_DATA_DESTRUCTOR_DEFAULT destructor is provided, data object
- * creation will copy the buffer into internal memory managed by the system.
- *
- * @param buffer	A contiguous buffer of data.
- * @param size		The size of the contiguous buffer of data.
- * @param queue		The queue to which the destructor should be submitted.
- * @param destructor	The destructor responsible for freeing the data when it
- *			is no longer needed.
- * @result		A newly created dispatch data object.
- */
-API_AVAILABLE(macos(10.7), ios(5.0))
-DISPATCH_EXPORT DISPATCH_RETURNS_RETAINED DISPATCH_WARN_RESULT DISPATCH_NOTHROW
-dispatch_data_t
-dispatch_data_create(const void *buffer,
-	size_t size,
-	dispatch_queue_t _Nullable queue,
-	dispatch_block_t _Nullable destructor);
-#endif /* __BLOCKS__ */
-
-/*!
- * @function dispatch_data_get_size
- * Returns the logical size of the memory region(s) represented by the specified
- * dispatch data object.
- *
- * @param data	The dispatch data object to query.
- * @result	The number of bytes represented by the data object.
- */
-API_AVAILABLE(macos(10.7), ios(5.0))
-DISPATCH_EXPORT DISPATCH_PURE DISPATCH_NONNULL1 DISPATCH_NOTHROW
-size_t
-dispatch_data_get_size(dispatch_data_t data);
-
-/*!
- * @function dispatch_data_create_map
- * Maps the memory represented by the specified dispatch data object as a single
- * contiguous memory region and returns a new data object representing it.
- * If non-NULL references to a pointer and a size variable are provided, they
- * are filled with the location and extent of that region. These allow direct
- * read access to the represented memory, but are only valid until the returned
- * object is released. Under ARC, if that object is held in a variable with
- * automatic storage, care needs to be taken to ensure that it is not released
- * by the compiler before memory access via the pointer has been completed.
- *
- * @param data		The dispatch data object to map.
- * @param buffer_ptr	A pointer to a pointer variable to be filled with the
- *			location of the mapped contiguous memory region, or
- *			NULL.
- * @param size_ptr	A pointer to a size_t variable to be filled with the
- *			size of the mapped contiguous memory region, or NULL.
- * @result		A newly created dispatch data object.
- */
-API_AVAILABLE(macos(10.7), ios(5.0))
-DISPATCH_EXPORT DISPATCH_NONNULL1 DISPATCH_RETURNS_RETAINED
-DISPATCH_WARN_RESULT DISPATCH_NOTHROW
-dispatch_data_t
-dispatch_data_create_map(dispatch_data_t data,
-	const void *_Nullable *_Nullable buffer_ptr,
-	size_t *_Nullable size_ptr);
-
-/*!
- * @function dispatch_data_create_concat
- * Returns a new dispatch data object representing the concatenation of the
- * specified data objects. Those objects may be released by the application
- * after the call returns (however, the system might not deallocate the memory
- * region(s) described by them until the newly created object has also been
- * released).
- *
- * @param data1	The data object representing the region(s) of memory to place
- *		at the beginning of the newly created object.
- * @param data2	The data object representing the region(s) of memory to place
- *		at the end of the newly created object.
- * @result	A newly created object representing the concatenation of the
- *		data1 and data2 objects.
- */
-API_AVAILABLE(macos(10.7), ios(5.0))
-DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_RETURNS_RETAINED
-DISPATCH_WARN_RESULT DISPATCH_NOTHROW
-dispatch_data_t
-dispatch_data_create_concat(dispatch_data_t data1, dispatch_data_t data2);
-
-/*!
- * @function dispatch_data_create_subrange
- * Returns a new dispatch data object representing a subrange of the specified
- * data object, which may be released by the application after the call returns
- * (however, the system might not deallocate the memory region(s) described by
- * that object until the newly created object has also been released).
- *
- * @param data		The data object representing the region(s) of memory to
- *			create a subrange of.
- * @param offset	The offset into the data object where the subrange
- *			starts.
- * @param length	The length of the range.
- * @result		A newly created object representing the specified
- *			subrange of the data object.
- */
-API_AVAILABLE(macos(10.7), ios(5.0))
-DISPATCH_EXPORT DISPATCH_NONNULL1 DISPATCH_RETURNS_RETAINED
-DISPATCH_WARN_RESULT DISPATCH_NOTHROW
-dispatch_data_t
-dispatch_data_create_subrange(dispatch_data_t data,
-	size_t offset,
-	size_t length);
-
-#ifdef __BLOCKS__
-/*!
- * @typedef dispatch_data_applier_t
- * A block to be invoked for every contiguous memory region in a data object.
- *
- * @param region	A data object representing the current region.
- * @param offset	The logical offset of the current region to the start
- *			of the data object.
- * @param buffer	The location of the memory for the current region.
- * @param size		The size of the memory for the current region.
- * @result		A Boolean indicating whether traversal should continue.
- */
-typedef bool (^dispatch_data_applier_t)(dispatch_data_t region,
-	size_t offset,
-	const void *buffer,
-	size_t size);
-
-/*!
- * @function dispatch_data_apply
- * Traverse the memory regions represented by the specified dispatch data object
- * in logical order and invoke the specified block once for every contiguous
- * memory region encountered.
- *
- * Each invocation of the block is passed a data object representing the current
- * region and its logical offset, along with the memory location and extent of
- * the region. These allow direct read access to the memory region, but are only
- * valid until the passed-in region object is released. Note that the region
- * object is released by the system when the block returns, it is the
- * responsibility of the application to retain it if the region object or the
- * associated memory location are needed after the block returns.
- *
- * @param data		The data object to traverse.
- * @param applier	The block to be invoked for every contiguous memory
- *			region in the data object.
- * @result		A Boolean indicating whether traversal completed
- *			successfully.
- */
-API_AVAILABLE(macos(10.7), ios(5.0))
-DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW
-bool
-dispatch_data_apply(dispatch_data_t data,
-	DISPATCH_NOESCAPE dispatch_data_applier_t applier);
-#endif /* __BLOCKS__ */
-
-/*!
- * @function dispatch_data_copy_region
- * Finds the contiguous memory region containing the specified location among
- * the regions represented by the specified object and returns a copy of the
- * internal dispatch data object representing that region along with its logical
- * offset in the specified object.
- *
- * @param data		The dispatch data object to query.
- * @param location	The logical position in the data object to query.
- * @param offset_ptr	A pointer to a size_t variable to be filled with the
- *			logical offset of the returned region object to the
- *			start of the queried data object.
- * @result		A newly created dispatch data object.
- */
-API_AVAILABLE(macos(10.7), ios(5.0))
-DISPATCH_EXPORT DISPATCH_NONNULL1 DISPATCH_NONNULL3 DISPATCH_RETURNS_RETAINED
-DISPATCH_WARN_RESULT DISPATCH_NOTHROW
-dispatch_data_t
-dispatch_data_copy_region(dispatch_data_t data,
-	size_t location,
-	size_t *offset_ptr);
-
-__END_DECLS
-
-DISPATCH_ASSUME_NONNULL_END
-
-#endif /* __DISPATCH_DATA__ */
--- a/Telegram/ThirdParty/dispatch/dispatch/dispatch.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/dispatch/dispatch.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,80 +0,0 @@
-/*
- * Copyright (c) 2008-2013 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#ifndef __DISPATCH_PUBLIC__
-#define __DISPATCH_PUBLIC__
-
-#ifdef __APPLE__
-#include <Availability.h>
-#include <os/availability.h>
-#include <TargetConditionals.h>
-#include <os/base.h>
-#elif defined(_WIN32)
-#include <os/generic_win_base.h>
-#elif defined(__unix__)
-#include <os/generic_unix_base.h>
-#endif
-
-#include <sys/types.h>
-#include <stddef.h>
-#include <stdint.h>
-#include <stdbool.h>
-#include <stdarg.h>
-#include <string.h>
-#if defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))
-#include <unistd.h>
-#endif
-#include <fcntl.h>
-#if defined(_WIN32)
-#include <time.h>
-#endif
-
-#if (defined(__linux__) || defined(__FreeBSD__)) && defined(__has_feature)
-#if __has_feature(modules)
-#if !defined(__arm__)
-#include <stdio.h> // for off_t (to match Glibc.modulemap)
-#endif
-#endif
-#endif
-
-#define DISPATCH_API_VERSION 20180109
-
-#ifndef __DISPATCH_BUILDING_DISPATCH__
-#ifndef __DISPATCH_INDIRECT__
-#define __DISPATCH_INDIRECT__
-#endif
-
-#include <os/object.h>
-#include <dispatch/base.h>
-#include <dispatch/time.h>
-#include <dispatch/object.h>
-#include <dispatch/queue.h>
-#include <dispatch/block.h>
-#include <dispatch/source.h>
-#include <dispatch/group.h>
-#include <dispatch/semaphore.h>
-#include <dispatch/once.h>
-#include <dispatch/data.h>
-#include <dispatch/io.h>
-
-#undef __DISPATCH_INDIRECT__
-#endif /* !__DISPATCH_BUILDING_DISPATCH__ */
-
-#endif
--- a/Telegram/ThirdParty/dispatch/dispatch/generic/module.modulemap	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/dispatch/generic/module.modulemap	1970-01-01 00:00:00.000000000 -0000
@@ -1,18 +0,0 @@
-module Dispatch {
-	requires blocks
-	export *
-	link "dispatch"
-	link "BlocksRuntime"
-}
-
-module DispatchIntrospection [system] [extern_c] {
-	header "introspection.h"
-	export *
-}
-
-module CDispatch [system] [extern_c] {
-	umbrella header "dispatch.h"
-	export *
-	requires blocks
-	link "dispatch"
-}
--- a/Telegram/ThirdParty/dispatch/dispatch/generic_static/module.modulemap	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/dispatch/generic_static/module.modulemap	1970-01-01 00:00:00.000000000 -0000
@@ -1,19 +0,0 @@
-module Dispatch {
-	requires blocks
-	export *
-	link "dispatch"
-	link "BlocksRuntime"
-	link "DispatchStubs"
-}
-
-module DispatchIntrospection [system] [extern_c] {
-	header "introspection.h"
-	export *
-}
-
-module CDispatch [system] [extern_c] {
-	umbrella header "dispatch.h"
-	export *
-	requires blocks
-	link "dispatch"
-}
--- a/Telegram/ThirdParty/dispatch/dispatch/group.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/dispatch/group.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,279 +0,0 @@
-/*
- * Copyright (c) 2008-2013 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#ifndef __DISPATCH_GROUP__
-#define __DISPATCH_GROUP__
-
-#ifndef __DISPATCH_INDIRECT__
-#error "Please #include <dispatch/dispatch.h> instead of this file directly."
-#include <dispatch/base.h> // for HeaderDoc
-#endif
-
-DISPATCH_ASSUME_NONNULL_BEGIN
-
-/*!
- * @typedef dispatch_group_t
- * @abstract
- * A group of blocks submitted to queues for asynchronous invocation.
- */
-DISPATCH_DECL(dispatch_group);
-
-__BEGIN_DECLS
-
-/*!
- * @function dispatch_group_create
- *
- * @abstract
- * Creates new group with which blocks may be associated.
- *
- * @discussion
- * This function creates a new group with which blocks may be associated.
- * The dispatch group may be used to wait for the completion of the blocks it
- * references. The group object memory is freed with dispatch_release().
- *
- * @result
- * The newly created group, or NULL on failure.
- */
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_EXPORT DISPATCH_MALLOC DISPATCH_RETURNS_RETAINED DISPATCH_WARN_RESULT
-DISPATCH_NOTHROW
-dispatch_group_t
-dispatch_group_create(void);
-
-/*!
- * @function dispatch_group_async
- *
- * @abstract
- * Submits a block to a dispatch queue and associates the block with the given
- * dispatch group.
- *
- * @discussion
- * Submits a block to a dispatch queue and associates the block with the given
- * dispatch group. The dispatch group may be used to wait for the completion
- * of the blocks it references.
- *
- * @param group
- * A dispatch group to associate with the submitted block.
- * The result of passing NULL in this parameter is undefined.
- *
- * @param queue
- * The dispatch queue to which the block will be submitted for asynchronous
- * invocation.
- *
- * @param block
- * The block to perform asynchronously.
- */
-#ifdef __BLOCKS__
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW
-void
-dispatch_group_async(dispatch_group_t group,
-	dispatch_queue_t queue,
-	dispatch_block_t block);
-#endif /* __BLOCKS__ */
-
-/*!
- * @function dispatch_group_async_f
- *
- * @abstract
- * Submits a function to a dispatch queue and associates the block with the
- * given dispatch group.
- *
- * @discussion
- * See dispatch_group_async() for details.
- *
- * @param group
- * A dispatch group to associate with the submitted function.
- * The result of passing NULL in this parameter is undefined.
- *
- * @param queue
- * The dispatch queue to which the function will be submitted for asynchronous
- * invocation.
- *
- * @param context
- * The application-defined context parameter to pass to the function.
- *
- * @param work
- * The application-defined function to invoke on the target queue. The first
- * parameter passed to this function is the context provided to
- * dispatch_group_async_f().
- */
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_EXPORT DISPATCH_NONNULL1 DISPATCH_NONNULL2 DISPATCH_NONNULL4
-DISPATCH_NOTHROW
-void
-dispatch_group_async_f(dispatch_group_t group,
-	dispatch_queue_t queue,
-	void *_Nullable context,
-	dispatch_function_t work);
-
-/*!
- * @function dispatch_group_wait
- *
- * @abstract
- * Wait synchronously until all the blocks associated with a group have
- * completed or until the specified timeout has elapsed.
- *
- * @discussion
- * This function waits for the completion of the blocks associated with the
- * given dispatch group, and returns after all blocks have completed or when
- * the specified timeout has elapsed.
- *
- * This function will return immediately if there are no blocks associated
- * with the dispatch group (i.e. the group is empty).
- *
- * The result of calling this function from multiple threads simultaneously
- * with the same dispatch group is undefined.
- *
- * After the successful return of this function, the dispatch group is empty.
- * It may either be released with dispatch_release() or re-used for additional
- * blocks. See dispatch_group_async() for more information.
- *
- * @param group
- * The dispatch group to wait on.
- * The result of passing NULL in this parameter is undefined.
- *
- * @param timeout
- * When to timeout (see dispatch_time). As a convenience, there are the
- * DISPATCH_TIME_NOW and DISPATCH_TIME_FOREVER constants.
- *
- * @result
- * Returns zero on success (all blocks associated with the group completed
- * within the specified timeout) or non-zero on error (i.e. timed out).
- */
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW
-intptr_t
-dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout);
-
-/*!
- * @function dispatch_group_notify
- *
- * @abstract
- * Schedule a block to be submitted to a queue when all the blocks associated
- * with a group have completed.
- *
- * @discussion
- * This function schedules a notification block to be submitted to the specified
- * queue once all blocks associated with the dispatch group have completed.
- *
- * If no blocks are associated with the dispatch group (i.e. the group is empty)
- * then the notification block will be submitted immediately.
- *
- * The group will be empty at the time the notification block is submitted to
- * the target queue. The group may either be released with dispatch_release()
- * or reused for additional operations.
- * See dispatch_group_async() for more information.
- *
- * @param group
- * The dispatch group to observe.
- * The result of passing NULL in this parameter is undefined.
- *
- * @param queue
- * The queue to which the supplied block will be submitted when the group
- * completes.
- *
- * @param block
- * The block to submit when the group completes.
- */
-#ifdef __BLOCKS__
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW
-void
-dispatch_group_notify(dispatch_group_t group,
-	dispatch_queue_t queue,
-	dispatch_block_t block);
-#endif /* __BLOCKS__ */
-
-/*!
- * @function dispatch_group_notify_f
- *
- * @abstract
- * Schedule a function to be submitted to a queue when all the blocks
- * associated with a group have completed.
- *
- * @discussion
- * See dispatch_group_notify() for details.
- *
- * @param group
- * The dispatch group to observe.
- * The result of passing NULL in this parameter is undefined.
- *
- * @param context
- * The application-defined context parameter to pass to the function.
- *
- * @param work
- * The application-defined function to invoke on the target queue. The first
- * parameter passed to this function is the context provided to
- * dispatch_group_notify_f().
- */
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_EXPORT DISPATCH_NONNULL1 DISPATCH_NONNULL2 DISPATCH_NONNULL4
-DISPATCH_NOTHROW
-void
-dispatch_group_notify_f(dispatch_group_t group,
-	dispatch_queue_t queue,
-	void *_Nullable context,
-	dispatch_function_t work);
-
-/*!
- * @function dispatch_group_enter
- *
- * @abstract
- * Manually indicate a block has entered the group
- *
- * @discussion
- * Calling this function indicates another block has joined the group through
- * a means other than dispatch_group_async(). Calls to this function must be
- * balanced with dispatch_group_leave().
- *
- * @param group
- * The dispatch group to update.
- * The result of passing NULL in this parameter is undefined.
- */
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW
-void
-dispatch_group_enter(dispatch_group_t group);
-
-/*!
- * @function dispatch_group_leave
- *
- * @abstract
- * Manually indicate a block in the group has completed
- *
- * @discussion
- * Calling this function indicates block has completed and left the dispatch
- * group by a means other than dispatch_group_async().
- *
- * @param group
- * The dispatch group to update.
- * The result of passing NULL in this parameter is undefined.
- */
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW
-void
-dispatch_group_leave(dispatch_group_t group);
-
-__END_DECLS
-
-DISPATCH_ASSUME_NONNULL_END
-
-#endif
--- a/Telegram/ThirdParty/dispatch/dispatch/introspection.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/dispatch/introspection.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,188 +0,0 @@
-/*
- * Copyright (c) 2013 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#ifndef __DISPATCH_INTROSPECTION__
-#define __DISPATCH_INTROSPECTION__
-
-#include <dispatch/dispatch.h>
-
-DISPATCH_ASSUME_NONNULL_BEGIN
-
-/*!
- * @header
- *
- * @abstract
- * Interposable introspection hooks for libdispatch.
- *
- * @discussion
- * These hooks are only available in the introspection version of the library,
- * loaded by running a process with the environment variable
- * DYLD_LIBRARY_PATH=/usr/lib/system/introspection
- */
-
-__BEGIN_DECLS
-
-/*!
- * @function dispatch_introspection_hook_queue_create
- *
- * @abstract
- * Interposable hook function called when a dispatch queue was created.
- *
- * @param queue
- * The newly created dispatch queue.
- */
-
-API_AVAILABLE(macos(10.9), ios(7.0))
-DISPATCH_EXPORT
-void
-dispatch_introspection_hook_queue_create(dispatch_queue_t queue);
-
-/*!
- * @function dispatch_introspection_hook_queue_destroy
- *
- * @abstract
- * Interposable hook function called when a dispatch queue is about to be
- * destroyed.
- *
- * @param queue
- * The dispatch queue about to be destroyed.
- */
-
-API_AVAILABLE(macos(10.9), ios(7.0))
-DISPATCH_EXPORT
-void
-dispatch_introspection_hook_queue_destroy(dispatch_queue_t queue);
-
-/*!
- * @function dispatch_introspection_hook_queue_item_enqueue
- *
- * @abstract
- * Interposable hook function called when an item is about to be enqueued onto
- * a dispatch queue.
- *
- * @param queue
- * The dispatch queue enqueued onto.
- *
- * @param item
- * The object about to be enqueued.
- */
-
-API_AVAILABLE(macos(10.9), ios(7.0))
-DISPATCH_EXPORT
-void
-dispatch_introspection_hook_queue_item_enqueue(dispatch_queue_t queue,
-		dispatch_object_t item);
-
-/*!
- * @function dispatch_introspection_hook_queue_item_dequeue
- *
- * @abstract
- * Interposable hook function called when an item was dequeued from a dispatch
- * queue.
- *
- * @param queue
- * The dispatch queue dequeued from.
- *
- * @param item
- * The dequeued object.
- */
-
-API_AVAILABLE(macos(10.9), ios(7.0))
-DISPATCH_EXPORT
-void
-dispatch_introspection_hook_queue_item_dequeue(dispatch_queue_t queue,
-		dispatch_object_t item);
-
-/*!
- * @function dispatch_introspection_hook_queue_item_complete
- *
- * @abstract
- * Interposable hook function called when an item previously dequeued from a
- * dispatch queue has completed processing.
- *
- * @discussion
- * The object pointer value passed to this function must be treated as a value
- * only. It is intended solely for matching up with an earlier call to a
- * dequeue hook function and must NOT be dereferenced.
- *
- * @param item
- * Opaque dentifier for completed item. Must NOT be dereferenced.
- */
-
-API_AVAILABLE(macos(10.10), ios(7.1))
-DISPATCH_EXPORT
-void
-dispatch_introspection_hook_queue_item_complete(dispatch_object_t item);
-
-/*!
- * @function dispatch_introspection_hook_queue_callout_begin
- *
- * @abstract
- * Interposable hook function called when a client function is about to be
- * called out to on a dispatch queue.
- *
- * @param queue
- * The dispatch queue the callout is performed on.
- *
- * @param context
- * The context parameter passed to the function. For a callout to a block,
- * this is a pointer to the block object.
- *
- * @param function
- * The client function about to be called out to. For a callout to a block,
- * this is the block object's invoke function.
- */
-
-API_AVAILABLE(macos(10.9), ios(7.0))
-DISPATCH_EXPORT
-void
-dispatch_introspection_hook_queue_callout_begin(dispatch_queue_t queue,
-		void *_Nullable context, dispatch_function_t function);
-
-/*!
- * @function dispatch_introspection_hook_queue_callout_end
- *
- * @abstract
- * Interposable hook function called after a client function has returned from
- * a callout on a dispatch queue.
- *
- * @param queue
- * The dispatch queue the callout was performed on.
- *
- * @param context
- * The context parameter passed to the function. For a callout to a block,
- * this is a pointer to the block object.
- *
- * @param function
- * The client function that was called out to. For a callout to a block,
- * this is the block object's invoke function.
- */
-
-API_AVAILABLE(macos(10.9), ios(7.0))
-DISPATCH_EXPORT
-void
-dispatch_introspection_hook_queue_callout_end(dispatch_queue_t queue,
-		void *_Nullable context, dispatch_function_t function);
-
-__END_DECLS
-
-DISPATCH_ASSUME_NONNULL_END
-
-#endif
--- a/Telegram/ThirdParty/dispatch/dispatch/io.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/dispatch/io.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,597 +0,0 @@
-/*
- * Copyright (c) 2009-2013 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#ifndef __DISPATCH_IO__
-#define __DISPATCH_IO__
-
-#ifndef __DISPATCH_INDIRECT__
-#error "Please #include <dispatch/dispatch.h> instead of this file directly."
-#include <dispatch/base.h> // for HeaderDoc
-#endif
-
-DISPATCH_ASSUME_NONNULL_BEGIN
-
-__BEGIN_DECLS
-
-/*! @header
- * Dispatch I/O provides both stream and random access asynchronous read and
- * write operations on file descriptors. One or more dispatch I/O channels may
- * be created from a file descriptor as either the DISPATCH_IO_STREAM type or
- * DISPATCH_IO_RANDOM type. Once a channel has been created the application may
- * schedule asynchronous read and write operations.
- *
- * The application may set policies on the dispatch I/O channel to indicate the
- * desired frequency of I/O handlers for long-running operations.
- *
- * Dispatch I/O also provides a memory management model for I/O buffers that
- * avoids unnecessary copying of data when pipelined between channels. Dispatch
- * I/O monitors the overall memory pressure and I/O access patterns for the
- * application to optimize resource utilization.
- */
-
-/*!
- * @typedef dispatch_fd_t
- * Native file descriptor type for the platform.
- */
-#if defined(_WIN32)
-typedef intptr_t dispatch_fd_t;
-#else
-typedef int dispatch_fd_t;
-#endif
-
-/*!
- * @functiongroup Dispatch I/O Convenience API
- * Convenience wrappers around the dispatch I/O channel API, with simpler
- * callback handler semantics and no explicit management of channel objects.
- * File descriptors passed to the convenience API are treated as streams, and
- * scheduling multiple operations on one file descriptor via the convenience API
- * may incur more overhead than by using the dispatch I/O channel API directly.
- */
-
-#ifdef __BLOCKS__
-/*!
- * @function dispatch_read
- * Schedule a read operation for asynchronous execution on the specified file
- * descriptor. The specified handler is enqueued with the data read from the
- * file descriptor when the operation has completed or an error occurs.
- *
- * The data object passed to the handler will be automatically released by the
- * system when the handler returns. It is the responsibility of the application
- * to retain, concatenate or copy the data object if it is needed after the
- * handler returns.
- *
- * The data object passed to the handler will only contain as much data as is
- * currently available from the file descriptor (up to the specified length).
- *
- * If an unrecoverable error occurs on the file descriptor, the handler will be
- * enqueued with the appropriate error code along with a data object of any data
- * that could be read successfully.
- *
- * An invocation of the handler with an error code of zero and an empty data
- * object indicates that EOF was reached.
- *
- * The system takes control of the file descriptor until the handler is
- * enqueued, and during this time file descriptor flags such as O_NONBLOCK will
- * be modified by the system on behalf of the application. It is an error for
- * the application to modify a file descriptor directly while it is under the
- * control of the system, but it may create additional dispatch I/O convenience
- * operations or dispatch I/O channels associated with that file descriptor.
- *
- * @param fd		The file descriptor from which to read the data.
- * @param length	The length of data to read from the file descriptor,
- *			or SIZE_MAX to indicate that all of the data currently
- *			available from the file descriptor should be read.
- * @param queue		The dispatch queue to which the handler should be
- *			submitted.
- * @param handler	The handler to enqueue when data is ready to be
- *			delivered.
- *		param data	The data read from the file descriptor.
- *		param error	An errno condition for the read operation or
- *				zero if the read was successful.
- */
-API_AVAILABLE(macos(10.7), ios(5.0))
-DISPATCH_EXPORT DISPATCH_NONNULL3 DISPATCH_NONNULL4 DISPATCH_NOTHROW
-void
-dispatch_read(dispatch_fd_t fd,
-	size_t length,
-	dispatch_queue_t queue,
-	void (^handler)(dispatch_data_t data, int error));
-
-/*!
- * @function dispatch_write
- * Schedule a write operation for asynchronous execution on the specified file
- * descriptor. The specified handler is enqueued when the operation has
- * completed or an error occurs.
- *
- * If an unrecoverable error occurs on the file descriptor, the handler will be
- * enqueued with the appropriate error code along with the data that could not
- * be successfully written.
- *
- * An invocation of the handler with an error code of zero indicates that the
- * data was fully written to the channel.
- *
- * The system takes control of the file descriptor until the handler is
- * enqueued, and during this time file descriptor flags such as O_NONBLOCK will
- * be modified by the system on behalf of the application. It is an error for
- * the application to modify a file descriptor directly while it is under the
- * control of the system, but it may create additional dispatch I/O convenience
- * operations or dispatch I/O channels associated with that file descriptor.
- *
- * @param fd		The file descriptor to which to write the data.
- * @param data		The data object to write to the file descriptor.
- * @param queue		The dispatch queue to which the handler should be
- *			submitted.
- * @param handler	The handler to enqueue when the data has been written.
- *		param data	The data that could not be written to the I/O
- *				channel, or NULL.
- *		param error	An errno condition for the write operation or
- *				zero if the write was successful.
- */
-API_AVAILABLE(macos(10.7), ios(5.0))
-DISPATCH_EXPORT DISPATCH_NONNULL2 DISPATCH_NONNULL3 DISPATCH_NONNULL4
-DISPATCH_NOTHROW
-void
-dispatch_write(dispatch_fd_t fd,
-	dispatch_data_t data,
-	dispatch_queue_t queue,
-	void (^handler)(dispatch_data_t _Nullable data, int error));
-#endif /* __BLOCKS__ */
-
-/*!
- * @functiongroup Dispatch I/O Channel API
- */
-
-/*!
- * @typedef dispatch_io_t
- * A dispatch I/O channel represents the asynchronous I/O policy applied to a
- * file descriptor. I/O channels are first class dispatch objects and may be
- * retained and released, suspended and resumed, etc.
- */
-DISPATCH_DECL(dispatch_io);
-
-/*!
- * @typedef dispatch_io_type_t
- * The type of a dispatch I/O channel:
- *
- * @const DISPATCH_IO_STREAM	A dispatch I/O channel representing a stream of
- * bytes. Read and write operations on a channel of this type are performed
- * serially (in order of creation) and read/write data at the file pointer
- * position that is current at the time the operation starts executing.
- * Operations of different type (read vs. write) may be performed simultaneously.
- * Offsets passed to operations on a channel of this type are ignored.
- *
- * @const DISPATCH_IO_RANDOM	A dispatch I/O channel representing a random
- * access file. Read and write operations on a channel of this type may be
- * performed concurrently and read/write data at the specified offset. Offsets
- * are interpreted relative to the file pointer position current at the time the
- * I/O channel is created. Attempting to create a channel of this type for a
- * file descriptor that is not seekable will result in an error.
- */
-#define DISPATCH_IO_STREAM 0
-#define DISPATCH_IO_RANDOM 1
-
-typedef unsigned long dispatch_io_type_t;
-
-#ifdef __BLOCKS__
-/*!
- * @function dispatch_io_create
- * Create a dispatch I/O channel associated with a file descriptor. The system
- * takes control of the file descriptor until the channel is closed, an error
- * occurs on the file descriptor or all references to the channel are released.
- * At that time the specified cleanup handler will be enqueued and control over
- * the file descriptor relinquished.
- *
- * While a file descriptor is under the control of a dispatch I/O channel, file
- * descriptor flags such as O_NONBLOCK will be modified by the system on behalf
- * of the application. It is an error for the application to modify a file
- * descriptor directly while it is under the control of a dispatch I/O channel,
- * but it may create additional channels associated with that file descriptor.
- *
- * @param type	The desired type of I/O channel (DISPATCH_IO_STREAM
- *		or DISPATCH_IO_RANDOM).
- * @param fd	The file descriptor to associate with the I/O channel.
- * @param queue	The dispatch queue to which the handler should be submitted.
- * @param cleanup_handler	The handler to enqueue when the system
- *				relinquishes control over the file descriptor.
- *	param error		An errno condition if control is relinquished
- *				because channel creation failed, zero otherwise.
- * @result	The newly created dispatch I/O channel or NULL if an error
- *		occurred (invalid type specified).
- */
-API_AVAILABLE(macos(10.7), ios(5.0))
-DISPATCH_EXPORT DISPATCH_MALLOC DISPATCH_RETURNS_RETAINED DISPATCH_WARN_RESULT
-DISPATCH_NOTHROW
-dispatch_io_t
-dispatch_io_create(dispatch_io_type_t type,
-	dispatch_fd_t fd,
-	dispatch_queue_t queue,
-	void (^cleanup_handler)(int error));
-
-/*!
- * @function dispatch_io_create_with_path
- * Create a dispatch I/O channel associated with a path name. The specified
- * path, oflag and mode parameters will be passed to open(2) when the first I/O
- * operation on the channel is ready to execute and the resulting file
- * descriptor will remain open and under the control of the system until the
- * channel is closed, an error occurs on the file descriptor or all references
- * to the channel are released. At that time the file descriptor will be closed
- * and the specified cleanup handler will be enqueued.
- *
- * @param type	The desired type of I/O channel (DISPATCH_IO_STREAM
- *		or DISPATCH_IO_RANDOM).
- * @param path	The absolute path to associate with the I/O channel.
- * @param oflag	The flags to pass to open(2) when opening the file at
- *		path.
- * @param mode	The mode to pass to open(2) when creating the file at
- *		path (i.e. with flag O_CREAT), zero otherwise.
- * @param queue	The dispatch queue to which the handler should be
- *		submitted.
- * @param cleanup_handler	The handler to enqueue when the system
- *				has closed the file at path.
- *	param error		An errno condition if control is relinquished
- *				because channel creation or opening of the
- *				specified file failed, zero otherwise.
- * @result	The newly created dispatch I/O channel or NULL if an error
- *		occurred (invalid type or non-absolute path specified).
- */
-API_AVAILABLE(macos(10.7), ios(5.0))
-DISPATCH_EXPORT DISPATCH_NONNULL2 DISPATCH_MALLOC DISPATCH_RETURNS_RETAINED
-DISPATCH_WARN_RESULT DISPATCH_NOTHROW
-dispatch_io_t
-dispatch_io_create_with_path(dispatch_io_type_t type,
-	const char *path, int oflag, mode_t mode,
-	dispatch_queue_t queue,
-	void (^cleanup_handler)(int error));
-
-/*!
- * @function dispatch_io_create_with_io
- * Create a new dispatch I/O channel from an existing dispatch I/O channel.
- * The new channel inherits the file descriptor or path name associated with
- * the existing channel, but not its channel type or policies.
- *
- * If the existing channel is associated with a file descriptor, control by the
- * system over that file descriptor is extended until the new channel is also
- * closed, an error occurs on the file descriptor, or all references to both
- * channels are released. At that time the specified cleanup handler will be
- * enqueued and control over the file descriptor relinquished.
- *
- * While a file descriptor is under the control of a dispatch I/O channel, file
- * descriptor flags such as O_NONBLOCK will be modified by the system on behalf
- * of the application. It is an error for the application to modify a file
- * descriptor directly while it is under the control of a dispatch I/O channel,
- * but it may create additional channels associated with that file descriptor.
- *
- * @param type	The desired type of I/O channel (DISPATCH_IO_STREAM
- *		or DISPATCH_IO_RANDOM).
- * @param io	The existing channel to create the new I/O channel from.
- * @param queue	The dispatch queue to which the handler should be submitted.
- * @param cleanup_handler	The handler to enqueue when the system
- *				relinquishes control over the file descriptor
- *				(resp. closes the file at path) associated with
- *				the existing channel.
- *	param error		An errno condition if control is relinquished
- *				because channel creation failed, zero otherwise.
- * @result	The newly created dispatch I/O channel or NULL if an error
- *		occurred (invalid type specified).
- */
-API_AVAILABLE(macos(10.7), ios(5.0))
-DISPATCH_EXPORT DISPATCH_NONNULL2 DISPATCH_MALLOC DISPATCH_RETURNS_RETAINED
-DISPATCH_WARN_RESULT DISPATCH_NOTHROW
-dispatch_io_t
-dispatch_io_create_with_io(dispatch_io_type_t type,
-	dispatch_io_t io,
-	dispatch_queue_t queue,
-	void (^cleanup_handler)(int error));
-
-/*!
- * @typedef dispatch_io_handler_t
- * The prototype of I/O handler blocks for dispatch I/O operations.
- *
- * @param done		A flag indicating whether the operation is complete.
- * @param data		The data object to be handled.
- * @param error		An errno condition for the operation.
- */
-typedef void (^dispatch_io_handler_t)(bool done, dispatch_data_t _Nullable data,
-		int error);
-
-/*!
- * @function dispatch_io_read
- * Schedule a read operation for asynchronous execution on the specified I/O
- * channel. The I/O handler is enqueued one or more times depending on the
- * general load of the system and the policy specified on the I/O channel.
- *
- * Any data read from the channel is described by the dispatch data object
- * passed to the I/O handler. This object will be automatically released by the
- * system when the I/O handler returns. It is the responsibility of the
- * application to retain, concatenate or copy the data object if it is needed
- * after the I/O handler returns.
- *
- * Dispatch I/O handlers are not reentrant. The system will ensure that no new
- * I/O handler instance is invoked until the previously enqueued handler block
- * has returned.
- *
- * An invocation of the I/O handler with the done flag set indicates that the
- * read operation is complete and that the handler will not be enqueued again.
- *
- * If an unrecoverable error occurs on the I/O channel's underlying file
- * descriptor, the I/O handler will be enqueued with the done flag set, the
- * appropriate error code and a NULL data object.
- *
- * An invocation of the I/O handler with the done flag set, an error code of
- * zero and an empty data object indicates that EOF was reached.
- *
- * @param channel	The dispatch I/O channel from which to read the data.
- * @param offset	The offset relative to the channel position from which
- *			to start reading (only for DISPATCH_IO_RANDOM).
- * @param length	The length of data to read from the I/O channel, or
- *			SIZE_MAX to indicate that data should be read until EOF
- *			is reached.
- * @param queue		The dispatch queue to which the I/O handler should be
- *			submitted.
- * @param io_handler	The I/O handler to enqueue when data is ready to be
- *			delivered.
- *	param done	A flag indicating whether the operation is complete.
- *	param data	An object with the data most recently read from the
- *			I/O channel as part of this read operation, or NULL.
- *	param error	An errno condition for the read operation or zero if
- *			the read was successful.
- */
-API_AVAILABLE(macos(10.7), ios(5.0))
-DISPATCH_EXPORT DISPATCH_NONNULL1 DISPATCH_NONNULL4 DISPATCH_NONNULL5
-DISPATCH_NOTHROW
-void
-dispatch_io_read(dispatch_io_t channel,
-	off_t offset,
-	size_t length,
-	dispatch_queue_t queue,
-	dispatch_io_handler_t io_handler);
-
-/*!
- * @function dispatch_io_write
- * Schedule a write operation for asynchronous execution on the specified I/O
- * channel. The I/O handler is enqueued one or more times depending on the
- * general load of the system and the policy specified on the I/O channel.
- *
- * Any data remaining to be written to the I/O channel is described by the
- * dispatch data object passed to the I/O handler. This object will be
- * automatically released by the system when the I/O handler returns. It is the
- * responsibility of the application to retain, concatenate or copy the data
- * object if it is needed after the I/O handler returns.
- *
- * Dispatch I/O handlers are not reentrant. The system will ensure that no new
- * I/O handler instance is invoked until the previously enqueued handler block
- * has returned.
- *
- * An invocation of the I/O handler with the done flag set indicates that the
- * write operation is complete and that the handler will not be enqueued again.
- *
- * If an unrecoverable error occurs on the I/O channel's underlying file
- * descriptor, the I/O handler will be enqueued with the done flag set, the
- * appropriate error code and an object containing the data that could not be
- * written.
- *
- * An invocation of the I/O handler with the done flag set and an error code of
- * zero indicates that the data was fully written to the channel.
- *
- * @param channel	The dispatch I/O channel on which to write the data.
- * @param offset	The offset relative to the channel position from which
- *			to start writing (only for DISPATCH_IO_RANDOM).
- * @param data		The data to write to the I/O channel. The data object
- *			will be retained by the system until the write operation
- *			is complete.
- * @param queue		The dispatch queue to which the I/O handler should be
- *			submitted.
- * @param io_handler	The I/O handler to enqueue when data has been delivered.
- *	param done	A flag indicating whether the operation is complete.
- *	param data	An object of the data remaining to be
- *			written to the I/O channel as part of this write
- *			operation, or NULL.
- *	param error	An errno condition for the write operation or zero
- *			if the write was successful.
- */
-API_AVAILABLE(macos(10.7), ios(5.0))
-DISPATCH_EXPORT DISPATCH_NONNULL1 DISPATCH_NONNULL3 DISPATCH_NONNULL4
-DISPATCH_NONNULL5 DISPATCH_NOTHROW
-void
-dispatch_io_write(dispatch_io_t channel,
-	off_t offset,
-	dispatch_data_t data,
-	dispatch_queue_t queue,
-	dispatch_io_handler_t io_handler);
-#endif /* __BLOCKS__ */
-
-/*!
- * @typedef dispatch_io_close_flags_t
- * The type of flags you can set on a dispatch_io_close() call
- *
- * @const DISPATCH_IO_STOP	Stop outstanding operations on a channel when
- *				the channel is closed.
- */
-#define DISPATCH_IO_STOP 0x1
-
-typedef unsigned long dispatch_io_close_flags_t;
-
-/*!
- * @function dispatch_io_close
- * Close the specified I/O channel to new read or write operations; scheduling
- * operations on a closed channel results in their handler returning an error.
- *
- * If the DISPATCH_IO_STOP flag is provided, the system will make a best effort
- * to interrupt any outstanding read and write operations on the I/O channel,
- * otherwise those operations will run to completion normally.
- * Partial results of read and write operations may be returned even after a
- * channel is closed with the DISPATCH_IO_STOP flag.
- * The final invocation of an I/O handler of an interrupted operation will be
- * passed an ECANCELED error code, as will the I/O handler of an operation
- * scheduled on a closed channel.
- *
- * @param channel	The dispatch I/O channel to close.
- * @param flags		The flags for the close operation.
- */
-API_AVAILABLE(macos(10.7), ios(5.0))
-DISPATCH_EXPORT DISPATCH_NONNULL1 DISPATCH_NOTHROW
-void
-dispatch_io_close(dispatch_io_t channel, dispatch_io_close_flags_t flags);
-
-#ifdef __BLOCKS__
-/*!
- * @function dispatch_io_barrier
- * Schedule a barrier operation on the specified I/O channel; all previously
- * scheduled operations on the channel will complete before the provided
- * barrier block is enqueued onto the global queue determined by the channel's
- * target queue, and no subsequently scheduled operations will start until the
- * barrier block has returned.
- *
- * If multiple channels are associated with the same file descriptor, a barrier
- * operation scheduled on any of these channels will act as a barrier across all
- * channels in question, i.e. all previously scheduled operations on any of the
- * channels will complete before the barrier block is enqueued, and no
- * operations subsequently scheduled on any of the channels will start until the
- * barrier block has returned.
- *
- * While the barrier block is running, it may safely operate on the channel's
- * underlying file descriptor with fsync(2), lseek(2) etc. (but not close(2)).
- *
- * @param channel	The dispatch I/O channel to schedule the barrier on.
- * @param barrier	The barrier block.
- */
-API_AVAILABLE(macos(10.7), ios(5.0))
-DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW
-void
-dispatch_io_barrier(dispatch_io_t channel, dispatch_block_t barrier);
-#endif /* __BLOCKS__ */
-
-/*!
- * @function dispatch_io_get_descriptor
- * Returns the file descriptor underlying a dispatch I/O channel.
- *
- * Will return -1 for a channel closed with dispatch_io_close() and for a
- * channel associated with a path name that has not yet been open(2)ed.
- *
- * If called from a barrier block scheduled on a channel associated with a path
- * name that has not yet been open(2)ed, this will trigger the channel open(2)
- * operation and return the resulting file descriptor.
- *
- * @param channel	The dispatch I/O channel to query.
- * @result		The file descriptor underlying the channel, or -1.
- */
-API_AVAILABLE(macos(10.7), ios(5.0))
-DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_WARN_RESULT DISPATCH_NOTHROW
-dispatch_fd_t
-dispatch_io_get_descriptor(dispatch_io_t channel);
-
-/*!
- * @function dispatch_io_set_high_water
- * Set a high water mark on the I/O channel for all operations.
- *
- * The system will make a best effort to enqueue I/O handlers with partial
- * results as soon the number of bytes processed by an operation (i.e. read or
- * written) reaches the high water mark.
- *
- * The size of data objects passed to I/O handlers for this channel will never
- * exceed the specified high water mark.
- *
- * The default value for the high water mark is unlimited (i.e. SIZE_MAX).
- *
- * @param channel	The dispatch I/O channel on which to set the policy.
- * @param high_water	The number of bytes to use as a high water mark.
- */
-API_AVAILABLE(macos(10.7), ios(5.0))
-DISPATCH_EXPORT DISPATCH_NONNULL1 DISPATCH_NOTHROW
-void
-dispatch_io_set_high_water(dispatch_io_t channel, size_t high_water);
-
-/*!
- * @function dispatch_io_set_low_water
- * Set a low water mark on the I/O channel for all operations.
- *
- * The system will process (i.e. read or write) at least the low water mark
- * number of bytes for an operation before enqueueing I/O handlers with partial
- * results.
- *
- * The size of data objects passed to intermediate I/O handler invocations for
- * this channel (i.e. excluding the final invocation) will never be smaller than
- * the specified low water mark, except if the channel has an interval with the
- * DISPATCH_IO_STRICT_INTERVAL flag set or if EOF or an error was encountered.
- *
- * I/O handlers should be prepared to receive amounts of data significantly
- * larger than the low water mark in general. If an I/O handler requires
- * intermediate results of fixed size, set both the low and and the high water
- * mark to that size.
- *
- * The default value for the low water mark is unspecified, but must be assumed
- * to be such that intermediate handler invocations may occur.
- * If I/O handler invocations with partial results are not desired, set the
- * low water mark to SIZE_MAX.
- *
- * @param channel	The dispatch I/O channel on which to set the policy.
- * @param low_water	The number of bytes to use as a low water mark.
- */
-API_AVAILABLE(macos(10.7), ios(5.0))
-DISPATCH_EXPORT DISPATCH_NONNULL1 DISPATCH_NOTHROW
-void
-dispatch_io_set_low_water(dispatch_io_t channel, size_t low_water);
-
-/*!
- * @typedef dispatch_io_interval_flags_t
- * Type of flags to set on dispatch_io_set_interval()
- *
- * @const DISPATCH_IO_STRICT_INTERVAL	Enqueue I/O handlers at a channel's
- * interval setting even if the amount of data ready to be delivered is inferior
- * to the low water mark (or zero).
- */
-#define DISPATCH_IO_STRICT_INTERVAL 0x1
-
-typedef unsigned long dispatch_io_interval_flags_t;
-
-/*!
- * @function dispatch_io_set_interval
- * Set a nanosecond interval at which I/O handlers are to be enqueued on the
- * I/O channel for all operations.
- *
- * This allows an application to receive periodic feedback on the progress of
- * read and write operations, e.g. for the purposes of displaying progress bars.
- *
- * If the amount of data ready to be delivered to an I/O handler at the interval
- * is inferior to the channel low water mark, the handler will only be enqueued
- * if the DISPATCH_IO_STRICT_INTERVAL flag is set.
- *
- * Note that the system may defer enqueueing interval I/O handlers by a small
- * unspecified amount of leeway in order to align with other system activity for
- * improved system performance or power consumption.
- *
- * @param channel	The dispatch I/O channel on which to set the policy.
- * @param interval	The interval in nanoseconds at which delivery of the I/O
- *					handler is desired.
- * @param flags		Flags indicating desired data delivery behavior at
- *					interval time.
- */
-API_AVAILABLE(macos(10.7), ios(5.0))
-DISPATCH_EXPORT DISPATCH_NONNULL1 DISPATCH_NOTHROW
-void
-dispatch_io_set_interval(dispatch_io_t channel,
-	uint64_t interval,
-	dispatch_io_interval_flags_t flags);
-
-__END_DECLS
-
-DISPATCH_ASSUME_NONNULL_END
-
-#endif /* __DISPATCH_IO__ */
--- a/Telegram/ThirdParty/dispatch/dispatch/object.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/dispatch/object.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,550 +0,0 @@
-/*
- * Copyright (c) 2008-2012 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#ifndef __DISPATCH_OBJECT__
-#define __DISPATCH_OBJECT__
-
-#ifndef __DISPATCH_INDIRECT__
-#error "Please #include <dispatch/dispatch.h> instead of this file directly."
-#include <dispatch/base.h> // for HeaderDoc
-#endif
-
-DISPATCH_ASSUME_NONNULL_BEGIN
-
-/*!
- * @typedef dispatch_object_t
- *
- * @abstract
- * Abstract base type for all dispatch objects.
- * The details of the type definition are language-specific.
- *
- * @discussion
- * Dispatch objects are reference counted via calls to dispatch_retain() and
- * dispatch_release().
- */
-
-#if OS_OBJECT_USE_OBJC
-/*
- * By default, dispatch objects are declared as Objective-C types when building
- * with an Objective-C compiler. This allows them to participate in ARC, in RR
- * management by the Blocks runtime and in leaks checking by the static
- * analyzer, and enables them to be added to Cocoa collections.
- * See <os/object.h> for details.
- */
-OS_OBJECT_DECL_CLASS(dispatch_object);
-
-#if OS_OBJECT_SWIFT3
-#define DISPATCH_DECL(name) OS_OBJECT_DECL_SUBCLASS_SWIFT(name, dispatch_object)
-#define DISPATCH_DECL_SUBCLASS(name, base) OS_OBJECT_DECL_SUBCLASS_SWIFT(name, base)
-#else // OS_OBJECT_SWIFT3
-#define DISPATCH_DECL(name) OS_OBJECT_DECL_SUBCLASS(name, dispatch_object)
-#define DISPATCH_DECL_SUBCLASS(name, base) OS_OBJECT_DECL_SUBCLASS(name, base)
-
-DISPATCH_INLINE DISPATCH_ALWAYS_INLINE DISPATCH_NONNULL_ALL DISPATCH_NOTHROW
-void
-_dispatch_object_validate(dispatch_object_t object)
-{
-	void *isa = *(void *volatile*)(OS_OBJECT_BRIDGE void*)object;
-	(void)isa;
-}
-#endif // OS_OBJECT_SWIFT3
-
-#define DISPATCH_GLOBAL_OBJECT(type, object) ((OS_OBJECT_BRIDGE type)&(object))
-#define DISPATCH_RETURNS_RETAINED OS_OBJECT_RETURNS_RETAINED
-#elif defined(__cplusplus) && !defined(__DISPATCH_BUILDING_DISPATCH__)
-/*
- * Dispatch objects are NOT C++ objects. Nevertheless, we can at least keep C++
- * aware of type compatibility.
- */
-typedef struct dispatch_object_s {
-private:
-	dispatch_object_s();
-	~dispatch_object_s();
-	dispatch_object_s(const dispatch_object_s &);
-	void operator=(const dispatch_object_s &);
-} *dispatch_object_t;
-#define DISPATCH_DECL(name) \
-		typedef struct name##_s : public dispatch_object_s {} *name##_t
-#define DISPATCH_DECL_SUBCLASS(name, base) \
-		typedef struct name##_s : public base##_s {} *name##_t
-#define DISPATCH_GLOBAL_OBJECT(type, object) (static_cast<type>(&(object)))
-#define DISPATCH_RETURNS_RETAINED
-#else /* Plain C */
-#ifndef __DISPATCH_BUILDING_DISPATCH__
-typedef union {
-	struct _os_object_s *_os_obj;
-	struct dispatch_object_s *_do;
-	struct dispatch_queue_s *_dq;
-	struct dispatch_queue_attr_s *_dqa;
-	struct dispatch_group_s *_dg;
-	struct dispatch_source_s *_ds;
-	struct dispatch_mach_s *_dm;
-	struct dispatch_mach_msg_s *_dmsg;
-	struct dispatch_semaphore_s *_dsema;
-	struct dispatch_data_s *_ddata;
-	struct dispatch_io_s *_dchannel;
-} dispatch_object_t DISPATCH_TRANSPARENT_UNION;
-#endif // !__DISPATCH_BUILDING_DISPATCH__
-#define DISPATCH_DECL(name) typedef struct name##_s *name##_t
-#define DISPATCH_DECL_SUBCLASS(name, base) typedef base##_t name##_t
-#define DISPATCH_GLOBAL_OBJECT(type, object) ((type)&(object))
-#define DISPATCH_RETURNS_RETAINED
-#endif
-
-#if OS_OBJECT_SWIFT3 && OS_OBJECT_USE_OBJC
-#define DISPATCH_SOURCE_TYPE_DECL(name) \
-		DISPATCH_EXPORT struct dispatch_source_type_s \
-				_dispatch_source_type_##name; \
-		OS_OBJECT_DECL_PROTOCOL(dispatch_source_##name, <OS_dispatch_source>); \
-		OS_OBJECT_CLASS_IMPLEMENTS_PROTOCOL( \
-				dispatch_source, dispatch_source_##name)
-#define DISPATCH_SOURCE_DECL(name) \
-		DISPATCH_DECL(name); \
-		OS_OBJECT_DECL_PROTOCOL(name, <NSObject>); \
-		OS_OBJECT_CLASS_IMPLEMENTS_PROTOCOL(name, name)
-#ifndef DISPATCH_DATA_DECL
-#define DISPATCH_DATA_DECL(name) OS_OBJECT_DECL_SWIFT(name)
-#endif // DISPATCH_DATA_DECL
-#else
-#define DISPATCH_SOURCE_DECL(name) \
-		DISPATCH_DECL(name);
-#define DISPATCH_DATA_DECL(name) DISPATCH_DECL(name)
-#define DISPATCH_SOURCE_TYPE_DECL(name) \
-		DISPATCH_EXPORT const struct dispatch_source_type_s \
-		_dispatch_source_type_##name
-#endif
-
-#ifdef __BLOCKS__
-/*!
- * @typedef dispatch_block_t
- *
- * @abstract
- * The type of blocks submitted to dispatch queues, which take no arguments
- * and have no return value.
- *
- * @discussion
- * When not building with Objective-C ARC, a block object allocated on or
- * copied to the heap must be released with a -[release] message or the
- * Block_release() function.
- *
- * The declaration of a block literal allocates storage on the stack.
- * Therefore, this is an invalid construct:
- * <code>
- * dispatch_block_t block;
- * if (x) {
- *     block = ^{ printf("true\n"); };
- * } else {
- *     block = ^{ printf("false\n"); };
- * }
- * block(); // unsafe!!!
- * </code>
- *
- * What is happening behind the scenes:
- * <code>
- * if (x) {
- *     struct Block __tmp_1 = ...; // setup details
- *     block = &__tmp_1;
- * } else {
- *     struct Block __tmp_2 = ...; // setup details
- *     block = &__tmp_2;
- * }
- * </code>
- *
- * As the example demonstrates, the address of a stack variable is escaping the
- * scope in which it is allocated. That is a classic C bug.
- *
- * Instead, the block literal must be copied to the heap with the Block_copy()
- * function or by sending it a -[copy] message.
- */
-typedef void (^dispatch_block_t)(void);
-#endif // __BLOCKS__
-
-__BEGIN_DECLS
-
-/*!
- * @function dispatch_retain
- *
- * @abstract
- * Increment the reference count of a dispatch object.
- *
- * @discussion
- * Calls to dispatch_retain() must be balanced with calls to
- * dispatch_release().
- *
- * @param object
- * The object to retain.
- * The result of passing NULL in this parameter is undefined.
- */
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW
-DISPATCH_SWIFT_UNAVAILABLE("Can't be used with ARC")
-void
-dispatch_retain(dispatch_object_t object);
-#if OS_OBJECT_USE_OBJC_RETAIN_RELEASE
-#undef dispatch_retain
-#define dispatch_retain(object) \
-		__extension__({ dispatch_object_t _o = (object); \
-		_dispatch_object_validate(_o); (void)[_o retain]; })
-#endif
-
-/*!
- * @function dispatch_release
- *
- * @abstract
- * Decrement the reference count of a dispatch object.
- *
- * @discussion
- * A dispatch object is asynchronously deallocated once all references are
- * released (i.e. the reference count becomes zero). The system does not
- * guarantee that a given client is the last or only reference to a given
- * object.
- *
- * @param object
- * The object to release.
- * The result of passing NULL in this parameter is undefined.
- */
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW
-DISPATCH_SWIFT_UNAVAILABLE("Can't be used with ARC")
-void
-dispatch_release(dispatch_object_t object);
-#if OS_OBJECT_USE_OBJC_RETAIN_RELEASE
-#undef dispatch_release
-#define dispatch_release(object) \
-		__extension__({ dispatch_object_t _o = (object); \
-		_dispatch_object_validate(_o); [_o release]; })
-#endif
-
-/*!
- * @function dispatch_get_context
- *
- * @abstract
- * Returns the application defined context of the object.
- *
- * @param object
- * The result of passing NULL in this parameter is undefined.
- *
- * @result
- * The context of the object; may be NULL.
- */
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_PURE DISPATCH_WARN_RESULT
-DISPATCH_NOTHROW
-void *_Nullable
-dispatch_get_context(dispatch_object_t object);
-
-/*!
- * @function dispatch_set_context
- *
- * @abstract
- * Associates an application defined context with the object.
- *
- * @param object
- * The result of passing NULL in this parameter is undefined.
- *
- * @param context
- * The new client defined context for the object. This may be NULL.
- *
- */
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_EXPORT DISPATCH_NOTHROW
-void
-dispatch_set_context(dispatch_object_t object, void *_Nullable context);
-
-/*!
- * @function dispatch_set_finalizer_f
- *
- * @abstract
- * Set the finalizer function for a dispatch object.
- *
- * @param object
- * The dispatch object to modify.
- * The result of passing NULL in this parameter is undefined.
- *
- * @param finalizer
- * The finalizer function pointer.
- *
- * @discussion
- * A dispatch object's finalizer will be invoked on the object's target queue
- * after all references to the object have been released. This finalizer may be
- * used by the application to release any resources associated with the object,
- * such as freeing the object's context.
- * The context parameter passed to the finalizer function is the current
- * context of the dispatch object at the time the finalizer call is made.
- */
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_EXPORT DISPATCH_NOTHROW
-void
-dispatch_set_finalizer_f(dispatch_object_t object,
-		dispatch_function_t _Nullable finalizer);
-
-/*!
- * @function dispatch_activate
- *
- * @abstract
- * Activates the specified dispatch object.
- *
- * @discussion
- * Dispatch objects such as queues and sources may be created in an inactive
- * state. Objects in this state have to be activated before any blocks
- * associated with them will be invoked.
- *
- * The target queue of inactive objects can be changed using
- * dispatch_set_target_queue(). Change of target queue is no longer permitted
- * once an initially inactive object has been activated.
- *
- * Calling dispatch_activate() on an active object has no effect.
- * Releasing the last reference count on an inactive object is undefined.
- *
- * @param object
- * The object to be activated.
- * The result of passing NULL in this parameter is undefined.
- */
-API_AVAILABLE(macos(10.12), ios(10.0), tvos(10.0), watchos(3.0))
-DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW
-void
-dispatch_activate(dispatch_object_t object);
-
-/*!
- * @function dispatch_suspend
- *
- * @abstract
- * Suspends the invocation of blocks on a dispatch object.
- *
- * @discussion
- * A suspended object will not invoke any blocks associated with it. The
- * suspension of an object will occur after any running block associated with
- * the object completes.
- *
- * Calls to dispatch_suspend() must be balanced with calls
- * to dispatch_resume().
- *
- * @param object
- * The object to be suspended.
- * The result of passing NULL in this parameter is undefined.
- */
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW
-void
-dispatch_suspend(dispatch_object_t object);
-
-/*!
- * @function dispatch_resume
- *
- * @abstract
- * Resumes the invocation of blocks on a dispatch object.
- *
- * @discussion
- * Dispatch objects can be suspended with dispatch_suspend(), which increments
- * an internal suspension count. dispatch_resume() is the inverse operation,
- * and consumes suspension counts. When the last suspension count is consumed,
- * blocks associated with the object will be invoked again.
- *
- * For backward compatibility reasons, dispatch_resume() on an inactive and not
- * otherwise suspended dispatch source object has the same effect as calling
- * dispatch_activate(). For new code, using dispatch_activate() is preferred.
- *
- * If the specified object has zero suspension count and is not an inactive
- * source, this function will result in an assertion and the process being
- * terminated.
- *
- * @param object
- * The object to be resumed.
- * The result of passing NULL in this parameter is undefined.
- */
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW
-void
-dispatch_resume(dispatch_object_t object);
-
-#ifdef __BLOCKS__
-/*!
- * @function dispatch_wait
- *
- * @abstract
- * Wait synchronously for an object or until the specified timeout has elapsed.
- *
- * @discussion
- * Type-generic macro that maps to dispatch_block_wait, dispatch_group_wait or
- * dispatch_semaphore_wait, depending on the type of the first argument.
- * See documentation for these functions for more details.
- * This function is unavailable for any other object type.
- *
- * @param object
- * The object to wait on.
- * The result of passing NULL in this parameter is undefined.
- *
- * @param timeout
- * When to timeout (see dispatch_time). As a convenience, there are the
- * DISPATCH_TIME_NOW and DISPATCH_TIME_FOREVER constants.
- *
- * @result
- * Returns zero on success or non-zero on error (i.e. timed out).
- */
-DISPATCH_UNAVAILABLE
-DISPATCH_EXPORT DISPATCH_NONNULL1 DISPATCH_NOTHROW
-intptr_t
-dispatch_wait(void *object, dispatch_time_t timeout);
-#if __has_extension(c_generic_selections)
-#define dispatch_wait(object, timeout) \
-		_Generic((object), \
-			dispatch_block_t:dispatch_block_wait, \
-			dispatch_group_t:dispatch_group_wait, \
-			dispatch_semaphore_t:dispatch_semaphore_wait \
-		)((object),(timeout))
-#endif
-
-/*!
- * @function dispatch_notify
- *
- * @abstract
- * Schedule a notification block to be submitted to a queue when the execution
- * of a specified object has completed.
- *
- * @discussion
- * Type-generic macro that maps to dispatch_block_notify or
- * dispatch_group_notify, depending on the type of the first argument.
- * See documentation for these functions for more details.
- * This function is unavailable for any other object type.
- *
- * @param object
- * The object to observe.
- * The result of passing NULL in this parameter is undefined.
- *
- * @param queue
- * The queue to which the supplied notification block will be submitted when
- * the observed object completes.
- *
- * @param notification_block
- * The block to submit when the observed object completes.
- */
-DISPATCH_UNAVAILABLE
-DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW
-void
-dispatch_notify(void *object, dispatch_object_t queue,
-		dispatch_block_t notification_block);
-#if __has_extension(c_generic_selections)
-#define dispatch_notify(object, queue, notification_block) \
-		_Generic((object), \
-			dispatch_block_t:dispatch_block_notify, \
-			dispatch_group_t:dispatch_group_notify \
-		)((object),(queue), (notification_block))
-#endif
-
-/*!
- * @function dispatch_cancel
- *
- * @abstract
- * Cancel the specified object.
- *
- * @discussion
- * Type-generic macro that maps to dispatch_block_cancel or
- * dispatch_source_cancel, depending on the type of the first argument.
- * See documentation for these functions for more details.
- * This function is unavailable for any other object type.
- *
- * @param object
- * The object to cancel.
- * The result of passing NULL in this parameter is undefined.
- */
-DISPATCH_UNAVAILABLE
-DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW
-void
-dispatch_cancel(void *object);
-#if __has_extension(c_generic_selections)
-#define dispatch_cancel(object) \
-		_Generic((object), \
-			dispatch_block_t:dispatch_block_cancel, \
-			dispatch_source_t:dispatch_source_cancel \
-		)((object))
-#endif
-
-/*!
- * @function dispatch_testcancel
- *
- * @abstract
- * Test whether the specified object has been canceled
- *
- * @discussion
- * Type-generic macro that maps to dispatch_block_testcancel or
- * dispatch_source_testcancel, depending on the type of the first argument.
- * See documentation for these functions for more details.
- * This function is unavailable for any other object type.
- *
- * @param object
- * The object to test.
- * The result of passing NULL in this parameter is undefined.
- *
- * @result
- * Non-zero if canceled and zero if not canceled.
- */
-DISPATCH_UNAVAILABLE
-DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_WARN_RESULT DISPATCH_PURE
-DISPATCH_NOTHROW
-intptr_t
-dispatch_testcancel(void *object);
-#if __has_extension(c_generic_selections)
-#define dispatch_testcancel(object) \
-		_Generic((object), \
-			dispatch_block_t:dispatch_block_testcancel, \
-			dispatch_source_t:dispatch_source_testcancel \
-		)((object))
-#endif
-#endif // __BLOCKS__
-
-/*!
- * @function dispatch_debug
- *
- * @abstract
- * Programmatically log debug information about a dispatch object.
- *
- * @discussion
- * Programmatically log debug information about a dispatch object. By default,
- * the log output is sent to syslog at notice level. In the debug version of
- * the library, the log output is sent to a file in /var/tmp.
- * The log output destination can be configured via the LIBDISPATCH_LOG
- * environment variable, valid values are: YES, NO, syslog, stderr, file.
- *
- * This function is deprecated and will be removed in a future release.
- * Objective-C callers may use -debugDescription instead.
- *
- * @param object
- * The object to introspect.
- *
- * @param message
- * The message to log above and beyond the introspection.
- */
-API_DEPRECATED("unsupported interface", macos(10.6,10.9), ios(4.0,6.0))
-DISPATCH_EXPORT DISPATCH_NONNULL2 DISPATCH_NOTHROW DISPATCH_COLD
-__attribute__((__format__(printf,2,3)))
-void
-dispatch_debug(dispatch_object_t object, const char *message, ...);
-
-API_DEPRECATED("unsupported interface", macos(10.6,10.9), ios(4.0,6.0))
-DISPATCH_EXPORT DISPATCH_NONNULL2 DISPATCH_NOTHROW DISPATCH_COLD
-__attribute__((__format__(printf,2,0)))
-void
-dispatch_debugv(dispatch_object_t object, const char *message, va_list ap);
-
-__END_DECLS
-
-DISPATCH_ASSUME_NONNULL_END
-
-#endif
--- a/Telegram/ThirdParty/dispatch/dispatch/once.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/dispatch/once.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,125 +0,0 @@
-/*
- * Copyright (c) 2008-2010 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#ifndef __DISPATCH_ONCE__
-#define __DISPATCH_ONCE__
-
-#ifndef __DISPATCH_INDIRECT__
-#error "Please #include <dispatch/dispatch.h> instead of this file directly."
-#include <dispatch/base.h> // for HeaderDoc
-#endif
-
-DISPATCH_ASSUME_NONNULL_BEGIN
-
-__BEGIN_DECLS
-
-/*!
- * @typedef dispatch_once_t
- *
- * @abstract
- * A predicate for use with dispatch_once(). It must be initialized to zero.
- * Note: static and global variables default to zero.
- */
-DISPATCH_SWIFT3_UNAVAILABLE("Use lazily initialized globals instead")
-typedef intptr_t dispatch_once_t;
-
-#if defined(__x86_64__) || defined(__i386__) || defined(__s390x__)
-#define DISPATCH_ONCE_INLINE_FASTPATH 1
-#elif defined(__APPLE__)
-#define DISPATCH_ONCE_INLINE_FASTPATH 1
-#else
-#define DISPATCH_ONCE_INLINE_FASTPATH 0
-#endif
-
-/*!
- * @function dispatch_once
- *
- * @abstract
- * Execute a block once and only once.
- *
- * @param predicate
- * A pointer to a dispatch_once_t that is used to test whether the block has
- * completed or not.
- *
- * @param block
- * The block to execute once.
- *
- * @discussion
- * Always call dispatch_once() before using or testing any variables that are
- * initialized by the block.
- */
-#ifdef __BLOCKS__
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW
-DISPATCH_SWIFT3_UNAVAILABLE("Use lazily initialized globals instead")
-void
-dispatch_once(dispatch_once_t *predicate,
-		DISPATCH_NOESCAPE dispatch_block_t block);
-
-#if DISPATCH_ONCE_INLINE_FASTPATH
-DISPATCH_INLINE DISPATCH_ALWAYS_INLINE DISPATCH_NONNULL_ALL DISPATCH_NOTHROW
-DISPATCH_SWIFT3_UNAVAILABLE("Use lazily initialized globals instead")
-void
-_dispatch_once(dispatch_once_t *predicate,
-		DISPATCH_NOESCAPE dispatch_block_t block)
-{
-	if (DISPATCH_EXPECT(*predicate, ~0l) != ~0l) {
-		dispatch_once(predicate, block);
-	} else {
-		dispatch_compiler_barrier();
-	}
-	DISPATCH_COMPILER_CAN_ASSUME(*predicate == ~0l);
-}
-#undef dispatch_once
-#define dispatch_once _dispatch_once
-#endif
-#endif // DISPATCH_ONCE_INLINE_FASTPATH
-
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_EXPORT DISPATCH_NONNULL1 DISPATCH_NONNULL3 DISPATCH_NOTHROW
-DISPATCH_SWIFT3_UNAVAILABLE("Use lazily initialized globals instead")
-void
-dispatch_once_f(dispatch_once_t *predicate, void *_Nullable context,
-		dispatch_function_t function);
-
-#if DISPATCH_ONCE_INLINE_FASTPATH
-DISPATCH_INLINE DISPATCH_ALWAYS_INLINE DISPATCH_NONNULL1 DISPATCH_NONNULL3
-DISPATCH_NOTHROW
-DISPATCH_SWIFT3_UNAVAILABLE("Use lazily initialized globals instead")
-void
-_dispatch_once_f(dispatch_once_t *predicate, void *_Nullable context,
-		dispatch_function_t function)
-{
-	if (DISPATCH_EXPECT(*predicate, ~0l) != ~0l) {
-		dispatch_once_f(predicate, context, function);
-	} else {
-		dispatch_compiler_barrier();
-	}
-	DISPATCH_COMPILER_CAN_ASSUME(*predicate == ~0l);
-}
-#undef dispatch_once_f
-#define dispatch_once_f _dispatch_once_f
-#endif // DISPATCH_ONCE_INLINE_FASTPATH
-
-__END_DECLS
-
-DISPATCH_ASSUME_NONNULL_END
-
-#endif
--- a/Telegram/ThirdParty/dispatch/dispatch/queue.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/dispatch/queue.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,1545 +0,0 @@
-/*
- * Copyright (c) 2008-2014 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#ifndef __DISPATCH_QUEUE__
-#define __DISPATCH_QUEUE__
-
-#ifndef __DISPATCH_INDIRECT__
-#error "Please #include <dispatch/dispatch.h> instead of this file directly."
-#include <dispatch/base.h> // for HeaderDoc
-#endif
-
-#if __has_include(<sys/qos.h>)
-#include <sys/qos.h>
-#endif
-
-DISPATCH_ASSUME_NONNULL_BEGIN
-
-/*!
- * @header
- *
- * Dispatch is an abstract model for expressing concurrency via simple but
- * powerful API.
- *
- * At the core, dispatch provides serial FIFO queues to which blocks may be
- * submitted. Blocks submitted to these dispatch queues are invoked on a pool
- * of threads fully managed by the system. No guarantee is made regarding
- * which thread a block will be invoked on; however, it is guaranteed that only
- * one block submitted to the FIFO dispatch queue will be invoked at a time.
- *
- * When multiple queues have blocks to be processed, the system is free to
- * allocate additional threads to invoke the blocks concurrently. When the
- * queues become empty, these threads are automatically released.
- */
-
-/*!
- * @typedef dispatch_queue_t
- *
- * @abstract
- * Dispatch queues invoke workitems submitted to them.
- *
- * @discussion
- * Dispatch queues come in many flavors, the most common one being the dispatch
- * serial queue (See dispatch_queue_serial_t).
- *
- * The system manages a pool of threads which process dispatch queues and invoke
- * workitems submitted to them.
- *
- * Conceptually a dispatch queue may have its own thread of execution, and
- * interaction between queues is highly asynchronous.
- *
- * Dispatch queues are reference counted via calls to dispatch_retain() and
- * dispatch_release(). Pending workitems submitted to a queue also hold a
- * reference to the queue until they have finished. Once all references to a
- * queue have been released, the queue will be deallocated by the system.
- */
-DISPATCH_DECL(dispatch_queue);
-
-/*!
- * @typedef dispatch_queue_global_t
- *
- * @abstract
- * Dispatch global concurrent queues are an abstraction around the system thread
- * pool which invokes workitems that are submitted to dispatch queues.
- *
- * @discussion
- * Dispatch global concurrent queues provide buckets of priorities on top of the
- * thread pool the system manages. The system will decide how many threads
- * to allocate to this pool depending on demand and system load. In particular,
- * the system tries to maintain a good level of concurrency for this resource,
- * and will create new threads when too many existing worker threads block in
- * system calls.
- *
- * The global concurrent queues are a shared resource and as such it is the
- * responsiblity of every user of this resource to not submit an unbounded
- * amount of work to this pool, especially work that may block, as this can
- * cause the system to spawn very large numbers of threads (aka. thread
- * explosion).
- *
- * Work items submitted to the global concurrent queues have no ordering
- * guarantee with respect to the order of submission, and workitems submitted
- * to these queues may be invoked concurrently.
- *
- * Dispatch global concurrent queues are well-known global objects that are
- * returned by dispatch_get_global_queue(). These objects cannot be modified.
- * Calls to dispatch_suspend(), dispatch_resume(), dispatch_set_context(), etc.,
- * will have no effect when used with queues of this type.
- */
-#if defined(__DISPATCH_BUILDING_DISPATCH__) && !defined(__OBJC__)
-typedef struct dispatch_queue_global_s *dispatch_queue_global_t;
-#else
-DISPATCH_DECL_SUBCLASS(dispatch_queue_global, dispatch_queue);
-#endif
-
-/*!
- * @typedef dispatch_queue_serial_t
- *
- * @abstract
- * Dispatch serial queues invoke workitems submitted to them serially in FIFO
- * order.
- *
- * @discussion
- * Dispatch serial queues are lightweight objects to which workitems may be
- * submitted to be invoked in FIFO order. A serial queue will only invoke one
- * workitem at a time, but independent serial queues may each invoke their work
- * items concurrently with respect to each other.
- *
- * Serial queues can target each other (See dispatch_set_target_queue()). The
- * serial queue at the bottom of a queue hierarchy provides an exclusion
- * context: at most one workitem submitted to any of the queues in such
- * a hiearchy will run at any given time.
- *
- * Such hierarchies provide a natural construct to organize an application
- * subsystem around.
- *
- * Serial queues are created by passing a dispatch queue attribute derived from
- * DISPATCH_QUEUE_SERIAL to dispatch_queue_create_with_target().
- */
-#if defined(__DISPATCH_BUILDING_DISPATCH__) && !defined(__OBJC__)
-typedef struct dispatch_lane_s *dispatch_queue_serial_t;
-#else
-DISPATCH_DECL_SUBCLASS(dispatch_queue_serial, dispatch_queue);
-#endif
-
-/*!
- * @typedef dispatch_queue_main_t
- *
- * @abstract
- * The type of the default queue that is bound to the main thread.
- *
- * @discussion
- * The main queue is a serial queue (See dispatch_queue_serial_t) which is bound
- * to the main thread of an application.
- *
- * In order to invoke workitems submitted to the main queue, the application
- * must call dispatch_main(), NSApplicationMain(), or use a CFRunLoop on the
- * main thread.
- *
- * The main queue is a well known global object that is made automatically on
- * behalf of the main thread during process initialization and is returned by
- * dispatch_get_main_queue(). This object cannot be modified.  Calls to
- * dispatch_suspend(), dispatch_resume(), dispatch_set_context(), etc., will
- * have no effect when used on the main queue.
- */
-#if defined(__DISPATCH_BUILDING_DISPATCH__) && !defined(__OBJC__)
-typedef struct dispatch_queue_static_s *dispatch_queue_main_t;
-#else
-DISPATCH_DECL_SUBCLASS(dispatch_queue_main, dispatch_queue_serial);
-#endif
-
-/*!
- * @typedef dispatch_queue_concurrent_t
- *
- * @abstract
- * Dispatch concurrent queues invoke workitems submitted to them concurrently,
- * and admit a notion of barrier workitems.
- *
- * @discussion
- * Dispatch concurrent queues are lightweight objects to which regular and
- * barrier workitems may be submited. Barrier workitems are invoked in
- * exclusion of any other kind of workitem in FIFO order.
- *
- * Regular workitems can be invoked concurrently for the same concurrent queue,
- * in any order. However, regular workitems will not be invoked before any
- * barrier workitem submited ahead of them has been invoked.
- *
- * In other words, if a serial queue is equivalent to a mutex in the Dispatch
- * world, a concurrent queue is equivalent to a reader-writer lock, where
- * regular items are readers and barriers are writers.
- *
- * Concurrent queues are created by passing a dispatch queue attribute derived
- * from DISPATCH_QUEUE_CONCURRENT to dispatch_queue_create_with_target().
- *
- * Caveat:
- * Dispatch concurrent queues at this time do not implement priority inversion
- * avoidance when lower priority regular workitems (readers) are being invoked
- * and are preventing a higher priority barrier (writer) from being invoked.
- */
-#if defined(__DISPATCH_BUILDING_DISPATCH__) && !defined(__OBJC__)
-typedef struct dispatch_lane_s *dispatch_queue_concurrent_t;
-#else
-DISPATCH_DECL_SUBCLASS(dispatch_queue_concurrent, dispatch_queue);
-#endif
-
-__BEGIN_DECLS
-
-/*!
- * @function dispatch_async
- *
- * @abstract
- * Submits a block for asynchronous execution on a dispatch queue.
- *
- * @discussion
- * The dispatch_async() function is the fundamental mechanism for submitting
- * blocks to a dispatch queue.
- *
- * Calls to dispatch_async() always return immediately after the block has
- * been submitted, and never wait for the block to be invoked.
- *
- * The target queue determines whether the block will be invoked serially or
- * concurrently with respect to other blocks submitted to that same queue.
- * Serial queues are processed concurrently with respect to each other.
- *
- * @param queue
- * The target dispatch queue to which the block is submitted.
- * The system will hold a reference on the target queue until the block
- * has finished.
- * The result of passing NULL in this parameter is undefined.
- *
- * @param block
- * The block to submit to the target dispatch queue. This function performs
- * Block_copy() and Block_release() on behalf of callers.
- * The result of passing NULL in this parameter is undefined.
- */
-#ifdef __BLOCKS__
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW
-void
-dispatch_async(dispatch_queue_t queue, dispatch_block_t block);
-#endif
-
-/*!
- * @function dispatch_async_f
- *
- * @abstract
- * Submits a function for asynchronous execution on a dispatch queue.
- *
- * @discussion
- * See dispatch_async() for details.
- *
- * @param queue
- * The target dispatch queue to which the function is submitted.
- * The system will hold a reference on the target queue until the function
- * has returned.
- * The result of passing NULL in this parameter is undefined.
- *
- * @param context
- * The application-defined context parameter to pass to the function.
- *
- * @param work
- * The application-defined function to invoke on the target queue. The first
- * parameter passed to this function is the context provided to
- * dispatch_async_f().
- * The result of passing NULL in this parameter is undefined.
- */
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_EXPORT DISPATCH_NONNULL1 DISPATCH_NONNULL3 DISPATCH_NOTHROW
-void
-dispatch_async_f(dispatch_queue_t queue,
-		void *_Nullable context, dispatch_function_t work);
-
-/*!
- * @function dispatch_sync
- *
- * @abstract
- * Submits a block for synchronous execution on a dispatch queue.
- *
- * @discussion
- * Submits a workitem to a dispatch queue like dispatch_async(), however
- * dispatch_sync() will not return until the workitem has finished.
- *
- * Work items submitted to a queue with dispatch_sync() do not observe certain
- * queue attributes of that queue when invoked (such as autorelease frequency
- * and QOS class).
- *
- * Calls to dispatch_sync() targeting the current queue will result
- * in dead-lock. Use of dispatch_sync() is also subject to the same
- * multi-party dead-lock problems that may result from the use of a mutex.
- * Use of dispatch_async() is preferred.
- *
- * Unlike dispatch_async(), no retain is performed on the target queue. Because
- * calls to this function are synchronous, the dispatch_sync() "borrows" the
- * reference of the caller.
- *
- * As an optimization, dispatch_sync() invokes the workitem on the thread which
- * submitted the workitem, except when the passed queue is the main queue or
- * a queue targetting it (See dispatch_queue_main_t,
- * dispatch_set_target_queue()).
- *
- * @param queue
- * The target dispatch queue to which the block is submitted.
- * The result of passing NULL in this parameter is undefined.
- *
- * @param block
- * The block to be invoked on the target dispatch queue.
- * The result of passing NULL in this parameter is undefined.
- */
-#ifdef __BLOCKS__
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW
-void
-dispatch_sync(dispatch_queue_t queue, DISPATCH_NOESCAPE dispatch_block_t block);
-#endif
-
-/*!
- * @function dispatch_sync_f
- *
- * @abstract
- * Submits a function for synchronous execution on a dispatch queue.
- *
- * @discussion
- * See dispatch_sync() for details.
- *
- * @param queue
- * The target dispatch queue to which the function is submitted.
- * The result of passing NULL in this parameter is undefined.
- *
- * @param context
- * The application-defined context parameter to pass to the function.
- *
- * @param work
- * The application-defined function to invoke on the target queue. The first
- * parameter passed to this function is the context provided to
- * dispatch_sync_f().
- * The result of passing NULL in this parameter is undefined.
- */
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_EXPORT DISPATCH_NONNULL1 DISPATCH_NONNULL3 DISPATCH_NOTHROW
-void
-dispatch_sync_f(dispatch_queue_t queue,
-		void *_Nullable context, dispatch_function_t work);
-
-
-#if defined(__APPLE__) && \
-		(defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && \
-		__IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_7_0) || \
-		(defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && \
-		__MAC_OS_X_VERSION_MIN_REQUIRED < __MAC_10_9)
-#define DISPATCH_APPLY_AUTO_AVAILABLE 0
-#define DISPATCH_APPLY_QUEUE_ARG_NULLABILITY _Nonnull
-#else
-#define DISPATCH_APPLY_AUTO_AVAILABLE 1
-#define DISPATCH_APPLY_QUEUE_ARG_NULLABILITY _Nullable
-#endif
-
-/*!
- * @constant DISPATCH_APPLY_AUTO
- *
- * @abstract
- * Constant to pass to dispatch_apply() or dispatch_apply_f() to request that
- * the system automatically use worker threads that match the configuration of
- * the current thread as closely as possible.
- *
- * @discussion
- * When submitting a block for parallel invocation, passing this constant as the
- * queue argument will automatically use the global concurrent queue that
- * matches the Quality of Service of the caller most closely.
- *
- * No assumptions should be made about which global concurrent queue will
- * actually be used.
- *
- * Using this constant deploys backward to macOS 10.9, iOS 7.0 and any tvOS or
- * watchOS version.
- */
-#if DISPATCH_APPLY_AUTO_AVAILABLE
-#define DISPATCH_APPLY_AUTO ((dispatch_queue_t _Nonnull)0)
-#endif
-
-/*!
- * @function dispatch_apply
- *
- * @abstract
- * Submits a block to a dispatch queue for parallel invocation.
- *
- * @discussion
- * Submits a block to a dispatch queue for parallel invocation. This function
- * waits for the task block to complete before returning. If the specified queue
- * is concurrent, the block may be invoked concurrently, and it must therefore
- * be reentrant safe.
- *
- * Each invocation of the block will be passed the current index of iteration.
- *
- * @param iterations
- * The number of iterations to perform.
- *
- * @param queue
- * The dispatch queue to which the block is submitted.
- * The preferred value to pass is DISPATCH_APPLY_AUTO to automatically use
- * a queue appropriate for the calling thread.
- *
- * @param block
- * The block to be invoked the specified number of iterations.
- * The result of passing NULL in this parameter is undefined.
- */
-#ifdef __BLOCKS__
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_EXPORT DISPATCH_NONNULL3 DISPATCH_NOTHROW
-void
-dispatch_apply(size_t iterations,
-		dispatch_queue_t DISPATCH_APPLY_QUEUE_ARG_NULLABILITY queue,
-		DISPATCH_NOESCAPE void (^block)(size_t));
-#endif
-
-/*!
- * @function dispatch_apply_f
- *
- * @abstract
- * Submits a function to a dispatch queue for parallel invocation.
- *
- * @discussion
- * See dispatch_apply() for details.
- *
- * @param iterations
- * The number of iterations to perform.
- *
- * @param queue
- * The dispatch queue to which the function is submitted.
- * The preferred value to pass is DISPATCH_APPLY_AUTO to automatically use
- * a queue appropriate for the calling thread.
- *
- * @param context
- * The application-defined context parameter to pass to the function.
- *
- * @param work
- * The application-defined function to invoke on the specified queue. The first
- * parameter passed to this function is the context provided to
- * dispatch_apply_f(). The second parameter passed to this function is the
- * current index of iteration.
- * The result of passing NULL in this parameter is undefined.
- */
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_EXPORT DISPATCH_NONNULL4 DISPATCH_NOTHROW
-void
-dispatch_apply_f(size_t iterations,
-		dispatch_queue_t DISPATCH_APPLY_QUEUE_ARG_NULLABILITY queue,
-		void *_Nullable context, void (*work)(void *_Nullable, size_t));
-
-/*!
- * @function dispatch_get_current_queue
- *
- * @abstract
- * Returns the queue on which the currently executing block is running.
- *
- * @discussion
- * Returns the queue on which the currently executing block is running.
- *
- * When dispatch_get_current_queue() is called outside of the context of a
- * submitted block, it will return the default concurrent queue.
- *
- * Recommended for debugging and logging purposes only:
- * The code must not make any assumptions about the queue returned, unless it
- * is one of the global queues or a queue the code has itself created.
- * The code must not assume that synchronous execution onto a queue is safe
- * from deadlock if that queue is not the one returned by
- * dispatch_get_current_queue().
- *
- * When dispatch_get_current_queue() is called on the main thread, it may
- * or may not return the same value as dispatch_get_main_queue(). Comparing
- * the two is not a valid way to test whether code is executing on the
- * main thread (see dispatch_assert_queue() and dispatch_assert_queue_not()).
- *
- * This function is deprecated and will be removed in a future release.
- *
- * @result
- * Returns the current queue.
- */
-API_DEPRECATED("unsupported interface", macos(10.6,10.9), ios(4.0,6.0))
-DISPATCH_EXPORT DISPATCH_PURE DISPATCH_WARN_RESULT DISPATCH_NOTHROW
-dispatch_queue_t
-dispatch_get_current_queue(void);
-
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_EXPORT
-#if defined(__DISPATCH_BUILDING_DISPATCH__) && !defined(__OBJC__)
-struct dispatch_queue_static_s _dispatch_main_q;
-#else
-struct dispatch_queue_s _dispatch_main_q;
-#endif
-
-/*!
- * @function dispatch_get_main_queue
- *
- * @abstract
- * Returns the default queue that is bound to the main thread.
- *
- * @discussion
- * In order to invoke blocks submitted to the main queue, the application must
- * call dispatch_main(), NSApplicationMain(), or use a CFRunLoop on the main
- * thread.
- *
- * The main queue is meant to be used in application context to interact with
- * the main thread and the main runloop.
- *
- * Because the main queue doesn't behave entirely like a regular serial queue,
- * it may have unwanted side-effects when used in processes that are not UI apps
- * (daemons). For such processes, the main queue should be avoided.
- *
- * @see dispatch_queue_main_t
- *
- * @result
- * Returns the main queue. This queue is created automatically on behalf of
- * the main thread before main() is called.
- */
-DISPATCH_INLINE DISPATCH_ALWAYS_INLINE DISPATCH_CONST DISPATCH_NOTHROW
-dispatch_queue_main_t
-dispatch_get_main_queue(void)
-{
-	return DISPATCH_GLOBAL_OBJECT(dispatch_queue_main_t, _dispatch_main_q);
-}
-
-/*!
- * @typedef dispatch_queue_priority_t
- * Type of dispatch_queue_priority
- *
- * @constant DISPATCH_QUEUE_PRIORITY_HIGH
- * Items dispatched to the queue will run at high priority,
- * i.e. the queue will be scheduled for execution before
- * any default priority or low priority queue.
- *
- * @constant DISPATCH_QUEUE_PRIORITY_DEFAULT
- * Items dispatched to the queue will run at the default
- * priority, i.e. the queue will be scheduled for execution
- * after all high priority queues have been scheduled, but
- * before any low priority queues have been scheduled.
- *
- * @constant DISPATCH_QUEUE_PRIORITY_LOW
- * Items dispatched to the queue will run at low priority,
- * i.e. the queue will be scheduled for execution after all
- * default priority and high priority queues have been
- * scheduled.
- *
- * @constant DISPATCH_QUEUE_PRIORITY_BACKGROUND
- * Items dispatched to the queue will run at background priority, i.e. the queue
- * will be scheduled for execution after all higher priority queues have been
- * scheduled and the system will run items on this queue on a thread with
- * background status as per setpriority(2) (i.e. disk I/O is throttled and the
- * thread's scheduling priority is set to lowest value).
- */
-#define DISPATCH_QUEUE_PRIORITY_HIGH 2
-#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0
-#define DISPATCH_QUEUE_PRIORITY_LOW (-2)
-#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN
-
-typedef long dispatch_queue_priority_t;
-
-/*!
- * @typedef dispatch_qos_class_t
- * Alias for qos_class_t type.
- */
-#if __has_include(<sys/qos.h>)
-typedef qos_class_t dispatch_qos_class_t;
-#else
-typedef unsigned int dispatch_qos_class_t;
-#endif
-
-/*!
- * @function dispatch_get_global_queue
- *
- * @abstract
- * Returns a well-known global concurrent queue of a given quality of service
- * class.
- *
- * @discussion
- * See dispatch_queue_global_t.
- *
- * @param identifier
- * A quality of service class defined in qos_class_t or a priority defined in
- * dispatch_queue_priority_t.
- *
- * It is recommended to use quality of service class values to identify the
- * well-known global concurrent queues:
- *  - QOS_CLASS_USER_INTERACTIVE
- *  - QOS_CLASS_USER_INITIATED
- *  - QOS_CLASS_DEFAULT
- *  - QOS_CLASS_UTILITY
- *  - QOS_CLASS_BACKGROUND
- *
- * The global concurrent queues may still be identified by their priority,
- * which map to the following QOS classes:
- *  - DISPATCH_QUEUE_PRIORITY_HIGH:         QOS_CLASS_USER_INITIATED
- *  - DISPATCH_QUEUE_PRIORITY_DEFAULT:      QOS_CLASS_DEFAULT
- *  - DISPATCH_QUEUE_PRIORITY_LOW:          QOS_CLASS_UTILITY
- *  - DISPATCH_QUEUE_PRIORITY_BACKGROUND:   QOS_CLASS_BACKGROUND
- *
- * @param flags
- * Reserved for future use. Passing any value other than zero may result in
- * a NULL return value.
- *
- * @result
- * Returns the requested global queue or NULL if the requested global queue
- * does not exist.
- */
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_EXPORT DISPATCH_CONST DISPATCH_WARN_RESULT DISPATCH_NOTHROW
-dispatch_queue_global_t
-dispatch_get_global_queue(intptr_t identifier, uintptr_t flags);
-
-/*!
- * @typedef dispatch_queue_attr_t
- *
- * @abstract
- * Attribute for dispatch queues.
- */
-DISPATCH_DECL(dispatch_queue_attr);
-
-/*!
- * @const DISPATCH_QUEUE_SERIAL
- *
- * @discussion
- * An attribute that can be used to create a dispatch queue that invokes blocks
- * serially in FIFO order.
- *
- * See dispatch_queue_serial_t.
- */
-#define DISPATCH_QUEUE_SERIAL NULL
-
-/*!
- * @const DISPATCH_QUEUE_SERIAL_INACTIVE
- *
- * @discussion
- * An attribute that can be used to create a dispatch queue that invokes blocks
- * serially in FIFO order, and that is initially inactive.
- *
- * See dispatch_queue_attr_make_initially_inactive().
- */
-#define DISPATCH_QUEUE_SERIAL_INACTIVE \
-		dispatch_queue_attr_make_initially_inactive(DISPATCH_QUEUE_SERIAL)
-
-/*!
- * @const DISPATCH_QUEUE_CONCURRENT
- *
- * @discussion
- * An attribute that can be used to create a dispatch queue that may invoke
- * blocks concurrently and supports barrier blocks submitted with the dispatch
- * barrier API.
- *
- * See dispatch_queue_concurrent_t.
- */
-#define DISPATCH_QUEUE_CONCURRENT \
-		DISPATCH_GLOBAL_OBJECT(dispatch_queue_attr_t, \
-		_dispatch_queue_attr_concurrent)
-API_AVAILABLE(macos(10.7), ios(4.3))
-DISPATCH_EXPORT
-struct dispatch_queue_attr_s _dispatch_queue_attr_concurrent;
-
-/*!
- * @const DISPATCH_QUEUE_CONCURRENT_INACTIVE
- *
- * @discussion
- * An attribute that can be used to create a dispatch queue that may invoke
- * blocks concurrently and supports barrier blocks submitted with the dispatch
- * barrier API, and that is initially inactive.
- *
- * See dispatch_queue_attr_make_initially_inactive().
- */
-#define DISPATCH_QUEUE_CONCURRENT_INACTIVE \
-		dispatch_queue_attr_make_initially_inactive(DISPATCH_QUEUE_CONCURRENT)
-
-/*!
- * @function dispatch_queue_attr_make_initially_inactive
- *
- * @abstract
- * Returns an attribute value which may be provided to dispatch_queue_create()
- * or dispatch_queue_create_with_target(), in order to make the created queue
- * initially inactive.
- *
- * @discussion
- * Dispatch queues may be created in an inactive state. Queues in this state
- * have to be activated before any blocks associated with them will be invoked.
- *
- * A queue in inactive state cannot be deallocated, dispatch_activate() must be
- * called before the last reference to a queue created with this attribute is
- * released.
- *
- * The target queue of a queue in inactive state can be changed using
- * dispatch_set_target_queue(). Change of target queue is no longer permitted
- * once an initially inactive queue has been activated.
- *
- * @param attr
- * A queue attribute value to be combined with the initially inactive attribute.
- *
- * @return
- * Returns an attribute value which may be provided to dispatch_queue_create()
- * and dispatch_queue_create_with_target().
- * The new value combines the attributes specified by the 'attr' parameter with
- * the initially inactive attribute.
- */
-API_AVAILABLE(macos(10.12), ios(10.0), tvos(10.0), watchos(3.0))
-DISPATCH_EXPORT DISPATCH_WARN_RESULT DISPATCH_PURE DISPATCH_NOTHROW
-dispatch_queue_attr_t
-dispatch_queue_attr_make_initially_inactive(
-		dispatch_queue_attr_t _Nullable attr);
-
-/*!
- * @const DISPATCH_QUEUE_SERIAL_WITH_AUTORELEASE_POOL
- *
- * @discussion
- * A dispatch queue created with this attribute invokes blocks serially in FIFO
- * order, and surrounds execution of any block submitted asynchronously to it
- * with the equivalent of a individual Objective-C <code>@autoreleasepool</code>
- * scope.
- *
- * See dispatch_queue_attr_make_with_autorelease_frequency().
- */
-#define DISPATCH_QUEUE_SERIAL_WITH_AUTORELEASE_POOL \
-		dispatch_queue_attr_make_with_autorelease_frequency(\
-				DISPATCH_QUEUE_SERIAL, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM)
-
-/*!
- * @const DISPATCH_QUEUE_CONCURRENT_WITH_AUTORELEASE_POOL
- *
- * @discussion
- * A dispatch queue created with this attribute may invokes blocks concurrently
- * and supports barrier blocks submitted with the dispatch barrier API. It also
- * surrounds execution of any block submitted asynchronously to it with the
- * equivalent of a individual Objective-C <code>@autoreleasepool</code>
- *
- * See dispatch_queue_attr_make_with_autorelease_frequency().
- */
-#define DISPATCH_QUEUE_CONCURRENT_WITH_AUTORELEASE_POOL \
-		dispatch_queue_attr_make_with_autorelease_frequency(\
-				DISPATCH_QUEUE_CONCURRENT, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM)
-
-/*!
- * @typedef dispatch_autorelease_frequency_t
- * Values to pass to the dispatch_queue_attr_make_with_autorelease_frequency()
- * function.
- *
- * @const DISPATCH_AUTORELEASE_FREQUENCY_INHERIT
- * Dispatch queues with this autorelease frequency inherit the behavior from
- * their target queue. This is the default behavior for manually created queues.
- *
- * @const DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM
- * Dispatch queues with this autorelease frequency push and pop an autorelease
- * pool around the execution of every block that was submitted to it
- * asynchronously.
- * @see dispatch_queue_attr_make_with_autorelease_frequency().
- *
- * @const DISPATCH_AUTORELEASE_FREQUENCY_NEVER
- * Dispatch queues with this autorelease frequency never set up an individual
- * autorelease pool around the execution of a block that is submitted to it
- * asynchronously. This is the behavior of the global concurrent queues.
- */
-DISPATCH_ENUM(dispatch_autorelease_frequency, unsigned long,
-	DISPATCH_AUTORELEASE_FREQUENCY_INHERIT DISPATCH_ENUM_API_AVAILABLE(macos(10.12), ios(10.0), tvos(10.0), watchos(3.0)) = 0,
-	DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM DISPATCH_ENUM_API_AVAILABLE(macos(10.12), ios(10.0), tvos(10.0), watchos(3.0)) = 1,
-	DISPATCH_AUTORELEASE_FREQUENCY_NEVER DISPATCH_ENUM_API_AVAILABLE(macos(10.12), ios(10.0), tvos(10.0), watchos(3.0)) = 2,
-);
-
-/*!
- * @function dispatch_queue_attr_make_with_autorelease_frequency
- *
- * @abstract
- * Returns a dispatch queue attribute value with the autorelease frequency
- * set to the specified value.
- *
- * @discussion
- * When a queue uses the per-workitem autorelease frequency (either directly
- * or inherithed from its target queue), any block submitted asynchronously to
- * this queue (via dispatch_async(), dispatch_barrier_async(),
- * dispatch_group_notify(), etc...) is executed as if surrounded by a individual
- * Objective-C <code>@autoreleasepool</code> scope.
- *
- * Autorelease frequency has no effect on blocks that are submitted
- * synchronously to a queue (via dispatch_sync(), dispatch_barrier_sync()).
- *
- * The global concurrent queues have the DISPATCH_AUTORELEASE_FREQUENCY_NEVER
- * behavior. Manually created dispatch queues use
- * DISPATCH_AUTORELEASE_FREQUENCY_INHERIT by default.
- *
- * Queues created with this attribute cannot change target queues after having
- * been activated. See dispatch_set_target_queue() and dispatch_activate().
- *
- * @param attr
- * A queue attribute value to be combined with the specified autorelease
- * frequency or NULL.
- *
- * @param frequency
- * The requested autorelease frequency.
- *
- * @return
- * Returns an attribute value which may be provided to dispatch_queue_create()
- * or NULL if an invalid autorelease frequency was requested.
- * This new value combines the attributes specified by the 'attr' parameter and
- * the chosen autorelease frequency.
- */
-API_AVAILABLE(macos(10.12), ios(10.0), tvos(10.0), watchos(3.0))
-DISPATCH_EXPORT DISPATCH_WARN_RESULT DISPATCH_PURE DISPATCH_NOTHROW
-dispatch_queue_attr_t
-dispatch_queue_attr_make_with_autorelease_frequency(
-		dispatch_queue_attr_t _Nullable attr,
-		dispatch_autorelease_frequency_t frequency);
-
-/*!
- * @function dispatch_queue_attr_make_with_qos_class
- *
- * @abstract
- * Returns an attribute value which may be provided to dispatch_queue_create()
- * or dispatch_queue_create_with_target(), in order to assign a QOS class and
- * relative priority to the queue.
- *
- * @discussion
- * When specified in this manner, the QOS class and relative priority take
- * precedence over those inherited from the dispatch queue's target queue (if
- * any) as long that does not result in a lower QOS class and relative priority.
- *
- * The global queue priorities map to the following QOS classes:
- *  - DISPATCH_QUEUE_PRIORITY_HIGH:         QOS_CLASS_USER_INITIATED
- *  - DISPATCH_QUEUE_PRIORITY_DEFAULT:      QOS_CLASS_DEFAULT
- *  - DISPATCH_QUEUE_PRIORITY_LOW:          QOS_CLASS_UTILITY
- *  - DISPATCH_QUEUE_PRIORITY_BACKGROUND:   QOS_CLASS_BACKGROUND
- *
- * Example:
- * <code>
- *	dispatch_queue_t queue;
- *	dispatch_queue_attr_t attr;
- *	attr = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_SERIAL,
- *			QOS_CLASS_UTILITY, 0);
- *	queue = dispatch_queue_create("com.example.myqueue", attr);
- * </code>
- *
- * The QOS class and relative priority set this way on a queue have no effect on
- * blocks that are submitted synchronously to a queue (via dispatch_sync(),
- * dispatch_barrier_sync()).
- *
- * @param attr
- * A queue attribute value to be combined with the QOS class, or NULL.
- *
- * @param qos_class
- * A QOS class value:
- *  - QOS_CLASS_USER_INTERACTIVE
- *  - QOS_CLASS_USER_INITIATED
- *  - QOS_CLASS_DEFAULT
- *  - QOS_CLASS_UTILITY
- *  - QOS_CLASS_BACKGROUND
- * Passing any other value results in NULL being returned.
- *
- * @param relative_priority
- * A relative priority within the QOS class. This value is a negative
- * offset from the maximum supported scheduler priority for the given class.
- * Passing a value greater than zero or less than QOS_MIN_RELATIVE_PRIORITY
- * results in NULL being returned.
- *
- * @return
- * Returns an attribute value which may be provided to dispatch_queue_create()
- * and dispatch_queue_create_with_target(), or NULL if an invalid QOS class was
- * requested.
- * The new value combines the attributes specified by the 'attr' parameter and
- * the new QOS class and relative priority.
- */
-API_AVAILABLE(macos(10.10), ios(8.0))
-DISPATCH_EXPORT DISPATCH_WARN_RESULT DISPATCH_PURE DISPATCH_NOTHROW
-dispatch_queue_attr_t
-dispatch_queue_attr_make_with_qos_class(dispatch_queue_attr_t _Nullable attr,
-		dispatch_qos_class_t qos_class, int relative_priority);
-
-/*!
- * @const DISPATCH_TARGET_QUEUE_DEFAULT
- * @discussion Constant to pass to the dispatch_queue_create_with_target(),
- * dispatch_set_target_queue() and dispatch_source_create() functions to
- * indicate that the default target queue for the object type in question
- * should be used.
- */
-#define DISPATCH_TARGET_QUEUE_DEFAULT NULL
-
-/*!
- * @function dispatch_queue_create_with_target
- *
- * @abstract
- * Creates a new dispatch queue with a specified target queue.
- *
- * @discussion
- * Dispatch queues created with the DISPATCH_QUEUE_SERIAL or a NULL attribute
- * invoke blocks serially in FIFO order.
- *
- * Dispatch queues created with the DISPATCH_QUEUE_CONCURRENT attribute may
- * invoke blocks concurrently (similarly to the global concurrent queues, but
- * potentially with more overhead), and support barrier blocks submitted with
- * the dispatch barrier API, which e.g. enables the implementation of efficient
- * reader-writer schemes.
- *
- * When a dispatch queue is no longer needed, it should be released with
- * dispatch_release(). Note that any pending blocks submitted asynchronously to
- * a queue will hold a reference to that queue. Therefore a queue will not be
- * deallocated until all pending blocks have finished.
- *
- * When using a dispatch queue attribute @a attr specifying a QoS class (derived
- * from the result of dispatch_queue_attr_make_with_qos_class()), passing the
- * result of dispatch_get_global_queue() in @a target will ignore the QoS class
- * of that global queue and will use the global queue with the QoS class
- * specified by attr instead.
- *
- * Queues created with dispatch_queue_create_with_target() cannot have their
- * target queue changed, unless created inactive (See
- * dispatch_queue_attr_make_initially_inactive()), in which case the target
- * queue can be changed until the newly created queue is activated with
- * dispatch_activate().
- *
- * @param label
- * A string label to attach to the queue.
- * This parameter is optional and may be NULL.
- *
- * @param attr
- * A predefined attribute such as DISPATCH_QUEUE_SERIAL,
- * DISPATCH_QUEUE_CONCURRENT, or the result of a call to
- * a dispatch_queue_attr_make_with_* function.
- *
- * @param target
- * The target queue for the newly created queue. The target queue is retained.
- * If this parameter is DISPATCH_TARGET_QUEUE_DEFAULT, sets the queue's target
- * queue to the default target queue for the given queue type.
- *
- * @result
- * The newly created dispatch queue.
- */
-API_AVAILABLE(macos(10.12), ios(10.0), tvos(10.0), watchos(3.0))
-DISPATCH_EXPORT DISPATCH_MALLOC DISPATCH_RETURNS_RETAINED DISPATCH_WARN_RESULT
-DISPATCH_NOTHROW
-dispatch_queue_t
-dispatch_queue_create_with_target(const char *_Nullable label,
-		dispatch_queue_attr_t _Nullable attr, dispatch_queue_t _Nullable target)
-		DISPATCH_ALIAS_V2(dispatch_queue_create_with_target);
-
-/*!
- * @function dispatch_queue_create
- *
- * @abstract
- * Creates a new dispatch queue to which blocks may be submitted.
- *
- * @discussion
- * Dispatch queues created with the DISPATCH_QUEUE_SERIAL or a NULL attribute
- * invoke blocks serially in FIFO order.
- *
- * Dispatch queues created with the DISPATCH_QUEUE_CONCURRENT attribute may
- * invoke blocks concurrently (similarly to the global concurrent queues, but
- * potentially with more overhead), and support barrier blocks submitted with
- * the dispatch barrier API, which e.g. enables the implementation of efficient
- * reader-writer schemes.
- *
- * When a dispatch queue is no longer needed, it should be released with
- * dispatch_release(). Note that any pending blocks submitted asynchronously to
- * a queue will hold a reference to that queue. Therefore a queue will not be
- * deallocated until all pending blocks have finished.
- *
- * Passing the result of the dispatch_queue_attr_make_with_qos_class() function
- * to the attr parameter of this function allows a quality of service class and
- * relative priority to be specified for the newly created queue.
- * The quality of service class so specified takes precedence over the quality
- * of service class of the newly created dispatch queue's target queue (if any)
- * as long that does not result in a lower QOS class and relative priority.
- *
- * When no quality of service class is specified, the target queue of a newly
- * created dispatch queue is the default priority global concurrent queue.
- *
- * @param label
- * A string label to attach to the queue.
- * This parameter is optional and may be NULL.
- *
- * @param attr
- * A predefined attribute such as DISPATCH_QUEUE_SERIAL,
- * DISPATCH_QUEUE_CONCURRENT, or the result of a call to
- * a dispatch_queue_attr_make_with_* function.
- *
- * @result
- * The newly created dispatch queue.
- */
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_EXPORT DISPATCH_MALLOC DISPATCH_RETURNS_RETAINED DISPATCH_WARN_RESULT
-DISPATCH_NOTHROW
-dispatch_queue_t
-dispatch_queue_create(const char *_Nullable label,
-		dispatch_queue_attr_t _Nullable attr);
-
-/*!
- * @const DISPATCH_CURRENT_QUEUE_LABEL
- * @discussion Constant to pass to the dispatch_queue_get_label() function to
- * retrieve the label of the current queue.
- */
-#define DISPATCH_CURRENT_QUEUE_LABEL NULL
-
-/*!
- * @function dispatch_queue_get_label
- *
- * @abstract
- * Returns the label of the given queue, as specified when the queue was
- * created, or the empty string if a NULL label was specified.
- *
- * Passing DISPATCH_CURRENT_QUEUE_LABEL will return the label of the current
- * queue.
- *
- * @param queue
- * The queue to query, or DISPATCH_CURRENT_QUEUE_LABEL.
- *
- * @result
- * The label of the queue.
- */
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_EXPORT DISPATCH_PURE DISPATCH_WARN_RESULT DISPATCH_NOTHROW
-const char *
-dispatch_queue_get_label(dispatch_queue_t _Nullable queue);
-
-/*!
- * @function dispatch_queue_get_qos_class
- *
- * @abstract
- * Returns the QOS class and relative priority of the given queue.
- *
- * @discussion
- * If the given queue was created with an attribute value returned from
- * dispatch_queue_attr_make_with_qos_class(), this function returns the QOS
- * class and relative priority specified at that time; for any other attribute
- * value it returns a QOS class of QOS_CLASS_UNSPECIFIED and a relative
- * priority of 0.
- *
- * If the given queue is one of the global queues, this function returns its
- * assigned QOS class value as documented under dispatch_get_global_queue() and
- * a relative priority of 0; in the case of the main queue it returns the QOS
- * value provided by qos_class_main() and a relative priority of 0.
- *
- * @param queue
- * The queue to query.
- *
- * @param relative_priority_ptr
- * A pointer to an int variable to be filled with the relative priority offset
- * within the QOS class, or NULL.
- *
- * @return
- * A QOS class value:
- *	- QOS_CLASS_USER_INTERACTIVE
- *	- QOS_CLASS_USER_INITIATED
- *	- QOS_CLASS_DEFAULT
- *	- QOS_CLASS_UTILITY
- *	- QOS_CLASS_BACKGROUND
- *	- QOS_CLASS_UNSPECIFIED
- */
-API_AVAILABLE(macos(10.10), ios(8.0))
-DISPATCH_EXPORT DISPATCH_WARN_RESULT DISPATCH_NONNULL1 DISPATCH_NOTHROW
-dispatch_qos_class_t
-dispatch_queue_get_qos_class(dispatch_queue_t queue,
-		int *_Nullable relative_priority_ptr);
-
-/*!
- * @function dispatch_set_target_queue
- *
- * @abstract
- * Sets the target queue for the given object.
- *
- * @discussion
- * An object's target queue is responsible for processing the object.
- *
- * When no quality of service class and relative priority is specified for a
- * dispatch queue at the time of creation, a dispatch queue's quality of service
- * class is inherited from its target queue. The dispatch_get_global_queue()
- * function may be used to obtain a target queue of a specific quality of
- * service class, however the use of dispatch_queue_attr_make_with_qos_class()
- * is recommended instead.
- *
- * Blocks submitted to a serial queue whose target queue is another serial
- * queue will not be invoked concurrently with blocks submitted to the target
- * queue or to any other queue with that same target queue.
- *
- * The result of introducing a cycle into the hierarchy of target queues is
- * undefined.
- *
- * A dispatch source's target queue specifies where its event handler and
- * cancellation handler blocks will be submitted.
- *
- * A dispatch I/O channel's target queue specifies where where its I/O
- * operations are executed. If the channel's target queue's priority is set to
- * DISPATCH_QUEUE_PRIORITY_BACKGROUND, then the I/O operations performed by
- * dispatch_io_read() or dispatch_io_write() on that queue will be
- * throttled when there is I/O contention.
- *
- * For all other dispatch object types, the only function of the target queue
- * is to determine where an object's finalizer function is invoked.
- *
- * In general, changing the target queue of an object is an asynchronous
- * operation that doesn't take effect immediately, and doesn't affect blocks
- * already associated with the specified object.
- *
- * However, if an object is inactive at the time dispatch_set_target_queue() is
- * called, then the target queue change takes effect immediately, and will
- * affect blocks already associated with the specified object. After an
- * initially inactive object has been activated, calling
- * dispatch_set_target_queue() results in an assertion and the process being
- * terminated.
- *
- * If a dispatch queue is active and targeted by other dispatch objects,
- * changing its target queue results in undefined behavior.
- *
- * @param object
- * The object to modify.
- * The result of passing NULL in this parameter is undefined.
- *
- * @param queue
- * The new target queue for the object. The queue is retained, and the
- * previous target queue, if any, is released.
- * If queue is DISPATCH_TARGET_QUEUE_DEFAULT, set the object's target queue
- * to the default target queue for the given object type.
- */
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_EXPORT DISPATCH_NOTHROW
-void
-dispatch_set_target_queue(dispatch_object_t object,
-		dispatch_queue_t _Nullable queue);
-
-/*!
- * @function dispatch_main
- *
- * @abstract
- * Execute blocks submitted to the main queue.
- *
- * @discussion
- * This function "parks" the main thread and waits for blocks to be submitted
- * to the main queue. This function never returns.
- *
- * Applications that call NSApplicationMain() or CFRunLoopRun() on the
- * main thread do not need to call dispatch_main().
- */
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_EXPORT DISPATCH_NOTHROW DISPATCH_NORETURN
-void
-dispatch_main(void);
-
-/*!
- * @function dispatch_after
- *
- * @abstract
- * Schedule a block for execution on a given queue at a specified time.
- *
- * @discussion
- * Passing DISPATCH_TIME_NOW as the "when" parameter is supported, but not as
- * optimal as calling dispatch_async() instead. Passing DISPATCH_TIME_FOREVER
- * is undefined.
- *
- * @param when
- * A temporal milestone returned by dispatch_time() or dispatch_walltime().
- *
- * @param queue
- * A queue to which the given block will be submitted at the specified time.
- * The result of passing NULL in this parameter is undefined.
- *
- * @param block
- * The block of code to execute.
- * The result of passing NULL in this parameter is undefined.
- */
-#ifdef __BLOCKS__
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_EXPORT DISPATCH_NONNULL2 DISPATCH_NONNULL3 DISPATCH_NOTHROW
-void
-dispatch_after(dispatch_time_t when, dispatch_queue_t queue,
-		dispatch_block_t block);
-#endif
-
-/*!
- * @function dispatch_after_f
- *
- * @abstract
- * Schedule a function for execution on a given queue at a specified time.
- *
- * @discussion
- * See dispatch_after() for details.
- *
- * @param when
- * A temporal milestone returned by dispatch_time() or dispatch_walltime().
- *
- * @param queue
- * A queue to which the given function will be submitted at the specified time.
- * The result of passing NULL in this parameter is undefined.
- *
- * @param context
- * The application-defined context parameter to pass to the function.
- *
- * @param work
- * The application-defined function to invoke on the target queue. The first
- * parameter passed to this function is the context provided to
- * dispatch_after_f().
- * The result of passing NULL in this parameter is undefined.
- */
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_EXPORT DISPATCH_NONNULL2 DISPATCH_NONNULL4 DISPATCH_NOTHROW
-void
-dispatch_after_f(dispatch_time_t when, dispatch_queue_t queue,
-		void *_Nullable context, dispatch_function_t work);
-
-/*!
- * @functiongroup Dispatch Barrier API
- * The dispatch barrier API is a mechanism for submitting barrier blocks to a
- * dispatch queue, analogous to the dispatch_async()/dispatch_sync() API.
- * It enables the implementation of efficient reader/writer schemes.
- * Barrier blocks only behave specially when submitted to queues created with
- * the DISPATCH_QUEUE_CONCURRENT attribute; on such a queue, a barrier block
- * will not run until all blocks submitted to the queue earlier have completed,
- * and any blocks submitted to the queue after a barrier block will not run
- * until the barrier block has completed.
- * When submitted to a a global queue or to a queue not created with the
- * DISPATCH_QUEUE_CONCURRENT attribute, barrier blocks behave identically to
- * blocks submitted with the dispatch_async()/dispatch_sync() API.
- */
-
-/*!
- * @function dispatch_barrier_async
- *
- * @abstract
- * Submits a barrier block for asynchronous execution on a dispatch queue.
- *
- * @discussion
- * Submits a block to a dispatch queue like dispatch_async(), but marks that
- * block as a barrier (relevant only on DISPATCH_QUEUE_CONCURRENT queues).
- *
- * See dispatch_async() for details.
- *
- * @param queue
- * The target dispatch queue to which the block is submitted.
- * The system will hold a reference on the target queue until the block
- * has finished.
- * The result of passing NULL in this parameter is undefined.
- *
- * @param block
- * The block to submit to the target dispatch queue. This function performs
- * Block_copy() and Block_release() on behalf of callers.
- * The result of passing NULL in this parameter is undefined.
- */
-#ifdef __BLOCKS__
-API_AVAILABLE(macos(10.7), ios(4.3))
-DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW
-void
-dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block);
-#endif
-
-/*!
- * @function dispatch_barrier_async_f
- *
- * @abstract
- * Submits a barrier function for asynchronous execution on a dispatch queue.
- *
- * @discussion
- * Submits a function to a dispatch queue like dispatch_async_f(), but marks
- * that function as a barrier (relevant only on DISPATCH_QUEUE_CONCURRENT
- * queues).
- *
- * See dispatch_async_f() for details.
- *
- * @param queue
- * The target dispatch queue to which the function is submitted.
- * The system will hold a reference on the target queue until the function
- * has returned.
- * The result of passing NULL in this parameter is undefined.
- *
- * @param context
- * The application-defined context parameter to pass to the function.
- *
- * @param work
- * The application-defined function to invoke on the target queue. The first
- * parameter passed to this function is the context provided to
- * dispatch_barrier_async_f().
- * The result of passing NULL in this parameter is undefined.
- */
-API_AVAILABLE(macos(10.7), ios(4.3))
-DISPATCH_EXPORT DISPATCH_NONNULL1 DISPATCH_NONNULL3 DISPATCH_NOTHROW
-void
-dispatch_barrier_async_f(dispatch_queue_t queue,
-		void *_Nullable context, dispatch_function_t work);
-
-/*!
- * @function dispatch_barrier_sync
- *
- * @abstract
- * Submits a barrier block for synchronous execution on a dispatch queue.
- *
- * @discussion
- * Submits a block to a dispatch queue like dispatch_sync(), but marks that
- * block as a barrier (relevant only on DISPATCH_QUEUE_CONCURRENT queues).
- *
- * See dispatch_sync() for details.
- *
- * @param queue
- * The target dispatch queue to which the block is submitted.
- * The result of passing NULL in this parameter is undefined.
- *
- * @param block
- * The block to be invoked on the target dispatch queue.
- * The result of passing NULL in this parameter is undefined.
- */
-#ifdef __BLOCKS__
-API_AVAILABLE(macos(10.7), ios(4.3))
-DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW
-void
-dispatch_barrier_sync(dispatch_queue_t queue,
-		DISPATCH_NOESCAPE dispatch_block_t block);
-#endif
-
-/*!
- * @function dispatch_barrier_sync_f
- *
- * @abstract
- * Submits a barrier function for synchronous execution on a dispatch queue.
- *
- * @discussion
- * Submits a function to a dispatch queue like dispatch_sync_f(), but marks that
- * fuction as a barrier (relevant only on DISPATCH_QUEUE_CONCURRENT queues).
- *
- * See dispatch_sync_f() for details.
- *
- * @param queue
- * The target dispatch queue to which the function is submitted.
- * The result of passing NULL in this parameter is undefined.
- *
- * @param context
- * The application-defined context parameter to pass to the function.
- *
- * @param work
- * The application-defined function to invoke on the target queue. The first
- * parameter passed to this function is the context provided to
- * dispatch_barrier_sync_f().
- * The result of passing NULL in this parameter is undefined.
- */
-API_AVAILABLE(macos(10.7), ios(4.3))
-DISPATCH_EXPORT DISPATCH_NONNULL1 DISPATCH_NONNULL3 DISPATCH_NOTHROW
-void
-dispatch_barrier_sync_f(dispatch_queue_t queue,
-		void *_Nullable context, dispatch_function_t work);
-
-/*!
- * @functiongroup Dispatch queue-specific contexts
- * This API allows different subsystems to associate context to a shared queue
- * without risk of collision and to retrieve that context from blocks executing
- * on that queue or any of its child queues in the target queue hierarchy.
- */
-
-/*!
- * @function dispatch_queue_set_specific
- *
- * @abstract
- * Associates a subsystem-specific context with a dispatch queue, for a key
- * unique to the subsystem.
- *
- * @discussion
- * The specified destructor will be invoked with the context on the default
- * priority global concurrent queue when a new context is set for the same key,
- * or after all references to the queue have been released.
- *
- * @param queue
- * The dispatch queue to modify.
- * The result of passing NULL in this parameter is undefined.
- *
- * @param key
- * The key to set the context for, typically a pointer to a static variable
- * specific to the subsystem. Keys are only compared as pointers and never
- * dereferenced. Passing a string constant directly is not recommended.
- * The NULL key is reserved and attempts to set a context for it are ignored.
- *
- * @param context
- * The new subsystem-specific context for the object. This may be NULL.
- *
- * @param destructor
- * The destructor function pointer. This may be NULL and is ignored if context
- * is NULL.
- */
-API_AVAILABLE(macos(10.7), ios(5.0))
-DISPATCH_EXPORT DISPATCH_NONNULL1 DISPATCH_NOTHROW
-void
-dispatch_queue_set_specific(dispatch_queue_t queue, const void *key,
-		void *_Nullable context, dispatch_function_t _Nullable destructor);
-
-/*!
- * @function dispatch_queue_get_specific
- *
- * @abstract
- * Returns the subsystem-specific context associated with a dispatch queue, for
- * a key unique to the subsystem.
- *
- * @discussion
- * Returns the context for the specified key if it has been set on the specified
- * queue.
- *
- * @param queue
- * The dispatch queue to query.
- * The result of passing NULL in this parameter is undefined.
- *
- * @param key
- * The key to get the context for, typically a pointer to a static variable
- * specific to the subsystem. Keys are only compared as pointers and never
- * dereferenced. Passing a string constant directly is not recommended.
- *
- * @result
- * The context for the specified key or NULL if no context was found.
- */
-API_AVAILABLE(macos(10.7), ios(5.0))
-DISPATCH_EXPORT DISPATCH_NONNULL1 DISPATCH_PURE DISPATCH_WARN_RESULT
-DISPATCH_NOTHROW
-void *_Nullable
-dispatch_queue_get_specific(dispatch_queue_t queue, const void *key);
-
-/*!
- * @function dispatch_get_specific
- *
- * @abstract
- * Returns the current subsystem-specific context for a key unique to the
- * subsystem.
- *
- * @discussion
- * When called from a block executing on a queue, returns the context for the
- * specified key if it has been set on the queue, otherwise returns the result
- * of dispatch_get_specific() executed on the queue's target queue or NULL
- * if the current queue is a global concurrent queue.
- *
- * @param key
- * The key to get the context for, typically a pointer to a static variable
- * specific to the subsystem. Keys are only compared as pointers and never
- * dereferenced. Passing a string constant directly is not recommended.
- *
- * @result
- * The context for the specified key or NULL if no context was found.
- */
-API_AVAILABLE(macos(10.7), ios(5.0))
-DISPATCH_EXPORT DISPATCH_PURE DISPATCH_WARN_RESULT DISPATCH_NOTHROW
-void *_Nullable
-dispatch_get_specific(const void *key);
-
-/*!
- * @functiongroup Dispatch assertion API
- *
- * This API asserts at runtime that code is executing in (or out of) the context
- * of a given queue. It can be used to check that a block accessing a resource
- * does so from the proper queue protecting the resource. It also can be used
- * to verify that a block that could cause a deadlock if run on a given queue
- * never executes on that queue.
- */
-
-/*!
- * @function dispatch_assert_queue
- *
- * @abstract
- * Verifies that the current block is executing on a given dispatch queue.
- *
- * @discussion
- * Some code expects to be run on a specific dispatch queue. This function
- * verifies that that expectation is true.
- *
- * If the currently executing block was submitted to the specified queue or to
- * any queue targeting it (see dispatch_set_target_queue()), this function
- * returns.
- *
- * If the currently executing block was submitted with a synchronous API
- * (dispatch_sync(), dispatch_barrier_sync(), ...), the context of the
- * submitting block is also evaluated (recursively).
- * If a synchronously submitting block is found that was itself submitted to
- * the specified queue or to any queue targeting it, this function returns.
- *
- * Otherwise this function asserts: it logs an explanation to the system log and
- * terminates the application.
- *
- * Passing the result of dispatch_get_main_queue() to this function verifies
- * that the current block was submitted to the main queue, or to a queue
- * targeting it, or is running on the main thread (in any context).
- *
- * When dispatch_assert_queue() is called outside of the context of a
- * submitted block (for example from the context of a thread created manually
- * with pthread_create()) then this function will also assert and terminate
- * the application.
- *
- * The variant dispatch_assert_queue_debug() is compiled out when the
- * preprocessor macro NDEBUG is defined. (See also assert(3)).
- *
- * @param queue
- * The dispatch queue that the current block is expected to run on.
- * The result of passing NULL in this parameter is undefined.
- */
-API_AVAILABLE(macos(10.12), ios(10.0), tvos(10.0), watchos(3.0))
-DISPATCH_EXPORT DISPATCH_NONNULL1
-void
-dispatch_assert_queue(dispatch_queue_t queue)
-		DISPATCH_ALIAS_V2(dispatch_assert_queue);
-
-/*!
- * @function dispatch_assert_queue_barrier
- *
- * @abstract
- * Verifies that the current block is executing on a given dispatch queue,
- * and that the block acts as a barrier on that queue.
- *
- * @discussion
- * This behaves exactly like dispatch_assert_queue(), with the additional check
- * that the current block acts as a barrier on the specified queue, which is
- * always true if the specified queue is serial (see DISPATCH_BLOCK_BARRIER or
- * dispatch_barrier_async() for details).
- *
- * The variant dispatch_assert_queue_barrier_debug() is compiled out when the
- * preprocessor macro NDEBUG is defined. (See also assert()).
- *
- * @param queue
- * The dispatch queue that the current block is expected to run as a barrier on.
- * The result of passing NULL in this parameter is undefined.
- */
-API_AVAILABLE(macos(10.12), ios(10.0), tvos(10.0), watchos(3.0))
-DISPATCH_EXPORT DISPATCH_NONNULL1
-void
-dispatch_assert_queue_barrier(dispatch_queue_t queue);
-
-/*!
- * @function dispatch_assert_queue_not
- *
- * @abstract
- * Verifies that the current block is not executing on a given dispatch queue.
- *
- * @discussion
- * This function is the equivalent of dispatch_queue_assert() with the test for
- * equality inverted. That means that it will terminate the application when
- * dispatch_queue_assert() would return, and vice-versa. See discussion there.
- *
- * The variant dispatch_assert_queue_not_debug() is compiled out when the
- * preprocessor macro NDEBUG is defined. (See also assert(3)).
- *
- * @param queue
- * The dispatch queue that the current block is expected not to run on.
- * The result of passing NULL in this parameter is undefined.
- */
-API_AVAILABLE(macos(10.12), ios(10.0), tvos(10.0), watchos(3.0))
-DISPATCH_EXPORT DISPATCH_NONNULL1
-void
-dispatch_assert_queue_not(dispatch_queue_t queue)
-		DISPATCH_ALIAS_V2(dispatch_assert_queue_not);
-
-#ifdef NDEBUG
-#define dispatch_assert_queue_debug(q) ((void)(0 && (q)))
-#define dispatch_assert_queue_barrier_debug(q) ((void)(0 && (q)))
-#define dispatch_assert_queue_not_debug(q) ((void)(0 && (q)))
-#else
-#define dispatch_assert_queue_debug(q) dispatch_assert_queue(q)
-#define dispatch_assert_queue_barrier_debug(q) dispatch_assert_queue_barrier(q)
-#define dispatch_assert_queue_not_debug(q) dispatch_assert_queue_not(q)
-#endif
-
-__END_DECLS
-
-DISPATCH_ASSUME_NONNULL_END
-
-#endif
--- a/Telegram/ThirdParty/dispatch/dispatch/semaphore.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/dispatch/semaphore.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,117 +0,0 @@
-/*
- * Copyright (c) 2008-2013 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#ifndef __DISPATCH_SEMAPHORE__
-#define __DISPATCH_SEMAPHORE__
-
-#ifndef __DISPATCH_INDIRECT__
-#error "Please #include <dispatch/dispatch.h> instead of this file directly."
-#include <dispatch/base.h> // for HeaderDoc
-#endif
-
-DISPATCH_ASSUME_NONNULL_BEGIN
-
-/*!
- * @typedef dispatch_semaphore_t
- *
- * @abstract
- * A counting semaphore.
- */
-DISPATCH_DECL(dispatch_semaphore);
-
-__BEGIN_DECLS
-
-/*!
- * @function dispatch_semaphore_create
- *
- * @abstract
- * Creates new counting semaphore with an initial value.
- *
- * @discussion
- * Passing zero for the value is useful for when two threads need to reconcile
- * the completion of a particular event. Passing a value greater than zero is
- * useful for managing a finite pool of resources, where the pool size is equal
- * to the value.
- *
- * @param value
- * The starting value for the semaphore. Passing a value less than zero will
- * cause NULL to be returned.
- *
- * @result
- * The newly created semaphore, or NULL on failure.
- */
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_EXPORT DISPATCH_MALLOC DISPATCH_RETURNS_RETAINED DISPATCH_WARN_RESULT
-DISPATCH_NOTHROW
-dispatch_semaphore_t
-dispatch_semaphore_create(intptr_t value);
-
-/*!
- * @function dispatch_semaphore_wait
- *
- * @abstract
- * Wait (decrement) for a semaphore.
- *
- * @discussion
- * Decrement the counting semaphore. If the resulting value is less than zero,
- * this function waits for a signal to occur before returning.
- *
- * @param dsema
- * The semaphore. The result of passing NULL in this parameter is undefined.
- *
- * @param timeout
- * When to timeout (see dispatch_time). As a convenience, there are the
- * DISPATCH_TIME_NOW and DISPATCH_TIME_FOREVER constants.
- *
- * @result
- * Returns zero on success, or non-zero if the timeout occurred.
- */
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW
-intptr_t
-dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout);
-
-/*!
- * @function dispatch_semaphore_signal
- *
- * @abstract
- * Signal (increment) a semaphore.
- *
- * @discussion
- * Increment the counting semaphore. If the previous value was less than zero,
- * this function wakes a waiting thread before returning.
- *
- * @param dsema The counting semaphore.
- * The result of passing NULL in this parameter is undefined.
- *
- * @result
- * This function returns non-zero if a thread is woken. Otherwise, zero is
- * returned.
- */
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW
-intptr_t
-dispatch_semaphore_signal(dispatch_semaphore_t dsema);
-
-__END_DECLS
-
-DISPATCH_ASSUME_NONNULL_END
-
-#endif /* __DISPATCH_SEMAPHORE__ */
--- a/Telegram/ThirdParty/dispatch/dispatch/source.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/dispatch/source.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,773 +0,0 @@
-/*
- * Copyright (c) 2008-2013 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#ifndef __DISPATCH_SOURCE__
-#define __DISPATCH_SOURCE__
-
-#ifndef __DISPATCH_INDIRECT__
-#error "Please #include <dispatch/dispatch.h> instead of this file directly."
-#include <dispatch/base.h> // for HeaderDoc
-#endif
-
-#if TARGET_OS_MAC
-#include <mach/port.h>
-#include <mach/message.h>
-#endif
-
-#if !defined(_WIN32)
-#include <sys/signal.h>
-#endif
-
-DISPATCH_ASSUME_NONNULL_BEGIN
-
-/*!
- * @header
- * The dispatch framework provides a suite of interfaces for monitoring low-
- * level system objects (file descriptors, Mach ports, signals, VFS nodes, etc.)
- * for activity and automatically submitting event handler blocks to dispatch
- * queues when such activity occurs.
- *
- * This suite of interfaces is known as the Dispatch Source API.
- */
-
-/*!
- * @typedef dispatch_source_t
- *
- * @abstract
- * Dispatch sources are used to automatically submit event handler blocks to
- * dispatch queues in response to external events.
- */
-DISPATCH_SOURCE_DECL(dispatch_source)
-
-__BEGIN_DECLS
-
-/*!
- * @typedef dispatch_source_type_t
- *
- * @abstract
- * Constants of this type represent the class of low-level system object that
- * is being monitored by the dispatch source. Constants of this type are
- * passed as a parameter to dispatch_source_create() and determine how the
- * handle argument is interpreted (i.e. as a file descriptor, mach port,
- * signal number, process identifier, etc.), and how the mask argument is
- * interpreted.
- */
-typedef const struct dispatch_source_type_s *dispatch_source_type_t;
-
-/*!
- * @const DISPATCH_SOURCE_TYPE_DATA_ADD
- * @discussion A dispatch source that coalesces data obtained via calls to
- * dispatch_source_merge_data(). An ADD is used to coalesce the data.
- * The handle is unused (pass zero for now).
- * The mask is unused (pass zero for now).
- */
-#define DISPATCH_SOURCE_TYPE_DATA_ADD (&_dispatch_source_type_data_add)
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_SOURCE_TYPE_DECL(data_add);
-
-/*!
- * @const DISPATCH_SOURCE_TYPE_DATA_OR
- * @discussion A dispatch source that coalesces data obtained via calls to
- * dispatch_source_merge_data(). A bitwise OR is used to coalesce the data.
- * The handle is unused (pass zero for now).
- * The mask is unused (pass zero for now).
- */
-#define DISPATCH_SOURCE_TYPE_DATA_OR (&_dispatch_source_type_data_or)
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_SOURCE_TYPE_DECL(data_or);
-
-/*!
- * @const DISPATCH_SOURCE_TYPE_DATA_REPLACE
- * @discussion A dispatch source that tracks data obtained via calls to
- * dispatch_source_merge_data(). Newly obtained data values replace existing
- * data values not yet delivered to the source handler
- *
- * A data value of zero will cause the source handler to not be invoked.
- *
- * The handle is unused (pass zero for now).
- * The mask is unused (pass zero for now).
- */
-#define DISPATCH_SOURCE_TYPE_DATA_REPLACE (&_dispatch_source_type_data_replace)
-API_AVAILABLE(macos(10.13), ios(11.0), tvos(11.0), watchos(4.0))
-DISPATCH_SOURCE_TYPE_DECL(data_replace);
-
-/*!
- * @const DISPATCH_SOURCE_TYPE_MACH_SEND
- * @discussion A dispatch source that monitors a Mach port for dead name
- * notifications (send right no longer has any corresponding receive right).
- * The handle is a Mach port with a send or send-once right (mach_port_t).
- * The mask is a mask of desired events from dispatch_source_mach_send_flags_t.
- */
-#define DISPATCH_SOURCE_TYPE_MACH_SEND (&_dispatch_source_type_mach_send)
-API_AVAILABLE(macos(10.6), ios(4.0)) DISPATCH_LINUX_UNAVAILABLE()
-DISPATCH_SOURCE_TYPE_DECL(mach_send);
-
-/*!
- * @const DISPATCH_SOURCE_TYPE_MACH_RECV
- * @discussion A dispatch source that monitors a Mach port for pending messages.
- * The handle is a Mach port with a receive right (mach_port_t).
- * The mask is unused (pass zero for now).
- */
-#define DISPATCH_SOURCE_TYPE_MACH_RECV (&_dispatch_source_type_mach_recv)
-API_AVAILABLE(macos(10.6), ios(4.0)) DISPATCH_LINUX_UNAVAILABLE()
-DISPATCH_SOURCE_TYPE_DECL(mach_recv);
-
-/*!
- * @const DISPATCH_SOURCE_TYPE_MEMORYPRESSURE
- * @discussion A dispatch source that monitors the system for changes in
- * memory pressure condition.
- * The handle is unused (pass zero for now).
- * The mask is a mask of desired events from
- * dispatch_source_memorypressure_flags_t.
- */
-#define DISPATCH_SOURCE_TYPE_MEMORYPRESSURE \
-		(&_dispatch_source_type_memorypressure)
-API_AVAILABLE(macos(10.9), ios(8.0)) DISPATCH_LINUX_UNAVAILABLE()
-DISPATCH_SOURCE_TYPE_DECL(memorypressure);
-
-/*!
- * @const DISPATCH_SOURCE_TYPE_PROC
- * @discussion A dispatch source that monitors an external process for events
- * defined by dispatch_source_proc_flags_t.
- * The handle is a process identifier (pid_t).
- * The mask is a mask of desired events from dispatch_source_proc_flags_t.
- */
-#define DISPATCH_SOURCE_TYPE_PROC (&_dispatch_source_type_proc)
-API_AVAILABLE(macos(10.6), ios(4.0)) DISPATCH_LINUX_UNAVAILABLE()
-DISPATCH_SOURCE_TYPE_DECL(proc);
-
-/*!
- * @const DISPATCH_SOURCE_TYPE_READ
- * @discussion A dispatch source that monitors a file descriptor for pending
- * bytes available to be read.
- * The handle is a file descriptor (int).
- * The mask is unused (pass zero for now).
- */
-#define DISPATCH_SOURCE_TYPE_READ (&_dispatch_source_type_read)
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_SOURCE_TYPE_DECL(read);
-
-/*!
- * @const DISPATCH_SOURCE_TYPE_SIGNAL
- * @discussion A dispatch source that monitors the current process for signals.
- * The handle is a signal number (int).
- * The mask is unused (pass zero for now).
- */
-#define DISPATCH_SOURCE_TYPE_SIGNAL (&_dispatch_source_type_signal)
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_SOURCE_TYPE_DECL(signal);
-
-/*!
- * @const DISPATCH_SOURCE_TYPE_TIMER
- * @discussion A dispatch source that submits the event handler block based
- * on a timer.
- * The handle is unused (pass zero for now).
- * The mask specifies which flags from dispatch_source_timer_flags_t to apply.
- */
-#define DISPATCH_SOURCE_TYPE_TIMER (&_dispatch_source_type_timer)
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_SOURCE_TYPE_DECL(timer);
-
-/*!
- * @const DISPATCH_SOURCE_TYPE_VNODE
- * @discussion A dispatch source that monitors a file descriptor for events
- * defined by dispatch_source_vnode_flags_t.
- * The handle is a file descriptor (int).
- * The mask is a mask of desired events from dispatch_source_vnode_flags_t.
- */
-#define DISPATCH_SOURCE_TYPE_VNODE (&_dispatch_source_type_vnode)
-API_AVAILABLE(macos(10.6), ios(4.0)) DISPATCH_LINUX_UNAVAILABLE()
-DISPATCH_SOURCE_TYPE_DECL(vnode);
-
-/*!
- * @const DISPATCH_SOURCE_TYPE_WRITE
- * @discussion A dispatch source that monitors a file descriptor for available
- * buffer space to write bytes.
- * The handle is a file descriptor (int).
- * The mask is unused (pass zero for now).
- */
-#define DISPATCH_SOURCE_TYPE_WRITE (&_dispatch_source_type_write)
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_SOURCE_TYPE_DECL(write);
-
-/*!
- * @typedef dispatch_source_mach_send_flags_t
- * Type of dispatch_source_mach_send flags
- *
- * @constant DISPATCH_MACH_SEND_DEAD
- * The receive right corresponding to the given send right was destroyed.
- */
-#define DISPATCH_MACH_SEND_DEAD	0x1
-
-typedef unsigned long dispatch_source_mach_send_flags_t;
-
-/*!
- * @typedef dispatch_source_memorypressure_flags_t
- * Type of dispatch_source_memorypressure flags
- *
- * @constant DISPATCH_MEMORYPRESSURE_NORMAL
- * The system memory pressure condition has returned to normal.
- *
- * @constant DISPATCH_MEMORYPRESSURE_WARN
- * The system memory pressure condition has changed to warning.
- *
- * @constant DISPATCH_MEMORYPRESSURE_CRITICAL
- * The system memory pressure condition has changed to critical.
- *
- * @discussion
- * Elevated memory pressure is a system-wide condition that applications
- * registered for this source should react to by changing their future memory
- * use behavior, e.g. by reducing cache sizes of newly initiated operations
- * until memory pressure returns back to normal.
- * NOTE: applications should NOT traverse and discard existing caches for past
- * operations when the system memory pressure enters an elevated state, as that
- * is likely to trigger VM operations that will further aggravate system memory
- * pressure.
- */
-
-#define DISPATCH_MEMORYPRESSURE_NORMAL		0x01
-#define DISPATCH_MEMORYPRESSURE_WARN		0x02
-#define DISPATCH_MEMORYPRESSURE_CRITICAL	0x04
-
-typedef unsigned long dispatch_source_memorypressure_flags_t;
-
-/*!
- * @typedef dispatch_source_proc_flags_t
- * Type of dispatch_source_proc flags
- *
- * @constant DISPATCH_PROC_EXIT
- * The process has exited (perhaps cleanly, perhaps not).
- *
- * @constant DISPATCH_PROC_FORK
- * The process has created one or more child processes.
- *
- * @constant DISPATCH_PROC_EXEC
- * The process has become another executable image via
- * exec*() or posix_spawn*().
- *
- * @constant DISPATCH_PROC_SIGNAL
- * A Unix signal was delivered to the process.
- */
-#define DISPATCH_PROC_EXIT		0x80000000
-#define DISPATCH_PROC_FORK		0x40000000
-#define DISPATCH_PROC_EXEC		0x20000000
-#define DISPATCH_PROC_SIGNAL	0x08000000
-
-typedef unsigned long dispatch_source_proc_flags_t;
-
-/*!
- * @typedef dispatch_source_vnode_flags_t
- * Type of dispatch_source_vnode flags
- *
- * @constant DISPATCH_VNODE_DELETE
- * The filesystem object was deleted from the namespace.
- *
- * @constant DISPATCH_VNODE_WRITE
- * The filesystem object data changed.
- *
- * @constant DISPATCH_VNODE_EXTEND
- * The filesystem object changed in size.
- *
- * @constant DISPATCH_VNODE_ATTRIB
- * The filesystem object metadata changed.
- *
- * @constant DISPATCH_VNODE_LINK
- * The filesystem object link count changed.
- *
- * @constant DISPATCH_VNODE_RENAME
- * The filesystem object was renamed in the namespace.
- *
- * @constant DISPATCH_VNODE_REVOKE
- * The filesystem object was revoked.
- *
- * @constant DISPATCH_VNODE_FUNLOCK
- * The filesystem object was unlocked.
- */
-
-#define DISPATCH_VNODE_DELETE	0x1
-#define DISPATCH_VNODE_WRITE	0x2
-#define DISPATCH_VNODE_EXTEND	0x4
-#define DISPATCH_VNODE_ATTRIB	0x8
-#define DISPATCH_VNODE_LINK		0x10
-#define DISPATCH_VNODE_RENAME	0x20
-#define DISPATCH_VNODE_REVOKE	0x40
-#define DISPATCH_VNODE_FUNLOCK	0x100
-
-typedef unsigned long dispatch_source_vnode_flags_t;
-
-/*!
- * @typedef dispatch_source_timer_flags_t
- * Type of dispatch_source_timer flags
- *
- * @constant DISPATCH_TIMER_STRICT
- * Specifies that the system should make a best effort to strictly observe the
- * leeway value specified for the timer via dispatch_source_set_timer(), even
- * if that value is smaller than the default leeway value that would be applied
- * to the timer otherwise. A minimal amount of leeway will be applied to the
- * timer even if this flag is specified.
- *
- * CAUTION: Use of this flag may override power-saving techniques employed by
- * the system and cause higher power consumption, so it must be used with care
- * and only when absolutely necessary.
- */
-
-#define DISPATCH_TIMER_STRICT 0x1
-
-typedef unsigned long dispatch_source_timer_flags_t;
-
-/*!
- * @function dispatch_source_create
- *
- * @abstract
- * Creates a new dispatch source to monitor low-level system objects and auto-
- * matically submit a handler block to a dispatch queue in response to events.
- *
- * @discussion
- * Dispatch sources are not reentrant. Any events received while the dispatch
- * source is suspended or while the event handler block is currently executing
- * will be coalesced and delivered after the dispatch source is resumed or the
- * event handler block has returned.
- *
- * Dispatch sources are created in an inactive state. After creating the
- * source and setting any desired attributes (i.e. the handler, context, etc.),
- * a call must be made to dispatch_activate() in order to begin event delivery.
- *
- * Calling dispatch_set_target_queue() on a source once it has been activated
- * is not allowed (see dispatch_activate() and dispatch_set_target_queue()).
- *
- * For backward compatibility reasons, dispatch_resume() on an inactive,
- * and not otherwise suspended source has the same effect as calling
- * dispatch_activate(). For new code, using dispatch_activate() is preferred.
- *
- * @param type
- * Declares the type of the dispatch source. Must be one of the defined
- * dispatch_source_type_t constants.
- *
- * @param handle
- * The underlying system handle to monitor. The interpretation of this argument
- * is determined by the constant provided in the type parameter.
- *
- * @param mask
- * A mask of flags specifying which events are desired. The interpretation of
- * this argument is determined by the constant provided in the type parameter.
- *
- * @param queue
- * The dispatch queue to which the event handler block will be submitted.
- * If queue is DISPATCH_TARGET_QUEUE_DEFAULT, the source will submit the event
- * handler block to the default priority global queue.
- *
- * @result
- * The newly created dispatch source. Or NULL if invalid arguments are passed.
- */
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_EXPORT DISPATCH_MALLOC DISPATCH_RETURNS_RETAINED DISPATCH_WARN_RESULT
-DISPATCH_NOTHROW
-dispatch_source_t
-dispatch_source_create(dispatch_source_type_t type,
-	uintptr_t handle,
-	uintptr_t mask,
-	dispatch_queue_t _Nullable queue);
-
-/*!
- * @function dispatch_source_set_event_handler
- *
- * @abstract
- * Sets the event handler block for the given dispatch source.
- *
- * @param source
- * The dispatch source to modify.
- * The result of passing NULL in this parameter is undefined.
- *
- * @param handler
- * The event handler block to submit to the source's target queue.
- */
-#ifdef __BLOCKS__
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_EXPORT DISPATCH_NONNULL1 DISPATCH_NOTHROW
-void
-dispatch_source_set_event_handler(dispatch_source_t source,
-	dispatch_block_t _Nullable handler);
-#endif /* __BLOCKS__ */
-
-/*!
- * @function dispatch_source_set_event_handler_f
- *
- * @abstract
- * Sets the event handler function for the given dispatch source.
- *
- * @param source
- * The dispatch source to modify.
- * The result of passing NULL in this parameter is undefined.
- *
- * @param handler
- * The event handler function to submit to the source's target queue.
- * The context parameter passed to the event handler function is the context of
- * the dispatch source current at the time the event handler was set.
- */
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_EXPORT DISPATCH_NONNULL1 DISPATCH_NOTHROW
-void
-dispatch_source_set_event_handler_f(dispatch_source_t source,
-	dispatch_function_t _Nullable handler);
-
-/*!
- * @function dispatch_source_set_cancel_handler
- *
- * @abstract
- * Sets the cancellation handler block for the given dispatch source.
- *
- * @discussion
- * The cancellation handler (if specified) will be submitted to the source's
- * target queue in response to a call to dispatch_source_cancel() once the
- * system has released all references to the source's underlying handle and
- * the source's event handler block has returned.
- *
- * IMPORTANT:
- * Source cancellation and a cancellation handler are required for file
- * descriptor and mach port based sources in order to safely close the
- * descriptor or destroy the port.
- * Closing the descriptor or port before the cancellation handler is invoked may
- * result in a race condition. If a new descriptor is allocated with the same
- * value as the recently closed descriptor while the source's event handler is
- * still running, the event handler may read/write data to the wrong descriptor.
- *
- * @param source
- * The dispatch source to modify.
- * The result of passing NULL in this parameter is undefined.
- *
- * @param handler
- * The cancellation handler block to submit to the source's target queue.
- */
-#ifdef __BLOCKS__
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_EXPORT DISPATCH_NONNULL1 DISPATCH_NOTHROW
-void
-dispatch_source_set_cancel_handler(dispatch_source_t source,
-	dispatch_block_t _Nullable handler);
-#endif /* __BLOCKS__ */
-
-/*!
- * @function dispatch_source_set_cancel_handler_f
- *
- * @abstract
- * Sets the cancellation handler function for the given dispatch source.
- *
- * @discussion
- * See dispatch_source_set_cancel_handler() for more details.
- *
- * @param source
- * The dispatch source to modify.
- * The result of passing NULL in this parameter is undefined.
- *
- * @param handler
- * The cancellation handler function to submit to the source's target queue.
- * The context parameter passed to the event handler function is the current
- * context of the dispatch source at the time the handler call is made.
- */
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_EXPORT DISPATCH_NONNULL1 DISPATCH_NOTHROW
-void
-dispatch_source_set_cancel_handler_f(dispatch_source_t source,
-	dispatch_function_t _Nullable handler);
-
-/*!
- * @function dispatch_source_cancel
- *
- * @abstract
- * Asynchronously cancel the dispatch source, preventing any further invocation
- * of its event handler block.
- *
- * @discussion
- * Cancellation prevents any further invocation of the event handler block for
- * the specified dispatch source, but does not interrupt an event handler
- * block that is already in progress.
- *
- * The cancellation handler is submitted to the source's target queue once the
- * the source's event handler has finished, indicating it is now safe to close
- * the source's handle (i.e. file descriptor or mach port).
- *
- * See dispatch_source_set_cancel_handler() for more information.
- *
- * @param source
- * The dispatch source to be canceled.
- * The result of passing NULL in this parameter is undefined.
- */
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW
-void
-dispatch_source_cancel(dispatch_source_t source);
-
-/*!
- * @function dispatch_source_testcancel
- *
- * @abstract
- * Tests whether the given dispatch source has been canceled.
- *
- * @param source
- * The dispatch source to be tested.
- * The result of passing NULL in this parameter is undefined.
- *
- * @result
- * Non-zero if canceled and zero if not canceled.
- */
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_WARN_RESULT DISPATCH_PURE
-DISPATCH_NOTHROW
-intptr_t
-dispatch_source_testcancel(dispatch_source_t source);
-
-/*!
- * @function dispatch_source_get_handle
- *
- * @abstract
- * Returns the underlying system handle associated with this dispatch source.
- *
- * @param source
- * The result of passing NULL in this parameter is undefined.
- *
- * @result
- * The return value should be interpreted according to the type of the dispatch
- * source, and may be one of the following handles:
- *
- *  DISPATCH_SOURCE_TYPE_DATA_ADD:        n/a
- *  DISPATCH_SOURCE_TYPE_DATA_OR:         n/a
- *  DISPATCH_SOURCE_TYPE_DATA_REPLACE:    n/a
- *  DISPATCH_SOURCE_TYPE_MACH_SEND:       mach port (mach_port_t)
- *  DISPATCH_SOURCE_TYPE_MACH_RECV:       mach port (mach_port_t)
- *  DISPATCH_SOURCE_TYPE_MEMORYPRESSURE   n/a
- *  DISPATCH_SOURCE_TYPE_PROC:            process identifier (pid_t)
- *  DISPATCH_SOURCE_TYPE_READ:            file descriptor (int)
- *  DISPATCH_SOURCE_TYPE_SIGNAL:          signal number (int)
- *  DISPATCH_SOURCE_TYPE_TIMER:           n/a
- *  DISPATCH_SOURCE_TYPE_VNODE:           file descriptor (int)
- *  DISPATCH_SOURCE_TYPE_WRITE:           file descriptor (int)
- */
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_WARN_RESULT DISPATCH_PURE
-DISPATCH_NOTHROW
-uintptr_t
-dispatch_source_get_handle(dispatch_source_t source);
-
-/*!
- * @function dispatch_source_get_mask
- *
- * @abstract
- * Returns the mask of events monitored by the dispatch source.
- *
- * @param source
- * The result of passing NULL in this parameter is undefined.
- *
- * @result
- * The return value should be interpreted according to the type of the dispatch
- * source, and may be one of the following flag sets:
- *
- *  DISPATCH_SOURCE_TYPE_DATA_ADD:        n/a
- *  DISPATCH_SOURCE_TYPE_DATA_OR:         n/a
- *  DISPATCH_SOURCE_TYPE_DATA_REPLACE:    n/a
- *  DISPATCH_SOURCE_TYPE_MACH_SEND:       dispatch_source_mach_send_flags_t
- *  DISPATCH_SOURCE_TYPE_MACH_RECV:       n/a
- *  DISPATCH_SOURCE_TYPE_MEMORYPRESSURE   dispatch_source_memorypressure_flags_t
- *  DISPATCH_SOURCE_TYPE_PROC:            dispatch_source_proc_flags_t
- *  DISPATCH_SOURCE_TYPE_READ:            n/a
- *  DISPATCH_SOURCE_TYPE_SIGNAL:          n/a
- *  DISPATCH_SOURCE_TYPE_TIMER:           dispatch_source_timer_flags_t
- *  DISPATCH_SOURCE_TYPE_VNODE:           dispatch_source_vnode_flags_t
- *  DISPATCH_SOURCE_TYPE_WRITE:           n/a
- */
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_WARN_RESULT DISPATCH_PURE
-DISPATCH_NOTHROW
-uintptr_t
-dispatch_source_get_mask(dispatch_source_t source);
-
-/*!
- * @function dispatch_source_get_data
- *
- * @abstract
- * Returns pending data for the dispatch source.
- *
- * @discussion
- * This function is intended to be called from within the event handler block.
- * The result of calling this function outside of the event handler callback is
- * undefined.
- *
- * @param source
- * The result of passing NULL in this parameter is undefined.
- *
- * @result
- * The return value should be interpreted according to the type of the dispatch
- * source, and may be one of the following:
- *
- *  DISPATCH_SOURCE_TYPE_DATA_ADD:        application defined data
- *  DISPATCH_SOURCE_TYPE_DATA_OR:         application defined data
- *  DISPATCH_SOURCE_TYPE_DATA_REPLACE:    application defined data
- *  DISPATCH_SOURCE_TYPE_MACH_SEND:       dispatch_source_mach_send_flags_t
- *  DISPATCH_SOURCE_TYPE_MACH_RECV:       n/a
- *  DISPATCH_SOURCE_TYPE_MEMORYPRESSURE   dispatch_source_memorypressure_flags_t
- *  DISPATCH_SOURCE_TYPE_PROC:            dispatch_source_proc_flags_t
- *  DISPATCH_SOURCE_TYPE_READ:            estimated bytes available to read
- *  DISPATCH_SOURCE_TYPE_SIGNAL:          number of signals delivered since
- *                                            the last handler invocation
- *  DISPATCH_SOURCE_TYPE_TIMER:           number of times the timer has fired
- *                                            since the last handler invocation
- *  DISPATCH_SOURCE_TYPE_VNODE:           dispatch_source_vnode_flags_t
- *  DISPATCH_SOURCE_TYPE_WRITE:           estimated buffer space available
- */
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_WARN_RESULT DISPATCH_PURE
-DISPATCH_NOTHROW
-uintptr_t
-dispatch_source_get_data(dispatch_source_t source);
-
-/*!
- * @function dispatch_source_merge_data
- *
- * @abstract
- * Merges data into a dispatch source of type DISPATCH_SOURCE_TYPE_DATA_ADD,
- * DISPATCH_SOURCE_TYPE_DATA_OR or DISPATCH_SOURCE_TYPE_DATA_REPLACE,
- * and submits its event handler block to its target queue.
- *
- * @param source
- * The result of passing NULL in this parameter is undefined.
- *
- * @param value
- * The value to coalesce with the pending data using a logical OR or an ADD
- * as specified by the dispatch source type. A value of zero has no effect
- * and will not result in the submission of the event handler block.
- */
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW
-void
-dispatch_source_merge_data(dispatch_source_t source, uintptr_t value);
-
-/*!
- * @function dispatch_source_set_timer
- *
- * @abstract
- * Sets a start time, interval, and leeway value for a timer source.
- *
- * @discussion
- * Once this function returns, any pending source data accumulated for the
- * previous timer values has been cleared; the next fire of the timer will
- * occur at 'start', and every 'interval' nanoseconds thereafter until the
- * timer source is canceled.
- *
- * Any fire of the timer may be delayed by the system in order to improve power
- * consumption and system performance. The upper limit to the allowable delay
- * may be configured with the 'leeway' argument, the lower limit is under the
- * control of the system.
- *
- * For the initial timer fire at 'start', the upper limit to the allowable
- * delay is set to 'leeway' nanoseconds. For the subsequent timer fires at
- * 'start' + N * 'interval', the upper limit is MIN('leeway','interval'/2).
- *
- * The lower limit to the allowable delay may vary with process state such as
- * visibility of application UI. If the specified timer source was created with
- * a mask of DISPATCH_TIMER_STRICT, the system will make a best effort to
- * strictly observe the provided 'leeway' value even if it is smaller than the
- * current lower limit. Note that a minimal amount of delay is to be expected
- * even if this flag is specified.
- *
- * The 'start' argument also determines which clock will be used for the timer:
- * If 'start' is DISPATCH_TIME_NOW or was created with dispatch_time(3), the
- * timer is based on up time (which is obtained from mach_absolute_time() on
- * Apple platforms). If 'start' was created with dispatch_walltime(3), the
- * timer is based on gettimeofday(3).
- *
- * Calling this function has no effect if the timer source has already been
- * canceled.
- *
- * @param start
- * The start time of the timer. See dispatch_time() and dispatch_walltime()
- * for more information.
- *
- * @param interval
- * The nanosecond interval for the timer. Use DISPATCH_TIME_FOREVER for a
- * one-shot timer.
- *
- * @param leeway
- * The nanosecond leeway for the timer.
- */
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW
-void
-dispatch_source_set_timer(dispatch_source_t source,
-	dispatch_time_t start,
-	uint64_t interval,
-	uint64_t leeway);
-
-/*!
- * @function dispatch_source_set_registration_handler
- *
- * @abstract
- * Sets the registration handler block for the given dispatch source.
- *
- * @discussion
- * The registration handler (if specified) will be submitted to the source's
- * target queue once the corresponding kevent() has been registered with the
- * system, following the initial dispatch_resume() of the source.
- *
- * If a source is already registered when the registration handler is set, the
- * registration handler will be invoked immediately.
- *
- * @param source
- * The dispatch source to modify.
- * The result of passing NULL in this parameter is undefined.
- *
- * @param handler
- * The registration handler block to submit to the source's target queue.
- */
-#ifdef __BLOCKS__
-API_AVAILABLE(macos(10.7), ios(4.3))
-DISPATCH_EXPORT DISPATCH_NONNULL1 DISPATCH_NOTHROW
-void
-dispatch_source_set_registration_handler(dispatch_source_t source,
-	dispatch_block_t _Nullable handler);
-#endif /* __BLOCKS__ */
-
-/*!
- * @function dispatch_source_set_registration_handler_f
- *
- * @abstract
- * Sets the registration handler function for the given dispatch source.
- *
- * @discussion
- * See dispatch_source_set_registration_handler() for more details.
- *
- * @param source
- * The dispatch source to modify.
- * The result of passing NULL in this parameter is undefined.
- *
- * @param handler
- * The registration handler function to submit to the source's target queue.
- * The context parameter passed to the registration handler function is the
- * current context of the dispatch source at the time the handler call is made.
- */
-API_AVAILABLE(macos(10.7), ios(4.3))
-DISPATCH_EXPORT DISPATCH_NONNULL1 DISPATCH_NOTHROW
-void
-dispatch_source_set_registration_handler_f(dispatch_source_t source,
-	dispatch_function_t _Nullable handler);
-
-__END_DECLS
-
-DISPATCH_ASSUME_NONNULL_END
-
-#endif
--- a/Telegram/ThirdParty/dispatch/dispatch/time.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/dispatch/time.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,135 +0,0 @@
-/*
- * Copyright (c) 2008-2011 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#ifndef __DISPATCH_TIME__
-#define __DISPATCH_TIME__
-
-#ifndef __DISPATCH_INDIRECT__
-#error "Please #include <dispatch/dispatch.h> instead of this file directly."
-#include <dispatch/base.h> // for HeaderDoc
-#endif
-
-#include <stdint.h>
-
-// <rdar://problem/6368156&7563559>
-#if TARGET_OS_MAC
-#include <mach/clock_types.h>
-#endif
-
-DISPATCH_ASSUME_NONNULL_BEGIN
-
-#ifdef NSEC_PER_SEC
-#undef NSEC_PER_SEC
-#endif
-#ifdef USEC_PER_SEC
-#undef USEC_PER_SEC
-#endif
-#ifdef NSEC_PER_USEC
-#undef NSEC_PER_USEC
-#endif
-#ifdef NSEC_PER_MSEC
-#undef NSEC_PER_MSEC
-#endif
-#define NSEC_PER_SEC 1000000000ull
-#define NSEC_PER_MSEC 1000000ull
-#define USEC_PER_SEC 1000000ull
-#define NSEC_PER_USEC 1000ull
-
-__BEGIN_DECLS
-
-struct timespec;
-
-/*!
- * @typedef dispatch_time_t
- *
- * @abstract
- * A somewhat abstract representation of time; where zero means "now" and
- * DISPATCH_TIME_FOREVER means "infinity" and every value in between is an
- * opaque encoding.
- */
-typedef uint64_t dispatch_time_t;
-
-enum {
-	DISPATCH_WALLTIME_NOW DISPATCH_ENUM_API_AVAILABLE(macos(10.14), ios(12.0), tvos(12.0), watchos(5.0))	= ~1ull,
-};
-
-#define DISPATCH_TIME_NOW (0ull)
-#define DISPATCH_TIME_FOREVER (~0ull)
-
-/*!
- * @function dispatch_time
- *
- * @abstract
- * Create a dispatch_time_t relative to the current value of the default or
- * wall time clock, or modify an existing dispatch_time_t.
- *
- * @discussion
- * On Apple platforms, the default clock is based on mach_absolute_time().
- *
- * @param when
- * An optional dispatch_time_t to add nanoseconds to. If DISPATCH_TIME_NOW is
- * passed, then dispatch_time() will use the default clock (which is based on
- * mach_absolute_time() on Apple platforms). If DISPATCH_WALLTIME_NOW is used,
- * dispatch_time() will use the value returned by gettimeofday(3).
- * dispatch_time(DISPATCH_WALLTIME_NOW, delta) is equivalent to
- * dispatch_walltime(NULL, delta).
- *
- * @param delta
- * Nanoseconds to add.
- *
- * @result
- * A new dispatch_time_t.
- */
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_EXPORT DISPATCH_WARN_RESULT DISPATCH_NOTHROW
-dispatch_time_t
-dispatch_time(dispatch_time_t when, int64_t delta);
-
-/*!
- * @function dispatch_walltime
- *
- * @abstract
- * Create a dispatch_time_t using the wall clock.
- *
- * @discussion
- * On Mac OS X the wall clock is based on gettimeofday(3).
- *
- * @param when
- * A struct timespec to add time to. If NULL is passed, then
- * dispatch_walltime() will use the result of gettimeofday(3).
- * dispatch_walltime(NULL, delta) returns the same value as
- * dispatch_time(DISPATCH_WALLTIME_NOW, delta).
- *
- * @param delta
- * Nanoseconds to add.
- *
- * @result
- * A new dispatch_time_t.
- */
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_EXPORT DISPATCH_WARN_RESULT DISPATCH_NOTHROW
-dispatch_time_t
-dispatch_walltime(const struct timespec *_Nullable when, int64_t delta);
-
-__END_DECLS
-
-DISPATCH_ASSUME_NONNULL_END
-
-#endif
--- a/Telegram/ThirdParty/dispatch/.gitignore	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/.gitignore	1970-01-01 00:00:00.000000000 -0000
@@ -1,33 +0,0 @@
-# Mac OS X filesystem metadata
-.DS_Store
-
-# Xcode user artifacts
-xcuserdata
-project.xcworkspace
-
-# python generated files
-*.pyc
-
-# build files generated by the configure script
-*.ninja
-.ninja_deps
-.ninja_log
-
-Build
-.build
-
-# build files generated by autotools
-Makefile
-Makefile.in
-config.log
-configure
-aclocal.m4
-autom4te.cache
-config.log
-config.status
-config
-configure
-libtool
-.dirstamp
-/dispatch/module.modulemap
-/private/module.modulemap
--- a/Telegram/ThirdParty/dispatch/INSTALL.md	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/INSTALL.md	1970-01-01 00:00:00.000000000 -0000
@@ -1,170 +0,0 @@
-## Grand Central Dispatch (GCD)
-
-GCD is a concurrent programming framework first shipped with Mac OS X Snow
-Leopard.  This package is an open source bundling of libdispatch, the core
-user space library implementing GCD.  At the time of writing, support for
-the BSD kqueue API, and specifically extensions introduced in Mac OS X Snow
-Leopard and FreeBSD 9-CURRENT, are required to use libdispatch.  Linux is
-supported, but requires specific packages to be installed (see Linux
-section at the end of the file). Other systems are currently unsupported.
-
-### Configuring and installing libdispatch (general comments)
-
-GCD is built using autoconf, automake, and libtool, and has a number of
-compile-time configuration options that should be reviewed before starting.
-An uncustomized install of the C-API to libdispatch requires:
-
-	sh autogen.sh
-	./configure
-	make
-	make install
-
-libdispatch can be optionally built to include a Swift API. This requires a
-Swift toolchain to compile the Swift code in libdispatch and can be done
-in two possible scenarios.
-
-If you are building your own Swift toolchain from source, then you should build
-libdispatch simply by giving additional arguments to swift/utils/build-script:
-
-    ./swift/utils/build-script --libdispatch -- --install-libdispatch
-
-To build libdispatch using a pre-built Swift toolchain and install libdispatch
-into that toolchain (to allow that toolchain to compile Swift code containing
-"import Dispatch") requires:
-
-    sh autogen.sh
-	./configure --with-swift-toolchain=<PATH_TO_SWIFT_TOOLCHAIN> --prefix=<PATH_TO_SWIFT_TOOLCHAIN>
-	make
-	make install
-
-Note that once libdispatch is installed into a Swift toolchain, that
-toolchain cannot be used to compile libdispatch again (you must 'make uninstall'
-libdispatch from the toolchain before using it to rebuild libdispatch).
-
-You can also use the build-toolchain script to create a toolchain
-that includes libdispatch on Linux:
-
-1. Add libdispatch and install-libdispatch lines to ./swift/utils/build-presets.ini under `[preset: buildbot_linux]` section, as following:
-
-    ```
-    [preset: buildbot_linux]
-    mixin-preset=mixin_linux_installation
-    build-subdir=buildbot_linux
-    lldb
-    release
-    test
-    validation-test
-    long-test
-    libdispatch
-    foundation
-    lit-args=-v
-    dash-dash
-
-    install-libdispatch
-    install-foundation
-    reconfigure
-    ```
-
-2. Run:
-
-    ```
-    ./swift/utils/build-toolchain local.swift
-    ```
-
-Note that adding libdispatch in build-presets.ini is for Linux only as Swift on macOS platforms uses the system installed libdispatch, so its not required.
-
-### Building and installing on OS X
-
-The following configure options may be of general interest:
-
-`--with-apple-libpthread-source`
-
-Specify the path to Apple's libpthread package, so that appropriate headers
-	can be found and used.
-
-`--with-apple-libplatform-source`
-
-Specify the path to Apple's libplatform package, so that appropriate headers
-	can be found and used.
-
-`--with-apple-xnu-source`
-
-Specify the path to Apple's XNU package, so that appropriate headers can be
-	found and used.
-
-`--with-blocks-runtime`
-
-On systems where -fblocks is supported, specify an additional library path in which libBlocksRuntime can be found. This is not required on OS X, where the Blocks runtime is included in libSystem, but is required on FreeBSD.
-
-The following options are likely to only be useful when building libdispatch on
-OS X as a replacement for /usr/lib/system/libdispatch.dylib:
-
-`--disable-libdispatch-init-constructor`
-
-Do not tag libdispatch's init routine as __constructor, in which case it must be run manually before libdispatch routines can be called. This is the default when building on OS X. For /usr/lib/system/libdispatch.dylib the init routine is called automatically during process start.
-
-`--enable-apple-tsd-optimizations`
-
-Use a non-portable allocation scheme for pthread per-thread data (TSD) keys when building libdispatch for /usr/lib/system on OS X.  This should not be used on other OS's, or on OS X when building a stand-alone library.
-
-#### Typical configuration commands
-
-The following command lines create the configuration required to build
-libdispatch for /usr/lib/system on OS X El Capitan:
-
-	clangpath=$(dirname `xcrun --find clang`)
-	sudo mkdir -p "$clangpath/../local/lib/clang/enable_objc_gc"
-	LIBTOOLIZE=glibtoolize sh autogen.sh
-	cflags='-arch x86_64 -arch i386 -g -Os'
-	./configure CFLAGS="$cflags" OBJCFLAGS="$cflags" CXXFLAGS="$cflags" \
-		--prefix=/usr --libdir=/usr/lib/system --disable-static \
-		--enable-apple-tsd-optimizations \
-		--with-apple-libpthread-source=/path/to/10.11.0/libpthread-137.1.1 \
-		--with-apple-libplatform-source=/path/to/10.11.0/libplatform-73.1.1 \
-		--with-apple-xnu-source=/path/to/10.11.0/xnu-3247.1.106 \
-	make check
-
-### Building and installing for FreeBSD
-
-Typical configuration line for FreeBSD 8.x and 9.x to build libdispatch with
-clang and blocks support:
-
-    ```
-    cmake -G Ninja -DCMAKE_C_COMPILER=clang -DCMAKE_CXX_COMPILER=clang++ -DBlocksRuntime_INCLUDE_DIR=/usr/local/include -DBlocksRuntime_LIBRARIES=/usr/local/lib/libBlocksRuntime.so <path-to-source>
-    ninja
-    ninja test
-    ```
-
-### Building for android
-
-Note that this assumes that you are building on Linux.  It requires that you
-have the android NDK available.  It has been tested against API Level 21.
-
-    ```
-    cmake -G Ninja -DCMAKE_C_COMPILER=clang -DCMAKE_CXX_COMPILER=clang++ -DCMAKE_SYSTEM_NAME=Android -DCMAKE_SYSTEM_VERSION=21 -DCMAKE_ANDROID_NDK=<path to android NDK> <path-to-source>
-    ninja
-    ```
-
-### Building and installing for Linux
-
-Note that libdispatch development and testing is done only
-on Ubuntu; currently supported versions are 14.04, 15.10 and 16.04.
-
-1. The first thing to do is install required packages:
-
-    `sudo apt-get install cmake ninja-build clang systemtap-sdt-dev libbsd-dev linux-libc-dev`
-
-    Note: compiling libdispatch requires clang 3.8 or better and
-the gold linker. If the default clang on your Ubuntu version is
-too old, see http://apt.llvm.org/ to install a newer version.
-On older Ubuntu releases, you may need to install binutils-gold
-to get the gold linker.
-
-2. Build
-
-    ```
-    cmake -G Ninja -DCMAKE_C_COMPILER=clang -DCMAKE_CXX_COMPILER=clang++ <path-to-source>
-    ninja
-    ninja install
-    ```
-
--- a/Telegram/ThirdParty/dispatch/libdispatch.xcodeproj/project.pbxproj	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/libdispatch.xcodeproj/project.pbxproj	1970-01-01 00:00:00.000000000 -0000
@@ -1,3014 +0,0 @@
-// !$*UTF8*$!
-{
-	archiveVersion = 1;
-	classes = {
-	};
-	objectVersion = 46;
-	objects = {
-
-/* Begin PBXAggregateTarget section */
-		3F3C9326128E637B0042B1F7 /* libdispatch_Sim */ = {
-			isa = PBXAggregateTarget;
-			buildConfigurationList = 3F3C9356128E637B0042B1F7 /* Build configuration list for PBXAggregateTarget "libdispatch_Sim" */;
-			buildPhases = (
-			);
-			dependencies = (
-				E4128E4A13B94BCE00ABB2CB /* PBXTargetDependency */,
-			);
-			name = libdispatch_Sim;
-			productName = libdispatch_Sim;
-		};
-		4552540A19B1389700B88766 /* libdispatch_tests */ = {
-			isa = PBXAggregateTarget;
-			buildConfigurationList = 4552540B19B1389700B88766 /* Build configuration list for PBXAggregateTarget "libdispatch_tests" */;
-			buildPhases = (
-			);
-			dependencies = (
-				92F3FECF1BEC6F1000025962 /* PBXTargetDependency */,
-			);
-			name = libdispatch_tests;
-			productName = libdispatch_tests;
-		};
-		6E2ECAFD1C49C2FF00A30A32 /* libdispatch_kernel */ = {
-			isa = PBXAggregateTarget;
-			buildConfigurationList = 6E2ECAFE1C49C30000A30A32 /* Build configuration list for PBXAggregateTarget "libdispatch_kernel" */;
-			buildPhases = (
-			);
-			dependencies = (
-				6E2ECB021C49C31200A30A32 /* PBXTargetDependency */,
-			);
-			name = libdispatch_kernel;
-			productName = libdispatch_kernel;
-		};
-		6E43553E215B5D9D00C13177 /* libdispatch_introspection */ = {
-			isa = PBXAggregateTarget;
-			buildConfigurationList = 6E435541215B5D9D00C13177 /* Build configuration list for PBXAggregateTarget "libdispatch_introspection" */;
-			buildPhases = (
-			);
-			dependencies = (
-				6EE5083B21701B9100833569 /* PBXTargetDependency */,
-			);
-			name = libdispatch_introspection;
-			productName = libdispatch_introspection;
-		};
-		6EA833C22162D6380045EFDC /* libdispatch_introspection_Sim */ = {
-			isa = PBXAggregateTarget;
-			buildConfigurationList = 6EA833C32162D6380045EFDC /* Build configuration list for PBXAggregateTarget "libdispatch_introspection_Sim" */;
-			buildPhases = (
-			);
-			dependencies = (
-				6EE5083D21701B9600833569 /* PBXTargetDependency */,
-			);
-			name = libdispatch_introspection_Sim;
-			productName = libdispatch_introspection_Sim;
-		};
-		92CBD7201BED924F006E0892 /* libdispatch_tests_legacy */ = {
-			isa = PBXAggregateTarget;
-			buildConfigurationList = 92CBD7231BED924F006E0892 /* Build configuration list for PBXAggregateTarget "libdispatch_tests_legacy" */;
-			buildPhases = (
-			);
-			dependencies = (
-				92CBD75A1BED926C006E0892 /* PBXTargetDependency */,
-			);
-			name = libdispatch_tests_legacy;
-			productName = libdispatch_tests;
-		};
-		9BEBA56F20127D3300E6FD0D /* libdispatch_tools_Sim */ = {
-			isa = PBXAggregateTarget;
-			buildConfigurationList = 9BEBA57620127D3300E6FD0D /* Build configuration list for PBXAggregateTarget "libdispatch_tools_Sim" */;
-			buildPhases = (
-			);
-			dependencies = (
-				9BEBA57820127D4400E6FD0D /* PBXTargetDependency */,
-			);
-			name = libdispatch_tools_Sim;
-			productName = libdispatch_tools_Sim;
-		};
-		C927F35A10FD7F0600C5AB8B /* libdispatch_tools */ = {
-			isa = PBXAggregateTarget;
-			buildConfigurationList = C927F35E10FD7F0B00C5AB8B /* Build configuration list for PBXAggregateTarget "libdispatch_tools" */;
-			buildPhases = (
-			);
-			dependencies = (
-				9B2A11A32032494E0060E7D4 /* PBXTargetDependency */,
-				C927F36910FD7F1A00C5AB8B /* PBXTargetDependency */,
-			);
-			name = libdispatch_tools;
-			productName = ddt;
-		};
-/* End PBXAggregateTarget section */
-
-/* Begin PBXBuildFile section */
-		2BBF5A60154B64D8002B20F9 /* allocator_internal.h in Headers */ = {isa = PBXBuildFile; fileRef = 2BBF5A5F154B64D8002B20F9 /* allocator_internal.h */; };
-		2BBF5A61154B64D8002B20F9 /* allocator_internal.h in Headers */ = {isa = PBXBuildFile; fileRef = 2BBF5A5F154B64D8002B20F9 /* allocator_internal.h */; };
-		2BBF5A63154B64F5002B20F9 /* allocator.c in Sources */ = {isa = PBXBuildFile; fileRef = 2BBF5A62154B64F5002B20F9 /* allocator.c */; };
-		2BBF5A64154B64F5002B20F9 /* allocator.c in Sources */ = {isa = PBXBuildFile; fileRef = 2BBF5A62154B64F5002B20F9 /* allocator.c */; };
-		2BBF5A66154B64F5002B20F9 /* allocator.c in Sources */ = {isa = PBXBuildFile; fileRef = 2BBF5A62154B64F5002B20F9 /* allocator.c */; };
-		2BE17C6418EA305E002CA4E8 /* layout_private.h in Headers */ = {isa = PBXBuildFile; fileRef = 2BE17C6318EA305E002CA4E8 /* layout_private.h */; settings = {ATTRIBUTES = (Private, ); }; };
-		2BE17C6518EA305E002CA4E8 /* layout_private.h in Headers */ = {isa = PBXBuildFile; fileRef = 2BE17C6318EA305E002CA4E8 /* layout_private.h */; settings = {ATTRIBUTES = (Private, ); }; };
-		5A0095A210F274B0000E2A31 /* io_internal.h in Headers */ = {isa = PBXBuildFile; fileRef = 5A0095A110F274B0000E2A31 /* io_internal.h */; };
-		5A27262610F26F1900751FBC /* io.c in Sources */ = {isa = PBXBuildFile; fileRef = 5A27262510F26F1900751FBC /* io.c */; };
-		5A5D13AC0F6B280500197CC3 /* semaphore_internal.h in Headers */ = {isa = PBXBuildFile; fileRef = 5A5D13AB0F6B280500197CC3 /* semaphore_internal.h */; };
-		5AAB45C010D30B79004407EA /* data.c in Sources */ = {isa = PBXBuildFile; fileRef = 5AAB45BF10D30B79004407EA /* data.c */; };
-		5AAB45C410D30CC7004407EA /* io.h in Headers */ = {isa = PBXBuildFile; fileRef = 5AAB45C310D30CC7004407EA /* io.h */; settings = {ATTRIBUTES = (Public, ); }; };
-		5AAB45C610D30D0C004407EA /* data.h in Headers */ = {isa = PBXBuildFile; fileRef = 5AAB45C510D30D0C004407EA /* data.h */; settings = {ATTRIBUTES = (Public, ); }; };
-		6E040C731C499C6500411A2E /* firehose_buffer.c in Sources */ = {isa = PBXBuildFile; fileRef = 72DEAA971AE181D300289540 /* firehose_buffer.c */; };
-		6E040C751C499CE600411A2E /* firehose_buffer_private.h in Headers */ = {isa = PBXBuildFile; fileRef = 6EDF10831BBB487E007F14BF /* firehose_buffer_private.h */; settings = {ATTRIBUTES = (Private, ); }; };
-		6E21F2E81BBB23FA0000C6A5 /* firehose_server_internal.h in Headers */ = {isa = PBXBuildFile; fileRef = 6E21F2E41BBB23F00000C6A5 /* firehose_server_internal.h */; };
-		6E21F2E91BBB240E0000C6A5 /* firehose_server.c in Sources */ = {isa = PBXBuildFile; fileRef = 6E21F2E51BBB23F00000C6A5 /* firehose_server.c */; };
-		6E393F981BD60F8D005A551E /* firehose_internal.h in Headers */ = {isa = PBXBuildFile; fileRef = 6EF0B26A1BA8C4AE007FA4F6 /* firehose_internal.h */; };
-		6E4BACBD1D48A41500B562AE /* mach.c in Sources */ = {isa = PBXBuildFile; fileRef = 6E4BACBC1D48A41500B562AE /* mach.c */; };
-		6E4BACC21D48A42000B562AE /* mach.c in Sources */ = {isa = PBXBuildFile; fileRef = 6E4BACBC1D48A41500B562AE /* mach.c */; };
-		6E4BACC31D48A42100B562AE /* mach.c in Sources */ = {isa = PBXBuildFile; fileRef = 6E4BACBC1D48A41500B562AE /* mach.c */; };
-		6E4BACC51D48A42200B562AE /* mach.c in Sources */ = {isa = PBXBuildFile; fileRef = 6E4BACBC1D48A41500B562AE /* mach.c */; };
-		6E4BACC71D48A42300B562AE /* mach.c in Sources */ = {isa = PBXBuildFile; fileRef = 6E4BACBC1D48A41500B562AE /* mach.c */; };
-		6E4BACC81D48A42400B562AE /* mach.c in Sources */ = {isa = PBXBuildFile; fileRef = 6E4BACBC1D48A41500B562AE /* mach.c */; };
-		6E4BACCA1D48A89500B562AE /* mach_internal.h in Headers */ = {isa = PBXBuildFile; fileRef = 6E4BACC91D48A89500B562AE /* mach_internal.h */; };
-		6E4BACF51D49A04600B562AE /* event_epoll.c in Sources */ = {isa = PBXBuildFile; fileRef = 6EA7937D1D456D1300929B1B /* event_epoll.c */; };
-		6E4BACF61D49A04700B562AE /* event_epoll.c in Sources */ = {isa = PBXBuildFile; fileRef = 6EA7937D1D456D1300929B1B /* event_epoll.c */; };
-		6E4BACF71D49A04700B562AE /* event_epoll.c in Sources */ = {isa = PBXBuildFile; fileRef = 6EA7937D1D456D1300929B1B /* event_epoll.c */; };
-		6E4BACF91D49A04800B562AE /* event_epoll.c in Sources */ = {isa = PBXBuildFile; fileRef = 6EA7937D1D456D1300929B1B /* event_epoll.c */; };
-		6E4BACFB1D49A04A00B562AE /* event_epoll.c in Sources */ = {isa = PBXBuildFile; fileRef = 6EA7937D1D456D1300929B1B /* event_epoll.c */; };
-		6E4BACFC1D49A04A00B562AE /* event_epoll.c in Sources */ = {isa = PBXBuildFile; fileRef = 6EA7937D1D456D1300929B1B /* event_epoll.c */; };
-		6E5662E11F8C2E3E00BC2474 /* workqueue_internal.h in Headers */ = {isa = PBXBuildFile; fileRef = 6E5662DC1F8C2E3E00BC2474 /* workqueue_internal.h */; };
-		6E5662E21F8C2E4F00BC2474 /* workqueue_internal.h in Headers */ = {isa = PBXBuildFile; fileRef = 6E5662DC1F8C2E3E00BC2474 /* workqueue_internal.h */; };
-		6E5662E31F8C2E5100BC2474 /* workqueue_internal.h in Headers */ = {isa = PBXBuildFile; fileRef = 6E5662DC1F8C2E3E00BC2474 /* workqueue_internal.h */; };
-		6E5ACCBA1D3C4D0B007DA2B4 /* event_internal.h in Headers */ = {isa = PBXBuildFile; fileRef = 6E5ACCB91D3C4D0B007DA2B4 /* event_internal.h */; };
-		6E5ACCBB1D3C4D0E007DA2B4 /* event_internal.h in Headers */ = {isa = PBXBuildFile; fileRef = 6E5ACCB91D3C4D0B007DA2B4 /* event_internal.h */; };
-		6E5ACCBC1D3C4D0F007DA2B4 /* event_internal.h in Headers */ = {isa = PBXBuildFile; fileRef = 6E5ACCB91D3C4D0B007DA2B4 /* event_internal.h */; };
-		6E7018211F4EB51B0077C1DC /* workloop_private.h in Headers */ = {isa = PBXBuildFile; fileRef = 6E70181C1F4EB51B0077C1DC /* workloop_private.h */; settings = {ATTRIBUTES = (Private, ); }; };
-		6E7018221F4EB5220077C1DC /* workloop_private.h in Headers */ = {isa = PBXBuildFile; fileRef = 6E70181C1F4EB51B0077C1DC /* workloop_private.h */; settings = {ATTRIBUTES = (Private, ); }; };
-		6E90269C1BB9BD50004DC3AD /* firehose.defs in Sources */ = {isa = PBXBuildFile; fileRef = 72DEAA9B1AE1B0BD00289540 /* firehose.defs */; settings = {ATTRIBUTES = (Server, ); }; };
-		6E9955581C3AF7710071D40C /* venture_private.h in Headers */ = {isa = PBXBuildFile; fileRef = 6E9955571C3AF7710071D40C /* venture_private.h */; };
-		6E99558A1C3AF7900071D40C /* venture_private.h in Headers */ = {isa = PBXBuildFile; fileRef = 6E9955571C3AF7710071D40C /* venture_private.h */; };
-		6E9955CF1C3B218E0071D40C /* venture.c in Sources */ = {isa = PBXBuildFile; fileRef = 6E9955CE1C3B218E0071D40C /* venture.c */; };
-		6E9956021C3B21990071D40C /* venture.c in Sources */ = {isa = PBXBuildFile; fileRef = 6E9955CE1C3B218E0071D40C /* venture.c */; };
-		6E9956041C3B219B0071D40C /* venture.c in Sources */ = {isa = PBXBuildFile; fileRef = 6E9955CE1C3B218E0071D40C /* venture.c */; };
-		6E9956051C3B219B0071D40C /* venture.c in Sources */ = {isa = PBXBuildFile; fileRef = 6E9955CE1C3B218E0071D40C /* venture.c */; };
-		6E9956071C3B21AA0071D40C /* venture_internal.h in Headers */ = {isa = PBXBuildFile; fileRef = 6E9956061C3B21AA0071D40C /* venture_internal.h */; };
-		6E9956081C3B21B30071D40C /* venture_internal.h in Headers */ = {isa = PBXBuildFile; fileRef = 6E9956061C3B21AA0071D40C /* venture_internal.h */; };
-		6E9956091C3B21B40071D40C /* venture_internal.h in Headers */ = {isa = PBXBuildFile; fileRef = 6E9956061C3B21AA0071D40C /* venture_internal.h */; };
-		6E9B6B5F1BB4F3C8009E324D /* firehose_buffer_internal.h in Headers */ = {isa = PBXBuildFile; fileRef = 6E9B6B201BB4CC73009E324D /* firehose_buffer_internal.h */; };
-		6E9C6CA720F9848100EA81C0 /* yield.c in Sources */ = {isa = PBXBuildFile; fileRef = 6E9C6CA220F9848000EA81C0 /* yield.c */; };
-		6E9C6CA820F9848C00EA81C0 /* yield.c in Sources */ = {isa = PBXBuildFile; fileRef = 6E9C6CA220F9848000EA81C0 /* yield.c */; };
-		6E9C6CA920F9848D00EA81C0 /* yield.c in Sources */ = {isa = PBXBuildFile; fileRef = 6E9C6CA220F9848000EA81C0 /* yield.c */; };
-		6E9C6CAA20F9848D00EA81C0 /* yield.c in Sources */ = {isa = PBXBuildFile; fileRef = 6E9C6CA220F9848000EA81C0 /* yield.c */; };
-		6E9C6CAB20F9848E00EA81C0 /* yield.c in Sources */ = {isa = PBXBuildFile; fileRef = 6E9C6CA220F9848000EA81C0 /* yield.c */; };
-		6E9C6CAC20F9848E00EA81C0 /* yield.c in Sources */ = {isa = PBXBuildFile; fileRef = 6E9C6CA220F9848000EA81C0 /* yield.c */; };
-		6E9C6CAD20F9848F00EA81C0 /* yield.c in Sources */ = {isa = PBXBuildFile; fileRef = 6E9C6CA220F9848000EA81C0 /* yield.c */; };
-		6EA283D71CAB93920041B2E0 /* libdispatch.codes in Copy Trace Definitions */ = {isa = PBXBuildFile; fileRef = 6EA283D01CAB93270041B2E0 /* libdispatch.codes */; };
-		6EA793891D458A5800929B1B /* event_config.h in Headers */ = {isa = PBXBuildFile; fileRef = 6EA793881D458A5800929B1B /* event_config.h */; };
-		6EA7938E1D458A5C00929B1B /* event_config.h in Headers */ = {isa = PBXBuildFile; fileRef = 6EA793881D458A5800929B1B /* event_config.h */; };
-		6EA7938F1D458A5E00929B1B /* event_config.h in Headers */ = {isa = PBXBuildFile; fileRef = 6EA793881D458A5800929B1B /* event_config.h */; };
-		6EA962971D48622600759D53 /* event.c in Sources */ = {isa = PBXBuildFile; fileRef = 6E5ACCBD1D3C6719007DA2B4 /* event.c */; };
-		6EA962981D48622700759D53 /* event.c in Sources */ = {isa = PBXBuildFile; fileRef = 6E5ACCBD1D3C6719007DA2B4 /* event.c */; };
-		6EA962991D48622800759D53 /* event.c in Sources */ = {isa = PBXBuildFile; fileRef = 6E5ACCBD1D3C6719007DA2B4 /* event.c */; };
-		6EA9629B1D48622900759D53 /* event.c in Sources */ = {isa = PBXBuildFile; fileRef = 6E5ACCBD1D3C6719007DA2B4 /* event.c */; };
-		6EA9629D1D48622B00759D53 /* event.c in Sources */ = {isa = PBXBuildFile; fileRef = 6E5ACCBD1D3C6719007DA2B4 /* event.c */; };
-		6EA9629E1D48622C00759D53 /* event.c in Sources */ = {isa = PBXBuildFile; fileRef = 6E5ACCBD1D3C6719007DA2B4 /* event.c */; };
-		6EA9629F1D48625000759D53 /* event_kevent.c in Sources */ = {isa = PBXBuildFile; fileRef = 6E5ACCB01D3C4CFB007DA2B4 /* event_kevent.c */; };
-		6EA962A01D48625100759D53 /* event_kevent.c in Sources */ = {isa = PBXBuildFile; fileRef = 6E5ACCB01D3C4CFB007DA2B4 /* event_kevent.c */; };
-		6EA962A11D48625100759D53 /* event_kevent.c in Sources */ = {isa = PBXBuildFile; fileRef = 6E5ACCB01D3C4CFB007DA2B4 /* event_kevent.c */; };
-		6EA962A31D48625300759D53 /* event_kevent.c in Sources */ = {isa = PBXBuildFile; fileRef = 6E5ACCB01D3C4CFB007DA2B4 /* event_kevent.c */; };
-		6EA962A51D48625400759D53 /* event_kevent.c in Sources */ = {isa = PBXBuildFile; fileRef = 6E5ACCB01D3C4CFB007DA2B4 /* event_kevent.c */; };
-		6EA962A61D48625500759D53 /* event_kevent.c in Sources */ = {isa = PBXBuildFile; fileRef = 6E5ACCB01D3C4CFB007DA2B4 /* event_kevent.c */; };
-		6EB60D2C1BBB197B0092FA94 /* firehose_inline_internal.h in Headers */ = {isa = PBXBuildFile; fileRef = 6EB60D291BBB19640092FA94 /* firehose_inline_internal.h */; };
-		6EBEC7E51BBDD30C009B1596 /* firehose.defs in Sources */ = {isa = PBXBuildFile; fileRef = 72DEAA9B1AE1B0BD00289540 /* firehose.defs */; };
-		6EBEC7E81BBDD324009B1596 /* firehose_reply.defs in Sources */ = {isa = PBXBuildFile; fileRef = 72406A031AF95DF800DF4E2B /* firehose_reply.defs */; settings = {ATTRIBUTES = (Server, ); }; };
-		6ED64B401BBD898300C35F4D /* firehose_buffer.c in Sources */ = {isa = PBXBuildFile; fileRef = 72DEAA971AE181D300289540 /* firehose_buffer.c */; };
-		6ED64B411BBD898400C35F4D /* firehose_buffer.c in Sources */ = {isa = PBXBuildFile; fileRef = 72DEAA971AE181D300289540 /* firehose_buffer.c */; };
-		6ED64B431BBD898600C35F4D /* firehose_buffer.c in Sources */ = {isa = PBXBuildFile; fileRef = 72DEAA971AE181D300289540 /* firehose_buffer.c */; };
-		6ED64B441BBD898700C35F4D /* firehose_buffer.c in Sources */ = {isa = PBXBuildFile; fileRef = 72DEAA971AE181D300289540 /* firehose_buffer.c */; };
-		6ED64B461BBD89AF00C35F4D /* firehose.defs in Sources */ = {isa = PBXBuildFile; fileRef = 72DEAA9B1AE1B0BD00289540 /* firehose.defs */; };
-		6ED64B471BBD89AF00C35F4D /* firehose.defs in Sources */ = {isa = PBXBuildFile; fileRef = 72DEAA9B1AE1B0BD00289540 /* firehose.defs */; };
-		6ED64B481BBD89B100C35F4D /* firehose.defs in Sources */ = {isa = PBXBuildFile; fileRef = 72DEAA9B1AE1B0BD00289540 /* firehose.defs */; };
-		6ED64B491BBD89BC00C35F4D /* firehose_reply.defs in Sources */ = {isa = PBXBuildFile; fileRef = 72406A031AF95DF800DF4E2B /* firehose_reply.defs */; settings = {ATTRIBUTES = (Server, ); }; };
-		6ED64B4A1BBD89BD00C35F4D /* firehose_reply.defs in Sources */ = {isa = PBXBuildFile; fileRef = 72406A031AF95DF800DF4E2B /* firehose_reply.defs */; settings = {ATTRIBUTES = (Server, ); }; };
-		6ED64B4B1BBD89BE00C35F4D /* firehose_reply.defs in Sources */ = {isa = PBXBuildFile; fileRef = 72406A031AF95DF800DF4E2B /* firehose_reply.defs */; settings = {ATTRIBUTES = (Server, ); }; };
-		6ED64B4F1BBD8A1400C35F4D /* firehose_internal.h in Headers */ = {isa = PBXBuildFile; fileRef = 6EF0B26A1BA8C4AE007FA4F6 /* firehose_internal.h */; };
-		6ED64B501BBD8A1400C35F4D /* firehose_internal.h in Headers */ = {isa = PBXBuildFile; fileRef = 6EF0B26A1BA8C4AE007FA4F6 /* firehose_internal.h */; };
-		6ED64B511BBD8A2100C35F4D /* firehose_buffer_internal.h in Headers */ = {isa = PBXBuildFile; fileRef = 6E9B6B201BB4CC73009E324D /* firehose_buffer_internal.h */; };
-		6ED64B521BBD8A2100C35F4D /* firehose_buffer_internal.h in Headers */ = {isa = PBXBuildFile; fileRef = 6E9B6B201BB4CC73009E324D /* firehose_buffer_internal.h */; };
-		6ED64B531BBD8A2300C35F4D /* firehose_buffer_internal.h in Headers */ = {isa = PBXBuildFile; fileRef = 6E9B6B201BB4CC73009E324D /* firehose_buffer_internal.h */; };
-		6ED64B571BBD8A3B00C35F4D /* firehose_inline_internal.h in Headers */ = {isa = PBXBuildFile; fileRef = 6EB60D291BBB19640092FA94 /* firehose_inline_internal.h */; };
-		6ED64B581BBD8A3E00C35F4D /* firehose_inline_internal.h in Headers */ = {isa = PBXBuildFile; fileRef = 6EB60D291BBB19640092FA94 /* firehose_inline_internal.h */; };
-		6ED64B591BBD8A3F00C35F4D /* firehose_inline_internal.h in Headers */ = {isa = PBXBuildFile; fileRef = 6EB60D291BBB19640092FA94 /* firehose_inline_internal.h */; };
-		6EDF10B81BBB488A007F14BF /* firehose_buffer_private.h in Headers */ = {isa = PBXBuildFile; fileRef = 6EDF10831BBB487E007F14BF /* firehose_buffer_private.h */; settings = {ATTRIBUTES = (Private, ); }; };
-		6EF0B26D1BA8C527007FA4F6 /* firehose_server_private.h in Headers */ = {isa = PBXBuildFile; fileRef = 72EA3FBA1AF41EA400BBA227 /* firehose_server_private.h */; settings = {ATTRIBUTES = (Private, ); }; };
-		6EF0B2711BA8C540007FA4F6 /* firehose_internal.h in Headers */ = {isa = PBXBuildFile; fileRef = 6EF0B26A1BA8C4AE007FA4F6 /* firehose_internal.h */; };
-		6EF0B2781BA8C56E007FA4F6 /* firehose_reply.defs in Sources */ = {isa = PBXBuildFile; fileRef = 72406A031AF95DF800DF4E2B /* firehose_reply.defs */; settings = {ATTRIBUTES = (Client, ); }; };
-		6EF0B27A1BA8C57D007FA4F6 /* firehose_server_object.m in Sources */ = {isa = PBXBuildFile; fileRef = 72DEAA9D1AE1BB7300289540 /* firehose_server_object.m */; };
-		6EF2CAA51C88998A001ABE83 /* lock.h in Headers */ = {isa = PBXBuildFile; fileRef = 6EF2CAA41C88998A001ABE83 /* lock.h */; };
-		6EF2CAAC1C8899D5001ABE83 /* lock.c in Sources */ = {isa = PBXBuildFile; fileRef = 6EF2CAAB1C8899D5001ABE83 /* lock.c */; };
-		6EF2CAAD1C8899E9001ABE83 /* lock.c in Sources */ = {isa = PBXBuildFile; fileRef = 6EF2CAAB1C8899D5001ABE83 /* lock.c */; };
-		6EF2CAAE1C8899EA001ABE83 /* lock.c in Sources */ = {isa = PBXBuildFile; fileRef = 6EF2CAAB1C8899D5001ABE83 /* lock.c */; };
-		6EF2CAB01C8899EB001ABE83 /* lock.c in Sources */ = {isa = PBXBuildFile; fileRef = 6EF2CAAB1C8899D5001ABE83 /* lock.c */; };
-		6EF2CAB21C8899EC001ABE83 /* lock.c in Sources */ = {isa = PBXBuildFile; fileRef = 6EF2CAAB1C8899D5001ABE83 /* lock.c */; };
-		6EF2CAB31C8899ED001ABE83 /* lock.c in Sources */ = {isa = PBXBuildFile; fileRef = 6EF2CAAB1C8899D5001ABE83 /* lock.c */; };
-		6EF2CAB41C889D65001ABE83 /* lock.h in Headers */ = {isa = PBXBuildFile; fileRef = 6EF2CAA41C88998A001ABE83 /* lock.h */; };
-		6EF2CAB51C889D67001ABE83 /* lock.h in Headers */ = {isa = PBXBuildFile; fileRef = 6EF2CAA41C88998A001ABE83 /* lock.h */; };
-		6EFBDA4B1D61A0D600282887 /* priority.h in Headers */ = {isa = PBXBuildFile; fileRef = 6EFBDA4A1D61A0D600282887 /* priority.h */; };
-		721F5C5D0F15520500FF03A6 /* semaphore.h in Headers */ = {isa = PBXBuildFile; fileRef = 721F5C5C0F15520500FF03A6 /* semaphore.h */; settings = {ATTRIBUTES = (Public, ); }; };
-		721F5CCF0F15553500FF03A6 /* semaphore.c in Sources */ = {isa = PBXBuildFile; fileRef = 721F5CCE0F15553500FF03A6 /* semaphore.c */; };
-		72CC94300ECCD8750031B751 /* base.h in Headers */ = {isa = PBXBuildFile; fileRef = 72CC942F0ECCD8750031B751 /* base.h */; settings = {ATTRIBUTES = (Public, ); }; };
-		96032E4B0F5CC8C700241C5F /* time.c in Sources */ = {isa = PBXBuildFile; fileRef = 96032E4A0F5CC8C700241C5F /* time.c */; };
-		96032E4D0F5CC8D100241C5F /* time.h in Headers */ = {isa = PBXBuildFile; fileRef = 96032E4C0F5CC8D100241C5F /* time.h */; settings = {ATTRIBUTES = (Public, ); }; };
-		961B99360F3E83980006BC96 /* benchmark.h in Headers */ = {isa = PBXBuildFile; fileRef = 961B99350F3E83980006BC96 /* benchmark.h */; settings = {ATTRIBUTES = (Private, ); }; };
-		961B99500F3E85C30006BC96 /* object.h in Headers */ = {isa = PBXBuildFile; fileRef = 961B994F0F3E85C30006BC96 /* object.h */; settings = {ATTRIBUTES = (Public, ); }; };
-		965CD6350F3E806200D4E28D /* benchmark.c in Sources */ = {isa = PBXBuildFile; fileRef = 965CD6340F3E806200D4E28D /* benchmark.c */; };
-		965ECC210F3EAB71004DDD89 /* object_internal.h in Headers */ = {isa = PBXBuildFile; fileRef = 965ECC200F3EAB71004DDD89 /* object_internal.h */; };
-		9661E56B0F3E7DDF00749F3E /* object.c in Sources */ = {isa = PBXBuildFile; fileRef = 9661E56A0F3E7DDF00749F3E /* object.c */; };
-		9676A0E10F3E755D00713ADB /* apply.c in Sources */ = {isa = PBXBuildFile; fileRef = 9676A0E00F3E755D00713ADB /* apply.c */; };
-		96929D840F3EA1020041FF5D /* atomic.h in Headers */ = {isa = PBXBuildFile; fileRef = 96929D820F3EA1020041FF5D /* atomic.h */; };
-		96929D850F3EA1020041FF5D /* shims.h in Headers */ = {isa = PBXBuildFile; fileRef = 96929D830F3EA1020041FF5D /* shims.h */; };
-		96929D960F3EA2170041FF5D /* queue_internal.h in Headers */ = {isa = PBXBuildFile; fileRef = 96929D950F3EA2170041FF5D /* queue_internal.h */; };
-		96A8AA870F41E7A400CD570B /* source.c in Sources */ = {isa = PBXBuildFile; fileRef = 96A8AA860F41E7A400CD570B /* source.c */; };
-		96BC39BD0F3EBAB100C59689 /* queue_private.h in Headers */ = {isa = PBXBuildFile; fileRef = 96BC39BC0F3EBAB100C59689 /* queue_private.h */; settings = {ATTRIBUTES = (Private, ); }; };
-		96C9553B0F3EAEDD000D2CA4 /* once.h in Headers */ = {isa = PBXBuildFile; fileRef = 96C9553A0F3EAEDD000D2CA4 /* once.h */; settings = {ATTRIBUTES = (Public, ); }; };
-		96DF70BE0F38FE3C0074BD99 /* once.c in Sources */ = {isa = PBXBuildFile; fileRef = 96DF70BD0F38FE3C0074BD99 /* once.c */; };
-		B683588F1FA77F5A00AA0D58 /* time_private.h in Headers */ = {isa = PBXBuildFile; fileRef = B683588A1FA77F4900AA0D58 /* time_private.h */; settings = {ATTRIBUTES = (Private, ); }; };
-		B68358901FA77F5B00AA0D58 /* time_private.h in Headers */ = {isa = PBXBuildFile; fileRef = B683588A1FA77F4900AA0D58 /* time_private.h */; settings = {ATTRIBUTES = (Private, ); }; };
-		C00B0DF21C5AEBBE000330B3 /* protocol.defs in Sources */ = {isa = PBXBuildFile; fileRef = FC7BED950E8361E600161930 /* protocol.defs */; settings = {ATTRIBUTES = (Client, Server, ); }; };
-		C00B0DF31C5AEBBE000330B3 /* resolver.c in Sources */ = {isa = PBXBuildFile; fileRef = E44EBE371251656400645D88 /* resolver.c */; };
-		C00B0DF41C5AEBBE000330B3 /* init.c in Sources */ = {isa = PBXBuildFile; fileRef = E44EBE3B1251659900645D88 /* init.c */; };
-		C00B0DF51C5AEBBE000330B3 /* queue.c in Sources */ = {isa = PBXBuildFile; fileRef = FC7BED8A0E8361E600161930 /* queue.c */; };
-		C00B0DF61C5AEBBE000330B3 /* firehose_buffer.c in Sources */ = {isa = PBXBuildFile; fileRef = 72DEAA971AE181D300289540 /* firehose_buffer.c */; };
-		C00B0DF71C5AEBBE000330B3 /* firehose.defs in Sources */ = {isa = PBXBuildFile; fileRef = 72DEAA9B1AE1B0BD00289540 /* firehose.defs */; };
-		C00B0DF81C5AEBBE000330B3 /* block.cpp in Sources */ = {isa = PBXBuildFile; fileRef = E43A724F1AF85BBC00BAA921 /* block.cpp */; };
-		C00B0DF91C5AEBBE000330B3 /* semaphore.c in Sources */ = {isa = PBXBuildFile; fileRef = 721F5CCE0F15553500FF03A6 /* semaphore.c */; };
-		C00B0DFA1C5AEBBE000330B3 /* firehose_reply.defs in Sources */ = {isa = PBXBuildFile; fileRef = 72406A031AF95DF800DF4E2B /* firehose_reply.defs */; settings = {ATTRIBUTES = (Server, ); }; };
-		C00B0DFB1C5AEBBE000330B3 /* once.c in Sources */ = {isa = PBXBuildFile; fileRef = 96DF70BD0F38FE3C0074BD99 /* once.c */; };
-		C00B0DFC1C5AEBBE000330B3 /* voucher.c in Sources */ = {isa = PBXBuildFile; fileRef = E44A8E6A1805C3E0009FFDB6 /* voucher.c */; };
-		C00B0DFD1C5AEBBE000330B3 /* apply.c in Sources */ = {isa = PBXBuildFile; fileRef = 9676A0E00F3E755D00713ADB /* apply.c */; };
-		C00B0DFE1C5AEBBE000330B3 /* object.c in Sources */ = {isa = PBXBuildFile; fileRef = 9661E56A0F3E7DDF00749F3E /* object.c */; };
-		C00B0DFF1C5AEBBE000330B3 /* benchmark.c in Sources */ = {isa = PBXBuildFile; fileRef = 965CD6340F3E806200D4E28D /* benchmark.c */; };
-		C00B0E001C5AEBBE000330B3 /* source.c in Sources */ = {isa = PBXBuildFile; fileRef = 96A8AA860F41E7A400CD570B /* source.c */; };
-		C00B0E011C5AEBBE000330B3 /* time.c in Sources */ = {isa = PBXBuildFile; fileRef = 96032E4A0F5CC8C700241C5F /* time.c */; };
-		C00B0E021C5AEBBE000330B3 /* data.c in Sources */ = {isa = PBXBuildFile; fileRef = 5AAB45BF10D30B79004407EA /* data.c */; };
-		C00B0E031C5AEBBE000330B3 /* io.c in Sources */ = {isa = PBXBuildFile; fileRef = 5A27262510F26F1900751FBC /* io.c */; };
-		C00B0E041C5AEBBE000330B3 /* transform.c in Sources */ = {isa = PBXBuildFile; fileRef = C9C5F80D143C1771006DC718 /* transform.c */; };
-		C00B0E051C5AEBBE000330B3 /* allocator.c in Sources */ = {isa = PBXBuildFile; fileRef = 2BBF5A62154B64F5002B20F9 /* allocator.c */; };
-		C01866A61C5973210040FC07 /* protocol.defs in Sources */ = {isa = PBXBuildFile; fileRef = FC7BED950E8361E600161930 /* protocol.defs */; settings = {ATTRIBUTES = (Client, Server, ); }; };
-		C01866A71C5973210040FC07 /* resolver.c in Sources */ = {isa = PBXBuildFile; fileRef = E44EBE371251656400645D88 /* resolver.c */; };
-		C01866A81C5973210040FC07 /* init.c in Sources */ = {isa = PBXBuildFile; fileRef = E44EBE3B1251659900645D88 /* init.c */; };
-		C01866A91C5973210040FC07 /* queue.c in Sources */ = {isa = PBXBuildFile; fileRef = FC7BED8A0E8361E600161930 /* queue.c */; };
-		C01866AA1C5973210040FC07 /* firehose_buffer.c in Sources */ = {isa = PBXBuildFile; fileRef = 72DEAA971AE181D300289540 /* firehose_buffer.c */; };
-		C01866AB1C5973210040FC07 /* firehose.defs in Sources */ = {isa = PBXBuildFile; fileRef = 72DEAA9B1AE1B0BD00289540 /* firehose.defs */; };
-		C01866AC1C5973210040FC07 /* block.cpp in Sources */ = {isa = PBXBuildFile; fileRef = E43A724F1AF85BBC00BAA921 /* block.cpp */; };
-		C01866AD1C5973210040FC07 /* semaphore.c in Sources */ = {isa = PBXBuildFile; fileRef = 721F5CCE0F15553500FF03A6 /* semaphore.c */; };
-		C01866AE1C5973210040FC07 /* firehose_reply.defs in Sources */ = {isa = PBXBuildFile; fileRef = 72406A031AF95DF800DF4E2B /* firehose_reply.defs */; settings = {ATTRIBUTES = (Server, ); }; };
-		C01866AF1C5973210040FC07 /* once.c in Sources */ = {isa = PBXBuildFile; fileRef = 96DF70BD0F38FE3C0074BD99 /* once.c */; };
-		C01866B01C5973210040FC07 /* voucher.c in Sources */ = {isa = PBXBuildFile; fileRef = E44A8E6A1805C3E0009FFDB6 /* voucher.c */; };
-		C01866B11C5973210040FC07 /* apply.c in Sources */ = {isa = PBXBuildFile; fileRef = 9676A0E00F3E755D00713ADB /* apply.c */; };
-		C01866B21C5973210040FC07 /* object.c in Sources */ = {isa = PBXBuildFile; fileRef = 9661E56A0F3E7DDF00749F3E /* object.c */; };
-		C01866B31C5973210040FC07 /* benchmark.c in Sources */ = {isa = PBXBuildFile; fileRef = 965CD6340F3E806200D4E28D /* benchmark.c */; };
-		C01866B41C5973210040FC07 /* source.c in Sources */ = {isa = PBXBuildFile; fileRef = 96A8AA860F41E7A400CD570B /* source.c */; };
-		C01866B51C5973210040FC07 /* time.c in Sources */ = {isa = PBXBuildFile; fileRef = 96032E4A0F5CC8C700241C5F /* time.c */; };
-		C01866B61C5973210040FC07 /* data.c in Sources */ = {isa = PBXBuildFile; fileRef = 5AAB45BF10D30B79004407EA /* data.c */; };
-		C01866B71C5973210040FC07 /* io.c in Sources */ = {isa = PBXBuildFile; fileRef = 5A27262510F26F1900751FBC /* io.c */; };
-		C01866B81C5973210040FC07 /* transform.c in Sources */ = {isa = PBXBuildFile; fileRef = C9C5F80D143C1771006DC718 /* transform.c */; };
-		C01866B91C5973210040FC07 /* allocator.c in Sources */ = {isa = PBXBuildFile; fileRef = 2BBF5A62154B64F5002B20F9 /* allocator.c */; };
-		C90144651C73A8A3002638FC /* module.modulemap in Headers */ = {isa = PBXBuildFile; fileRef = C901445E1C73A7FE002638FC /* module.modulemap */; settings = {ATTRIBUTES = (Public, ); }; };
-		C90144661C73A9F6002638FC /* module.modulemap in Headers */ = {isa = PBXBuildFile; fileRef = C90144641C73A845002638FC /* module.modulemap */; settings = {ATTRIBUTES = (Private, ); }; };
-		C913AC0F143BD34800B78976 /* data_private.h in Headers */ = {isa = PBXBuildFile; fileRef = C913AC0E143BD34800B78976 /* data_private.h */; settings = {ATTRIBUTES = (Private, ); }; };
-		C93D6165143E190E00EB9023 /* transform.c in Sources */ = {isa = PBXBuildFile; fileRef = C9C5F80D143C1771006DC718 /* transform.c */; };
-		C93D6167143E190F00EB9023 /* transform.c in Sources */ = {isa = PBXBuildFile; fileRef = C9C5F80D143C1771006DC718 /* transform.c */; };
-		C9C5F80E143C1771006DC718 /* transform.c in Sources */ = {isa = PBXBuildFile; fileRef = C9C5F80D143C1771006DC718 /* transform.c */; };
-		E4128ED613BA9A1700ABB2CB /* hw_config.h in Headers */ = {isa = PBXBuildFile; fileRef = E4128ED513BA9A1700ABB2CB /* hw_config.h */; };
-		E4128ED713BA9A1700ABB2CB /* hw_config.h in Headers */ = {isa = PBXBuildFile; fileRef = E4128ED513BA9A1700ABB2CB /* hw_config.h */; };
-		E417A38512A472C5004D659D /* provider.d in Sources */ = {isa = PBXBuildFile; fileRef = E43570B8126E93380097AB9F /* provider.d */; };
-		E420867016027AE500EEE210 /* data.m in Sources */ = {isa = PBXBuildFile; fileRef = E420866F16027AE500EEE210 /* data.m */; };
-		E420867116027AE500EEE210 /* data.m in Sources */ = {isa = PBXBuildFile; fileRef = E420866F16027AE500EEE210 /* data.m */; };
-		E420867216027AE500EEE210 /* data.m in Sources */ = {isa = PBXBuildFile; fileRef = E420866F16027AE500EEE210 /* data.m */; };
-		E421E5F91716ADA10090DC9B /* introspection.h in Headers */ = {isa = PBXBuildFile; fileRef = E421E5F81716ADA10090DC9B /* introspection.h */; settings = {ATTRIBUTES = (Public, ); }; };
-		E422A0D512A557B5005E5BDB /* trace.h in Headers */ = {isa = PBXBuildFile; fileRef = E422A0D412A557B5005E5BDB /* trace.h */; };
-		E422A0D612A557B5005E5BDB /* trace.h in Headers */ = {isa = PBXBuildFile; fileRef = E422A0D412A557B5005E5BDB /* trace.h */; };
-		E43570B9126E93380097AB9F /* provider.d in Sources */ = {isa = PBXBuildFile; fileRef = E43570B8126E93380097AB9F /* provider.d */; };
-		E43570BA126E93380097AB9F /* provider.d in Sources */ = {isa = PBXBuildFile; fileRef = E43570B8126E93380097AB9F /* provider.d */; };
-		E43A710615783F7E0012D38D /* data_private.h in Headers */ = {isa = PBXBuildFile; fileRef = C913AC0E143BD34800B78976 /* data_private.h */; settings = {ATTRIBUTES = (Private, ); }; };
-		E43A72501AF85BBC00BAA921 /* block.cpp in Sources */ = {isa = PBXBuildFile; fileRef = E43A724F1AF85BBC00BAA921 /* block.cpp */; };
-		E43A72841AF85BCB00BAA921 /* block.cpp in Sources */ = {isa = PBXBuildFile; fileRef = E43A724F1AF85BBC00BAA921 /* block.cpp */; };
-		E43A72851AF85BCC00BAA921 /* block.cpp in Sources */ = {isa = PBXBuildFile; fileRef = E43A724F1AF85BBC00BAA921 /* block.cpp */; };
-		E43A72871AF85BCD00BAA921 /* block.cpp in Sources */ = {isa = PBXBuildFile; fileRef = E43A724F1AF85BBC00BAA921 /* block.cpp */; };
-		E44757DA17F4572600B82CA1 /* inline_internal.h in Headers */ = {isa = PBXBuildFile; fileRef = E44757D917F4572600B82CA1 /* inline_internal.h */; };
-		E44757DB17F4573500B82CA1 /* inline_internal.h in Headers */ = {isa = PBXBuildFile; fileRef = E44757D917F4572600B82CA1 /* inline_internal.h */; };
-		E44757DC17F4573600B82CA1 /* inline_internal.h in Headers */ = {isa = PBXBuildFile; fileRef = E44757D917F4572600B82CA1 /* inline_internal.h */; };
-		E44A8E6B1805C3E0009FFDB6 /* voucher.c in Sources */ = {isa = PBXBuildFile; fileRef = E44A8E6A1805C3E0009FFDB6 /* voucher.c */; };
-		E44A8E6C1805C3E0009FFDB6 /* voucher.c in Sources */ = {isa = PBXBuildFile; fileRef = E44A8E6A1805C3E0009FFDB6 /* voucher.c */; };
-		E44A8E6D1805C3E0009FFDB6 /* voucher.c in Sources */ = {isa = PBXBuildFile; fileRef = E44A8E6A1805C3E0009FFDB6 /* voucher.c */; };
-		E44A8E6F1805C3E0009FFDB6 /* voucher.c in Sources */ = {isa = PBXBuildFile; fileRef = E44A8E6A1805C3E0009FFDB6 /* voucher.c */; };
-		E44A8E721805C473009FFDB6 /* voucher_private.h in Headers */ = {isa = PBXBuildFile; fileRef = E44A8E711805C473009FFDB6 /* voucher_private.h */; };
-		E44A8E731805C473009FFDB6 /* voucher_private.h in Headers */ = {isa = PBXBuildFile; fileRef = E44A8E711805C473009FFDB6 /* voucher_private.h */; };
-		E44A8E7518066276009FFDB6 /* voucher_internal.h in Headers */ = {isa = PBXBuildFile; fileRef = E44A8E7418066276009FFDB6 /* voucher_internal.h */; };
-		E44A8E7618066276009FFDB6 /* voucher_internal.h in Headers */ = {isa = PBXBuildFile; fileRef = E44A8E7418066276009FFDB6 /* voucher_internal.h */; };
-		E44A8E7718066276009FFDB6 /* voucher_internal.h in Headers */ = {isa = PBXBuildFile; fileRef = E44A8E7418066276009FFDB6 /* voucher_internal.h */; };
-		E44EBE3E1251659900645D88 /* init.c in Sources */ = {isa = PBXBuildFile; fileRef = E44EBE3B1251659900645D88 /* init.c */; };
-		E44EBE5612517EBE00645D88 /* protocol.defs in Sources */ = {isa = PBXBuildFile; fileRef = FC7BED950E8361E600161930 /* protocol.defs */; settings = {ATTRIBUTES = (Client, Server, ); }; };
-		E44EBE5712517EBE00645D88 /* init.c in Sources */ = {isa = PBXBuildFile; fileRef = E44EBE3B1251659900645D88 /* init.c */; };
-		E44F9DAB16543F94001DCD38 /* introspection_internal.h in Headers */ = {isa = PBXBuildFile; fileRef = E44F9DA816543F79001DCD38 /* introspection_internal.h */; };
-		E44F9DAC1654400D001DCD38 /* introspection_internal.h in Headers */ = {isa = PBXBuildFile; fileRef = E44F9DA816543F79001DCD38 /* introspection_internal.h */; };
-		E44F9DAD1654400E001DCD38 /* introspection_internal.h in Headers */ = {isa = PBXBuildFile; fileRef = E44F9DA816543F79001DCD38 /* introspection_internal.h */; };
-		E44F9DAE16544022001DCD38 /* allocator_internal.h in Headers */ = {isa = PBXBuildFile; fileRef = 2BBF5A5F154B64D8002B20F9 /* allocator_internal.h */; };
-		E44F9DAF16544026001DCD38 /* internal.h in Headers */ = {isa = PBXBuildFile; fileRef = FC7BED8F0E8361E600161930 /* internal.h */; };
-		E44F9DB01654402B001DCD38 /* data_internal.h in Headers */ = {isa = PBXBuildFile; fileRef = E4C1ED6E1263E714000D3C8B /* data_internal.h */; };
-		E44F9DB11654402E001DCD38 /* io_internal.h in Headers */ = {isa = PBXBuildFile; fileRef = 5A0095A110F274B0000E2A31 /* io_internal.h */; };
-		E44F9DB216544032001DCD38 /* object_internal.h in Headers */ = {isa = PBXBuildFile; fileRef = 965ECC200F3EAB71004DDD89 /* object_internal.h */; };
-		E44F9DB316544037001DCD38 /* queue_internal.h in Headers */ = {isa = PBXBuildFile; fileRef = 96929D950F3EA2170041FF5D /* queue_internal.h */; };
-		E44F9DB41654403B001DCD38 /* semaphore_internal.h in Headers */ = {isa = PBXBuildFile; fileRef = 5A5D13AB0F6B280500197CC3 /* semaphore_internal.h */; };
-		E44F9DB51654403F001DCD38 /* source_internal.h in Headers */ = {isa = PBXBuildFile; fileRef = FC0B34780FA2851C0080FFA0 /* source_internal.h */; };
-		E44F9DB616544043001DCD38 /* trace.h in Headers */ = {isa = PBXBuildFile; fileRef = E422A0D412A557B5005E5BDB /* trace.h */; };
-		E44F9DB71654404F001DCD38 /* shims.h in Headers */ = {isa = PBXBuildFile; fileRef = 96929D830F3EA1020041FF5D /* shims.h */; };
-		E44F9DB816544053001DCD38 /* atomic.h in Headers */ = {isa = PBXBuildFile; fileRef = 96929D820F3EA1020041FF5D /* atomic.h */; };
-		E44F9DB916544056001DCD38 /* getprogname.h in Headers */ = {isa = PBXBuildFile; fileRef = E4BA743913A8911B0095BDF1 /* getprogname.h */; };
-		E44F9DBA1654405B001DCD38 /* hw_config.h in Headers */ = {isa = PBXBuildFile; fileRef = E4128ED513BA9A1700ABB2CB /* hw_config.h */; };
-		E44F9DBC1654405B001DCD38 /* perfmon.h in Headers */ = {isa = PBXBuildFile; fileRef = FC1832A2109923C7003403D5 /* perfmon.h */; };
-		E44F9DBE1654405B001DCD38 /* tsd.h in Headers */ = {isa = PBXBuildFile; fileRef = FC1832A4109923C7003403D5 /* tsd.h */; };
-		E44F9DBF165440EF001DCD38 /* config.h in Headers */ = {isa = PBXBuildFile; fileRef = FC9C70E7105EC9620074F9CA /* config.h */; };
-		E44F9DC016544115001DCD38 /* object.h in Headers */ = {isa = PBXBuildFile; fileRef = E4EB4A2614C35ECE00AA0FA9 /* object.h */; };
-		E44F9DC116544115001DCD38 /* object_private.h in Headers */ = {isa = PBXBuildFile; fileRef = E454569214746F1B00106147 /* object_private.h */; };
-		E454569314746F1B00106147 /* object_private.h in Headers */ = {isa = PBXBuildFile; fileRef = E454569214746F1B00106147 /* object_private.h */; settings = {ATTRIBUTES = (); }; };
-		E454569414746F1B00106147 /* object_private.h in Headers */ = {isa = PBXBuildFile; fileRef = E454569214746F1B00106147 /* object_private.h */; settings = {ATTRIBUTES = (); }; };
-		E4630251176162D200E11F4C /* atomic_sfb.h in Headers */ = {isa = PBXBuildFile; fileRef = E463024F1761603C00E11F4C /* atomic_sfb.h */; };
-		E4630252176162D300E11F4C /* atomic_sfb.h in Headers */ = {isa = PBXBuildFile; fileRef = E463024F1761603C00E11F4C /* atomic_sfb.h */; };
-		E4630253176162D400E11F4C /* atomic_sfb.h in Headers */ = {isa = PBXBuildFile; fileRef = E463024F1761603C00E11F4C /* atomic_sfb.h */; };
-		E48AF55A16E70FD9004105FF /* io_private.h in Headers */ = {isa = PBXBuildFile; fileRef = E48AF55916E70FD9004105FF /* io_private.h */; settings = {ATTRIBUTES = (Private, ); }; };
-		E48AF55B16E72D44004105FF /* io_private.h in Headers */ = {isa = PBXBuildFile; fileRef = E48AF55916E70FD9004105FF /* io_private.h */; settings = {ATTRIBUTES = (Private, ); }; };
-		E48EC97C1835BADD00EAC4F1 /* yield.h in Headers */ = {isa = PBXBuildFile; fileRef = E48EC97B1835BADD00EAC4F1 /* yield.h */; };
-		E48EC97D1835BADD00EAC4F1 /* yield.h in Headers */ = {isa = PBXBuildFile; fileRef = E48EC97B1835BADD00EAC4F1 /* yield.h */; };
-		E48EC97E1835BADD00EAC4F1 /* yield.h in Headers */ = {isa = PBXBuildFile; fileRef = E48EC97B1835BADD00EAC4F1 /* yield.h */; };
-		E49BB6D11E70748100868613 /* provider.d in Sources */ = {isa = PBXBuildFile; fileRef = E43570B8126E93380097AB9F /* provider.d */; };
-		E49BB6D21E70748100868613 /* protocol.defs in Sources */ = {isa = PBXBuildFile; fileRef = FC7BED950E8361E600161930 /* protocol.defs */; settings = {ATTRIBUTES = (Client, Server, ); }; };
-		E49BB6D31E70748100868613 /* venture.c in Sources */ = {isa = PBXBuildFile; fileRef = 6E9955CE1C3B218E0071D40C /* venture.c */; };
-		E49BB6D41E70748100868613 /* firehose.defs in Sources */ = {isa = PBXBuildFile; fileRef = 72DEAA9B1AE1B0BD00289540 /* firehose.defs */; };
-		E49BB6D51E70748100868613 /* firehose_buffer.c in Sources */ = {isa = PBXBuildFile; fileRef = 72DEAA971AE181D300289540 /* firehose_buffer.c */; };
-		E49BB6D61E70748100868613 /* event_kevent.c in Sources */ = {isa = PBXBuildFile; fileRef = 6E5ACCB01D3C4CFB007DA2B4 /* event_kevent.c */; };
-		E49BB6D71E70748100868613 /* resolver.c in Sources */ = {isa = PBXBuildFile; fileRef = E44EBE371251656400645D88 /* resolver.c */; };
-		E49BB6D81E70748100868613 /* mach.c in Sources */ = {isa = PBXBuildFile; fileRef = 6E4BACBC1D48A41500B562AE /* mach.c */; };
-		E49BB6D91E70748100868613 /* init.c in Sources */ = {isa = PBXBuildFile; fileRef = E44EBE3B1251659900645D88 /* init.c */; };
-		E49BB6DA1E70748100868613 /* queue.c in Sources */ = {isa = PBXBuildFile; fileRef = FC7BED8A0E8361E600161930 /* queue.c */; };
-		E49BB6DB1E70748100868613 /* semaphore.c in Sources */ = {isa = PBXBuildFile; fileRef = 721F5CCE0F15553500FF03A6 /* semaphore.c */; };
-		E49BB6DC1E70748100868613 /* lock.c in Sources */ = {isa = PBXBuildFile; fileRef = 6EF2CAAB1C8899D5001ABE83 /* lock.c */; };
-		E49BB6DD1E70748100868613 /* firehose_reply.defs in Sources */ = {isa = PBXBuildFile; fileRef = 72406A031AF95DF800DF4E2B /* firehose_reply.defs */; settings = {ATTRIBUTES = (Server, ); }; };
-		E49BB6DE1E70748100868613 /* once.c in Sources */ = {isa = PBXBuildFile; fileRef = 96DF70BD0F38FE3C0074BD99 /* once.c */; };
-		E49BB6DF1E70748100868613 /* apply.c in Sources */ = {isa = PBXBuildFile; fileRef = 9676A0E00F3E755D00713ADB /* apply.c */; };
-		E49BB6E01E70748100868613 /* object.c in Sources */ = {isa = PBXBuildFile; fileRef = 9661E56A0F3E7DDF00749F3E /* object.c */; };
-		E49BB6E11E70748100868613 /* benchmark.c in Sources */ = {isa = PBXBuildFile; fileRef = 965CD6340F3E806200D4E28D /* benchmark.c */; };
-		E49BB6E21E70748100868613 /* event_epoll.c in Sources */ = {isa = PBXBuildFile; fileRef = 6EA7937D1D456D1300929B1B /* event_epoll.c */; };
-		E49BB6E31E70748100868613 /* source.c in Sources */ = {isa = PBXBuildFile; fileRef = 96A8AA860F41E7A400CD570B /* source.c */; };
-		E49BB6E41E70748100868613 /* time.c in Sources */ = {isa = PBXBuildFile; fileRef = 96032E4A0F5CC8C700241C5F /* time.c */; };
-		E49BB6E51E70748100868613 /* data.c in Sources */ = {isa = PBXBuildFile; fileRef = 5AAB45BF10D30B79004407EA /* data.c */; };
-		E49BB6E61E70748100868613 /* io.c in Sources */ = {isa = PBXBuildFile; fileRef = 5A27262510F26F1900751FBC /* io.c */; };
-		E49BB6E71E70748100868613 /* block.cpp in Sources */ = {isa = PBXBuildFile; fileRef = E43A724F1AF85BBC00BAA921 /* block.cpp */; };
-		E49BB6E81E70748100868613 /* event.c in Sources */ = {isa = PBXBuildFile; fileRef = 6E5ACCBD1D3C6719007DA2B4 /* event.c */; };
-		E49BB6E91E70748100868613 /* transform.c in Sources */ = {isa = PBXBuildFile; fileRef = C9C5F80D143C1771006DC718 /* transform.c */; };
-		E49BB6EA1E70748100868613 /* object.m in Sources */ = {isa = PBXBuildFile; fileRef = E4FC3263145F46C9002FBDDB /* object.m */; };
-		E49BB6EB1E70748100868613 /* allocator.c in Sources */ = {isa = PBXBuildFile; fileRef = 2BBF5A62154B64F5002B20F9 /* allocator.c */; };
-		E49BB6EC1E70748100868613 /* data.m in Sources */ = {isa = PBXBuildFile; fileRef = E420866F16027AE500EEE210 /* data.m */; };
-		E49BB6ED1E70748100868613 /* voucher.c in Sources */ = {isa = PBXBuildFile; fileRef = E44A8E6A1805C3E0009FFDB6 /* voucher.c */; };
-		E49BB7091E70A39700868613 /* venture.c in Sources */ = {isa = PBXBuildFile; fileRef = 6E9955CE1C3B218E0071D40C /* venture.c */; };
-		E49BB70A1E70A3B000868613 /* venture.c in Sources */ = {isa = PBXBuildFile; fileRef = 6E9955CE1C3B218E0071D40C /* venture.c */; };
-		E49F2423125D3C960057C971 /* resolver.c in Sources */ = {isa = PBXBuildFile; fileRef = E44EBE371251656400645D88 /* resolver.c */; };
-		E49F2499125D48D80057C971 /* resolver.c in Sources */ = {isa = PBXBuildFile; fileRef = E44EBE371251656400645D88 /* resolver.c */; };
-		E49F24AB125D57FA0057C971 /* dispatch.h in Headers */ = {isa = PBXBuildFile; fileRef = FC7BED960E8361E600161930 /* dispatch.h */; settings = {ATTRIBUTES = (Public, ); }; };
-		E49F24AC125D57FA0057C971 /* base.h in Headers */ = {isa = PBXBuildFile; fileRef = 72CC942F0ECCD8750031B751 /* base.h */; settings = {ATTRIBUTES = (Public, ); }; };
-		E49F24AD125D57FA0057C971 /* object.h in Headers */ = {isa = PBXBuildFile; fileRef = 961B994F0F3E85C30006BC96 /* object.h */; settings = {ATTRIBUTES = (Public, ); }; };
-		E49F24AE125D57FA0057C971 /* queue.h in Headers */ = {isa = PBXBuildFile; fileRef = FC7BED8B0E8361E600161930 /* queue.h */; settings = {ATTRIBUTES = (Public, ); }; };
-		E49F24AF125D57FA0057C971 /* source.h in Headers */ = {isa = PBXBuildFile; fileRef = FC7BED8D0E8361E600161930 /* source.h */; settings = {ATTRIBUTES = (Public, ); }; };
-		E49F24B0125D57FA0057C971 /* semaphore.h in Headers */ = {isa = PBXBuildFile; fileRef = 721F5C5C0F15520500FF03A6 /* semaphore.h */; settings = {ATTRIBUTES = (Public, ); }; };
-		E49F24B1125D57FA0057C971 /* group.h in Headers */ = {isa = PBXBuildFile; fileRef = FC5C9C1D0EADABE3006E462D /* group.h */; settings = {ATTRIBUTES = (Public, ); }; };
-		E49F24B2125D57FA0057C971 /* once.h in Headers */ = {isa = PBXBuildFile; fileRef = 96C9553A0F3EAEDD000D2CA4 /* once.h */; settings = {ATTRIBUTES = (Public, ); }; };
-		E49F24B3125D57FA0057C971 /* io.h in Headers */ = {isa = PBXBuildFile; fileRef = 5AAB45C310D30CC7004407EA /* io.h */; settings = {ATTRIBUTES = (Public, ); }; };
-		E49F24B4125D57FA0057C971 /* data.h in Headers */ = {isa = PBXBuildFile; fileRef = 5AAB45C510D30D0C004407EA /* data.h */; settings = {ATTRIBUTES = (Public, ); }; };
-		E49F24B5125D57FA0057C971 /* time.h in Headers */ = {isa = PBXBuildFile; fileRef = 96032E4C0F5CC8D100241C5F /* time.h */; settings = {ATTRIBUTES = (Public, ); }; };
-		E49F24B6125D57FA0057C971 /* private.h in Headers */ = {isa = PBXBuildFile; fileRef = FC7BED930E8361E600161930 /* private.h */; settings = {ATTRIBUTES = (Private, ); }; };
-		E49F24B7125D57FA0057C971 /* queue_private.h in Headers */ = {isa = PBXBuildFile; fileRef = 96BC39BC0F3EBAB100C59689 /* queue_private.h */; settings = {ATTRIBUTES = (Private, ); }; };
-		E49F24B8125D57FA0057C971 /* source_private.h in Headers */ = {isa = PBXBuildFile; fileRef = FCEF047F0F5661960067401F /* source_private.h */; settings = {ATTRIBUTES = (Private, ); }; };
-		E49F24B9125D57FA0057C971 /* benchmark.h in Headers */ = {isa = PBXBuildFile; fileRef = 961B99350F3E83980006BC96 /* benchmark.h */; settings = {ATTRIBUTES = (Private, ); }; };
-		E49F24BA125D57FA0057C971 /* internal.h in Headers */ = {isa = PBXBuildFile; fileRef = FC7BED8F0E8361E600161930 /* internal.h */; settings = {ATTRIBUTES = (); }; };
-		E49F24BB125D57FA0057C971 /* queue_internal.h in Headers */ = {isa = PBXBuildFile; fileRef = 96929D950F3EA2170041FF5D /* queue_internal.h */; };
-		E49F24BC125D57FA0057C971 /* object_internal.h in Headers */ = {isa = PBXBuildFile; fileRef = 965ECC200F3EAB71004DDD89 /* object_internal.h */; };
-		E49F24BD125D57FA0057C971 /* semaphore_internal.h in Headers */ = {isa = PBXBuildFile; fileRef = 5A5D13AB0F6B280500197CC3 /* semaphore_internal.h */; };
-		E49F24BE125D57FA0057C971 /* source_internal.h in Headers */ = {isa = PBXBuildFile; fileRef = FC0B34780FA2851C0080FFA0 /* source_internal.h */; };
-		E49F24BF125D57FA0057C971 /* io_internal.h in Headers */ = {isa = PBXBuildFile; fileRef = 5A0095A110F274B0000E2A31 /* io_internal.h */; };
-		E49F24C1125D57FA0057C971 /* tsd.h in Headers */ = {isa = PBXBuildFile; fileRef = FC1832A4109923C7003403D5 /* tsd.h */; };
-		E49F24C2125D57FA0057C971 /* atomic.h in Headers */ = {isa = PBXBuildFile; fileRef = 96929D820F3EA1020041FF5D /* atomic.h */; };
-		E49F24C3125D57FA0057C971 /* shims.h in Headers */ = {isa = PBXBuildFile; fileRef = 96929D830F3EA1020041FF5D /* shims.h */; };
-		E49F24C4125D57FA0057C971 /* time.h in Headers */ = {isa = PBXBuildFile; fileRef = FC1832A3109923C7003403D5 /* time.h */; };
-		E49F24C5125D57FA0057C971 /* perfmon.h in Headers */ = {isa = PBXBuildFile; fileRef = FC1832A2109923C7003403D5 /* perfmon.h */; };
-		E49F24C6125D57FA0057C971 /* config.h in Headers */ = {isa = PBXBuildFile; fileRef = FC9C70E7105EC9620074F9CA /* config.h */; };
-		E49F24C8125D57FA0057C971 /* protocol.defs in Sources */ = {isa = PBXBuildFile; fileRef = FC7BED950E8361E600161930 /* protocol.defs */; settings = {ATTRIBUTES = (Client, Server, ); }; };
-		E49F24C9125D57FA0057C971 /* resolver.c in Sources */ = {isa = PBXBuildFile; fileRef = E44EBE371251656400645D88 /* resolver.c */; };
-		E49F24CA125D57FA0057C971 /* init.c in Sources */ = {isa = PBXBuildFile; fileRef = E44EBE3B1251659900645D88 /* init.c */; };
-		E49F24CB125D57FA0057C971 /* queue.c in Sources */ = {isa = PBXBuildFile; fileRef = FC7BED8A0E8361E600161930 /* queue.c */; };
-		E49F24CC125D57FA0057C971 /* semaphore.c in Sources */ = {isa = PBXBuildFile; fileRef = 721F5CCE0F15553500FF03A6 /* semaphore.c */; };
-		E49F24CD125D57FA0057C971 /* once.c in Sources */ = {isa = PBXBuildFile; fileRef = 96DF70BD0F38FE3C0074BD99 /* once.c */; };
-		E49F24CE125D57FA0057C971 /* apply.c in Sources */ = {isa = PBXBuildFile; fileRef = 9676A0E00F3E755D00713ADB /* apply.c */; };
-		E49F24CF125D57FA0057C971 /* object.c in Sources */ = {isa = PBXBuildFile; fileRef = 9661E56A0F3E7DDF00749F3E /* object.c */; };
-		E49F24D0125D57FA0057C971 /* benchmark.c in Sources */ = {isa = PBXBuildFile; fileRef = 965CD6340F3E806200D4E28D /* benchmark.c */; };
-		E49F24D1125D57FA0057C971 /* source.c in Sources */ = {isa = PBXBuildFile; fileRef = 96A8AA860F41E7A400CD570B /* source.c */; };
-		E49F24D2125D57FA0057C971 /* time.c in Sources */ = {isa = PBXBuildFile; fileRef = 96032E4A0F5CC8C700241C5F /* time.c */; };
-		E49F24D3125D57FA0057C971 /* data.c in Sources */ = {isa = PBXBuildFile; fileRef = 5AAB45BF10D30B79004407EA /* data.c */; };
-		E49F24D4125D57FA0057C971 /* io.c in Sources */ = {isa = PBXBuildFile; fileRef = 5A27262510F26F1900751FBC /* io.c */; };
-		E4B3C3FE18C50D000039F49F /* voucher_activity_private.h in Headers */ = {isa = PBXBuildFile; fileRef = E4B3C3FD18C50D000039F49F /* voucher_activity_private.h */; };
-		E4B3C3FF18C50D0E0039F49F /* voucher_activity_private.h in Headers */ = {isa = PBXBuildFile; fileRef = E4B3C3FD18C50D000039F49F /* voucher_activity_private.h */; };
-		E4B515BD164B2DA300E003AF /* provider.d in Sources */ = {isa = PBXBuildFile; fileRef = E43570B8126E93380097AB9F /* provider.d */; };
-		E4B515BE164B2DA300E003AF /* protocol.defs in Sources */ = {isa = PBXBuildFile; fileRef = FC7BED950E8361E600161930 /* protocol.defs */; settings = {ATTRIBUTES = (Client, Server, ); }; };
-		E4B515BF164B2DA300E003AF /* resolver.c in Sources */ = {isa = PBXBuildFile; fileRef = E44EBE371251656400645D88 /* resolver.c */; };
-		E4B515C0164B2DA300E003AF /* init.c in Sources */ = {isa = PBXBuildFile; fileRef = E44EBE3B1251659900645D88 /* init.c */; };
-		E4B515C1164B2DA300E003AF /* queue.c in Sources */ = {isa = PBXBuildFile; fileRef = FC7BED8A0E8361E600161930 /* queue.c */; };
-		E4B515C2164B2DA300E003AF /* semaphore.c in Sources */ = {isa = PBXBuildFile; fileRef = 721F5CCE0F15553500FF03A6 /* semaphore.c */; };
-		E4B515C3164B2DA300E003AF /* once.c in Sources */ = {isa = PBXBuildFile; fileRef = 96DF70BD0F38FE3C0074BD99 /* once.c */; };
-		E4B515C4164B2DA300E003AF /* apply.c in Sources */ = {isa = PBXBuildFile; fileRef = 9676A0E00F3E755D00713ADB /* apply.c */; };
-		E4B515C5164B2DA300E003AF /* object.c in Sources */ = {isa = PBXBuildFile; fileRef = 9661E56A0F3E7DDF00749F3E /* object.c */; };
-		E4B515C6164B2DA300E003AF /* benchmark.c in Sources */ = {isa = PBXBuildFile; fileRef = 965CD6340F3E806200D4E28D /* benchmark.c */; };
-		E4B515C7164B2DA300E003AF /* source.c in Sources */ = {isa = PBXBuildFile; fileRef = 96A8AA860F41E7A400CD570B /* source.c */; };
-		E4B515C8164B2DA300E003AF /* time.c in Sources */ = {isa = PBXBuildFile; fileRef = 96032E4A0F5CC8C700241C5F /* time.c */; };
-		E4B515C9164B2DA300E003AF /* data.c in Sources */ = {isa = PBXBuildFile; fileRef = 5AAB45BF10D30B79004407EA /* data.c */; };
-		E4B515CA164B2DA300E003AF /* io.c in Sources */ = {isa = PBXBuildFile; fileRef = 5A27262510F26F1900751FBC /* io.c */; };
-		E4B515CB164B2DA300E003AF /* transform.c in Sources */ = {isa = PBXBuildFile; fileRef = C9C5F80D143C1771006DC718 /* transform.c */; };
-		E4B515CC164B2DA300E003AF /* object.m in Sources */ = {isa = PBXBuildFile; fileRef = E4FC3263145F46C9002FBDDB /* object.m */; };
-		E4B515CD164B2DA300E003AF /* allocator.c in Sources */ = {isa = PBXBuildFile; fileRef = 2BBF5A62154B64F5002B20F9 /* allocator.c */; };
-		E4B515CE164B2DA300E003AF /* data.m in Sources */ = {isa = PBXBuildFile; fileRef = E420866F16027AE500EEE210 /* data.m */; };
-		E4B515D8164B2DFB00E003AF /* introspection_private.h in Headers */ = {isa = PBXBuildFile; fileRef = E4B515D7164B2DFB00E003AF /* introspection_private.h */; settings = {ATTRIBUTES = (Private, ); }; };
-		E4B515DD164B32E000E003AF /* introspection.c in Sources */ = {isa = PBXBuildFile; fileRef = E4B515DC164B32E000E003AF /* introspection.c */; };
-		E4BA743B13A8911B0095BDF1 /* getprogname.h in Headers */ = {isa = PBXBuildFile; fileRef = E4BA743913A8911B0095BDF1 /* getprogname.h */; };
-		E4BA743C13A8911B0095BDF1 /* getprogname.h in Headers */ = {isa = PBXBuildFile; fileRef = E4BA743913A8911B0095BDF1 /* getprogname.h */; };
-		E4C1ED6F1263E714000D3C8B /* data_internal.h in Headers */ = {isa = PBXBuildFile; fileRef = E4C1ED6E1263E714000D3C8B /* data_internal.h */; };
-		E4C1ED701263E714000D3C8B /* data_internal.h in Headers */ = {isa = PBXBuildFile; fileRef = E4C1ED6E1263E714000D3C8B /* data_internal.h */; };
-		E4D76A9318E325D200B1F98B /* block.h in Headers */ = {isa = PBXBuildFile; fileRef = E4D76A9218E325D200B1F98B /* block.h */; settings = {ATTRIBUTES = (Public, ); }; };
-		E4D76A9418E325D200B1F98B /* block.h in Headers */ = {isa = PBXBuildFile; fileRef = E4D76A9218E325D200B1F98B /* block.h */; settings = {ATTRIBUTES = (Public, ); }; };
-		E4EB4A2714C35ECE00AA0FA9 /* object.h in Headers */ = {isa = PBXBuildFile; fileRef = E4EB4A2614C35ECE00AA0FA9 /* object.h */; };
-		E4EB4A2814C35ECE00AA0FA9 /* object.h in Headers */ = {isa = PBXBuildFile; fileRef = E4EB4A2614C35ECE00AA0FA9 /* object.h */; };
-		E4EC121A12514715000DDBD1 /* queue.c in Sources */ = {isa = PBXBuildFile; fileRef = FC7BED8A0E8361E600161930 /* queue.c */; };
-		E4EC121B12514715000DDBD1 /* semaphore.c in Sources */ = {isa = PBXBuildFile; fileRef = 721F5CCE0F15553500FF03A6 /* semaphore.c */; };
-		E4EC121C12514715000DDBD1 /* once.c in Sources */ = {isa = PBXBuildFile; fileRef = 96DF70BD0F38FE3C0074BD99 /* once.c */; };
-		E4EC121D12514715000DDBD1 /* apply.c in Sources */ = {isa = PBXBuildFile; fileRef = 9676A0E00F3E755D00713ADB /* apply.c */; };
-		E4EC121E12514715000DDBD1 /* object.c in Sources */ = {isa = PBXBuildFile; fileRef = 9661E56A0F3E7DDF00749F3E /* object.c */; };
-		E4EC121F12514715000DDBD1 /* benchmark.c in Sources */ = {isa = PBXBuildFile; fileRef = 965CD6340F3E806200D4E28D /* benchmark.c */; };
-		E4EC122012514715000DDBD1 /* source.c in Sources */ = {isa = PBXBuildFile; fileRef = 96A8AA860F41E7A400CD570B /* source.c */; };
-		E4EC122112514715000DDBD1 /* time.c in Sources */ = {isa = PBXBuildFile; fileRef = 96032E4A0F5CC8C700241C5F /* time.c */; };
-		E4EC122312514715000DDBD1 /* data.c in Sources */ = {isa = PBXBuildFile; fileRef = 5AAB45BF10D30B79004407EA /* data.c */; };
-		E4EC122412514715000DDBD1 /* io.c in Sources */ = {isa = PBXBuildFile; fileRef = 5A27262510F26F1900751FBC /* io.c */; };
-		E4ECBAA515253C25002C313C /* mach_private.h in Headers */ = {isa = PBXBuildFile; fileRef = E4ECBAA415253C25002C313C /* mach_private.h */; settings = {ATTRIBUTES = (Private, ); }; };
-		E4ECBAA615253D17002C313C /* mach_private.h in Headers */ = {isa = PBXBuildFile; fileRef = E4ECBAA415253C25002C313C /* mach_private.h */; settings = {ATTRIBUTES = (Private, ); }; };
-		E4FC3264145F46C9002FBDDB /* object.m in Sources */ = {isa = PBXBuildFile; fileRef = E4FC3263145F46C9002FBDDB /* object.m */; };
-		E4FC3265145F46C9002FBDDB /* object.m in Sources */ = {isa = PBXBuildFile; fileRef = E4FC3263145F46C9002FBDDB /* object.m */; };
-		E4FC3267145F46C9002FBDDB /* object.m in Sources */ = {isa = PBXBuildFile; fileRef = E4FC3263145F46C9002FBDDB /* object.m */; };
-		F7DC045B2060BBBE00C90737 /* target.h in Headers */ = {isa = PBXBuildFile; fileRef = F7DC045A2060BBBE00C90737 /* target.h */; };
-		FC0B34790FA2851C0080FFA0 /* source_internal.h in Headers */ = {isa = PBXBuildFile; fileRef = FC0B34780FA2851C0080FFA0 /* source_internal.h */; };
-		FC1832A6109923C7003403D5 /* perfmon.h in Headers */ = {isa = PBXBuildFile; fileRef = FC1832A2109923C7003403D5 /* perfmon.h */; };
-		FC1832A7109923C7003403D5 /* time.h in Headers */ = {isa = PBXBuildFile; fileRef = FC1832A3109923C7003403D5 /* time.h */; };
-		FC1832A8109923C7003403D5 /* tsd.h in Headers */ = {isa = PBXBuildFile; fileRef = FC1832A4109923C7003403D5 /* tsd.h */; };
-		FC5C9C1E0EADABE3006E462D /* group.h in Headers */ = {isa = PBXBuildFile; fileRef = FC5C9C1D0EADABE3006E462D /* group.h */; settings = {ATTRIBUTES = (Public, ); }; };
-		FC7BED990E8361E600161930 /* queue.c in Sources */ = {isa = PBXBuildFile; fileRef = FC7BED8A0E8361E600161930 /* queue.c */; };
-		FC7BED9A0E8361E600161930 /* queue.h in Headers */ = {isa = PBXBuildFile; fileRef = FC7BED8B0E8361E600161930 /* queue.h */; settings = {ATTRIBUTES = (Public, ); }; };
-		FC7BED9C0E8361E600161930 /* source.h in Headers */ = {isa = PBXBuildFile; fileRef = FC7BED8D0E8361E600161930 /* source.h */; settings = {ATTRIBUTES = (Public, ); }; };
-		FC7BED9E0E8361E600161930 /* internal.h in Headers */ = {isa = PBXBuildFile; fileRef = FC7BED8F0E8361E600161930 /* internal.h */; settings = {ATTRIBUTES = (); }; };
-		FC7BEDA20E8361E600161930 /* private.h in Headers */ = {isa = PBXBuildFile; fileRef = FC7BED930E8361E600161930 /* private.h */; settings = {ATTRIBUTES = (Private, ); }; };
-		FC7BEDA40E8361E600161930 /* protocol.defs in Sources */ = {isa = PBXBuildFile; fileRef = FC7BED950E8361E600161930 /* protocol.defs */; settings = {ATTRIBUTES = (Client, Server, ); }; };
-		FC7BEDA50E8361E600161930 /* dispatch.h in Headers */ = {isa = PBXBuildFile; fileRef = FC7BED960E8361E600161930 /* dispatch.h */; settings = {ATTRIBUTES = (Public, ); }; };
-		FC9C70E8105EC9620074F9CA /* config.h in Headers */ = {isa = PBXBuildFile; fileRef = FC9C70E7105EC9620074F9CA /* config.h */; };
-		FCEF04800F5661960067401F /* source_private.h in Headers */ = {isa = PBXBuildFile; fileRef = FCEF047F0F5661960067401F /* source_private.h */; settings = {ATTRIBUTES = (Private, ); }; };
-/* End PBXBuildFile section */
-
-/* Begin PBXContainerItemProxy section */
-		4552540219B1384900B88766 /* PBXContainerItemProxy */ = {
-			isa = PBXContainerItemProxy;
-			containerPortal = 4552536E19B1384900B88766 /* libdispatchtest.xcodeproj */;
-			proxyType = 2;
-			remoteGlobalIDString = E4D020B4108F73E000FAA873;
-			remoteInfo = bench;
-		};
-		4552540419B1384900B88766 /* PBXContainerItemProxy */ = {
-			isa = PBXContainerItemProxy;
-			containerPortal = 4552536E19B1384900B88766 /* libdispatchtest.xcodeproj */;
-			proxyType = 2;
-			remoteGlobalIDString = E454823616C1D8E50042EC2D;
-			remoteInfo = jsgc_bench;
-		};
-		4552540619B1384900B88766 /* PBXContainerItemProxy */ = {
-			isa = PBXContainerItemProxy;
-			containerPortal = 4552536E19B1384900B88766 /* libdispatchtest.xcodeproj */;
-			proxyType = 2;
-			remoteGlobalIDString = E454824516C1F0EF0042EC2D;
-			remoteInfo = async_bench;
-		};
-		4552540819B1384900B88766 /* PBXContainerItemProxy */ = {
-			isa = PBXContainerItemProxy;
-			containerPortal = 4552536E19B1384900B88766 /* libdispatchtest.xcodeproj */;
-			proxyType = 2;
-			remoteGlobalIDString = E454824F16C1F0FE0042EC2D;
-			remoteInfo = apply_bench;
-		};
-		6E2ECB011C49C31200A30A32 /* PBXContainerItemProxy */ = {
-			isa = PBXContainerItemProxy;
-			containerPortal = 08FB7793FE84155DC02AAC07 /* Project object */;
-			proxyType = 1;
-			remoteGlobalIDString = 6E040C621C499B1B00411A2E;
-			remoteInfo = libfirehose_kernel;
-		};
-		6EE5083A21701B9100833569 /* PBXContainerItemProxy */ = {
-			isa = PBXContainerItemProxy;
-			containerPortal = 08FB7793FE84155DC02AAC07 /* Project object */;
-			proxyType = 1;
-			remoteGlobalIDString = E4B51595164B2DA300E003AF;
-			remoteInfo = "libdispatch introspection";
-		};
-		6EE5083C21701B9600833569 /* PBXContainerItemProxy */ = {
-			isa = PBXContainerItemProxy;
-			containerPortal = 08FB7793FE84155DC02AAC07 /* Project object */;
-			proxyType = 1;
-			remoteGlobalIDString = E4B51595164B2DA300E003AF;
-			remoteInfo = "libdispatch introspection";
-		};
-		6EF0B27D1BA8C5BF007FA4F6 /* PBXContainerItemProxy */ = {
-			isa = PBXContainerItemProxy;
-			containerPortal = 08FB7793FE84155DC02AAC07 /* Project object */;
-			proxyType = 1;
-			remoteGlobalIDString = 6EB4E4081BA8BCAD00D7B9D2;
-			remoteInfo = libfirehose_server;
-		};
-		92CBD7591BED926C006E0892 /* PBXContainerItemProxy */ = {
-			isa = PBXContainerItemProxy;
-			containerPortal = 4552536E19B1384900B88766 /* libdispatchtest.xcodeproj */;
-			proxyType = 1;
-			remoteGlobalIDString = E4D01DC5108E708E00FAA873;
-			remoteInfo = all;
-		};
-		92F3FECE1BEC6F1000025962 /* PBXContainerItemProxy */ = {
-			isa = PBXContainerItemProxy;
-			containerPortal = 08FB7793FE84155DC02AAC07 /* Project object */;
-			proxyType = 1;
-			remoteGlobalIDString = 92F3FECA1BEC69E500025962;
-			remoteInfo = darwintests;
-		};
-		9B2A11A22032494E0060E7D4 /* PBXContainerItemProxy */ = {
-			isa = PBXContainerItemProxy;
-			containerPortal = 9B6A42E01FE098430000D146 /* queue-tip.xcodeproj */;
-			proxyType = 1;
-			remoteGlobalIDString = 9BECABC71E944C0400ED341E;
-			remoteInfo = "queue-tip";
-		};
-		9B2A11A92032494E0060E7D4 /* PBXContainerItemProxy */ = {
-			isa = PBXContainerItemProxy;
-			containerPortal = 9B6A42E01FE098430000D146 /* queue-tip.xcodeproj */;
-			proxyType = 2;
-			remoteGlobalIDString = 9BECABC81E944C0400ED341E;
-			remoteInfo = "queue-tip";
-		};
-		9BEBA57720127D4400E6FD0D /* PBXContainerItemProxy */ = {
-			isa = PBXContainerItemProxy;
-			containerPortal = C927F35F10FD7F1000C5AB8B /* ddt.xcodeproj */;
-			proxyType = 1;
-			remoteGlobalIDString = FCFA5A9F10D1AE050074F59A;
-			remoteInfo = ddt;
-		};
-		C00B0E131C5AEED6000330B3 /* PBXContainerItemProxy */ = {
-			isa = PBXContainerItemProxy;
-			containerPortal = 08FB7793FE84155DC02AAC07 /* Project object */;
-			proxyType = 1;
-			remoteGlobalIDString = C00B0DF01C5AEBBE000330B3;
-			remoteInfo = "libdispatch dyld stub";
-		};
-		C01866C11C597AEA0040FC07 /* PBXContainerItemProxy */ = {
-			isa = PBXContainerItemProxy;
-			containerPortal = 08FB7793FE84155DC02AAC07 /* Project object */;
-			proxyType = 1;
-			remoteGlobalIDString = C01866A41C5973210040FC07;
-			remoteInfo = "libdispatch static";
-		};
-		C927F36610FD7F1000C5AB8B /* PBXContainerItemProxy */ = {
-			isa = PBXContainerItemProxy;
-			containerPortal = C927F35F10FD7F1000C5AB8B /* ddt.xcodeproj */;
-			proxyType = 2;
-			remoteGlobalIDString = FCFA5AA010D1AE050074F59A;
-			remoteInfo = ddt;
-		};
-		C927F36810FD7F1A00C5AB8B /* PBXContainerItemProxy */ = {
-			isa = PBXContainerItemProxy;
-			containerPortal = C927F35F10FD7F1000C5AB8B /* ddt.xcodeproj */;
-			proxyType = 1;
-			remoteGlobalIDString = FCFA5A9F10D1AE050074F59A;
-			remoteInfo = ddt;
-		};
-		E4128E4913B94BCE00ABB2CB /* PBXContainerItemProxy */ = {
-			isa = PBXContainerItemProxy;
-			containerPortal = 08FB7793FE84155DC02AAC07 /* Project object */;
-			proxyType = 1;
-			remoteGlobalIDString = D2AAC045055464E500DB518D;
-			remoteInfo = libdispatch;
-		};
-		E47D6ECC125FEBA10070D91C /* PBXContainerItemProxy */ = {
-			isa = PBXContainerItemProxy;
-			containerPortal = 08FB7793FE84155DC02AAC07 /* Project object */;
-			proxyType = 1;
-			remoteGlobalIDString = E4EC121612514715000DDBD1;
-			remoteInfo = "libdispatch mp resolved";
-		};
-		E49BB6F71E7074C100868613 /* PBXContainerItemProxy */ = {
-			isa = PBXContainerItemProxy;
-			containerPortal = 08FB7793FE84155DC02AAC07 /* Project object */;
-			proxyType = 1;
-			remoteGlobalIDString = E49BB6CE1E70748100868613;
-			remoteInfo = "libdispatch armv81 resolved";
-		};
-/* End PBXContainerItemProxy section */
-
-/* Begin PBXCopyFilesBuildPhase section */
-		6EA283D61CAB933E0041B2E0 /* Copy Trace Definitions */ = {
-			isa = PBXCopyFilesBuildPhase;
-			buildActionMask = 8;
-			dstPath = "$(INSTALL_PATH_PREFIX)/usr/local/share/misc";
-			dstSubfolderSpec = 0;
-			files = (
-				6EA283D71CAB93920041B2E0 /* libdispatch.codes in Copy Trace Definitions */,
-			);
-			name = "Copy Trace Definitions";
-			runOnlyForDeploymentPostprocessing = 1;
-		};
-/* End PBXCopyFilesBuildPhase section */
-
-/* Begin PBXFileReference section */
-		2BBF5A5F154B64D8002B20F9 /* allocator_internal.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = allocator_internal.h; sourceTree = "<group>"; };
-		2BBF5A62154B64F5002B20F9 /* allocator.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = allocator.c; sourceTree = "<group>"; };
-		2BE17C6318EA305E002CA4E8 /* layout_private.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = layout_private.h; sourceTree = "<group>"; };
-		4552536E19B1384900B88766 /* libdispatchtest.xcodeproj */ = {isa = PBXFileReference; lastKnownFileType = "wrapper.pb-project"; name = libdispatchtest.xcodeproj; path = tests/libdispatchtest.xcodeproj; sourceTree = "<group>"; };
-		5A0095A110F274B0000E2A31 /* io_internal.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = io_internal.h; sourceTree = "<group>"; };
-		5A27262510F26F1900751FBC /* io.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; lineEnding = 0; path = io.c; sourceTree = "<group>"; xcLanguageSpecificationIdentifier = xcode.lang.c; };
-		5A5D13AB0F6B280500197CC3 /* semaphore_internal.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = semaphore_internal.h; sourceTree = "<group>"; };
-		5AAB45BF10D30B79004407EA /* data.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; lineEnding = 0; path = data.c; sourceTree = "<group>"; xcLanguageSpecificationIdentifier = xcode.lang.c; };
-		5AAB45C310D30CC7004407EA /* io.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = io.h; sourceTree = "<group>"; tabWidth = 8; };
-		5AAB45C510D30D0C004407EA /* data.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = data.h; sourceTree = "<group>"; tabWidth = 8; };
-		6E040C631C499B1B00411A2E /* libfirehose_kernel.a */ = {isa = PBXFileReference; explicitFileType = archive.ar; includeInIndex = 0; path = libfirehose_kernel.a; sourceTree = BUILT_PRODUCTS_DIR; };
-		6E040C721C499C3600411A2E /* libfirehose_kernel.xcconfig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.xcconfig; path = libfirehose_kernel.xcconfig; sourceTree = "<group>"; };
-		6E1612691C79606E006FC9A9 /* dispatch_queue_label.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = dispatch_queue_label.c; sourceTree = "<group>"; };
-		6E21F2E41BBB23F00000C6A5 /* firehose_server_internal.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = firehose_server_internal.h; sourceTree = "<group>"; };
-		6E21F2E51BBB23F00000C6A5 /* firehose_server.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = firehose_server.c; sourceTree = "<group>"; };
-		6E2464E21F5E67E20031ADD9 /* check-order.sh */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.script.sh; path = "check-order.sh"; sourceTree = "<group>"; };
-		6E29394C1FB9526E00FDAC90 /* libdispatch.plist */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist.xml; path = libdispatch.plist; sourceTree = "<group>"; };
-		6E326A8F1C2245C4002A6505 /* dispatch_transform.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = dispatch_transform.c; sourceTree = "<group>"; };
-		6E326AB11C224830002A6505 /* dispatch_cascade.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = dispatch_cascade.c; sourceTree = "<group>"; };
-		6E326AB31C224870002A6505 /* dispatch_qos.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = dispatch_qos.c; sourceTree = "<group>"; };
-		6E326AB51C225477002A6505 /* dispatch_proc.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = dispatch_proc.c; sourceTree = "<group>"; };
-		6E326AB71C225FCA002A6505 /* dispatch_vnode.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = dispatch_vnode.c; sourceTree = "<group>"; };
-		6E326AB91C229866002A6505 /* dispatch_read.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = dispatch_read.c; sourceTree = "<group>"; };
-		6E326ABB1C229895002A6505 /* dispatch_read2.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = dispatch_read2.c; sourceTree = "<group>"; };
-		6E326ABD1C22A577002A6505 /* dispatch_io_net.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = dispatch_io_net.c; sourceTree = "<group>"; };
-		6E326ABE1C22A577002A6505 /* dispatch_io.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = dispatch_io.c; sourceTree = "<group>"; };
-		6E326AD81C233209002A6505 /* dispatch_sync_gc.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = dispatch_sync_gc.m; sourceTree = "<group>"; };
-		6E326AD91C233209002A6505 /* dispatch_sync_on_main.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = dispatch_sync_on_main.c; sourceTree = "<group>"; };
-		6E326ADC1C234396002A6505 /* dispatch_readsync.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = dispatch_readsync.c; sourceTree = "<group>"; };
-		6E326ADE1C23451A002A6505 /* dispatch_concur.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = dispatch_concur.c; sourceTree = "<group>"; };
-		6E326AE01C234780002A6505 /* dispatch_starfish.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = dispatch_starfish.c; sourceTree = "<group>"; };
-		6E326AE61C2392E8002A6505 /* dispatch_timer.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = dispatch_timer.c; sourceTree = "<group>"; };
-		6E326AEF1C239303002A6505 /* dispatch_context_for_key.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = dispatch_context_for_key.c; sourceTree = "<group>"; };
-		6E326B121C239431002A6505 /* dispatch_suspend_timer.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = dispatch_suspend_timer.c; sourceTree = "<group>"; };
-		6E326B131C239431002A6505 /* dispatch_timer_bit.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = dispatch_timer_bit.c; sourceTree = "<group>"; };
-		6E326B151C239431002A6505 /* dispatch_timer_set_time.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = dispatch_timer_set_time.c; sourceTree = "<group>"; };
-		6E326B161C239431002A6505 /* dispatch_timer_short.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = dispatch_timer_short.c; sourceTree = "<group>"; };
-		6E326B171C239431002A6505 /* dispatch_timer_timeout.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = dispatch_timer_timeout.c; sourceTree = "<group>"; };
-		6E326B441C239B61002A6505 /* dispatch_priority.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = dispatch_priority.c; sourceTree = "<group>"; };
-		6E49BF2420E34B43002624FC /* libdispatch.clean */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = libdispatch.clean; sourceTree = "<group>"; };
-		6E49BF2920E34B44002624FC /* libdispatch.dirty */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = libdispatch.dirty; sourceTree = "<group>"; };
-		6E4BACBC1D48A41500B562AE /* mach.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = mach.c; sourceTree = "<group>"; };
-		6E4BACC91D48A89500B562AE /* mach_internal.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = mach_internal.h; sourceTree = "<group>"; };
-		6E4FC9D11C84123600520351 /* os_venture_basic.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = os_venture_basic.c; sourceTree = "<group>"; };
-		6E5662DC1F8C2E3E00BC2474 /* workqueue_internal.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = workqueue_internal.h; sourceTree = "<group>"; };
-		6E5662E41F8C2E5B00BC2474 /* workqueue.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = workqueue.c; sourceTree = "<group>"; };
-		6E5ACCB01D3C4CFB007DA2B4 /* event_kevent.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = event_kevent.c; sourceTree = "<group>"; };
-		6E5ACCB91D3C4D0B007DA2B4 /* event_internal.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = event_internal.h; sourceTree = "<group>"; };
-		6E5ACCBD1D3C6719007DA2B4 /* event.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = event.c; sourceTree = "<group>"; };
-		6E67D8D31C16C20B00FC98AC /* dispatch_apply.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = dispatch_apply.c; sourceTree = "<group>"; };
-		6E67D8D91C16C94B00FC98AC /* dispatch_cf_main.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = dispatch_cf_main.c; sourceTree = "<group>"; };
-		6E67D90D1C16CCEB00FC98AC /* dispatch_debug.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = dispatch_debug.c; sourceTree = "<group>"; };
-		6E67D90F1C16CF0B00FC98AC /* dispatch_group.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = dispatch_group.c; sourceTree = "<group>"; };
-		6E67D9111C17669C00FC98AC /* dispatch_queue_finalizer.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = dispatch_queue_finalizer.c; sourceTree = "<group>"; };
-		6E67D9131C17676D00FC98AC /* dispatch_overcommit.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = dispatch_overcommit.c; sourceTree = "<group>"; };
-		6E67D9151C1768B300FC98AC /* dispatch_pingpong.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = dispatch_pingpong.c; sourceTree = "<group>"; };
-		6E67D9171C17BA7200FC98AC /* nsoperation.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = nsoperation.m; sourceTree = "<group>"; };
-		6E70181C1F4EB51B0077C1DC /* workloop_private.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = workloop_private.h; sourceTree = "<group>"; };
-		6E8E4E6D1C1A35EE0004F5CC /* dispatch_select.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = dispatch_select.c; sourceTree = "<group>"; };
-		6E8E4E6E1C1A35EE0004F5CC /* test_lib.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = test_lib.c; sourceTree = "<group>"; };
-		6E8E4E6F1C1A35EE0004F5CC /* test_lib.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = test_lib.h; sourceTree = "<group>"; };
-		6E8E4E9B1C1A4EF10004F5CC /* dispatch_sema.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = dispatch_sema.c; sourceTree = "<group>"; };
-		6E8E4EC31C1A57760004F5CC /* dispatch_after.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = dispatch_after.c; sourceTree = "<group>"; };
-		6E8E4EC51C1A5D450004F5CC /* cf_file_descriptor.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = cf_file_descriptor.c; sourceTree = "<group>"; };
-		6E8E4EC71C1A61680004F5CC /* dispatch_data.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = dispatch_data.m; sourceTree = "<group>"; };
-		6E8E4EC91C1A670B0004F5CC /* dispatch_vm.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = dispatch_vm.c; sourceTree = "<group>"; };
-		6E8E4ECB1C1A72650004F5CC /* dispatch_drift.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = dispatch_drift.c; sourceTree = "<group>"; };
-		6E9926711D01295F000CB89A /* dispatch_block.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = dispatch_block.c; sourceTree = "<group>"; };
-		6E9955571C3AF7710071D40C /* venture_private.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = venture_private.h; sourceTree = "<group>"; };
-		6E9955CE1C3B218E0071D40C /* venture.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = venture.c; sourceTree = "<group>"; };
-		6E9956061C3B21AA0071D40C /* venture_internal.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = venture_internal.h; sourceTree = "<group>"; };
-		6E9B6B201BB4CC73009E324D /* firehose_buffer_internal.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = firehose_buffer_internal.h; sourceTree = "<group>"; };
-		6E9C6CA220F9848000EA81C0 /* yield.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; name = yield.c; path = shims/yield.c; sourceTree = "<group>"; };
-		6EA283D01CAB93270041B2E0 /* libdispatch.codes */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = libdispatch.codes; sourceTree = "<group>"; };
-		6EA2CB841C005DEF0076794A /* dispatch_source.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = dispatch_source.c; sourceTree = "<group>"; };
-		6EA7937D1D456D1300929B1B /* event_epoll.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = event_epoll.c; sourceTree = "<group>"; };
-		6EA793881D458A5800929B1B /* event_config.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = event_config.h; sourceTree = "<group>"; };
-		6EB4E4091BA8BCAD00D7B9D2 /* libfirehose_server.a */ = {isa = PBXFileReference; explicitFileType = archive.ar; includeInIndex = 0; path = libfirehose_server.a; sourceTree = BUILT_PRODUCTS_DIR; };
-		6EB4E4421BA8BD7800D7B9D2 /* libfirehose.xcconfig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.xcconfig; path = libfirehose.xcconfig; sourceTree = "<group>"; };
-		6EB60D291BBB19640092FA94 /* firehose_inline_internal.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = firehose_inline_internal.h; sourceTree = "<group>"; };
-		6EC5ABE31D4436E4004F8674 /* dispatch_deadname.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = dispatch_deadname.c; sourceTree = "<group>"; };
-		6EC670C61E37E201004F10D6 /* dispatch_network_event_thread.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = dispatch_network_event_thread.c; sourceTree = "<group>"; };
-		6EC670C71E37E201004F10D6 /* perf_mach_async.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = perf_mach_async.c; sourceTree = "<group>"; };
-		6EC670C81E37E201004F10D6 /* perf_pipepingpong.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = perf_pipepingpong.c; sourceTree = "<group>"; };
-		6EDB888D1CB73BDC006776D6 /* dispatch_kevent_cancel_races.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = dispatch_kevent_cancel_races.c; sourceTree = "<group>"; };
-		6EDF10831BBB487E007F14BF /* firehose_buffer_private.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = firehose_buffer_private.h; sourceTree = "<group>"; };
-		6EE89F3D1BFAF5B000EB140D /* dispatch_state_machine.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = dispatch_state_machine.c; sourceTree = "<group>"; };
-		6EF0B26A1BA8C4AE007FA4F6 /* firehose_internal.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = firehose_internal.h; sourceTree = "<group>"; };
-		6EF2CAA41C88998A001ABE83 /* lock.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = lock.h; sourceTree = "<group>"; };
-		6EF2CAAB1C8899D5001ABE83 /* lock.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; name = lock.c; path = shims/lock.c; sourceTree = "<group>"; };
-		6EFBDA4A1D61A0D600282887 /* priority.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = priority.h; sourceTree = "<group>"; };
-		721F5C5C0F15520500FF03A6 /* semaphore.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = semaphore.h; sourceTree = "<group>"; };
-		721F5CCE0F15553500FF03A6 /* semaphore.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; lineEnding = 0; path = semaphore.c; sourceTree = "<group>"; xcLanguageSpecificationIdentifier = xcode.lang.c; };
-		72406A031AF95DF800DF4E2B /* firehose_reply.defs */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.mig; path = firehose_reply.defs; sourceTree = "<group>"; };
-		72406A391AF9926000DF4E2B /* firehose_types.defs */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.mig; path = firehose_types.defs; sourceTree = "<group>"; };
-		72B54F690EB169EB00DBECBA /* dispatch_source_create.3 */ = {isa = PBXFileReference; explicitFileType = text.man; fileEncoding = 4; path = dispatch_source_create.3; sourceTree = "<group>"; };
-		72CC940C0ECCD5720031B751 /* dispatch_object.3 */ = {isa = PBXFileReference; explicitFileType = text.man; fileEncoding = 4; path = dispatch_object.3; sourceTree = "<group>"; };
-		72CC940D0ECCD5720031B751 /* dispatch.3 */ = {isa = PBXFileReference; explicitFileType = text.man; fileEncoding = 4; path = dispatch.3; sourceTree = "<group>"; };
-		72CC942F0ECCD8750031B751 /* base.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = base.h; sourceTree = "<group>"; };
-		72DEAA971AE181D300289540 /* firehose_buffer.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = firehose_buffer.c; sourceTree = "<group>"; };
-		72DEAA9B1AE1B0BD00289540 /* firehose.defs */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.mig; path = firehose.defs; sourceTree = "<group>"; };
-		72DEAA9D1AE1BB7300289540 /* firehose_server_object.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = firehose_server_object.m; sourceTree = "<group>"; };
-		72EA3FBA1AF41EA400BBA227 /* firehose_server_private.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = firehose_server_private.h; sourceTree = "<group>"; };
-		924D8EAA1C116B9F002AC2BC /* dispatch_c99.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = dispatch_c99.c; sourceTree = "<group>"; };
-		92F3FE8F1BEC686300025962 /* dispatch_api.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = dispatch_api.c; sourceTree = "<group>"; };
-		92F3FE921BEC686300025962 /* Makefile */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.make; path = Makefile; sourceTree = "<group>"; };
-		96032E4A0F5CC8C700241C5F /* time.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = time.c; sourceTree = "<group>"; };
-		96032E4C0F5CC8D100241C5F /* time.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = time.h; sourceTree = "<group>"; };
-		960F0E7D0F3FB232000D88BF /* dispatch_apply.3 */ = {isa = PBXFileReference; explicitFileType = text.man; fileEncoding = 4; path = dispatch_apply.3; sourceTree = "<group>"; };
-		960F0E7E0F3FB232000D88BF /* dispatch_once.3 */ = {isa = PBXFileReference; explicitFileType = text.man; fileEncoding = 4; path = dispatch_once.3; sourceTree = "<group>"; };
-		961B99350F3E83980006BC96 /* benchmark.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = benchmark.h; sourceTree = "<group>"; };
-		961B994F0F3E85C30006BC96 /* object.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = object.h; sourceTree = "<group>"; };
-		963FDDE50F3FB6BD00BF2D00 /* dispatch_semaphore_create.3 */ = {isa = PBXFileReference; explicitFileType = text.man; fileEncoding = 4; path = dispatch_semaphore_create.3; sourceTree = "<group>"; };
-		965CD6340F3E806200D4E28D /* benchmark.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = benchmark.c; sourceTree = "<group>"; };
-		965ECC200F3EAB71004DDD89 /* object_internal.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = object_internal.h; sourceTree = "<group>"; };
-		9661E56A0F3E7DDF00749F3E /* object.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; lineEnding = 0; path = object.c; sourceTree = "<group>"; xcLanguageSpecificationIdentifier = xcode.lang.c; };
-		9676A0E00F3E755D00713ADB /* apply.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; lineEnding = 0; path = apply.c; sourceTree = "<group>"; xcLanguageSpecificationIdentifier = xcode.lang.c; };
-		96859A3D0EF71BAD003EB3FB /* dispatch_benchmark.3 */ = {isa = PBXFileReference; explicitFileType = text.man; fileEncoding = 4; path = dispatch_benchmark.3; sourceTree = "<group>"; };
-		96929D820F3EA1020041FF5D /* atomic.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; lineEnding = 0; path = atomic.h; sourceTree = "<group>"; xcLanguageSpecificationIdentifier = xcode.lang.objcpp; };
-		96929D830F3EA1020041FF5D /* shims.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = shims.h; sourceTree = "<group>"; };
-		96929D950F3EA2170041FF5D /* queue_internal.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; lineEnding = 0; path = queue_internal.h; sourceTree = "<group>"; xcLanguageSpecificationIdentifier = xcode.lang.objcpp; };
-		96A8AA860F41E7A400CD570B /* source.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; lineEnding = 0; path = source.c; sourceTree = "<group>"; xcLanguageSpecificationIdentifier = xcode.lang.c; };
-		96BC39BC0F3EBAB100C59689 /* queue_private.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = queue_private.h; sourceTree = "<group>"; };
-		96C9553A0F3EAEDD000D2CA4 /* once.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = once.h; sourceTree = "<group>"; };
-		96DF70BD0F38FE3C0074BD99 /* once.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; lineEnding = 0; path = once.c; sourceTree = "<group>"; xcLanguageSpecificationIdentifier = xcode.lang.c; };
-		9B6A42E01FE098430000D146 /* queue-tip.xcodeproj */ = {isa = PBXFileReference; lastKnownFileType = "wrapper.pb-project"; name = "queue-tip.xcodeproj"; path = "tools/queue-tip/queue-tip.xcodeproj"; sourceTree = "<group>"; };
-		B63B793F1E8F004F0060C1E1 /* dispatch_no_blocks.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; path = dispatch_no_blocks.c; sourceTree = "<group>"; };
-		B68330BC1EBCF6080003E71C /* dispatch_wl.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; path = dispatch_wl.c; sourceTree = "<group>"; };
-		B683588A1FA77F4900AA0D58 /* time_private.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = time_private.h; sourceTree = "<group>"; };
-		B68358911FA77FFD00AA0D58 /* dispatch_time.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = dispatch_time.c; sourceTree = "<group>"; };
-		B69878521F06F8790088F94F /* dispatch_signals.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; path = dispatch_signals.c; sourceTree = "<group>"; };
-		B6AC73FD1EB10973009FB2F2 /* perf_thread_request.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; path = perf_thread_request.c; sourceTree = "<group>"; };
-		B6AE9A4A1D7F53B300AC007F /* dispatch_queue_create.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = dispatch_queue_create.c; sourceTree = "<group>"; };
-		B6AE9A561D7F53C100AC007F /* perf_async_bench.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = perf_async_bench.m; sourceTree = "<group>"; };
-		B6AE9A581D7F53CB00AC007F /* perf_bench.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = perf_bench.m; sourceTree = "<group>"; };
-		B6FA01801F0AD522004479BF /* dispatch_pthread_root_queue.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; path = dispatch_pthread_root_queue.c; sourceTree = "<group>"; };
-		C00B0E0A1C5AEBBE000330B3 /* libdispatch_dyld_stub.a */ = {isa = PBXFileReference; explicitFileType = archive.ar; includeInIndex = 0; path = libdispatch_dyld_stub.a; sourceTree = BUILT_PRODUCTS_DIR; };
-		C00B0E121C5AEBF7000330B3 /* libdispatch-dyld-stub.xcconfig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.xcconfig; path = "libdispatch-dyld-stub.xcconfig"; sourceTree = "<group>"; };
-		C01866BD1C5973210040FC07 /* libdispatch.a */ = {isa = PBXFileReference; explicitFileType = archive.ar; includeInIndex = 0; path = libdispatch.a; sourceTree = BUILT_PRODUCTS_DIR; };
-		C01866BE1C59735B0040FC07 /* libdispatch-mp-static.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; path = "libdispatch-mp-static.xcconfig"; sourceTree = "<group>"; };
-		C01866BF1C5976C90040FC07 /* run-on-install.sh */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.script.sh; path = "run-on-install.sh"; sourceTree = "<group>"; };
-		C901445E1C73A7FE002638FC /* module.modulemap */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = "sourcecode.module-map"; name = module.modulemap; path = darwin/module.modulemap; sourceTree = "<group>"; };
-		C90144641C73A845002638FC /* module.modulemap */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = "sourcecode.module-map"; name = module.modulemap; path = darwin/module.modulemap; sourceTree = "<group>"; };
-		C913AC0E143BD34800B78976 /* data_private.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = data_private.h; sourceTree = "<group>"; tabWidth = 8; };
-		C927F35F10FD7F1000C5AB8B /* ddt.xcodeproj */ = {isa = PBXFileReference; lastKnownFileType = "wrapper.pb-project"; name = ddt.xcodeproj; path = tools/ddt/ddt.xcodeproj; sourceTree = "<group>"; };
-		C96CE17A1CEB851600F4B8E6 /* dispatch_objc.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = dispatch_objc.m; sourceTree = "<group>"; };
-		C9C5F80D143C1771006DC718 /* transform.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = transform.c; sourceTree = "<group>"; };
-		D2AAC046055464E500DB518D /* libdispatch.dylib */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.dylib"; includeInIndex = 0; path = libdispatch.dylib; sourceTree = BUILT_PRODUCTS_DIR; };
-		E40041A9125D70590022B135 /* libdispatch-resolved.xcconfig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.xcconfig; path = "libdispatch-resolved.xcconfig"; sourceTree = "<group>"; };
-		E40041AA125D705F0022B135 /* libdispatch-resolver.xcconfig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.xcconfig; path = "libdispatch-resolver.xcconfig"; sourceTree = "<group>"; };
-		E4128ED513BA9A1700ABB2CB /* hw_config.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = hw_config.h; sourceTree = "<group>"; };
-		E420866F16027AE500EEE210 /* data.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = data.m; sourceTree = "<group>"; };
-		E421E5F81716ADA10090DC9B /* introspection.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = introspection.h; sourceTree = "<group>"; };
-		E421E5FB1716B8730090DC9B /* install-dtrace.sh */ = {isa = PBXFileReference; lastKnownFileType = text.script.sh; path = "install-dtrace.sh"; sourceTree = "<group>"; };
-		E421E5FD1716BEA70090DC9B /* libdispatch.interposable */ = {isa = PBXFileReference; lastKnownFileType = text; path = libdispatch.interposable; sourceTree = "<group>"; };
-		E422A0D412A557B5005E5BDB /* trace.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = trace.h; sourceTree = "<group>"; };
-		E422DA3614D2A7E7003C6EE4 /* libdispatch.aliases */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = libdispatch.aliases; sourceTree = "<group>"; };
-		E43570B8126E93380097AB9F /* provider.d */ = {isa = PBXFileReference; explicitFileType = sourcecode.dtrace; fileEncoding = 4; path = provider.d; sourceTree = "<group>"; };
-		E43A724F1AF85BBC00BAA921 /* block.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = block.cpp; sourceTree = "<group>"; };
-		E43D93F11097917E004F6A62 /* libdispatch.xcconfig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.xcconfig; path = libdispatch.xcconfig; sourceTree = "<group>"; };
-		E44757D917F4572600B82CA1 /* inline_internal.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = inline_internal.h; sourceTree = "<group>"; };
-		E448727914C6215D00BB45C2 /* libdispatch.order */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = libdispatch.order; sourceTree = "<group>"; };
-		E44A8E6A1805C3E0009FFDB6 /* voucher.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = voucher.c; sourceTree = "<group>"; };
-		E44A8E711805C473009FFDB6 /* voucher_private.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = voucher_private.h; sourceTree = "<group>"; };
-		E44A8E7418066276009FFDB6 /* voucher_internal.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = voucher_internal.h; sourceTree = "<group>"; };
-		E44EBE331251654000645D88 /* resolver.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = resolver.h; sourceTree = "<group>"; };
-		E44EBE371251656400645D88 /* resolver.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = resolver.c; sourceTree = "<group>"; };
-		E44EBE3B1251659900645D88 /* init.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = init.c; sourceTree = "<group>"; };
-		E44F9DA816543F79001DCD38 /* introspection_internal.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = introspection_internal.h; sourceTree = "<group>"; };
-		E454569214746F1B00106147 /* object_private.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = object_private.h; sourceTree = "<group>"; };
-		E463024F1761603C00E11F4C /* atomic_sfb.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = atomic_sfb.h; sourceTree = "<group>"; };
-		E47D6BB5125F0F800070D91C /* resolved.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = resolved.h; sourceTree = "<group>"; };
-		E482F1CD12DBAB590030614D /* postprocess-headers.sh */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.script.sh; path = "postprocess-headers.sh"; sourceTree = "<group>"; };
-		E48AF55916E70FD9004105FF /* io_private.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = io_private.h; path = private/io_private.h; sourceTree = SOURCE_ROOT; tabWidth = 8; };
-		E48EC97B1835BADD00EAC4F1 /* yield.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = yield.h; sourceTree = "<group>"; };
-		E49BB6F21E70748100868613 /* libdispatch_armv81.a */ = {isa = PBXFileReference; explicitFileType = archive.ar; includeInIndex = 0; path = libdispatch_armv81.a; sourceTree = BUILT_PRODUCTS_DIR; };
-		E49F24DF125D57FA0057C971 /* libdispatch.dylib */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.dylib"; includeInIndex = 0; path = libdispatch.dylib; sourceTree = BUILT_PRODUCTS_DIR; };
-		E49F251D125D630A0057C971 /* install-manpages.sh */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.script.sh; path = "install-manpages.sh"; sourceTree = "<group>"; };
-		E49F251E125D631D0057C971 /* mig-headers.sh */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.script.sh; path = "mig-headers.sh"; sourceTree = "<group>"; };
-		E4B3C3FD18C50D000039F49F /* voucher_activity_private.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = voucher_activity_private.h; sourceTree = "<group>"; };
-		E4B515D6164B2DA300E003AF /* libdispatch.dylib */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.dylib"; includeInIndex = 0; path = libdispatch.dylib; sourceTree = BUILT_PRODUCTS_DIR; };
-		E4B515D7164B2DFB00E003AF /* introspection_private.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = introspection_private.h; sourceTree = "<group>"; };
-		E4B515D9164B2E9B00E003AF /* libdispatch-introspection.xcconfig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.xcconfig; path = "libdispatch-introspection.xcconfig"; sourceTree = "<group>"; };
-		E4B515DC164B32E000E003AF /* introspection.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = introspection.c; sourceTree = "<group>"; };
-		E4BA743513A88FE10095BDF1 /* dispatch_data_create.3 */ = {isa = PBXFileReference; explicitFileType = text.man; path = dispatch_data_create.3; sourceTree = "<group>"; };
-		E4BA743613A88FF30095BDF1 /* dispatch_io_create.3 */ = {isa = PBXFileReference; explicitFileType = text.man; path = dispatch_io_create.3; sourceTree = "<group>"; };
-		E4BA743713A88FF30095BDF1 /* dispatch_io_read.3 */ = {isa = PBXFileReference; explicitFileType = text.man; path = dispatch_io_read.3; sourceTree = "<group>"; };
-		E4BA743813A8900B0095BDF1 /* dispatch_read.3 */ = {isa = PBXFileReference; explicitFileType = text.man; path = dispatch_read.3; sourceTree = "<group>"; };
-		E4BA743913A8911B0095BDF1 /* getprogname.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = getprogname.h; sourceTree = "<group>"; };
-		E4C1ED6E1263E714000D3C8B /* data_internal.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = data_internal.h; sourceTree = "<group>"; };
-		E4D76A9218E325D200B1F98B /* block.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = block.h; sourceTree = "<group>"; };
-		E4EB4A2614C35ECE00AA0FA9 /* object.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = object.h; sourceTree = "<group>"; };
-		E4EB4A2A14C36F4E00AA0FA9 /* install-headers.sh */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.script.sh; path = "install-headers.sh"; sourceTree = "<group>"; };
-		E4EC122D12514715000DDBD1 /* libdispatch_mp.a */ = {isa = PBXFileReference; explicitFileType = archive.ar; includeInIndex = 0; path = libdispatch_mp.a; sourceTree = BUILT_PRODUCTS_DIR; };
-		E4ECBAA415253C25002C313C /* mach_private.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = mach_private.h; sourceTree = "<group>"; };
-		E4FB8E90218CD7F8004B7A25 /* install-plists.sh */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.script.sh; path = "install-plists.sh"; sourceTree = "<group>"; };
-		E4FC3263145F46C9002FBDDB /* object.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = object.m; sourceTree = "<group>"; };
-		EA53C60E1BFEA851000A02EA /* bsdtestharness.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = bsdtestharness.c; path = tests/bsdtestharness.c; sourceTree = "<group>"; };
-		EA53C60F1BFEA851000A02EA /* bsdtests.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = bsdtests.c; path = tests/bsdtests.c; sourceTree = "<group>"; };
-		EA53C6101BFEA851000A02EA /* bsdtests.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = bsdtests.h; path = tests/bsdtests.h; sourceTree = "<group>"; };
-		EA53C6111BFEA851000A02EA /* bsdtestsummarize.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = bsdtestsummarize.c; path = tests/bsdtestsummarize.c; sourceTree = "<group>"; };
-		EA53C6121BFEA851000A02EA /* cffd.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = cffd.c; path = tests/cffd.c; sourceTree = "<group>"; };
-		EA53C6131BFEA851000A02EA /* dispatch_after.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = dispatch_after.c; path = tests/dispatch_after.c; sourceTree = "<group>"; };
-		EA53C6141BFEA851000A02EA /* dispatch_api.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = dispatch_api.c; path = tests/dispatch_api.c; sourceTree = "<group>"; };
-		EA53C6151BFEA851000A02EA /* dispatch_apply.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = dispatch_apply.c; path = tests/dispatch_apply.c; sourceTree = "<group>"; };
-		EA53C6161BFEA851000A02EA /* dispatch_c99.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = dispatch_c99.c; path = tests/dispatch_c99.c; sourceTree = "<group>"; };
-		EA53C6171BFEA851000A02EA /* dispatch_cascade.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = dispatch_cascade.c; path = tests/dispatch_cascade.c; sourceTree = "<group>"; };
-		EA53C6181BFEA851000A02EA /* dispatch_cf_main.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = dispatch_cf_main.c; path = tests/dispatch_cf_main.c; sourceTree = "<group>"; };
-		EA53C6191BFEA851000A02EA /* dispatch_concur.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = dispatch_concur.c; path = tests/dispatch_concur.c; sourceTree = "<group>"; };
-		EA53C61A1BFEA851000A02EA /* dispatch_context_for_key.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = dispatch_context_for_key.c; path = tests/dispatch_context_for_key.c; sourceTree = "<group>"; };
-		EA53C61B1BFEA851000A02EA /* dispatch_data.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = dispatch_data.c; path = tests/dispatch_data.c; sourceTree = "<group>"; };
-		EA53C61C1BFEA851000A02EA /* dispatch_deadname.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = dispatch_deadname.c; path = tests/dispatch_deadname.c; sourceTree = "<group>"; };
-		EA53C61D1BFEA851000A02EA /* dispatch_debug.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = dispatch_debug.c; path = tests/dispatch_debug.c; sourceTree = "<group>"; };
-		EA53C61E1BFEA851000A02EA /* dispatch_drift.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = dispatch_drift.c; path = tests/dispatch_drift.c; sourceTree = "<group>"; };
-		EA53C61F1BFEA851000A02EA /* dispatch_group.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = dispatch_group.c; path = tests/dispatch_group.c; sourceTree = "<group>"; };
-		EA53C6201BFEA851000A02EA /* dispatch_io_net.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = dispatch_io_net.c; path = tests/dispatch_io_net.c; sourceTree = "<group>"; };
-		EA53C6211BFEA851000A02EA /* dispatch_io.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = dispatch_io.c; path = tests/dispatch_io.c; sourceTree = "<group>"; };
-		EA53C6221BFEA851000A02EA /* dispatch_overcommit.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = dispatch_overcommit.c; path = tests/dispatch_overcommit.c; sourceTree = "<group>"; };
-		EA53C6231BFEA851000A02EA /* dispatch_pingpong.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = dispatch_pingpong.c; path = tests/dispatch_pingpong.c; sourceTree = "<group>"; };
-		EA53C6241BFEA851000A02EA /* dispatch_plusplus.cpp */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.cpp.cpp; name = dispatch_plusplus.cpp; path = tests/dispatch_plusplus.cpp; sourceTree = "<group>"; };
-		EA53C6251BFEA851000A02EA /* dispatch_priority.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = dispatch_priority.c; path = tests/dispatch_priority.c; sourceTree = "<group>"; };
-		EA53C6261BFEA851000A02EA /* dispatch_proc.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = dispatch_proc.c; path = tests/dispatch_proc.c; sourceTree = "<group>"; };
-		EA53C6271BFEA851000A02EA /* dispatch_queue_finalizer.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = dispatch_queue_finalizer.c; path = tests/dispatch_queue_finalizer.c; sourceTree = "<group>"; };
-		EA53C6281BFEA851000A02EA /* dispatch_read.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = dispatch_read.c; path = tests/dispatch_read.c; sourceTree = "<group>"; };
-		EA53C6291BFEA851000A02EA /* dispatch_read2.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = dispatch_read2.c; path = tests/dispatch_read2.c; sourceTree = "<group>"; };
-		EA53C62A1BFEA851000A02EA /* dispatch_readsync.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = dispatch_readsync.c; path = tests/dispatch_readsync.c; sourceTree = "<group>"; };
-		EA53C62B1BFEA851000A02EA /* dispatch_select.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = dispatch_select.c; path = tests/dispatch_select.c; sourceTree = "<group>"; };
-		EA53C62C1BFEA851000A02EA /* dispatch_sema.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = dispatch_sema.c; path = tests/dispatch_sema.c; sourceTree = "<group>"; };
-		EA53C62D1BFEA851000A02EA /* dispatch_starfish.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = dispatch_starfish.c; path = tests/dispatch_starfish.c; sourceTree = "<group>"; };
-		EA53C62E1BFEA851000A02EA /* dispatch_suspend_timer.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = dispatch_suspend_timer.c; path = tests/dispatch_suspend_timer.c; sourceTree = "<group>"; };
-		EA53C62F1BFEA851000A02EA /* dispatch_sync_on_main.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = dispatch_sync_on_main.c; path = tests/dispatch_sync_on_main.c; sourceTree = "<group>"; };
-		EA53C6301BFEA851000A02EA /* dispatch_test.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = dispatch_test.c; path = tests/dispatch_test.c; sourceTree = "<group>"; };
-		EA53C6311BFEA851000A02EA /* dispatch_test.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = dispatch_test.h; path = tests/dispatch_test.h; sourceTree = "<group>"; };
-		EA53C6321BFEA851000A02EA /* dispatch_timer_bit31.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = dispatch_timer_bit31.c; path = tests/dispatch_timer_bit31.c; sourceTree = "<group>"; };
-		EA53C6331BFEA851000A02EA /* dispatch_timer_bit63.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = dispatch_timer_bit63.c; path = tests/dispatch_timer_bit63.c; sourceTree = "<group>"; };
-		EA53C6341BFEA851000A02EA /* dispatch_timer_set_time.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = dispatch_timer_set_time.c; path = tests/dispatch_timer_set_time.c; sourceTree = "<group>"; };
-		EA53C6351BFEA851000A02EA /* dispatch_timer_short.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = dispatch_timer_short.c; path = tests/dispatch_timer_short.c; sourceTree = "<group>"; };
-		EA53C6361BFEA851000A02EA /* dispatch_timer_timeout.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = dispatch_timer_timeout.c; path = tests/dispatch_timer_timeout.c; sourceTree = "<group>"; };
-		EA53C6371BFEA851000A02EA /* dispatch_timer.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = dispatch_timer.c; path = tests/dispatch_timer.c; sourceTree = "<group>"; };
-		EA53C6381BFEA851000A02EA /* dispatch_transform.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = dispatch_transform.c; path = tests/dispatch_transform.c; sourceTree = "<group>"; };
-		EA53C6391BFEA851000A02EA /* dispatch_vm.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = dispatch_vm.c; path = tests/dispatch_vm.c; sourceTree = "<group>"; };
-		EA53C63A1BFEA851000A02EA /* dispatch_vnode.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = dispatch_vnode.c; path = tests/dispatch_vnode.c; sourceTree = "<group>"; };
-		EA53C63B1BFEA851000A02EA /* func.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; name = func.c; path = tests/func.c; sourceTree = "<group>"; };
-		F7DC045A2060BBBE00C90737 /* target.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = target.h; sourceTree = "<group>"; };
-		FC0B34780FA2851C0080FFA0 /* source_internal.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = source_internal.h; sourceTree = "<group>"; };
-		FC1832A2109923C7003403D5 /* perfmon.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = perfmon.h; sourceTree = "<group>"; };
-		FC1832A3109923C7003403D5 /* time.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = time.h; sourceTree = "<group>"; };
-		FC1832A4109923C7003403D5 /* tsd.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = tsd.h; sourceTree = "<group>"; };
-		FC36279C0E933ED80054F1A3 /* dispatch_queue_create.3 */ = {isa = PBXFileReference; explicitFileType = text.man; fileEncoding = 4; path = dispatch_queue_create.3; sourceTree = "<group>"; };
-		FC5C9C1D0EADABE3006E462D /* group.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = group.h; sourceTree = "<group>"; };
-		FC678DE80F97E0C300AB5993 /* dispatch_after.3 */ = {isa = PBXFileReference; explicitFileType = text.man; fileEncoding = 4; path = dispatch_after.3; sourceTree = "<group>"; };
-		FC678DE90F97E0C300AB5993 /* dispatch_api.3 */ = {isa = PBXFileReference; explicitFileType = text.man; fileEncoding = 4; path = dispatch_api.3; sourceTree = "<group>"; };
-		FC678DEA0F97E0C300AB5993 /* dispatch_async.3 */ = {isa = PBXFileReference; explicitFileType = text.man; fileEncoding = 4; path = dispatch_async.3; sourceTree = "<group>"; };
-		FC678DEB0F97E0C300AB5993 /* dispatch_group_create.3 */ = {isa = PBXFileReference; explicitFileType = text.man; fileEncoding = 4; path = dispatch_group_create.3; sourceTree = "<group>"; };
-		FC678DEC0F97E0C300AB5993 /* dispatch_time.3 */ = {isa = PBXFileReference; explicitFileType = text.man; fileEncoding = 4; path = dispatch_time.3; sourceTree = "<group>"; };
-		FC7BED8A0E8361E600161930 /* queue.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; lineEnding = 0; path = queue.c; sourceTree = "<group>"; xcLanguageSpecificationIdentifier = xcode.lang.c; };
-		FC7BED8B0E8361E600161930 /* queue.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = queue.h; sourceTree = "<group>"; };
-		FC7BED8D0E8361E600161930 /* source.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = source.h; sourceTree = "<group>"; };
-		FC7BED8F0E8361E600161930 /* internal.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = internal.h; sourceTree = "<group>"; };
-		FC7BED930E8361E600161930 /* private.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = private.h; sourceTree = "<group>"; };
-		FC7BED950E8361E600161930 /* protocol.defs */ = {isa = PBXFileReference; explicitFileType = sourcecode.mig; fileEncoding = 4; path = protocol.defs; sourceTree = "<group>"; };
-		FC7BED960E8361E600161930 /* dispatch.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = dispatch.h; sourceTree = "<group>"; };
-		FC9C70E7105EC9620074F9CA /* config.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = config.h; sourceTree = "<group>"; };
-		FCEF047F0F5661960067401F /* source_private.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = source_private.h; sourceTree = "<group>"; };
-/* End PBXFileReference section */
-
-/* Begin PBXFrameworksBuildPhase section */
-		6E040C601C499B1B00411A2E /* Frameworks */ = {
-			isa = PBXFrameworksBuildPhase;
-			buildActionMask = 2147483647;
-			files = (
-			);
-			runOnlyForDeploymentPostprocessing = 0;
-		};
-		E49F24D5125D57FA0057C971 /* Frameworks */ = {
-			isa = PBXFrameworksBuildPhase;
-			buildActionMask = 2147483647;
-			files = (
-			);
-			runOnlyForDeploymentPostprocessing = 0;
-		};
-/* End PBXFrameworksBuildPhase section */
-
-/* Begin PBXGroup section */
-		08FB7794FE84155DC02AAC07 /* libdispatch */ = {
-			isa = PBXGroup;
-			children = (
-				E44DB71E11D2FF080074F2AD /* Build Support */,
-				6E9B6AE21BB39793009E324D /* OS Public Headers */,
-				E4EB4A2914C35F1800AA0FA9 /* OS Private Headers */,
-				FC7BEDAA0E83625200161930 /* Dispatch Public Headers */,
-				FC7BEDAF0E83626100161930 /* Dispatch Private Headers */,
-				FC7BEDB60E8363DC00161930 /* Dispatch Project Headers */,
-				08FB7795FE84155DC02AAC07 /* Dispatch Source */,
-				92F3FEC91BEC687200025962 /* Darwin Tests */,
-				C6A0FF2B0290797F04C91782 /* Documentation */,
-				1AB674ADFE9D54B511CA2CBB /* Products */,
-				EA53C60D1BFE9605000A02EA /* Tests */,
-				9B6A42E01FE098430000D146 /* queue-tip.xcodeproj */,
-				C927F35F10FD7F1000C5AB8B /* ddt.xcodeproj */,
-				4552536E19B1384900B88766 /* libdispatchtest.xcodeproj */,
-			);
-			indentWidth = 4;
-			name = libdispatch;
-			sourceTree = "<group>";
-			tabWidth = 4;
-			usesTabs = 1;
-		};
-		08FB7795FE84155DC02AAC07 /* Dispatch Source */ = {
-			isa = PBXGroup;
-			children = (
-				2BBF5A62154B64F5002B20F9 /* allocator.c */,
-				9676A0E00F3E755D00713ADB /* apply.c */,
-				965CD6340F3E806200D4E28D /* benchmark.c */,
-				E43A724F1AF85BBC00BAA921 /* block.cpp */,
-				5AAB45BF10D30B79004407EA /* data.c */,
-				E420866F16027AE500EEE210 /* data.m */,
-				E44EBE3B1251659900645D88 /* init.c */,
-				E4B515DC164B32E000E003AF /* introspection.c */,
-				5A27262510F26F1900751FBC /* io.c */,
-				6EF2CAAB1C8899D5001ABE83 /* lock.c */,
-				6E4BACBC1D48A41500B562AE /* mach.c */,
-				9661E56A0F3E7DDF00749F3E /* object.c */,
-				E4FC3263145F46C9002FBDDB /* object.m */,
-				96DF70BD0F38FE3C0074BD99 /* once.c */,
-				FC7BED8A0E8361E600161930 /* queue.c */,
-				721F5CCE0F15553500FF03A6 /* semaphore.c */,
-				96A8AA860F41E7A400CD570B /* source.c */,
-				96032E4A0F5CC8C700241C5F /* time.c */,
-				C9C5F80D143C1771006DC718 /* transform.c */,
-				6E9955CE1C3B218E0071D40C /* venture.c */,
-				E44A8E6A1805C3E0009FFDB6 /* voucher.c */,
-				6E9C6CA220F9848000EA81C0 /* yield.c */,
-				6EA283D01CAB93270041B2E0 /* libdispatch.codes */,
-				6E29394C1FB9526E00FDAC90 /* libdispatch.plist */,
-				FC7BED950E8361E600161930 /* protocol.defs */,
-				E43570B8126E93380097AB9F /* provider.d */,
-				6E5ACCAF1D3BF2A0007DA2B4 /* event */,
-				6EF0B2641BA8C3A0007FA4F6 /* firehose */,
-			);
-			name = "Dispatch Source";
-			path = src;
-			sourceTree = "<group>";
-		};
-		1AB674ADFE9D54B511CA2CBB /* Products */ = {
-			isa = PBXGroup;
-			children = (
-				D2AAC046055464E500DB518D /* libdispatch.dylib */,
-				E4B515D6164B2DA300E003AF /* libdispatch.dylib */,
-				E49F24DF125D57FA0057C971 /* libdispatch.dylib */,
-				E4EC122D12514715000DDBD1 /* libdispatch_mp.a */,
-				E49BB6F21E70748100868613 /* libdispatch_armv81.a */,
-				C01866BD1C5973210040FC07 /* libdispatch.a */,
-				C00B0E0A1C5AEBBE000330B3 /* libdispatch_dyld_stub.a */,
-				6E040C631C499B1B00411A2E /* libfirehose_kernel.a */,
-				6EB4E4091BA8BCAD00D7B9D2 /* libfirehose_server.a */,
-			);
-			name = Products;
-			sourceTree = "<group>";
-		};
-		4552536F19B1384900B88766 /* Products */ = {
-			isa = PBXGroup;
-			children = (
-				4552540319B1384900B88766 /* bench */,
-				4552540519B1384900B88766 /* jsgc_bench */,
-				4552540719B1384900B88766 /* async_bench */,
-				4552540919B1384900B88766 /* apply_bench */,
-			);
-			name = Products;
-			sourceTree = "<group>";
-		};
-		6E5ACCAE1D3BF27F007DA2B4 /* event */ = {
-			isa = PBXGroup;
-			children = (
-				6EA793881D458A5800929B1B /* event_config.h */,
-				6E5ACCB91D3C4D0B007DA2B4 /* event_internal.h */,
-				6E5662DC1F8C2E3E00BC2474 /* workqueue_internal.h */,
-			);
-			path = event;
-			sourceTree = "<group>";
-		};
-		6E5ACCAF1D3BF2A0007DA2B4 /* event */ = {
-			isa = PBXGroup;
-			children = (
-				6E5ACCBD1D3C6719007DA2B4 /* event.c */,
-				6E5ACCB01D3C4CFB007DA2B4 /* event_kevent.c */,
-				6EA7937D1D456D1300929B1B /* event_epoll.c */,
-				6E5662E41F8C2E5B00BC2474 /* workqueue.c */,
-			);
-			path = event;
-			sourceTree = "<group>";
-		};
-		6E9B6AE21BB39793009E324D /* OS Public Headers */ = {
-			isa = PBXGroup;
-			children = (
-				E4EB4A2614C35ECE00AA0FA9 /* object.h */,
-			);
-			name = "OS Public Headers";
-			path = os;
-			sourceTree = "<group>";
-		};
-		6EF0B2641BA8C3A0007FA4F6 /* firehose */ = {
-			isa = PBXGroup;
-			children = (
-				72406A391AF9926000DF4E2B /* firehose_types.defs */,
-				72DEAA9B1AE1B0BD00289540 /* firehose.defs */,
-				72406A031AF95DF800DF4E2B /* firehose_reply.defs */,
-				72DEAA971AE181D300289540 /* firehose_buffer.c */,
-				6E21F2E51BBB23F00000C6A5 /* firehose_server.c */,
-				72DEAA9D1AE1BB7300289540 /* firehose_server_object.m */,
-			);
-			path = firehose;
-			sourceTree = "<group>";
-		};
-		6EF0B2661BA8C43D007FA4F6 /* firehose */ = {
-			isa = PBXGroup;
-			children = (
-				6EF0B26A1BA8C4AE007FA4F6 /* firehose_internal.h */,
-				6EB60D291BBB19640092FA94 /* firehose_inline_internal.h */,
-				6E9B6B201BB4CC73009E324D /* firehose_buffer_internal.h */,
-				6E21F2E41BBB23F00000C6A5 /* firehose_server_internal.h */,
-			);
-			path = firehose;
-			sourceTree = "<group>";
-		};
-		92F3FEC91BEC687200025962 /* Darwin Tests */ = {
-			isa = PBXGroup;
-			children = (
-				6E8E4EC51C1A5D450004F5CC /* cf_file_descriptor.c */,
-				6E8E4EC31C1A57760004F5CC /* dispatch_after.c */,
-				92F3FE8F1BEC686300025962 /* dispatch_api.c */,
-				6E67D8D31C16C20B00FC98AC /* dispatch_apply.c */,
-				6E9926711D01295F000CB89A /* dispatch_block.c */,
-				924D8EAA1C116B9F002AC2BC /* dispatch_c99.c */,
-				6E326AB11C224830002A6505 /* dispatch_cascade.c */,
-				6E67D8D91C16C94B00FC98AC /* dispatch_cf_main.c */,
-				6E326ADE1C23451A002A6505 /* dispatch_concur.c */,
-				6E326AEF1C239303002A6505 /* dispatch_context_for_key.c */,
-				6E8E4EC71C1A61680004F5CC /* dispatch_data.m */,
-				6EC5ABE31D4436E4004F8674 /* dispatch_deadname.c */,
-				6E67D90D1C16CCEB00FC98AC /* dispatch_debug.c */,
-				6E8E4ECB1C1A72650004F5CC /* dispatch_drift.c */,
-				6E67D90F1C16CF0B00FC98AC /* dispatch_group.c */,
-				6E326ABD1C22A577002A6505 /* dispatch_io_net.c */,
-				6E326ABE1C22A577002A6505 /* dispatch_io.c */,
-				6EDB888D1CB73BDC006776D6 /* dispatch_kevent_cancel_races.c */,
-				6EC670C61E37E201004F10D6 /* dispatch_network_event_thread.c */,
-				B63B793F1E8F004F0060C1E1 /* dispatch_no_blocks.c */,
-				C96CE17A1CEB851600F4B8E6 /* dispatch_objc.m */,
-				6E67D9131C17676D00FC98AC /* dispatch_overcommit.c */,
-				6E67D9151C1768B300FC98AC /* dispatch_pingpong.c */,
-				6E326B441C239B61002A6505 /* dispatch_priority.c */,
-				6E326AB51C225477002A6505 /* dispatch_proc.c */,
-				B6FA01801F0AD522004479BF /* dispatch_pthread_root_queue.c */,
-				6E326AB31C224870002A6505 /* dispatch_qos.c */,
-				B6AE9A4A1D7F53B300AC007F /* dispatch_queue_create.c */,
-				6E67D9111C17669C00FC98AC /* dispatch_queue_finalizer.c */,
-				6E1612691C79606E006FC9A9 /* dispatch_queue_label.c */,
-				6E326AB91C229866002A6505 /* dispatch_read.c */,
-				6E326ABB1C229895002A6505 /* dispatch_read2.c */,
-				6E326ADC1C234396002A6505 /* dispatch_readsync.c */,
-				6E8E4E6D1C1A35EE0004F5CC /* dispatch_select.c */,
-				6E8E4E9B1C1A4EF10004F5CC /* dispatch_sema.c */,
-				B69878521F06F8790088F94F /* dispatch_signals.c */,
-				6EA2CB841C005DEF0076794A /* dispatch_source.c */,
-				6E326AE01C234780002A6505 /* dispatch_starfish.c */,
-				6EE89F3D1BFAF5B000EB140D /* dispatch_state_machine.c */,
-				6E326B121C239431002A6505 /* dispatch_suspend_timer.c */,
-				6E326AD81C233209002A6505 /* dispatch_sync_gc.m */,
-				6E326AD91C233209002A6505 /* dispatch_sync_on_main.c */,
-				6E326B131C239431002A6505 /* dispatch_timer_bit.c */,
-				6E326B151C239431002A6505 /* dispatch_timer_set_time.c */,
-				6E326B161C239431002A6505 /* dispatch_timer_short.c */,
-				6E326B171C239431002A6505 /* dispatch_timer_timeout.c */,
-				B68358911FA77FFD00AA0D58 /* dispatch_time.c */,
-				6E326AE61C2392E8002A6505 /* dispatch_timer.c */,
-				6E326A8F1C2245C4002A6505 /* dispatch_transform.c */,
-				6E8E4EC91C1A670B0004F5CC /* dispatch_vm.c */,
-				6E326AB71C225FCA002A6505 /* dispatch_vnode.c */,
-				B68330BC1EBCF6080003E71C /* dispatch_wl.c */,
-				6E67D9171C17BA7200FC98AC /* nsoperation.m */,
-				6E4FC9D11C84123600520351 /* os_venture_basic.c */,
-				B6AE9A561D7F53C100AC007F /* perf_async_bench.m */,
-				B6AE9A581D7F53CB00AC007F /* perf_bench.m */,
-				6EC670C71E37E201004F10D6 /* perf_mach_async.c */,
-				6EC670C81E37E201004F10D6 /* perf_pipepingpong.c */,
-				B6AC73FD1EB10973009FB2F2 /* perf_thread_request.c */,
-				92F3FE921BEC686300025962 /* Makefile */,
-				6E8E4E6E1C1A35EE0004F5CC /* test_lib.c */,
-				6E8E4E6F1C1A35EE0004F5CC /* test_lib.h */,
-			);
-			name = "Darwin Tests";
-			path = tests;
-			sourceTree = "<group>";
-		};
-		9B6A42E11FE098430000D146 /* Products */ = {
-			isa = PBXGroup;
-			children = (
-				9B2A11AA2032494E0060E7D4 /* queue-tip */,
-			);
-			name = Products;
-			sourceTree = "<group>";
-		};
-		C6A0FF2B0290797F04C91782 /* Documentation */ = {
-			isa = PBXGroup;
-			children = (
-				72CC940D0ECCD5720031B751 /* dispatch.3 */,
-				FC678DE80F97E0C300AB5993 /* dispatch_after.3 */,
-				FC678DE90F97E0C300AB5993 /* dispatch_api.3 */,
-				960F0E7D0F3FB232000D88BF /* dispatch_apply.3 */,
-				FC678DEA0F97E0C300AB5993 /* dispatch_async.3 */,
-				96859A3D0EF71BAD003EB3FB /* dispatch_benchmark.3 */,
-				E4BA743513A88FE10095BDF1 /* dispatch_data_create.3 */,
-				FC678DEB0F97E0C300AB5993 /* dispatch_group_create.3 */,
-				E4BA743613A88FF30095BDF1 /* dispatch_io_create.3 */,
-				E4BA743713A88FF30095BDF1 /* dispatch_io_read.3 */,
-				72CC940C0ECCD5720031B751 /* dispatch_object.3 */,
-				960F0E7E0F3FB232000D88BF /* dispatch_once.3 */,
-				FC36279C0E933ED80054F1A3 /* dispatch_queue_create.3 */,
-				E4BA743813A8900B0095BDF1 /* dispatch_read.3 */,
-				963FDDE50F3FB6BD00BF2D00 /* dispatch_semaphore_create.3 */,
-				72B54F690EB169EB00DBECBA /* dispatch_source_create.3 */,
-				FC678DEC0F97E0C300AB5993 /* dispatch_time.3 */,
-			);
-			name = Documentation;
-			path = man;
-			sourceTree = "<group>";
-		};
-		C927F36010FD7F1000C5AB8B /* Products */ = {
-			isa = PBXGroup;
-			children = (
-				C927F36710FD7F1000C5AB8B /* ddt */,
-			);
-			name = Products;
-			sourceTree = "<group>";
-		};
-		E40041E4125E71150022B135 /* xcodeconfig */ = {
-			isa = PBXGroup;
-			children = (
-				E43D93F11097917E004F6A62 /* libdispatch.xcconfig */,
-				E40041AA125D705F0022B135 /* libdispatch-resolver.xcconfig */,
-				E40041A9125D70590022B135 /* libdispatch-resolved.xcconfig */,
-				C01866BE1C59735B0040FC07 /* libdispatch-mp-static.xcconfig */,
-				C00B0E121C5AEBF7000330B3 /* libdispatch-dyld-stub.xcconfig */,
-				E4B515D9164B2E9B00E003AF /* libdispatch-introspection.xcconfig */,
-				6EB4E4421BA8BD7800D7B9D2 /* libfirehose.xcconfig */,
-				6E040C721C499C3600411A2E /* libfirehose_kernel.xcconfig */,
-				E422DA3614D2A7E7003C6EE4 /* libdispatch.aliases */,
-				E448727914C6215D00BB45C2 /* libdispatch.order */,
-				6E49BF2420E34B43002624FC /* libdispatch.clean */,
-				6E49BF2920E34B44002624FC /* libdispatch.dirty */,
-				E421E5FD1716BEA70090DC9B /* libdispatch.interposable */,
-			);
-			path = xcodeconfig;
-			sourceTree = "<group>";
-		};
-		E44DB71E11D2FF080074F2AD /* Build Support */ = {
-			isa = PBXGroup;
-			children = (
-				E4BA743413A88D390095BDF1 /* config */,
-				E40041E4125E71150022B135 /* xcodeconfig */,
-				E49F259C125D664F0057C971 /* xcodescripts */,
-				E47D6BCA125F10F70070D91C /* resolver */,
-			);
-			name = "Build Support";
-			sourceTree = "<group>";
-		};
-		E47D6BCA125F10F70070D91C /* resolver */ = {
-			isa = PBXGroup;
-			children = (
-				E47D6BB5125F0F800070D91C /* resolved.h */,
-				E44EBE331251654000645D88 /* resolver.h */,
-				E44EBE371251656400645D88 /* resolver.c */,
-			);
-			path = resolver;
-			sourceTree = "<group>";
-		};
-		E49F259C125D664F0057C971 /* xcodescripts */ = {
-			isa = PBXGroup;
-			children = (
-				6E2464E21F5E67E20031ADD9 /* check-order.sh */,
-				E49F251D125D630A0057C971 /* install-manpages.sh */,
-				E4EB4A2A14C36F4E00AA0FA9 /* install-headers.sh */,
-				E421E5FB1716B8730090DC9B /* install-dtrace.sh */,
-				E4FB8E90218CD7F8004B7A25 /* install-plists.sh */,
-				E49F251E125D631D0057C971 /* mig-headers.sh */,
-				E482F1CD12DBAB590030614D /* postprocess-headers.sh */,
-				C01866BF1C5976C90040FC07 /* run-on-install.sh */,
-			);
-			path = xcodescripts;
-			sourceTree = "<group>";
-		};
-		E4BA743413A88D390095BDF1 /* config */ = {
-			isa = PBXGroup;
-			children = (
-				FC9C70E7105EC9620074F9CA /* config.h */,
-			);
-			path = config;
-			sourceTree = "<group>";
-		};
-		E4EB4A2914C35F1800AA0FA9 /* OS Private Headers */ = {
-			isa = PBXGroup;
-			children = (
-				E454569214746F1B00106147 /* object_private.h */,
-				6EDF10831BBB487E007F14BF /* firehose_buffer_private.h */,
-				72EA3FBA1AF41EA400BBA227 /* firehose_server_private.h */,
-				6E9955571C3AF7710071D40C /* venture_private.h */,
-				E44A8E711805C473009FFDB6 /* voucher_private.h */,
-				E4B3C3FD18C50D000039F49F /* voucher_activity_private.h */,
-			);
-			name = "OS Private Headers";
-			path = os;
-			sourceTree = "<group>";
-		};
-		EA53C60D1BFE9605000A02EA /* Tests */ = {
-			isa = PBXGroup;
-			children = (
-				EA53C60E1BFEA851000A02EA /* bsdtestharness.c */,
-				EA53C60F1BFEA851000A02EA /* bsdtests.c */,
-				EA53C6101BFEA851000A02EA /* bsdtests.h */,
-				EA53C6111BFEA851000A02EA /* bsdtestsummarize.c */,
-				EA53C6121BFEA851000A02EA /* cffd.c */,
-				EA53C6131BFEA851000A02EA /* dispatch_after.c */,
-				EA53C6141BFEA851000A02EA /* dispatch_api.c */,
-				EA53C6151BFEA851000A02EA /* dispatch_apply.c */,
-				EA53C6161BFEA851000A02EA /* dispatch_c99.c */,
-				EA53C6171BFEA851000A02EA /* dispatch_cascade.c */,
-				EA53C6181BFEA851000A02EA /* dispatch_cf_main.c */,
-				EA53C6191BFEA851000A02EA /* dispatch_concur.c */,
-				EA53C61A1BFEA851000A02EA /* dispatch_context_for_key.c */,
-				EA53C61B1BFEA851000A02EA /* dispatch_data.c */,
-				EA53C61C1BFEA851000A02EA /* dispatch_deadname.c */,
-				EA53C61D1BFEA851000A02EA /* dispatch_debug.c */,
-				EA53C61E1BFEA851000A02EA /* dispatch_drift.c */,
-				EA53C61F1BFEA851000A02EA /* dispatch_group.c */,
-				EA53C6201BFEA851000A02EA /* dispatch_io_net.c */,
-				EA53C6211BFEA851000A02EA /* dispatch_io.c */,
-				EA53C6221BFEA851000A02EA /* dispatch_overcommit.c */,
-				EA53C6231BFEA851000A02EA /* dispatch_pingpong.c */,
-				EA53C6241BFEA851000A02EA /* dispatch_plusplus.cpp */,
-				EA53C6251BFEA851000A02EA /* dispatch_priority.c */,
-				EA53C6261BFEA851000A02EA /* dispatch_proc.c */,
-				EA53C6271BFEA851000A02EA /* dispatch_queue_finalizer.c */,
-				EA53C6281BFEA851000A02EA /* dispatch_read.c */,
-				EA53C6291BFEA851000A02EA /* dispatch_read2.c */,
-				EA53C62A1BFEA851000A02EA /* dispatch_readsync.c */,
-				EA53C62B1BFEA851000A02EA /* dispatch_select.c */,
-				EA53C62C1BFEA851000A02EA /* dispatch_sema.c */,
-				EA53C62D1BFEA851000A02EA /* dispatch_starfish.c */,
-				EA53C62E1BFEA851000A02EA /* dispatch_suspend_timer.c */,
-				EA53C62F1BFEA851000A02EA /* dispatch_sync_on_main.c */,
-				EA53C6301BFEA851000A02EA /* dispatch_test.c */,
-				EA53C6311BFEA851000A02EA /* dispatch_test.h */,
-				EA53C6321BFEA851000A02EA /* dispatch_timer_bit31.c */,
-				EA53C6331BFEA851000A02EA /* dispatch_timer_bit63.c */,
-				EA53C6341BFEA851000A02EA /* dispatch_timer_set_time.c */,
-				EA53C6351BFEA851000A02EA /* dispatch_timer_short.c */,
-				EA53C6361BFEA851000A02EA /* dispatch_timer_timeout.c */,
-				EA53C6371BFEA851000A02EA /* dispatch_timer.c */,
-				EA53C6381BFEA851000A02EA /* dispatch_transform.c */,
-				EA53C6391BFEA851000A02EA /* dispatch_vm.c */,
-				EA53C63A1BFEA851000A02EA /* dispatch_vnode.c */,
-				EA53C63B1BFEA851000A02EA /* func.c */,
-			);
-			name = Tests;
-			sourceTree = "<group>";
-		};
-		FC1832A0109923B3003403D5 /* shims */ = {
-			isa = PBXGroup;
-			children = (
-				96929D820F3EA1020041FF5D /* atomic.h */,
-				E463024F1761603C00E11F4C /* atomic_sfb.h */,
-				E4BA743913A8911B0095BDF1 /* getprogname.h */,
-				E4128ED513BA9A1700ABB2CB /* hw_config.h */,
-				6EF2CAA41C88998A001ABE83 /* lock.h */,
-				FC1832A2109923C7003403D5 /* perfmon.h */,
-				6EFBDA4A1D61A0D600282887 /* priority.h */,
-				F7DC045A2060BBBE00C90737 /* target.h */,
-				FC1832A3109923C7003403D5 /* time.h */,
-				FC1832A4109923C7003403D5 /* tsd.h */,
-				E48EC97B1835BADD00EAC4F1 /* yield.h */,
-			);
-			path = shims;
-			sourceTree = "<group>";
-		};
-		FC7BEDAA0E83625200161930 /* Dispatch Public Headers */ = {
-			isa = PBXGroup;
-			children = (
-				72CC942F0ECCD8750031B751 /* base.h */,
-				E4D76A9218E325D200B1F98B /* block.h */,
-				5AAB45C510D30D0C004407EA /* data.h */,
-				FC7BED960E8361E600161930 /* dispatch.h */,
-				FC5C9C1D0EADABE3006E462D /* group.h */,
-				5AAB45C310D30CC7004407EA /* io.h */,
-				C901445E1C73A7FE002638FC /* module.modulemap */,
-				961B994F0F3E85C30006BC96 /* object.h */,
-				96C9553A0F3EAEDD000D2CA4 /* once.h */,
-				FC7BED8B0E8361E600161930 /* queue.h */,
-				721F5C5C0F15520500FF03A6 /* semaphore.h */,
-				FC7BED8D0E8361E600161930 /* source.h */,
-				96032E4C0F5CC8D100241C5F /* time.h */,
-				E421E5F81716ADA10090DC9B /* introspection.h */,
-			);
-			name = "Dispatch Public Headers";
-			path = dispatch;
-			sourceTree = "<group>";
-		};
-		FC7BEDAF0E83626100161930 /* Dispatch Private Headers */ = {
-			isa = PBXGroup;
-			children = (
-				FC7BED930E8361E600161930 /* private.h */,
-				C913AC0E143BD34800B78976 /* data_private.h */,
-				E48AF55916E70FD9004105FF /* io_private.h */,
-				96BC39BC0F3EBAB100C59689 /* queue_private.h */,
-				6E70181C1F4EB51B0077C1DC /* workloop_private.h */,
-				FCEF047F0F5661960067401F /* source_private.h */,
-				E4ECBAA415253C25002C313C /* mach_private.h */,
-				B683588A1FA77F4900AA0D58 /* time_private.h */,
-				C90144641C73A845002638FC /* module.modulemap */,
-				961B99350F3E83980006BC96 /* benchmark.h */,
-				E4B515D7164B2DFB00E003AF /* introspection_private.h */,
-				2BE17C6318EA305E002CA4E8 /* layout_private.h */,
-			);
-			name = "Dispatch Private Headers";
-			path = private;
-			sourceTree = "<group>";
-		};
-		FC7BEDB60E8363DC00161930 /* Dispatch Project Headers */ = {
-			isa = PBXGroup;
-			children = (
-				2BBF5A5F154B64D8002B20F9 /* allocator_internal.h */,
-				FC7BED8F0E8361E600161930 /* internal.h */,
-				E44757D917F4572600B82CA1 /* inline_internal.h */,
-				E4C1ED6E1263E714000D3C8B /* data_internal.h */,
-				5A0095A110F274B0000E2A31 /* io_internal.h */,
-				6E4BACC91D48A89500B562AE /* mach_internal.h */,
-				965ECC200F3EAB71004DDD89 /* object_internal.h */,
-				96929D950F3EA2170041FF5D /* queue_internal.h */,
-				5A5D13AB0F6B280500197CC3 /* semaphore_internal.h */,
-				FC0B34780FA2851C0080FFA0 /* source_internal.h */,
-				6E9956061C3B21AA0071D40C /* venture_internal.h */,
-				E44A8E7418066276009FFDB6 /* voucher_internal.h */,
-				E422A0D412A557B5005E5BDB /* trace.h */,
-				E44F9DA816543F79001DCD38 /* introspection_internal.h */,
-				96929D830F3EA1020041FF5D /* shims.h */,
-				6E5ACCAE1D3BF27F007DA2B4 /* event */,
-				6EF0B2661BA8C43D007FA4F6 /* firehose */,
-				FC1832A0109923B3003403D5 /* shims */,
-			);
-			name = "Dispatch Project Headers";
-			path = src;
-			sourceTree = "<group>";
-		};
-/* End PBXGroup section */
-
-/* Begin PBXHeadersBuildPhase section */
-		6E040C611C499B1B00411A2E /* Headers */ = {
-			isa = PBXHeadersBuildPhase;
-			buildActionMask = 2147483647;
-			files = (
-				6E040C751C499CE600411A2E /* firehose_buffer_private.h in Headers */,
-			);
-			runOnlyForDeploymentPostprocessing = 0;
-		};
-		6EB4E4071BA8BCAD00D7B9D2 /* Headers */ = {
-			isa = PBXHeadersBuildPhase;
-			buildActionMask = 2147483647;
-			files = (
-				6EB60D2C1BBB197B0092FA94 /* firehose_inline_internal.h in Headers */,
-				6EF0B2711BA8C540007FA4F6 /* firehose_internal.h in Headers */,
-				6E9B6B5F1BB4F3C8009E324D /* firehose_buffer_internal.h in Headers */,
-				6E21F2E81BBB23FA0000C6A5 /* firehose_server_internal.h in Headers */,
-				6EF0B26D1BA8C527007FA4F6 /* firehose_server_private.h in Headers */,
-				6EDF10B81BBB488A007F14BF /* firehose_buffer_private.h in Headers */,
-			);
-			runOnlyForDeploymentPostprocessing = 0;
-		};
-		D2AAC043055464E500DB518D /* Headers */ = {
-			isa = PBXHeadersBuildPhase;
-			buildActionMask = 2147483647;
-			files = (
-				FC7BEDA50E8361E600161930 /* dispatch.h in Headers */,
-				72CC94300ECCD8750031B751 /* base.h in Headers */,
-				961B99500F3E85C30006BC96 /* object.h in Headers */,
-				E44757DA17F4572600B82CA1 /* inline_internal.h in Headers */,
-				FC7BED9A0E8361E600161930 /* queue.h in Headers */,
-				FC7BED9C0E8361E600161930 /* source.h in Headers */,
-				6E9955581C3AF7710071D40C /* venture_private.h in Headers */,
-				E4B3C3FE18C50D000039F49F /* voucher_activity_private.h in Headers */,
-				721F5C5D0F15520500FF03A6 /* semaphore.h in Headers */,
-				FC5C9C1E0EADABE3006E462D /* group.h in Headers */,
-				6EFBDA4B1D61A0D600282887 /* priority.h in Headers */,
-				96C9553B0F3EAEDD000D2CA4 /* once.h in Headers */,
-				5AAB45C410D30CC7004407EA /* io.h in Headers */,
-				E44A8E7518066276009FFDB6 /* voucher_internal.h in Headers */,
-				C90144651C73A8A3002638FC /* module.modulemap in Headers */,
-				E4630253176162D400E11F4C /* atomic_sfb.h in Headers */,
-				5AAB45C610D30D0C004407EA /* data.h in Headers */,
-				6E393F981BD60F8D005A551E /* firehose_internal.h in Headers */,
-				96032E4D0F5CC8D100241C5F /* time.h in Headers */,
-				FC7BEDA20E8361E600161930 /* private.h in Headers */,
-				E4D76A9318E325D200B1F98B /* block.h in Headers */,
-				C913AC0F143BD34800B78976 /* data_private.h in Headers */,
-				96BC39BD0F3EBAB100C59689 /* queue_private.h in Headers */,
-				C90144661C73A9F6002638FC /* module.modulemap in Headers */,
-				FCEF04800F5661960067401F /* source_private.h in Headers */,
-				F7DC045B2060BBBE00C90737 /* target.h in Headers */,
-				961B99360F3E83980006BC96 /* benchmark.h in Headers */,
-				FC7BED9E0E8361E600161930 /* internal.h in Headers */,
-				6E7018211F4EB51B0077C1DC /* workloop_private.h in Headers */,
-				965ECC210F3EAB71004DDD89 /* object_internal.h in Headers */,
-				96929D960F3EA2170041FF5D /* queue_internal.h in Headers */,
-				FC0B34790FA2851C0080FFA0 /* source_internal.h in Headers */,
-				5A5D13AC0F6B280500197CC3 /* semaphore_internal.h in Headers */,
-				E4C1ED6F1263E714000D3C8B /* data_internal.h in Headers */,
-				E44A8E721805C473009FFDB6 /* voucher_private.h in Headers */,
-				5A0095A210F274B0000E2A31 /* io_internal.h in Headers */,
-				FC1832A8109923C7003403D5 /* tsd.h in Headers */,
-				6EA793891D458A5800929B1B /* event_config.h in Headers */,
-				96929D840F3EA1020041FF5D /* atomic.h in Headers */,
-				96929D850F3EA1020041FF5D /* shims.h in Headers */,
-				FC1832A7109923C7003403D5 /* time.h in Headers */,
-				6E4BACCA1D48A89500B562AE /* mach_internal.h in Headers */,
-				6ED64B511BBD8A2100C35F4D /* firehose_buffer_internal.h in Headers */,
-				E48EC97C1835BADD00EAC4F1 /* yield.h in Headers */,
-				2BE17C6418EA305E002CA4E8 /* layout_private.h in Headers */,
-				FC1832A6109923C7003403D5 /* perfmon.h in Headers */,
-				FC9C70E8105EC9620074F9CA /* config.h in Headers */,
-				6E9956071C3B21AA0071D40C /* venture_internal.h in Headers */,
-				6EF2CAA51C88998A001ABE83 /* lock.h in Headers */,
-				E422A0D512A557B5005E5BDB /* trace.h in Headers */,
-				E4BA743B13A8911B0095BDF1 /* getprogname.h in Headers */,
-				6E5ACCBA1D3C4D0B007DA2B4 /* event_internal.h in Headers */,
-				6ED64B571BBD8A3B00C35F4D /* firehose_inline_internal.h in Headers */,
-				E4128ED613BA9A1700ABB2CB /* hw_config.h in Headers */,
-				E454569314746F1B00106147 /* object_private.h in Headers */,
-				B683588F1FA77F5A00AA0D58 /* time_private.h in Headers */,
-				6E5662E11F8C2E3E00BC2474 /* workqueue_internal.h in Headers */,
-				E4EB4A2714C35ECE00AA0FA9 /* object.h in Headers */,
-				E48AF55A16E70FD9004105FF /* io_private.h in Headers */,
-				E4ECBAA515253C25002C313C /* mach_private.h in Headers */,
-				2BBF5A60154B64D8002B20F9 /* allocator_internal.h in Headers */,
-				E44F9DAC1654400D001DCD38 /* introspection_internal.h in Headers */,
-			);
-			runOnlyForDeploymentPostprocessing = 0;
-		};
-		E49F24AA125D57FA0057C971 /* Headers */ = {
-			isa = PBXHeadersBuildPhase;
-			buildActionMask = 2147483647;
-			files = (
-				E49F24AB125D57FA0057C971 /* dispatch.h in Headers */,
-				E49F24AC125D57FA0057C971 /* base.h in Headers */,
-				6E5ACCBB1D3C4D0E007DA2B4 /* event_internal.h in Headers */,
-				6E7018221F4EB5220077C1DC /* workloop_private.h in Headers */,
-				E49F24AD125D57FA0057C971 /* object.h in Headers */,
-				E44757DC17F4573600B82CA1 /* inline_internal.h in Headers */,
-				E49F24AE125D57FA0057C971 /* queue.h in Headers */,
-				E49F24AF125D57FA0057C971 /* source.h in Headers */,
-				6E99558A1C3AF7900071D40C /* venture_private.h in Headers */,
-				E4B3C3FF18C50D0E0039F49F /* voucher_activity_private.h in Headers */,
-				E49F24B0125D57FA0057C971 /* semaphore.h in Headers */,
-				E49F24B1125D57FA0057C971 /* group.h in Headers */,
-				E49F24B2125D57FA0057C971 /* once.h in Headers */,
-				E49F24B3125D57FA0057C971 /* io.h in Headers */,
-				6E5662E21F8C2E4F00BC2474 /* workqueue_internal.h in Headers */,
-				E44A8E7618066276009FFDB6 /* voucher_internal.h in Headers */,
-				E4630252176162D300E11F4C /* atomic_sfb.h in Headers */,
-				E49F24B4125D57FA0057C971 /* data.h in Headers */,
-				E49F24B5125D57FA0057C971 /* time.h in Headers */,
-				E49F24B6125D57FA0057C971 /* private.h in Headers */,
-				E4D76A9418E325D200B1F98B /* block.h in Headers */,
-				E49F24B7125D57FA0057C971 /* queue_private.h in Headers */,
-				E49F24B8125D57FA0057C971 /* source_private.h in Headers */,
-				E49F24B9125D57FA0057C971 /* benchmark.h in Headers */,
-				E49F24BA125D57FA0057C971 /* internal.h in Headers */,
-				E49F24BC125D57FA0057C971 /* object_internal.h in Headers */,
-				E49F24BB125D57FA0057C971 /* queue_internal.h in Headers */,
-				E49F24BE125D57FA0057C971 /* source_internal.h in Headers */,
-				E49F24BD125D57FA0057C971 /* semaphore_internal.h in Headers */,
-				E4C1ED701263E714000D3C8B /* data_internal.h in Headers */,
-				6EA7938F1D458A5E00929B1B /* event_config.h in Headers */,
-				6ED64B501BBD8A1400C35F4D /* firehose_internal.h in Headers */,
-				E49F24BF125D57FA0057C971 /* io_internal.h in Headers */,
-				E44A8E731805C473009FFDB6 /* voucher_private.h in Headers */,
-				E49F24C1125D57FA0057C971 /* tsd.h in Headers */,
-				E49F24C2125D57FA0057C971 /* atomic.h in Headers */,
-				E49F24C3125D57FA0057C971 /* shims.h in Headers */,
-				E49F24C4125D57FA0057C971 /* time.h in Headers */,
-				E49F24C5125D57FA0057C971 /* perfmon.h in Headers */,
-				6ED64B521BBD8A2100C35F4D /* firehose_buffer_internal.h in Headers */,
-				E48EC97D1835BADD00EAC4F1 /* yield.h in Headers */,
-				2BE17C6518EA305E002CA4E8 /* layout_private.h in Headers */,
-				B68358901FA77F5B00AA0D58 /* time_private.h in Headers */,
-				E49F24C6125D57FA0057C971 /* config.h in Headers */,
-				E422A0D612A557B5005E5BDB /* trace.h in Headers */,
-				6E9956091C3B21B40071D40C /* venture_internal.h in Headers */,
-				6EF2CAB41C889D65001ABE83 /* lock.h in Headers */,
-				E4BA743C13A8911B0095BDF1 /* getprogname.h in Headers */,
-				E4128ED713BA9A1700ABB2CB /* hw_config.h in Headers */,
-				6ED64B581BBD8A3E00C35F4D /* firehose_inline_internal.h in Headers */,
-				E454569414746F1B00106147 /* object_private.h in Headers */,
-				E4EB4A2814C35ECE00AA0FA9 /* object.h in Headers */,
-				E4ECBAA615253D17002C313C /* mach_private.h in Headers */,
-				E48AF55B16E72D44004105FF /* io_private.h in Headers */,
-				2BBF5A61154B64D8002B20F9 /* allocator_internal.h in Headers */,
-				E43A710615783F7E0012D38D /* data_private.h in Headers */,
-				E44F9DAD1654400E001DCD38 /* introspection_internal.h in Headers */,
-			);
-			runOnlyForDeploymentPostprocessing = 0;
-		};
-		E4B51596164B2DA300E003AF /* Headers */ = {
-			isa = PBXHeadersBuildPhase;
-			buildActionMask = 2147483647;
-			files = (
-				E4B515D8164B2DFB00E003AF /* introspection_private.h in Headers */,
-				E44F9DAF16544026001DCD38 /* internal.h in Headers */,
-				E421E5F91716ADA10090DC9B /* introspection.h in Headers */,
-				6E5662E31F8C2E5100BC2474 /* workqueue_internal.h in Headers */,
-				E44F9DB216544032001DCD38 /* object_internal.h in Headers */,
-				E44F9DB316544037001DCD38 /* queue_internal.h in Headers */,
-				6ED64B531BBD8A2300C35F4D /* firehose_buffer_internal.h in Headers */,
-				E44F9DB51654403F001DCD38 /* source_internal.h in Headers */,
-				E44F9DB41654403B001DCD38 /* semaphore_internal.h in Headers */,
-				E44F9DB01654402B001DCD38 /* data_internal.h in Headers */,
-				6E5ACCBC1D3C4D0F007DA2B4 /* event_internal.h in Headers */,
-				6E9956081C3B21B30071D40C /* venture_internal.h in Headers */,
-				E44F9DB11654402E001DCD38 /* io_internal.h in Headers */,
-				E4630251176162D200E11F4C /* atomic_sfb.h in Headers */,
-				E44F9DBE1654405B001DCD38 /* tsd.h in Headers */,
-				E44F9DB816544053001DCD38 /* atomic.h in Headers */,
-				6ED64B591BBD8A3F00C35F4D /* firehose_inline_internal.h in Headers */,
-				6EF2CAB51C889D67001ABE83 /* lock.h in Headers */,
-				E44757DB17F4573500B82CA1 /* inline_internal.h in Headers */,
-				6EA7938E1D458A5C00929B1B /* event_config.h in Headers */,
-				6ED64B4F1BBD8A1400C35F4D /* firehose_internal.h in Headers */,
-				E44F9DB71654404F001DCD38 /* shims.h in Headers */,
-				E44F9DBC1654405B001DCD38 /* perfmon.h in Headers */,
-				E44F9DBF165440EF001DCD38 /* config.h in Headers */,
-				E44A8E7718066276009FFDB6 /* voucher_internal.h in Headers */,
-				E44F9DB616544043001DCD38 /* trace.h in Headers */,
-				E44F9DB916544056001DCD38 /* getprogname.h in Headers */,
-				E48EC97E1835BADD00EAC4F1 /* yield.h in Headers */,
-				E44F9DBA1654405B001DCD38 /* hw_config.h in Headers */,
-				E44F9DC116544115001DCD38 /* object_private.h in Headers */,
-				E44F9DC016544115001DCD38 /* object.h in Headers */,
-				E44F9DAE16544022001DCD38 /* allocator_internal.h in Headers */,
-				E44F9DAB16543F94001DCD38 /* introspection_internal.h in Headers */,
-			);
-			runOnlyForDeploymentPostprocessing = 0;
-		};
-/* End PBXHeadersBuildPhase section */
-
-/* Begin PBXLegacyTarget section */
-		92F3FECA1BEC69E500025962 /* darwintests */ = {
-			isa = PBXLegacyTarget;
-			buildArgumentsString = "$(ACTION)";
-			buildConfigurationList = 92F3FECB1BEC69E500025962 /* Build configuration list for PBXLegacyTarget "darwintests" */;
-			buildPhases = (
-			);
-			buildToolPath = /usr/bin/make;
-			buildWorkingDirectory = tests/;
-			dependencies = (
-			);
-			name = darwintests;
-			passBuildSettingsInEnvironment = 1;
-			productName = darwintests;
-		};
-/* End PBXLegacyTarget section */
-
-/* Begin PBXNativeTarget section */
-		6E040C621C499B1B00411A2E /* libfirehose_kernel */ = {
-			isa = PBXNativeTarget;
-			buildConfigurationList = 6E040C6A1C499B1B00411A2E /* Build configuration list for PBXNativeTarget "libfirehose_kernel" */;
-			buildPhases = (
-				6E040C5F1C499B1B00411A2E /* Sources */,
-				6E040C601C499B1B00411A2E /* Frameworks */,
-				6E040C611C499B1B00411A2E /* Headers */,
-			);
-			buildRules = (
-			);
-			dependencies = (
-			);
-			name = libfirehose_kernel;
-			productName = libfirehose_kernel;
-			productReference = 6E040C631C499B1B00411A2E /* libfirehose_kernel.a */;
-			productType = "com.apple.product-type.library.static";
-		};
-		6EB4E4081BA8BCAD00D7B9D2 /* libfirehose_server */ = {
-			isa = PBXNativeTarget;
-			buildConfigurationList = 6EB4E40A1BA8BCAD00D7B9D2 /* Build configuration list for PBXNativeTarget "libfirehose_server" */;
-			buildPhases = (
-				6EB4E4051BA8BCAD00D7B9D2 /* Sources */,
-				6EB4E4071BA8BCAD00D7B9D2 /* Headers */,
-			);
-			buildRules = (
-			);
-			dependencies = (
-			);
-			name = libfirehose_server;
-			productName = libfirehose_server;
-			productReference = 6EB4E4091BA8BCAD00D7B9D2 /* libfirehose_server.a */;
-			productType = "com.apple.product-type.library.static";
-		};
-		C00B0DF01C5AEBBE000330B3 /* libdispatch dyld stub */ = {
-			isa = PBXNativeTarget;
-			buildConfigurationList = C00B0E071C5AEBBE000330B3 /* Build configuration list for PBXNativeTarget "libdispatch dyld stub" */;
-			buildPhases = (
-				C00B0DF11C5AEBBE000330B3 /* Sources */,
-				C00B0E061C5AEBBE000330B3 /* Symlink libdispatch.a -> libdispatch_dyld_target.a */,
-			);
-			buildRules = (
-			);
-			dependencies = (
-			);
-			name = "libdispatch dyld stub";
-			productName = libdispatch;
-			productReference = C00B0E0A1C5AEBBE000330B3 /* libdispatch_dyld_stub.a */;
-			productType = "com.apple.product-type.library.static";
-		};
-		C01866A41C5973210040FC07 /* libdispatch mp static */ = {
-			isa = PBXNativeTarget;
-			buildConfigurationList = C01866BA1C5973210040FC07 /* Build configuration list for PBXNativeTarget "libdispatch mp static" */;
-			buildPhases = (
-				C01866A51C5973210040FC07 /* Sources */,
-				C01866C01C59777B0040FC07 /* Symlink to the loaderd path */,
-			);
-			buildRules = (
-			);
-			dependencies = (
-			);
-			name = "libdispatch mp static";
-			productName = libdispatch;
-			productReference = C01866BD1C5973210040FC07 /* libdispatch.a */;
-			productType = "com.apple.product-type.library.static";
-		};
-		D2AAC045055464E500DB518D /* libdispatch */ = {
-			isa = PBXNativeTarget;
-			buildConfigurationList = 1DEB91EB08733DB70010E9CD /* Build configuration list for PBXNativeTarget "libdispatch" */;
-			buildPhases = (
-				D2AAC043055464E500DB518D /* Headers */,
-				D2AAC044055464E500DB518D /* Sources */,
-				6EA283D61CAB933E0041B2E0 /* Copy Trace Definitions */,
-				E4EB4A2B14C3720B00AA0FA9 /* Install Headers */,
-				E482F1C512DBAA110030614D /* Postprocess Headers */,
-				4CED8B9D0EEDF8B600AF99AB /* Install Manpages */,
-				6E2464DD1F5E67900031ADD9 /* Validate symbol ordering */,
-				E4FB8E8F218CD68A004B7A25 /* Install Plists */,
-			);
-			buildRules = (
-			);
-			dependencies = (
-				6EF0B27E1BA8C5BF007FA4F6 /* PBXTargetDependency */,
-				E47D6ECD125FEBA10070D91C /* PBXTargetDependency */,
-				E49BB6F81E7074C100868613 /* PBXTargetDependency */,
-				C01866C21C597AEA0040FC07 /* PBXTargetDependency */,
-				C00B0E141C5AEED6000330B3 /* PBXTargetDependency */,
-			);
-			name = libdispatch;
-			productName = libdispatch;
-			productReference = D2AAC046055464E500DB518D /* libdispatch.dylib */;
-			productType = "com.apple.product-type.library.dynamic";
-		};
-		E49BB6CE1E70748100868613 /* libdispatch armv81 resolved */ = {
-			isa = PBXNativeTarget;
-			buildConfigurationList = E49BB6EF1E70748100868613 /* Build configuration list for PBXNativeTarget "libdispatch armv81 resolved" */;
-			buildPhases = (
-				E49BB6CF1E70748100868613 /* Mig Headers */,
-				E49BB6D01E70748100868613 /* Sources */,
-				E49BB6EE1E70748100868613 /* Symlink normal variant */,
-			);
-			buildRules = (
-			);
-			dependencies = (
-			);
-			name = "libdispatch armv81 resolved";
-			productName = libdispatch;
-			productReference = E49BB6F21E70748100868613 /* libdispatch_armv81.a */;
-			productType = "com.apple.product-type.library.static";
-		};
-		E49F24A9125D57FA0057C971 /* libdispatch no resolver */ = {
-			isa = PBXNativeTarget;
-			buildConfigurationList = E49F24D8125D57FA0057C971 /* Build configuration list for PBXNativeTarget "libdispatch no resolver" */;
-			buildPhases = (
-				E49F24AA125D57FA0057C971 /* Headers */,
-				E49F24C7125D57FA0057C971 /* Sources */,
-				E49F24D5125D57FA0057C971 /* Frameworks */,
-				E4EB4A3014C3A14000AA0FA9 /* Install Headers */,
-				E4128EB213B9612700ABB2CB /* Postprocess Headers */,
-				E49F24D7125D57FA0057C971 /* Install Manpages */,
-			);
-			buildRules = (
-			);
-			dependencies = (
-			);
-			name = "libdispatch no resolver";
-			productName = libdispatch;
-			productReference = E49F24DF125D57FA0057C971 /* libdispatch.dylib */;
-			productType = "com.apple.product-type.library.dynamic";
-		};
-		E4B51595164B2DA300E003AF /* libdispatch introspection */ = {
-			isa = PBXNativeTarget;
-			buildConfigurationList = E4B515D3164B2DA300E003AF /* Build configuration list for PBXNativeTarget "libdispatch introspection" */;
-			buildPhases = (
-				E4B51596164B2DA300E003AF /* Headers */,
-				E4B515BC164B2DA300E003AF /* Sources */,
-				E421E5FC1716B8E10090DC9B /* Install DTrace Header */,
-			);
-			buildRules = (
-			);
-			dependencies = (
-			);
-			name = "libdispatch introspection";
-			productName = libdispatch;
-			productReference = E4B515D6164B2DA300E003AF /* libdispatch.dylib */;
-			productType = "com.apple.product-type.library.dynamic";
-		};
-		E4EC121612514715000DDBD1 /* libdispatch mp resolved */ = {
-			isa = PBXNativeTarget;
-			buildConfigurationList = E4EC122612514715000DDBD1 /* Build configuration list for PBXNativeTarget "libdispatch mp resolved" */;
-			buildPhases = (
-				E4EC121712514715000DDBD1 /* Mig Headers */,
-				E4EC121812514715000DDBD1 /* Sources */,
-				E4EC122512514715000DDBD1 /* Symlink normal variant */,
-			);
-			buildRules = (
-			);
-			dependencies = (
-			);
-			name = "libdispatch mp resolved";
-			productName = libdispatch;
-			productReference = E4EC122D12514715000DDBD1 /* libdispatch_mp.a */;
-			productType = "com.apple.product-type.library.static";
-		};
-/* End PBXNativeTarget section */
-
-/* Begin PBXProject section */
-		08FB7793FE84155DC02AAC07 /* Project object */ = {
-			isa = PBXProject;
-			attributes = {
-				BuildIndependentTargetsInParallel = YES;
-				DefaultBuildSystemTypeForWorkspace = Latest;
-				LastUpgradeCheck = 1010;
-				TargetAttributes = {
-					3F3C9326128E637B0042B1F7 = {
-						ProvisioningStyle = Manual;
-					};
-					4552540A19B1389700B88766 = {
-						ProvisioningStyle = Manual;
-					};
-					6E040C621C499B1B00411A2E = {
-						CreatedOnToolsVersion = 7.3;
-						ProvisioningStyle = Manual;
-					};
-					6E2ECAFD1C49C2FF00A30A32 = {
-						CreatedOnToolsVersion = 7.3;
-						ProvisioningStyle = Manual;
-					};
-					6EB4E4081BA8BCAD00D7B9D2 = {
-						CreatedOnToolsVersion = 7.0;
-						ProvisioningStyle = Manual;
-					};
-					92CBD7201BED924F006E0892 = {
-						ProvisioningStyle = Manual;
-					};
-					92F3FECA1BEC69E500025962 = {
-						CreatedOnToolsVersion = 7.1;
-						ProvisioningStyle = Manual;
-					};
-					9BEBA56F20127D3300E6FD0D = {
-						CreatedOnToolsVersion = 9.3;
-						ProvisioningStyle = Automatic;
-					};
-					C00B0DF01C5AEBBE000330B3 = {
-						ProvisioningStyle = Manual;
-					};
-					C01866A41C5973210040FC07 = {
-						ProvisioningStyle = Manual;
-					};
-					C927F35A10FD7F0600C5AB8B = {
-						ProvisioningStyle = Manual;
-					};
-					D2AAC045055464E500DB518D = {
-						ProvisioningStyle = Manual;
-					};
-					E49F24A9125D57FA0057C971 = {
-						ProvisioningStyle = Manual;
-					};
-					E4B51595164B2DA300E003AF = {
-						ProvisioningStyle = Manual;
-					};
-					E4EC121612514715000DDBD1 = {
-						ProvisioningStyle = Manual;
-					};
-				};
-			};
-			buildConfigurationList = 1DEB91EF08733DB70010E9CD /* Build configuration list for PBXProject "libdispatch" */;
-			compatibilityVersion = "Xcode 3.2";
-			developmentRegion = English;
-			hasScannedForEncodings = 1;
-			knownRegions = (
-				English,
-				Japanese,
-				French,
-				German,
-			);
-			mainGroup = 08FB7794FE84155DC02AAC07 /* libdispatch */;
-			projectDirPath = "";
-			projectReferences = (
-				{
-					ProductGroup = C927F36010FD7F1000C5AB8B /* Products */;
-					ProjectRef = C927F35F10FD7F1000C5AB8B /* ddt.xcodeproj */;
-				},
-				{
-					ProductGroup = 4552536F19B1384900B88766 /* Products */;
-					ProjectRef = 4552536E19B1384900B88766 /* libdispatchtest.xcodeproj */;
-				},
-				{
-					ProductGroup = 9B6A42E11FE098430000D146 /* Products */;
-					ProjectRef = 9B6A42E01FE098430000D146 /* queue-tip.xcodeproj */;
-				},
-			);
-			projectRoot = "";
-			targets = (
-				D2AAC045055464E500DB518D /* libdispatch */,
-				E49F24A9125D57FA0057C971 /* libdispatch no resolver */,
-				E4EC121612514715000DDBD1 /* libdispatch mp resolved */,
-				E49BB6CE1E70748100868613 /* libdispatch armv81 resolved */,
-				E4B51595164B2DA300E003AF /* libdispatch introspection */,
-				C01866A41C5973210040FC07 /* libdispatch mp static */,
-				C00B0DF01C5AEBBE000330B3 /* libdispatch dyld stub */,
-				6E43553E215B5D9D00C13177 /* libdispatch_introspection */,
-				6EA833C22162D6380045EFDC /* libdispatch_introspection_Sim */,
-				3F3C9326128E637B0042B1F7 /* libdispatch_Sim */,
-				6E2ECAFD1C49C2FF00A30A32 /* libdispatch_kernel */,
-				C927F35A10FD7F0600C5AB8B /* libdispatch_tools */,
-				9BEBA56F20127D3300E6FD0D /* libdispatch_tools_Sim */,
-				4552540A19B1389700B88766 /* libdispatch_tests */,
-				92CBD7201BED924F006E0892 /* libdispatch_tests_legacy */,
-				92F3FECA1BEC69E500025962 /* darwintests */,
-				6E040C621C499B1B00411A2E /* libfirehose_kernel */,
-				6EB4E4081BA8BCAD00D7B9D2 /* libfirehose_server */,
-			);
-		};
-/* End PBXProject section */
-
-/* Begin PBXReferenceProxy section */
-		4552540319B1384900B88766 /* bench */ = {
-			isa = PBXReferenceProxy;
-			fileType = "compiled.mach-o.executable";
-			path = bench;
-			remoteRef = 4552540219B1384900B88766 /* PBXContainerItemProxy */;
-			sourceTree = BUILT_PRODUCTS_DIR;
-		};
-		4552540519B1384900B88766 /* jsgc_bench */ = {
-			isa = PBXReferenceProxy;
-			fileType = "compiled.mach-o.executable";
-			path = jsgc_bench;
-			remoteRef = 4552540419B1384900B88766 /* PBXContainerItemProxy */;
-			sourceTree = BUILT_PRODUCTS_DIR;
-		};
-		4552540719B1384900B88766 /* async_bench */ = {
-			isa = PBXReferenceProxy;
-			fileType = "compiled.mach-o.executable";
-			path = async_bench;
-			remoteRef = 4552540619B1384900B88766 /* PBXContainerItemProxy */;
-			sourceTree = BUILT_PRODUCTS_DIR;
-		};
-		4552540919B1384900B88766 /* apply_bench */ = {
-			isa = PBXReferenceProxy;
-			fileType = "compiled.mach-o.executable";
-			path = apply_bench;
-			remoteRef = 4552540819B1384900B88766 /* PBXContainerItemProxy */;
-			sourceTree = BUILT_PRODUCTS_DIR;
-		};
-		9B2A11AA2032494E0060E7D4 /* queue-tip */ = {
-			isa = PBXReferenceProxy;
-			fileType = "compiled.mach-o.executable";
-			path = "queue-tip";
-			remoteRef = 9B2A11A92032494E0060E7D4 /* PBXContainerItemProxy */;
-			sourceTree = BUILT_PRODUCTS_DIR;
-		};
-		C927F36710FD7F1000C5AB8B /* ddt */ = {
-			isa = PBXReferenceProxy;
-			fileType = "compiled.mach-o.executable";
-			path = ddt;
-			remoteRef = C927F36610FD7F1000C5AB8B /* PBXContainerItemProxy */;
-			sourceTree = BUILT_PRODUCTS_DIR;
-		};
-/* End PBXReferenceProxy section */
-
-/* Begin PBXShellScriptBuildPhase section */
-		4CED8B9D0EEDF8B600AF99AB /* Install Manpages */ = {
-			isa = PBXShellScriptBuildPhase;
-			buildActionMask = 8;
-			files = (
-			);
-			inputPaths = (
-				"$(SRCROOT)/xcodescripts/install-manpages.sh",
-			);
-			name = "Install Manpages";
-			outputPaths = (
-			);
-			runOnlyForDeploymentPostprocessing = 1;
-			shellPath = "/bin/bash -e";
-			shellScript = ". \"${SCRIPT_INPUT_FILE_0}\"";
-			showEnvVarsInLog = 0;
-		};
-		6E2464DD1F5E67900031ADD9 /* Validate symbol ordering */ = {
-			isa = PBXShellScriptBuildPhase;
-			buildActionMask = 8;
-			files = (
-			);
-			inputPaths = (
-				"$(SRCROOT)/xcodeconfig/libdispatch.order",
-				"$(SRCROOT)/xcodeconfig/libdispatch.dirty",
-				"$(SRCROOT)/xcodeconfig/libdispatch.clean",
-			);
-			name = "Validate symbol ordering";
-			outputPaths = (
-			);
-			runOnlyForDeploymentPostprocessing = 1;
-			shellPath = "/bin/bash -e";
-			shellScript = ". \"${SRCROOT}/xcodescripts/check-order.sh\"\n";
-			showEnvVarsInLog = 0;
-		};
-		C00B0E061C5AEBBE000330B3 /* Symlink libdispatch.a -> libdispatch_dyld_target.a */ = {
-			isa = PBXShellScriptBuildPhase;
-			buildActionMask = 2147483647;
-			files = (
-			);
-			inputPaths = (
-				"$(SRCROOT)/xcodescripts/run-on-install.sh",
-			);
-			name = "Symlink libdispatch.a -> libdispatch_dyld_target.a";
-			outputPaths = (
-				"${DSTROOT}${INSTALL_PATH}/libdispatch.a",
-			);
-			runOnlyForDeploymentPostprocessing = 0;
-			shellPath = "/bin/bash -e";
-			shellScript = ". \"${SCRIPT_INPUT_FILE_0}\" /bin/ln -sf ${PRODUCT_NAME}.a ${SCRIPT_OUTPUT_FILE_0}";
-			showEnvVarsInLog = 0;
-		};
-		C01866C01C59777B0040FC07 /* Symlink to the loaderd path */ = {
-			isa = PBXShellScriptBuildPhase;
-			buildActionMask = 2147483647;
-			files = (
-			);
-			inputPaths = (
-				"$(SRCROOT)/xcodescripts/run-on-install.sh",
-			);
-			name = "Symlink to the loaderd path";
-			outputPaths = (
-				"${DSTROOT}/usr/local/lib/loaderd/${PRODUCT_NAME}.a",
-			);
-			runOnlyForDeploymentPostprocessing = 0;
-			shellPath = "/bin/bash -e";
-			shellScript = ". \"${SCRIPT_INPUT_FILE_0}\" /bin/ln -sf ../../../..${INSTALL_PATH}/${PRODUCT_NAME}.a ${DSTROOT}/usr/local/lib/loaderd/${PRODUCT_NAME}.a";
-			showEnvVarsInLog = 0;
-		};
-		E4128EB213B9612700ABB2CB /* Postprocess Headers */ = {
-			isa = PBXShellScriptBuildPhase;
-			buildActionMask = 8;
-			files = (
-			);
-			inputPaths = (
-				"$(SRCROOT)/xcodescripts/postprocess-headers.sh",
-			);
-			name = "Postprocess Headers";
-			outputPaths = (
-			);
-			runOnlyForDeploymentPostprocessing = 1;
-			shellPath = "/bin/bash -e";
-			shellScript = ". \"${SCRIPT_INPUT_FILE_0}\"";
-			showEnvVarsInLog = 0;
-		};
-		E421E5FC1716B8E10090DC9B /* Install DTrace Header */ = {
-			isa = PBXShellScriptBuildPhase;
-			buildActionMask = 2147483647;
-			files = (
-			);
-			inputPaths = (
-				"$(SRCROOT)/xcodescripts/install-dtrace.sh",
-				"$(SRCROOT)/src/provider.d",
-			);
-			name = "Install DTrace Header";
-			outputPaths = (
-				"$(CONFIGURATION_BUILD_DIR)/$(PUBLIC_HEADERS_FOLDER_PATH)/introspection.d",
-			);
-			runOnlyForDeploymentPostprocessing = 0;
-			shellPath = "/bin/bash -e";
-			shellScript = ". \"${SCRIPT_INPUT_FILE_0}\"\n";
-			showEnvVarsInLog = 0;
-		};
-		E482F1C512DBAA110030614D /* Postprocess Headers */ = {
-			isa = PBXShellScriptBuildPhase;
-			buildActionMask = 8;
-			files = (
-			);
-			inputPaths = (
-				"$(SRCROOT)/xcodescripts/postprocess-headers.sh",
-			);
-			name = "Postprocess Headers";
-			outputPaths = (
-			);
-			runOnlyForDeploymentPostprocessing = 1;
-			shellPath = "/bin/bash -e";
-			shellScript = ". \"${SCRIPT_INPUT_FILE_0}\"\n";
-			showEnvVarsInLog = 0;
-		};
-		E49BB6CF1E70748100868613 /* Mig Headers */ = {
-			isa = PBXShellScriptBuildPhase;
-			buildActionMask = 2147483647;
-			files = (
-			);
-			inputPaths = (
-				"$(SRCROOT)/src/protocol.defs",
-				"$(SRCROOT)/src/firehose/firehose.defs",
-				"$(SRCROOT)/src/firehose/firehose_reply.defs",
-				"$(SRCROOT)/xcodescripts/mig-headers.sh",
-			);
-			name = "Mig Headers";
-			outputPaths = (
-				"$(DERIVED_FILE_DIR)/protocol.h",
-				"$(DERIVED_FILE_DIR)/protocolServer.h",
-				"$(DERIVED_FILE_DIR)/firehose.h",
-				"$(DERIVED_FILE_DIR)/firehoseServer.h",
-				"$(DERIVED_FILE_DIR)/firehose_reply.h",
-				"$(DERIVED_FILE_DIR)/firehose_replyServer.h",
-			);
-			runOnlyForDeploymentPostprocessing = 0;
-			shellPath = "/bin/bash -e";
-			shellScript = ". \"${SCRIPT_INPUT_FILE_3}\"";
-			showEnvVarsInLog = 0;
-		};
-		E49BB6EE1E70748100868613 /* Symlink normal variant */ = {
-			isa = PBXShellScriptBuildPhase;
-			buildActionMask = 2147483647;
-			files = (
-			);
-			inputPaths = (
-			);
-			name = "Symlink normal variant";
-			outputPaths = (
-				"$(CONFIGURATION_BUILD_DIR)/$(PRODUCT_NAME)_normal.a",
-			);
-			runOnlyForDeploymentPostprocessing = 0;
-			shellPath = "/bin/bash -e";
-			shellScript = "ln -fs \"${PRODUCT_NAME}.a\" \"${SCRIPT_OUTPUT_FILE_0}\"";
-			showEnvVarsInLog = 0;
-		};
-		E49F24D7125D57FA0057C971 /* Install Manpages */ = {
-			isa = PBXShellScriptBuildPhase;
-			buildActionMask = 8;
-			files = (
-			);
-			inputPaths = (
-				"$(SRCROOT)/xcodescripts/install-manpages.sh",
-			);
-			name = "Install Manpages";
-			outputPaths = (
-			);
-			runOnlyForDeploymentPostprocessing = 1;
-			shellPath = "/bin/bash -e";
-			shellScript = ". \"${SCRIPT_INPUT_FILE_0}\"";
-			showEnvVarsInLog = 0;
-		};
-		E4EB4A2B14C3720B00AA0FA9 /* Install Headers */ = {
-			isa = PBXShellScriptBuildPhase;
-			buildActionMask = 2147483647;
-			files = (
-			);
-			inputPaths = (
-				"$(SRCROOT)/xcodescripts/install-headers.sh",
-				"$(SRCROOT)/os/object.h",
-				"$(SRCROOT)/os/object_private.h",
-				"$(SRCROOT)/os/venture_private.h",
-				"$(SRCROOT)/os/voucher_private.h",
-				"$(SRCROOT)/os/voucher_activity_private.h",
-			);
-			name = "Install Headers";
-			outputPaths = (
-				"$(CONFIGURATION_BUILD_DIR)/$(OS_PUBLIC_HEADERS_FOLDER_PATH)/object.h",
-				"$(CONFIGURATION_BUILD_DIR)/$(OS_PRIVATE_HEADERS_FOLDER_PATH)/object_private.h",
-				"$(CONFIGURATION_BUILD_DIR)/$(OS_PRIVATE_HEADERS_FOLDER_PATH)/venture_private.h",
-				"$(CONFIGURATION_BUILD_DIR)/$(OS_PRIVATE_HEADERS_FOLDER_PATH)/voucher_private.h",
-				"$(CONFIGURATION_BUILD_DIR)/$(OS_PRIVATE_HEADERS_FOLDER_PATH)/voucher_activity_private.h",
-			);
-			runOnlyForDeploymentPostprocessing = 0;
-			shellPath = "/bin/bash -e";
-			shellScript = ". \"${SCRIPT_INPUT_FILE_0}\"";
-			showEnvVarsInLog = 0;
-		};
-		E4EB4A3014C3A14000AA0FA9 /* Install Headers */ = {
-			isa = PBXShellScriptBuildPhase;
-			buildActionMask = 2147483647;
-			files = (
-			);
-			inputPaths = (
-				"$(SRCROOT)/xcodescripts/install-headers.sh",
-				"$(SRCROOT)/os/object.h",
-				"$(SRCROOT)/os/object_private.h",
-				"$(SRCROOT)/os/venture_private.h",
-				"$(SRCROOT)/os/voucher_private.h",
-				"$(SRCROOT)/os/voucher_activity_private.h",
-			);
-			name = "Install Headers";
-			outputPaths = (
-				"$(CONFIGURATION_BUILD_DIR)/$(OS_PUBLIC_HEADERS_FOLDER_PATH)/object.h",
-				"$(CONFIGURATION_BUILD_DIR)/$(OS_PRIVATE_HEADERS_FOLDER_PATH)/object_private.h",
-				"$(CONFIGURATION_BUILD_DIR)/$(OS_PRIVATE_HEADERS_FOLDER_PATH)/venture_private.h",
-				"$(CONFIGURATION_BUILD_DIR)/$(OS_PRIVATE_HEADERS_FOLDER_PATH)/voucher_private.h",
-				"$(CONFIGURATION_BUILD_DIR)/$(OS_PRIVATE_HEADERS_FOLDER_PATH)/voucher_activity_private.h",
-			);
-			runOnlyForDeploymentPostprocessing = 0;
-			shellPath = "/bin/bash -e";
-			shellScript = ". \"${SCRIPT_INPUT_FILE_0}\"";
-			showEnvVarsInLog = 0;
-		};
-		E4EC121712514715000DDBD1 /* Mig Headers */ = {
-			isa = PBXShellScriptBuildPhase;
-			buildActionMask = 2147483647;
-			files = (
-			);
-			inputPaths = (
-				"$(SRCROOT)/src/protocol.defs",
-				"$(SRCROOT)/src/firehose/firehose.defs",
-				"$(SRCROOT)/src/firehose/firehose_reply.defs",
-				"$(SRCROOT)/xcodescripts/mig-headers.sh",
-			);
-			name = "Mig Headers";
-			outputPaths = (
-				"$(DERIVED_FILE_DIR)/protocol.h",
-				"$(DERIVED_FILE_DIR)/protocolServer.h",
-				"$(DERIVED_FILE_DIR)/firehose.h",
-				"$(DERIVED_FILE_DIR)/firehoseServer.h",
-				"$(DERIVED_FILE_DIR)/firehose_reply.h",
-				"$(DERIVED_FILE_DIR)/firehose_replyServer.h",
-			);
-			runOnlyForDeploymentPostprocessing = 0;
-			shellPath = "/bin/bash -e";
-			shellScript = ". \"${SCRIPT_INPUT_FILE_3}\"";
-			showEnvVarsInLog = 0;
-		};
-		E4EC122512514715000DDBD1 /* Symlink normal variant */ = {
-			isa = PBXShellScriptBuildPhase;
-			buildActionMask = 2147483647;
-			files = (
-			);
-			inputPaths = (
-			);
-			name = "Symlink normal variant";
-			outputPaths = (
-				"$(CONFIGURATION_BUILD_DIR)/$(PRODUCT_NAME)_normal.a",
-			);
-			runOnlyForDeploymentPostprocessing = 0;
-			shellPath = "/bin/bash -e";
-			shellScript = "ln -fs \"${PRODUCT_NAME}.a\" \"${SCRIPT_OUTPUT_FILE_0}\"";
-			showEnvVarsInLog = 0;
-		};
-		E4FB8E8F218CD68A004B7A25 /* Install Plists */ = {
-			isa = PBXShellScriptBuildPhase;
-			buildActionMask = 8;
-			files = (
-			);
-			inputFileListPaths = (
-			);
-			inputPaths = (
-				"$(SRCROOT)/xcodescripts/install-plists.sh",
-				"$(SRCROOT)/src/libdispatch.plist",
-			);
-			name = "Install Plists";
-			outputFileListPaths = (
-			);
-			outputPaths = (
-			);
-			runOnlyForDeploymentPostprocessing = 1;
-			shellPath = "/bin/bash -e";
-			shellScript = ". \"${SCRIPT_INPUT_FILE_0}\"\n";
-			showEnvVarsInLog = 0;
-		};
-/* End PBXShellScriptBuildPhase section */
-
-/* Begin PBXSourcesBuildPhase section */
-		6E040C5F1C499B1B00411A2E /* Sources */ = {
-			isa = PBXSourcesBuildPhase;
-			buildActionMask = 2147483647;
-			files = (
-				6E040C731C499C6500411A2E /* firehose_buffer.c in Sources */,
-			);
-			runOnlyForDeploymentPostprocessing = 0;
-		};
-		6EB4E4051BA8BCAD00D7B9D2 /* Sources */ = {
-			isa = PBXSourcesBuildPhase;
-			buildActionMask = 2147483647;
-			files = (
-				6E90269C1BB9BD50004DC3AD /* firehose.defs in Sources */,
-				6EF0B2781BA8C56E007FA4F6 /* firehose_reply.defs in Sources */,
-				6EF0B27A1BA8C57D007FA4F6 /* firehose_server_object.m in Sources */,
-				6E21F2E91BBB240E0000C6A5 /* firehose_server.c in Sources */,
-			);
-			runOnlyForDeploymentPostprocessing = 0;
-		};
-		C00B0DF11C5AEBBE000330B3 /* Sources */ = {
-			isa = PBXSourcesBuildPhase;
-			buildActionMask = 2147483647;
-			files = (
-				6E9C6CAD20F9848F00EA81C0 /* yield.c in Sources */,
-				C00B0DF21C5AEBBE000330B3 /* protocol.defs in Sources */,
-				C00B0DF71C5AEBBE000330B3 /* firehose.defs in Sources */,
-				C00B0DFA1C5AEBBE000330B3 /* firehose_reply.defs in Sources */,
-				C00B0DF31C5AEBBE000330B3 /* resolver.c in Sources */,
-				C00B0DF41C5AEBBE000330B3 /* init.c in Sources */,
-				C00B0DFE1C5AEBBE000330B3 /* object.c in Sources */,
-				C00B0DF81C5AEBBE000330B3 /* block.cpp in Sources */,
-				6EF2CAB31C8899ED001ABE83 /* lock.c in Sources */,
-				C00B0DF91C5AEBBE000330B3 /* semaphore.c in Sources */,
-				C00B0DFB1C5AEBBE000330B3 /* once.c in Sources */,
-				C00B0DF51C5AEBBE000330B3 /* queue.c in Sources */,
-				C00B0DFD1C5AEBBE000330B3 /* apply.c in Sources */,
-				C00B0E001C5AEBBE000330B3 /* source.c in Sources */,
-				6E4BACC81D48A42400B562AE /* mach.c in Sources */,
-				6EA9629E1D48622C00759D53 /* event.c in Sources */,
-				6EA962A61D48625500759D53 /* event_kevent.c in Sources */,
-				6E4BACFC1D49A04A00B562AE /* event_epoll.c in Sources */,
-				C00B0DFC1C5AEBBE000330B3 /* voucher.c in Sources */,
-				C00B0DF61C5AEBBE000330B3 /* firehose_buffer.c in Sources */,
-				C00B0E031C5AEBBE000330B3 /* io.c in Sources */,
-				C00B0E021C5AEBBE000330B3 /* data.c in Sources */,
-				C00B0E041C5AEBBE000330B3 /* transform.c in Sources */,
-				C00B0E011C5AEBBE000330B3 /* time.c in Sources */,
-				C00B0E051C5AEBBE000330B3 /* allocator.c in Sources */,
-				C00B0DFF1C5AEBBE000330B3 /* benchmark.c in Sources */,
-				E49BB70A1E70A3B000868613 /* venture.c in Sources */,
-			);
-			runOnlyForDeploymentPostprocessing = 0;
-		};
-		C01866A51C5973210040FC07 /* Sources */ = {
-			isa = PBXSourcesBuildPhase;
-			buildActionMask = 2147483647;
-			files = (
-				6E9C6CAC20F9848E00EA81C0 /* yield.c in Sources */,
-				C01866A61C5973210040FC07 /* protocol.defs in Sources */,
-				C01866AB1C5973210040FC07 /* firehose.defs in Sources */,
-				C01866AE1C5973210040FC07 /* firehose_reply.defs in Sources */,
-				C01866A71C5973210040FC07 /* resolver.c in Sources */,
-				C01866A81C5973210040FC07 /* init.c in Sources */,
-				C01866B21C5973210040FC07 /* object.c in Sources */,
-				C01866AC1C5973210040FC07 /* block.cpp in Sources */,
-				6EF2CAB21C8899EC001ABE83 /* lock.c in Sources */,
-				C01866AD1C5973210040FC07 /* semaphore.c in Sources */,
-				C01866AF1C5973210040FC07 /* once.c in Sources */,
-				C01866A91C5973210040FC07 /* queue.c in Sources */,
-				C01866B11C5973210040FC07 /* apply.c in Sources */,
-				C01866B41C5973210040FC07 /* source.c in Sources */,
-				6E4BACC71D48A42300B562AE /* mach.c in Sources */,
-				6EA9629D1D48622B00759D53 /* event.c in Sources */,
-				6EA962A51D48625400759D53 /* event_kevent.c in Sources */,
-				6E4BACFB1D49A04A00B562AE /* event_epoll.c in Sources */,
-				C01866B01C5973210040FC07 /* voucher.c in Sources */,
-				C01866AA1C5973210040FC07 /* firehose_buffer.c in Sources */,
-				C01866B71C5973210040FC07 /* io.c in Sources */,
-				C01866B61C5973210040FC07 /* data.c in Sources */,
-				C01866B81C5973210040FC07 /* transform.c in Sources */,
-				C01866B51C5973210040FC07 /* time.c in Sources */,
-				C01866B91C5973210040FC07 /* allocator.c in Sources */,
-				C01866B31C5973210040FC07 /* benchmark.c in Sources */,
-				E49BB7091E70A39700868613 /* venture.c in Sources */,
-			);
-			runOnlyForDeploymentPostprocessing = 0;
-		};
-		D2AAC044055464E500DB518D /* Sources */ = {
-			isa = PBXSourcesBuildPhase;
-			buildActionMask = 2147483647;
-			files = (
-				E43570B9126E93380097AB9F /* provider.d in Sources */,
-				FC7BEDA40E8361E600161930 /* protocol.defs in Sources */,
-				6ED64B471BBD89AF00C35F4D /* firehose.defs in Sources */,
-				6ED64B491BBD89BC00C35F4D /* firehose_reply.defs in Sources */,
-				E49F2499125D48D80057C971 /* resolver.c in Sources */,
-				E44EBE3E1251659900645D88 /* init.c in Sources */,
-				9661E56B0F3E7DDF00749F3E /* object.c in Sources */,
-				E4FC3264145F46C9002FBDDB /* object.m in Sources */,
-				E43A72501AF85BBC00BAA921 /* block.cpp in Sources */,
-				6EF2CAAC1C8899D5001ABE83 /* lock.c in Sources */,
-				721F5CCF0F15553500FF03A6 /* semaphore.c in Sources */,
-				96DF70BE0F38FE3C0074BD99 /* once.c in Sources */,
-				FC7BED990E8361E600161930 /* queue.c in Sources */,
-				9676A0E10F3E755D00713ADB /* apply.c in Sources */,
-				96A8AA870F41E7A400CD570B /* source.c in Sources */,
-				6E9C6CA720F9848100EA81C0 /* yield.c in Sources */,
-				6E4BACBD1D48A41500B562AE /* mach.c in Sources */,
-				6EA962971D48622600759D53 /* event.c in Sources */,
-				6EA9629F1D48625000759D53 /* event_kevent.c in Sources */,
-				6E4BACF51D49A04600B562AE /* event_epoll.c in Sources */,
-				E44A8E6B1805C3E0009FFDB6 /* voucher.c in Sources */,
-				6ED64B441BBD898700C35F4D /* firehose_buffer.c in Sources */,
-				5A27262610F26F1900751FBC /* io.c in Sources */,
-				5AAB45C010D30B79004407EA /* data.c in Sources */,
-				E420867016027AE500EEE210 /* data.m in Sources */,
-				C9C5F80E143C1771006DC718 /* transform.c in Sources */,
-				96032E4B0F5CC8C700241C5F /* time.c in Sources */,
-				2BBF5A63154B64F5002B20F9 /* allocator.c in Sources */,
-				965CD6350F3E806200D4E28D /* benchmark.c in Sources */,
-				6E9955CF1C3B218E0071D40C /* venture.c in Sources */,
-			);
-			runOnlyForDeploymentPostprocessing = 0;
-		};
-		E49BB6D01E70748100868613 /* Sources */ = {
-			isa = PBXSourcesBuildPhase;
-			buildActionMask = 2147483647;
-			files = (
-				E49BB6D11E70748100868613 /* provider.d in Sources */,
-				E49BB6D21E70748100868613 /* protocol.defs in Sources */,
-				E49BB6D41E70748100868613 /* firehose.defs in Sources */,
-				E49BB6DD1E70748100868613 /* firehose_reply.defs in Sources */,
-				E49BB6D71E70748100868613 /* resolver.c in Sources */,
-				E49BB6D91E70748100868613 /* init.c in Sources */,
-				E49BB6E01E70748100868613 /* object.c in Sources */,
-				E49BB6EA1E70748100868613 /* object.m in Sources */,
-				E49BB6E71E70748100868613 /* block.cpp in Sources */,
-				E49BB6DC1E70748100868613 /* lock.c in Sources */,
-				E49BB6DB1E70748100868613 /* semaphore.c in Sources */,
-				E49BB6DE1E70748100868613 /* once.c in Sources */,
-				E49BB6D81E70748100868613 /* mach.c in Sources */,
-				E49BB6DA1E70748100868613 /* queue.c in Sources */,
-				E49BB6DF1E70748100868613 /* apply.c in Sources */,
-				6E9C6CAA20F9848D00EA81C0 /* yield.c in Sources */,
-				E49BB6E31E70748100868613 /* source.c in Sources */,
-				E49BB6E81E70748100868613 /* event.c in Sources */,
-				E49BB6D61E70748100868613 /* event_kevent.c in Sources */,
-				E49BB6E21E70748100868613 /* event_epoll.c in Sources */,
-				E49BB6ED1E70748100868613 /* voucher.c in Sources */,
-				E49BB6D51E70748100868613 /* firehose_buffer.c in Sources */,
-				E49BB6E61E70748100868613 /* io.c in Sources */,
-				E49BB6E51E70748100868613 /* data.c in Sources */,
-				E49BB6EC1E70748100868613 /* data.m in Sources */,
-				E49BB6E91E70748100868613 /* transform.c in Sources */,
-				E49BB6E41E70748100868613 /* time.c in Sources */,
-				E49BB6EB1E70748100868613 /* allocator.c in Sources */,
-				E49BB6E11E70748100868613 /* benchmark.c in Sources */,
-				E49BB6D31E70748100868613 /* venture.c in Sources */,
-			);
-			runOnlyForDeploymentPostprocessing = 0;
-		};
-		E49F24C7125D57FA0057C971 /* Sources */ = {
-			isa = PBXSourcesBuildPhase;
-			buildActionMask = 2147483647;
-			files = (
-				E43570BA126E93380097AB9F /* provider.d in Sources */,
-				E49F24C8125D57FA0057C971 /* protocol.defs in Sources */,
-				6ED64B461BBD89AF00C35F4D /* firehose.defs in Sources */,
-				6ED64B4A1BBD89BD00C35F4D /* firehose_reply.defs in Sources */,
-				E49F24C9125D57FA0057C971 /* resolver.c in Sources */,
-				E49F24CA125D57FA0057C971 /* init.c in Sources */,
-				E49F24CF125D57FA0057C971 /* object.c in Sources */,
-				E4FC3265145F46C9002FBDDB /* object.m in Sources */,
-				E43A72841AF85BCB00BAA921 /* block.cpp in Sources */,
-				6EF2CAAD1C8899E9001ABE83 /* lock.c in Sources */,
-				E49F24CC125D57FA0057C971 /* semaphore.c in Sources */,
-				E49F24CD125D57FA0057C971 /* once.c in Sources */,
-				E49F24CB125D57FA0057C971 /* queue.c in Sources */,
-				E49F24CE125D57FA0057C971 /* apply.c in Sources */,
-				E49F24D1125D57FA0057C971 /* source.c in Sources */,
-				6E9C6CA820F9848C00EA81C0 /* yield.c in Sources */,
-				6E4BACC21D48A42000B562AE /* mach.c in Sources */,
-				6EA962981D48622700759D53 /* event.c in Sources */,
-				6EA962A01D48625100759D53 /* event_kevent.c in Sources */,
-				6E4BACF61D49A04700B562AE /* event_epoll.c in Sources */,
-				E44A8E6C1805C3E0009FFDB6 /* voucher.c in Sources */,
-				6ED64B401BBD898300C35F4D /* firehose_buffer.c in Sources */,
-				E49F24D4125D57FA0057C971 /* io.c in Sources */,
-				E49F24D3125D57FA0057C971 /* data.c in Sources */,
-				E420867116027AE500EEE210 /* data.m in Sources */,
-				C93D6165143E190E00EB9023 /* transform.c in Sources */,
-				E49F24D2125D57FA0057C971 /* time.c in Sources */,
-				2BBF5A64154B64F5002B20F9 /* allocator.c in Sources */,
-				E49F24D0125D57FA0057C971 /* benchmark.c in Sources */,
-				6E9956051C3B219B0071D40C /* venture.c in Sources */,
-			);
-			runOnlyForDeploymentPostprocessing = 0;
-		};
-		E4B515BC164B2DA300E003AF /* Sources */ = {
-			isa = PBXSourcesBuildPhase;
-			buildActionMask = 2147483647;
-			files = (
-				E4B515BD164B2DA300E003AF /* provider.d in Sources */,
-				E4B515BE164B2DA300E003AF /* protocol.defs in Sources */,
-				6ED64B481BBD89B100C35F4D /* firehose.defs in Sources */,
-				6ED64B4B1BBD89BE00C35F4D /* firehose_reply.defs in Sources */,
-				E4B515BF164B2DA300E003AF /* resolver.c in Sources */,
-				E4B515C0164B2DA300E003AF /* init.c in Sources */,
-				E4B515C5164B2DA300E003AF /* object.c in Sources */,
-				E4B515CC164B2DA300E003AF /* object.m in Sources */,
-				6E9C6CAB20F9848E00EA81C0 /* yield.c in Sources */,
-				E43A72871AF85BCD00BAA921 /* block.cpp in Sources */,
-				6EF2CAB01C8899EB001ABE83 /* lock.c in Sources */,
-				E4B515C2164B2DA300E003AF /* semaphore.c in Sources */,
-				E4B515C3164B2DA300E003AF /* once.c in Sources */,
-				E4B515C1164B2DA300E003AF /* queue.c in Sources */,
-				E4B515C4164B2DA300E003AF /* apply.c in Sources */,
-				E4B515C7164B2DA300E003AF /* source.c in Sources */,
-				6E4BACC51D48A42200B562AE /* mach.c in Sources */,
-				6EA9629B1D48622900759D53 /* event.c in Sources */,
-				6EA962A31D48625300759D53 /* event_kevent.c in Sources */,
-				6E4BACF91D49A04800B562AE /* event_epoll.c in Sources */,
-				E44A8E6F1805C3E0009FFDB6 /* voucher.c in Sources */,
-				6ED64B431BBD898600C35F4D /* firehose_buffer.c in Sources */,
-				E4B515CA164B2DA300E003AF /* io.c in Sources */,
-				E4B515C9164B2DA300E003AF /* data.c in Sources */,
-				E4B515CE164B2DA300E003AF /* data.m in Sources */,
-				E4B515CB164B2DA300E003AF /* transform.c in Sources */,
-				E4B515C8164B2DA300E003AF /* time.c in Sources */,
-				E4B515CD164B2DA300E003AF /* allocator.c in Sources */,
-				E4B515C6164B2DA300E003AF /* benchmark.c in Sources */,
-				6E9956021C3B21990071D40C /* venture.c in Sources */,
-				E4B515DD164B32E000E003AF /* introspection.c in Sources */,
-			);
-			runOnlyForDeploymentPostprocessing = 0;
-		};
-		E4EC121812514715000DDBD1 /* Sources */ = {
-			isa = PBXSourcesBuildPhase;
-			buildActionMask = 2147483647;
-			files = (
-				E417A38512A472C5004D659D /* provider.d in Sources */,
-				E44EBE5612517EBE00645D88 /* protocol.defs in Sources */,
-				6EBEC7E51BBDD30C009B1596 /* firehose.defs in Sources */,
-				6EBEC7E81BBDD324009B1596 /* firehose_reply.defs in Sources */,
-				E49F2423125D3C960057C971 /* resolver.c in Sources */,
-				E44EBE5712517EBE00645D88 /* init.c in Sources */,
-				E4EC121E12514715000DDBD1 /* object.c in Sources */,
-				E4FC3267145F46C9002FBDDB /* object.m in Sources */,
-				E43A72851AF85BCC00BAA921 /* block.cpp in Sources */,
-				6EF2CAAE1C8899EA001ABE83 /* lock.c in Sources */,
-				E4EC121B12514715000DDBD1 /* semaphore.c in Sources */,
-				E4EC121C12514715000DDBD1 /* once.c in Sources */,
-				E4EC121A12514715000DDBD1 /* queue.c in Sources */,
-				E4EC121D12514715000DDBD1 /* apply.c in Sources */,
-				E4EC122012514715000DDBD1 /* source.c in Sources */,
-				6E9C6CA920F9848D00EA81C0 /* yield.c in Sources */,
-				6E4BACC31D48A42100B562AE /* mach.c in Sources */,
-				6EA962991D48622800759D53 /* event.c in Sources */,
-				6EA962A11D48625100759D53 /* event_kevent.c in Sources */,
-				6E4BACF71D49A04700B562AE /* event_epoll.c in Sources */,
-				E44A8E6D1805C3E0009FFDB6 /* voucher.c in Sources */,
-				6ED64B411BBD898400C35F4D /* firehose_buffer.c in Sources */,
-				E4EC122412514715000DDBD1 /* io.c in Sources */,
-				E4EC122312514715000DDBD1 /* data.c in Sources */,
-				E420867216027AE500EEE210 /* data.m in Sources */,
-				C93D6167143E190F00EB9023 /* transform.c in Sources */,
-				E4EC122112514715000DDBD1 /* time.c in Sources */,
-				2BBF5A66154B64F5002B20F9 /* allocator.c in Sources */,
-				E4EC121F12514715000DDBD1 /* benchmark.c in Sources */,
-				6E9956041C3B219B0071D40C /* venture.c in Sources */,
-			);
-			runOnlyForDeploymentPostprocessing = 0;
-		};
-/* End PBXSourcesBuildPhase section */
-
-/* Begin PBXTargetDependency section */
-		6E2ECB021C49C31200A30A32 /* PBXTargetDependency */ = {
-			isa = PBXTargetDependency;
-			target = 6E040C621C499B1B00411A2E /* libfirehose_kernel */;
-			targetProxy = 6E2ECB011C49C31200A30A32 /* PBXContainerItemProxy */;
-		};
-		6EE5083B21701B9100833569 /* PBXTargetDependency */ = {
-			isa = PBXTargetDependency;
-			target = E4B51595164B2DA300E003AF /* libdispatch introspection */;
-			targetProxy = 6EE5083A21701B9100833569 /* PBXContainerItemProxy */;
-		};
-		6EE5083D21701B9600833569 /* PBXTargetDependency */ = {
-			isa = PBXTargetDependency;
-			target = E4B51595164B2DA300E003AF /* libdispatch introspection */;
-			targetProxy = 6EE5083C21701B9600833569 /* PBXContainerItemProxy */;
-		};
-		6EF0B27E1BA8C5BF007FA4F6 /* PBXTargetDependency */ = {
-			isa = PBXTargetDependency;
-			target = 6EB4E4081BA8BCAD00D7B9D2 /* libfirehose_server */;
-			targetProxy = 6EF0B27D1BA8C5BF007FA4F6 /* PBXContainerItemProxy */;
-		};
-		92CBD75A1BED926C006E0892 /* PBXTargetDependency */ = {
-			isa = PBXTargetDependency;
-			name = all;
-			targetProxy = 92CBD7591BED926C006E0892 /* PBXContainerItemProxy */;
-		};
-		92F3FECF1BEC6F1000025962 /* PBXTargetDependency */ = {
-			isa = PBXTargetDependency;
-			target = 92F3FECA1BEC69E500025962 /* darwintests */;
-			targetProxy = 92F3FECE1BEC6F1000025962 /* PBXContainerItemProxy */;
-		};
-		9B2A11A32032494E0060E7D4 /* PBXTargetDependency */ = {
-			isa = PBXTargetDependency;
-			name = "queue-tip";
-			targetProxy = 9B2A11A22032494E0060E7D4 /* PBXContainerItemProxy */;
-		};
-		9BEBA57820127D4400E6FD0D /* PBXTargetDependency */ = {
-			isa = PBXTargetDependency;
-			name = ddt;
-			targetProxy = 9BEBA57720127D4400E6FD0D /* PBXContainerItemProxy */;
-		};
-		C00B0E141C5AEED6000330B3 /* PBXTargetDependency */ = {
-			isa = PBXTargetDependency;
-			target = C00B0DF01C5AEBBE000330B3 /* libdispatch dyld stub */;
-			targetProxy = C00B0E131C5AEED6000330B3 /* PBXContainerItemProxy */;
-		};
-		C01866C21C597AEA0040FC07 /* PBXTargetDependency */ = {
-			isa = PBXTargetDependency;
-			target = C01866A41C5973210040FC07 /* libdispatch mp static */;
-			targetProxy = C01866C11C597AEA0040FC07 /* PBXContainerItemProxy */;
-		};
-		C927F36910FD7F1A00C5AB8B /* PBXTargetDependency */ = {
-			isa = PBXTargetDependency;
-			name = ddt;
-			targetProxy = C927F36810FD7F1A00C5AB8B /* PBXContainerItemProxy */;
-		};
-		E4128E4A13B94BCE00ABB2CB /* PBXTargetDependency */ = {
-			isa = PBXTargetDependency;
-			target = D2AAC045055464E500DB518D /* libdispatch */;
-			targetProxy = E4128E4913B94BCE00ABB2CB /* PBXContainerItemProxy */;
-		};
-		E47D6ECD125FEBA10070D91C /* PBXTargetDependency */ = {
-			isa = PBXTargetDependency;
-			target = E4EC121612514715000DDBD1 /* libdispatch mp resolved */;
-			targetProxy = E47D6ECC125FEBA10070D91C /* PBXContainerItemProxy */;
-		};
-		E49BB6F81E7074C100868613 /* PBXTargetDependency */ = {
-			isa = PBXTargetDependency;
-			target = E49BB6CE1E70748100868613 /* libdispatch armv81 resolved */;
-			targetProxy = E49BB6F71E7074C100868613 /* PBXContainerItemProxy */;
-		};
-/* End PBXTargetDependency section */
-
-/* Begin XCBuildConfiguration section */
-		1DEB91ED08733DB70010E9CD /* Release */ = {
-			isa = XCBuildConfiguration;
-			baseConfigurationReference = E40041AA125D705F0022B135 /* libdispatch-resolver.xcconfig */;
-			buildSettings = {
-			};
-			name = Release;
-		};
-		1DEB91F108733DB70010E9CD /* Release */ = {
-			isa = XCBuildConfiguration;
-			baseConfigurationReference = E43D93F11097917E004F6A62 /* libdispatch.xcconfig */;
-			buildSettings = {
-			};
-			name = Release;
-		};
-		3F3C9357128E637B0042B1F7 /* Release */ = {
-			isa = XCBuildConfiguration;
-			buildSettings = {
-			};
-			name = Release;
-		};
-		3F3C9358128E637B0042B1F7 /* Debug */ = {
-			isa = XCBuildConfiguration;
-			buildSettings = {
-			};
-			name = Debug;
-		};
-		4552540C19B1389700B88766 /* Release */ = {
-			isa = XCBuildConfiguration;
-			buildSettings = {
-				PRODUCT_NAME = "$(TARGET_NAME)";
-			};
-			name = Release;
-		};
-		4552540D19B1389700B88766 /* Debug */ = {
-			isa = XCBuildConfiguration;
-			buildSettings = {
-				PRODUCT_NAME = "$(TARGET_NAME)";
-			};
-			name = Debug;
-		};
-		6E040C641C499B1B00411A2E /* Release */ = {
-			isa = XCBuildConfiguration;
-			baseConfigurationReference = 6E040C721C499C3600411A2E /* libfirehose_kernel.xcconfig */;
-			buildSettings = {
-			};
-			name = Release;
-		};
-		6E040C651C499B1B00411A2E /* Debug */ = {
-			isa = XCBuildConfiguration;
-			baseConfigurationReference = 6E040C721C499C3600411A2E /* libfirehose_kernel.xcconfig */;
-			buildSettings = {
-			};
-			name = Debug;
-		};
-		6E2ECAFF1C49C30000A30A32 /* Release */ = {
-			isa = XCBuildConfiguration;
-			buildSettings = {
-				PRODUCT_NAME = "$(TARGET_NAME)";
-			};
-			name = Release;
-		};
-		6E2ECB001C49C30000A30A32 /* Debug */ = {
-			isa = XCBuildConfiguration;
-			buildSettings = {
-				PRODUCT_NAME = "$(TARGET_NAME)";
-			};
-			name = Debug;
-		};
-		6E435542215B5D9D00C13177 /* Release */ = {
-			isa = XCBuildConfiguration;
-			buildSettings = {
-				PRODUCT_NAME = "$(TARGET_NAME)";
-			};
-			name = Release;
-		};
-		6E435543215B5D9D00C13177 /* Debug */ = {
-			isa = XCBuildConfiguration;
-			buildSettings = {
-				PRODUCT_NAME = "$(TARGET_NAME)";
-			};
-			name = Debug;
-		};
-		6EA833C42162D6380045EFDC /* Release */ = {
-			isa = XCBuildConfiguration;
-			buildSettings = {
-				PRODUCT_NAME = "$(TARGET_NAME)";
-			};
-			name = Release;
-		};
-		6EA833C52162D6380045EFDC /* Debug */ = {
-			isa = XCBuildConfiguration;
-			buildSettings = {
-				PRODUCT_NAME = "$(TARGET_NAME)";
-			};
-			name = Debug;
-		};
-		6EB4E40B1BA8BCAD00D7B9D2 /* Release */ = {
-			isa = XCBuildConfiguration;
-			baseConfigurationReference = 6EB4E4421BA8BD7800D7B9D2 /* libfirehose.xcconfig */;
-			buildSettings = {
-			};
-			name = Release;
-		};
-		6EB4E40C1BA8BCAD00D7B9D2 /* Debug */ = {
-			isa = XCBuildConfiguration;
-			baseConfigurationReference = 6EB4E4421BA8BD7800D7B9D2 /* libfirehose.xcconfig */;
-			buildSettings = {
-			};
-			name = Debug;
-		};
-		92CBD7241BED924F006E0892 /* Release */ = {
-			isa = XCBuildConfiguration;
-			buildSettings = {
-				PRODUCT_NAME = "$(TARGET_NAME)";
-			};
-			name = Release;
-		};
-		92CBD7251BED924F006E0892 /* Debug */ = {
-			isa = XCBuildConfiguration;
-			buildSettings = {
-				PRODUCT_NAME = "$(TARGET_NAME)";
-			};
-			name = Debug;
-		};
-		92F3FECC1BEC69E500025962 /* Release */ = {
-			isa = XCBuildConfiguration;
-			buildSettings = {
-			};
-			name = Release;
-		};
-		92F3FECD1BEC69E500025962 /* Debug */ = {
-			isa = XCBuildConfiguration;
-			buildSettings = {
-			};
-			name = Debug;
-		};
-		9BEBA57020127D3300E6FD0D /* Release */ = {
-			isa = XCBuildConfiguration;
-			buildSettings = {
-				CODE_SIGN_STYLE = Automatic;
-				PRODUCT_NAME = "$(TARGET_NAME)";
-			};
-			name = Release;
-		};
-		9BEBA57120127D3300E6FD0D /* Debug */ = {
-			isa = XCBuildConfiguration;
-			buildSettings = {
-				CODE_SIGN_STYLE = Automatic;
-				PRODUCT_NAME = "$(TARGET_NAME)";
-			};
-			name = Debug;
-		};
-		C00B0E081C5AEBBE000330B3 /* Release */ = {
-			isa = XCBuildConfiguration;
-			baseConfigurationReference = C00B0E121C5AEBF7000330B3 /* libdispatch-dyld-stub.xcconfig */;
-			buildSettings = {
-			};
-			name = Release;
-		};
-		C00B0E091C5AEBBE000330B3 /* Debug */ = {
-			isa = XCBuildConfiguration;
-			baseConfigurationReference = C00B0E121C5AEBF7000330B3 /* libdispatch-dyld-stub.xcconfig */;
-			buildSettings = {
-			};
-			name = Debug;
-		};
-		C01866BB1C5973210040FC07 /* Release */ = {
-			isa = XCBuildConfiguration;
-			baseConfigurationReference = C01866BE1C59735B0040FC07 /* libdispatch-mp-static.xcconfig */;
-			buildSettings = {
-			};
-			name = Release;
-		};
-		C01866BC1C5973210040FC07 /* Debug */ = {
-			isa = XCBuildConfiguration;
-			baseConfigurationReference = C01866BE1C59735B0040FC07 /* libdispatch-mp-static.xcconfig */;
-			buildSettings = {
-			};
-			name = Debug;
-		};
-		C927F35B10FD7F0600C5AB8B /* Release */ = {
-			isa = XCBuildConfiguration;
-			buildSettings = {
-			};
-			name = Release;
-		};
-		C927F35C10FD7F0600C5AB8B /* Debug */ = {
-			isa = XCBuildConfiguration;
-			buildSettings = {
-			};
-			name = Debug;
-		};
-		E49BB6F01E70748100868613 /* Release */ = {
-			isa = XCBuildConfiguration;
-			baseConfigurationReference = E40041A9125D70590022B135 /* libdispatch-resolved.xcconfig */;
-			buildSettings = {
-				DISPATCH_RESOLVED_VARIANT = armv81;
-			};
-			name = Release;
-		};
-		E49BB6F11E70748100868613 /* Debug */ = {
-			isa = XCBuildConfiguration;
-			baseConfigurationReference = E40041A9125D70590022B135 /* libdispatch-resolved.xcconfig */;
-			buildSettings = {
-				DISPATCH_RESOLVED_VARIANT = armv81;
-			};
-			name = Debug;
-		};
-		E49F24D9125D57FA0057C971 /* Release */ = {
-			isa = XCBuildConfiguration;
-			buildSettings = {
-				WARNING_CFLAGS = (
-					"-Weverything",
-					"$(inherited)",
-				);
-			};
-			name = Release;
-		};
-		E49F24DA125D57FA0057C971 /* Debug */ = {
-			isa = XCBuildConfiguration;
-			buildSettings = {
-				ONLY_ACTIVE_ARCH = YES;
-				WARNING_CFLAGS = (
-					"-Weverything",
-					"$(inherited)",
-				);
-			};
-			name = Debug;
-		};
-		E4B515D4164B2DA300E003AF /* Release */ = {
-			isa = XCBuildConfiguration;
-			baseConfigurationReference = E4B515D9164B2E9B00E003AF /* libdispatch-introspection.xcconfig */;
-			buildSettings = {
-			};
-			name = Release;
-		};
-		E4B515D5164B2DA300E003AF /* Debug */ = {
-			isa = XCBuildConfiguration;
-			baseConfigurationReference = E4B515D9164B2E9B00E003AF /* libdispatch-introspection.xcconfig */;
-			buildSettings = {
-			};
-			name = Debug;
-		};
-		E4EB382D1089033000C33AD4 /* Debug */ = {
-			isa = XCBuildConfiguration;
-			baseConfigurationReference = E43D93F11097917E004F6A62 /* libdispatch.xcconfig */;
-			buildSettings = {
-			};
-			name = Debug;
-		};
-		E4EB382E1089033000C33AD4 /* Debug */ = {
-			isa = XCBuildConfiguration;
-			baseConfigurationReference = E40041AA125D705F0022B135 /* libdispatch-resolver.xcconfig */;
-			buildSettings = {
-			};
-			name = Debug;
-		};
-		E4EC122712514715000DDBD1 /* Release */ = {
-			isa = XCBuildConfiguration;
-			baseConfigurationReference = E40041A9125D70590022B135 /* libdispatch-resolved.xcconfig */;
-			buildSettings = {
-				DISPATCH_RESOLVED_VARIANT = mp;
-			};
-			name = Release;
-		};
-		E4EC122812514715000DDBD1 /* Debug */ = {
-			isa = XCBuildConfiguration;
-			baseConfigurationReference = E40041A9125D70590022B135 /* libdispatch-resolved.xcconfig */;
-			buildSettings = {
-				DISPATCH_RESOLVED_VARIANT = mp;
-			};
-			name = Debug;
-		};
-/* End XCBuildConfiguration section */
-
-/* Begin XCConfigurationList section */
-		1DEB91EB08733DB70010E9CD /* Build configuration list for PBXNativeTarget "libdispatch" */ = {
-			isa = XCConfigurationList;
-			buildConfigurations = (
-				1DEB91ED08733DB70010E9CD /* Release */,
-				E4EB382E1089033000C33AD4 /* Debug */,
-			);
-			defaultConfigurationIsVisible = 0;
-			defaultConfigurationName = Release;
-		};
-		1DEB91EF08733DB70010E9CD /* Build configuration list for PBXProject "libdispatch" */ = {
-			isa = XCConfigurationList;
-			buildConfigurations = (
-				1DEB91F108733DB70010E9CD /* Release */,
-				E4EB382D1089033000C33AD4 /* Debug */,
-			);
-			defaultConfigurationIsVisible = 0;
-			defaultConfigurationName = Release;
-		};
-		3F3C9356128E637B0042B1F7 /* Build configuration list for PBXAggregateTarget "libdispatch_Sim" */ = {
-			isa = XCConfigurationList;
-			buildConfigurations = (
-				3F3C9357128E637B0042B1F7 /* Release */,
-				3F3C9358128E637B0042B1F7 /* Debug */,
-			);
-			defaultConfigurationIsVisible = 0;
-			defaultConfigurationName = Release;
-		};
-		4552540B19B1389700B88766 /* Build configuration list for PBXAggregateTarget "libdispatch_tests" */ = {
-			isa = XCConfigurationList;
-			buildConfigurations = (
-				4552540C19B1389700B88766 /* Release */,
-				4552540D19B1389700B88766 /* Debug */,
-			);
-			defaultConfigurationIsVisible = 0;
-			defaultConfigurationName = Release;
-		};
-		6E040C6A1C499B1B00411A2E /* Build configuration list for PBXNativeTarget "libfirehose_kernel" */ = {
-			isa = XCConfigurationList;
-			buildConfigurations = (
-				6E040C641C499B1B00411A2E /* Release */,
-				6E040C651C499B1B00411A2E /* Debug */,
-			);
-			defaultConfigurationIsVisible = 0;
-			defaultConfigurationName = Release;
-		};
-		6E2ECAFE1C49C30000A30A32 /* Build configuration list for PBXAggregateTarget "libdispatch_kernel" */ = {
-			isa = XCConfigurationList;
-			buildConfigurations = (
-				6E2ECAFF1C49C30000A30A32 /* Release */,
-				6E2ECB001C49C30000A30A32 /* Debug */,
-			);
-			defaultConfigurationIsVisible = 0;
-			defaultConfigurationName = Release;
-		};
-		6E435541215B5D9D00C13177 /* Build configuration list for PBXAggregateTarget "libdispatch_introspection" */ = {
-			isa = XCConfigurationList;
-			buildConfigurations = (
-				6E435542215B5D9D00C13177 /* Release */,
-				6E435543215B5D9D00C13177 /* Debug */,
-			);
-			defaultConfigurationIsVisible = 0;
-			defaultConfigurationName = Release;
-		};
-		6EA833C32162D6380045EFDC /* Build configuration list for PBXAggregateTarget "libdispatch_introspection_Sim" */ = {
-			isa = XCConfigurationList;
-			buildConfigurations = (
-				6EA833C42162D6380045EFDC /* Release */,
-				6EA833C52162D6380045EFDC /* Debug */,
-			);
-			defaultConfigurationIsVisible = 0;
-			defaultConfigurationName = Release;
-		};
-		6EB4E40A1BA8BCAD00D7B9D2 /* Build configuration list for PBXNativeTarget "libfirehose_server" */ = {
-			isa = XCConfigurationList;
-			buildConfigurations = (
-				6EB4E40B1BA8BCAD00D7B9D2 /* Release */,
-				6EB4E40C1BA8BCAD00D7B9D2 /* Debug */,
-			);
-			defaultConfigurationIsVisible = 0;
-			defaultConfigurationName = Release;
-		};
-		92CBD7231BED924F006E0892 /* Build configuration list for PBXAggregateTarget "libdispatch_tests_legacy" */ = {
-			isa = XCConfigurationList;
-			buildConfigurations = (
-				92CBD7241BED924F006E0892 /* Release */,
-				92CBD7251BED924F006E0892 /* Debug */,
-			);
-			defaultConfigurationIsVisible = 0;
-			defaultConfigurationName = Release;
-		};
-		92F3FECB1BEC69E500025962 /* Build configuration list for PBXLegacyTarget "darwintests" */ = {
-			isa = XCConfigurationList;
-			buildConfigurations = (
-				92F3FECC1BEC69E500025962 /* Release */,
-				92F3FECD1BEC69E500025962 /* Debug */,
-			);
-			defaultConfigurationIsVisible = 0;
-			defaultConfigurationName = Release;
-		};
-		9BEBA57620127D3300E6FD0D /* Build configuration list for PBXAggregateTarget "libdispatch_tools_Sim" */ = {
-			isa = XCConfigurationList;
-			buildConfigurations = (
-				9BEBA57020127D3300E6FD0D /* Release */,
-				9BEBA57120127D3300E6FD0D /* Debug */,
-			);
-			defaultConfigurationIsVisible = 0;
-			defaultConfigurationName = Release;
-		};
-		C00B0E071C5AEBBE000330B3 /* Build configuration list for PBXNativeTarget "libdispatch dyld stub" */ = {
-			isa = XCConfigurationList;
-			buildConfigurations = (
-				C00B0E081C5AEBBE000330B3 /* Release */,
-				C00B0E091C5AEBBE000330B3 /* Debug */,
-			);
-			defaultConfigurationIsVisible = 0;
-			defaultConfigurationName = Release;
-		};
-		C01866BA1C5973210040FC07 /* Build configuration list for PBXNativeTarget "libdispatch mp static" */ = {
-			isa = XCConfigurationList;
-			buildConfigurations = (
-				C01866BB1C5973210040FC07 /* Release */,
-				C01866BC1C5973210040FC07 /* Debug */,
-			);
-			defaultConfigurationIsVisible = 0;
-			defaultConfigurationName = Release;
-		};
-		C927F35E10FD7F0B00C5AB8B /* Build configuration list for PBXAggregateTarget "libdispatch_tools" */ = {
-			isa = XCConfigurationList;
-			buildConfigurations = (
-				C927F35B10FD7F0600C5AB8B /* Release */,
-				C927F35C10FD7F0600C5AB8B /* Debug */,
-			);
-			defaultConfigurationIsVisible = 0;
-			defaultConfigurationName = Release;
-		};
-		E49BB6EF1E70748100868613 /* Build configuration list for PBXNativeTarget "libdispatch armv81 resolved" */ = {
-			isa = XCConfigurationList;
-			buildConfigurations = (
-				E49BB6F01E70748100868613 /* Release */,
-				E49BB6F11E70748100868613 /* Debug */,
-			);
-			defaultConfigurationIsVisible = 0;
-			defaultConfigurationName = Release;
-		};
-		E49F24D8125D57FA0057C971 /* Build configuration list for PBXNativeTarget "libdispatch no resolver" */ = {
-			isa = XCConfigurationList;
-			buildConfigurations = (
-				E49F24D9125D57FA0057C971 /* Release */,
-				E49F24DA125D57FA0057C971 /* Debug */,
-			);
-			defaultConfigurationIsVisible = 0;
-			defaultConfigurationName = Release;
-		};
-		E4B515D3164B2DA300E003AF /* Build configuration list for PBXNativeTarget "libdispatch introspection" */ = {
-			isa = XCConfigurationList;
-			buildConfigurations = (
-				E4B515D4164B2DA300E003AF /* Release */,
-				E4B515D5164B2DA300E003AF /* Debug */,
-			);
-			defaultConfigurationIsVisible = 0;
-			defaultConfigurationName = Release;
-		};
-		E4EC122612514715000DDBD1 /* Build configuration list for PBXNativeTarget "libdispatch mp resolved" */ = {
-			isa = XCConfigurationList;
-			buildConfigurations = (
-				E4EC122712514715000DDBD1 /* Release */,
-				E4EC122812514715000DDBD1 /* Debug */,
-			);
-			defaultConfigurationIsVisible = 0;
-			defaultConfigurationName = Release;
-		};
-/* End XCConfigurationList section */
-	};
-	rootObject = 08FB7793FE84155DC02AAC07 /* Project object */;
-}
--- a/Telegram/ThirdParty/dispatch/LICENSE	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/LICENSE	1970-01-01 00:00:00.000000000 -0000
@@ -1,211 +0,0 @@
-                                 Apache License
-                           Version 2.0, January 2004
-                        http://www.apache.org/licenses/
-
-    TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
-
-    1. Definitions.
-
-      "License" shall mean the terms and conditions for use, reproduction,
-      and distribution as defined by Sections 1 through 9 of this document.
-
-      "Licensor" shall mean the copyright owner or entity authorized by
-      the copyright owner that is granting the License.
-
-      "Legal Entity" shall mean the union of the acting entity and all
-      other entities that control, are controlled by, or are under common
-      control with that entity. For the purposes of this definition,
-      "control" means (i) the power, direct or indirect, to cause the
-      direction or management of such entity, whether by contract or
-      otherwise, or (ii) ownership of fifty percent (50%) or more of the
-      outstanding shares, or (iii) beneficial ownership of such entity.
-
-      "You" (or "Your") shall mean an individual or Legal Entity
-      exercising permissions granted by this License.
-
-      "Source" form shall mean the preferred form for making modifications,
-      including but not limited to software source code, documentation
-      source, and configuration files.
-
-      "Object" form shall mean any form resulting from mechanical
-      transformation or translation of a Source form, including but
-      not limited to compiled object code, generated documentation,
-      and conversions to other media types.
-
-      "Work" shall mean the work of authorship, whether in Source or
-      Object form, made available under the License, as indicated by a
-      copyright notice that is included in or attached to the work
-      (an example is provided in the Appendix below).
-
-      "Derivative Works" shall mean any work, whether in Source or Object
-      form, that is based on (or derived from) the Work and for which the
-      editorial revisions, annotations, elaborations, or other modifications
-      represent, as a whole, an original work of authorship. For the purposes
-      of this License, Derivative Works shall not include works that remain
-      separable from, or merely link (or bind by name) to the interfaces of,
-      the Work and Derivative Works thereof.
-
-      "Contribution" shall mean any work of authorship, including
-      the original version of the Work and any modifications or additions
-      to that Work or Derivative Works thereof, that is intentionally
-      submitted to Licensor for inclusion in the Work by the copyright owner
-      or by an individual or Legal Entity authorized to submit on behalf of
-      the copyright owner. For the purposes of this definition, "submitted"
-      means any form of electronic, verbal, or written communication sent
-      to the Licensor or its representatives, including but not limited to
-      communication on electronic mailing lists, source code control systems,
-      and issue tracking systems that are managed by, or on behalf of, the
-      Licensor for the purpose of discussing and improving the Work, but
-      excluding communication that is conspicuously marked or otherwise
-      designated in writing by the copyright owner as "Not a Contribution."
-
-      "Contributor" shall mean Licensor and any individual or Legal Entity
-      on behalf of whom a Contribution has been received by Licensor and
-      subsequently incorporated within the Work.
-
-    2. Grant of Copyright License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      copyright license to reproduce, prepare Derivative Works of,
-      publicly display, publicly perform, sublicense, and distribute the
-      Work and such Derivative Works in Source or Object form.
-
-    3. Grant of Patent License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      (except as stated in this section) patent license to make, have made,
-      use, offer to sell, sell, import, and otherwise transfer the Work,
-      where such license applies only to those patent claims licensable
-      by such Contributor that are necessarily infringed by their
-      Contribution(s) alone or by combination of their Contribution(s)
-      with the Work to which such Contribution(s) was submitted. If You
-      institute patent litigation against any entity (including a
-      cross-claim or counterclaim in a lawsuit) alleging that the Work
-      or a Contribution incorporated within the Work constitutes direct
-      or contributory patent infringement, then any patent licenses
-      granted to You under this License for that Work shall terminate
-      as of the date such litigation is filed.
-
-    4. Redistribution. You may reproduce and distribute copies of the
-      Work or Derivative Works thereof in any medium, with or without
-      modifications, and in Source or Object form, provided that You
-      meet the following conditions:
-
-      (a) You must give any other recipients of the Work or
-          Derivative Works a copy of this License; and
-
-      (b) You must cause any modified files to carry prominent notices
-          stating that You changed the files; and
-
-      (c) You must retain, in the Source form of any Derivative Works
-          that You distribute, all copyright, patent, trademark, and
-          attribution notices from the Source form of the Work,
-          excluding those notices that do not pertain to any part of
-          the Derivative Works; and
-
-      (d) If the Work includes a "NOTICE" text file as part of its
-          distribution, then any Derivative Works that You distribute must
-          include a readable copy of the attribution notices contained
-          within such NOTICE file, excluding those notices that do not
-          pertain to any part of the Derivative Works, in at least one
-          of the following places: within a NOTICE text file distributed
-          as part of the Derivative Works; within the Source form or
-          documentation, if provided along with the Derivative Works; or,
-          within a display generated by the Derivative Works, if and
-          wherever such third-party notices normally appear. The contents
-          of the NOTICE file are for informational purposes only and
-          do not modify the License. You may add Your own attribution
-          notices within Derivative Works that You distribute, alongside
-          or as an addendum to the NOTICE text from the Work, provided
-          that such additional attribution notices cannot be construed
-          as modifying the License.
-
-      You may add Your own copyright statement to Your modifications and
-      may provide additional or different license terms and conditions
-      for use, reproduction, or distribution of Your modifications, or
-      for any such Derivative Works as a whole, provided Your use,
-      reproduction, and distribution of the Work otherwise complies with
-      the conditions stated in this License.
-
-    5. Submission of Contributions. Unless You explicitly state otherwise,
-      any Contribution intentionally submitted for inclusion in the Work
-      by You to the Licensor shall be under the terms and conditions of
-      this License, without any additional terms or conditions.
-      Notwithstanding the above, nothing herein shall supersede or modify
-      the terms of any separate license agreement you may have executed
-      with Licensor regarding such Contributions.
-
-    6. Trademarks. This License does not grant permission to use the trade
-      names, trademarks, service marks, or product names of the Licensor,
-      except as required for reasonable and customary use in describing the
-      origin of the Work and reproducing the content of the NOTICE file.
-
-    7. Disclaimer of Warranty. Unless required by applicable law or
-      agreed to in writing, Licensor provides the Work (and each
-      Contributor provides its Contributions) on an "AS IS" BASIS,
-      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
-      implied, including, without limitation, any warranties or conditions
-      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
-      PARTICULAR PURPOSE. You are solely responsible for determining the
-      appropriateness of using or redistributing the Work and assume any
-      risks associated with Your exercise of permissions under this License.
-
-    8. Limitation of Liability. In no event and under no legal theory,
-      whether in tort (including negligence), contract, or otherwise,
-      unless required by applicable law (such as deliberate and grossly
-      negligent acts) or agreed to in writing, shall any Contributor be
-      liable to You for damages, including any direct, indirect, special,
-      incidental, or consequential damages of any character arising as a
-      result of this License or out of the use or inability to use the
-      Work (including but not limited to damages for loss of goodwill,
-      work stoppage, computer failure or malfunction, or any and all
-      other commercial damages or losses), even if such Contributor
-      has been advised of the possibility of such damages.
-
-    9. Accepting Warranty or Additional Liability. While redistributing
-      the Work or Derivative Works thereof, You may choose to offer,
-      and charge a fee for, acceptance of support, warranty, indemnity,
-      or other liability obligations and/or rights consistent with this
-      License. However, in accepting such obligations, You may act only
-      on Your own behalf and on Your sole responsibility, not on behalf
-      of any other Contributor, and only if You agree to indemnify,
-      defend, and hold each Contributor harmless for any liability
-      incurred by, or claims asserted against, such Contributor by reason
-      of your accepting any such warranty or additional liability.
-
-    END OF TERMS AND CONDITIONS
-
-    APPENDIX: How to apply the Apache License to your work.
-
-      To apply the Apache License to your work, attach the following
-      boilerplate notice, with the fields enclosed by brackets "[]"
-      replaced with your own identifying information. (Don't include
-      the brackets!)  The text should be enclosed in the appropriate
-      comment syntax for the file format. We also recommend that a
-      file or class name and description of purpose be included on the
-      same "printed page" as the copyright notice for easier
-      identification within third-party archives.
-
-    Copyright [yyyy] [name of copyright owner]
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
-
-   
-   
-### Runtime Library Exception to the Apache 2.0 License: ###
-
-
-    As an exception, if you use this Software to compile your source code and
-    portions of this Software are embedded into the binary product as a result,
-    you may redistribute such product without providing attribution as would
-    otherwise be required by Sections 4(a), 4(b) and 4(d) of the License.
--- a/Telegram/ThirdParty/dispatch/.mailmap	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/.mailmap	1970-01-01 00:00:00.000000000 -0000
@@ -1,134 +0,0 @@
-Adrian-Constantin Popescu <epsilon.gamma@gmail.com> <adrian-constantin.popescu@outlook.com>
-Alex Blewitt <alblue@apple.com> <alex.blewitt@gmail.com>
-Alex Hoppen <alex@alexhoppen.de> <alex@ateamer.de>
-Alexis Beingessner <abeingessner@apple.com> <a.beingessner@gmail.com>
-Alper Çugun <github@alper.nl> <alper@users.noreply.github.com>
-Amr Aboelela <amraboelela@gmail.com> <amraboelela@users.noreply.github.com>
-Ankit Aggarwal <ankit_aggarwal@apple.com> <ankit.spd@gmail.com>
-Argyrios Kyrtzidis <kyrtzidis@apple.com> <akyrtzi@gmail.com>
-Arsen Gasparyan <to.arsen.gasparyan@gmail.com> <frootloops@users.noreply.github.com>
-Ben Cohen <ben_cohen@apple.com>
-Ben Cohen <ben_cohen@apple.com> <airspeedswift@users.noreply.github.com>
-Ben Cohen <ben_cohen@apple.com> <ben@airspeedvelocity.net>
-Ben Langmuir <blangmuir@apple.com> <ben.langmuir@gmail.com>
-Brent Royal-Gordon <brent@brentdax.com> <brent@architechies.com>
-Brian Croom <bcroom@apple.com> <brian.s.croom@gmail.com>
-Brian Gesiak <bgesiak@fb.com> <modocache@gmail.com>
-Bryan Chan <bryan.chan@ca.ibm.com> <bryanpkc@gmail.com>
-Calvin Hill <mr_j.c.h@hotmail.com> <return@users.noreply.github.com>
-Chris Bieneman <beanz@apple.com>
-Chris Bieneman <beanz@apple.com> <cbieneman@apple.com>
-Chris Lattner <clattner@nondot.org> <clattner@apple.com>
-Chris Lattner <clattner@nondot.org> <lattner@users.noreply.github.com>
-Chris Lattner <clattner@nondot.org> <sabre@iMac.local>
-Chris Williams <cwilliams@fitbit.com> <ultramiraculous@users.noreply.github.com>
-codester <sahil.profile@gmail.com> codestergit <sahil.profile@gmail.com>
-Dan Liew <dliew@apple.com> <36706441+danliew-apple@users.noreply.github.com>
-Daniel Duan <daniel@duan.org> <danmarner@gmail.com>
-Dante Broggi <34220985+Dante-Broggi@users.noreply.github.com>
-Dave <davesweeris@mac.com>
-Dave Abrahams <dabrahams@apple.com> <dave@boostpro.com>
-Dave Abrahams <dabrahams@apple.com> <dave@fripp.apple.com>
-Dave Abrahams <dabrahams@apple.com> <dave@Skree.local>
-Dave Abrahams <dabrahams@apple.com> <dave@Wingy.local>
-Dave Lee <davelee@lyft.com> <davelee.com@gmail.com>
-David Rönnqvist <david.ronnqvist@gmail.com> <david.ronnqvist@skype.net>
-David Zarzycki <dave@znu.io> <zarzycki@icloud.com>
-David Zarzycki <dave@znu.io> <zarzycki@mac.com>
-Davide Italiano <ditaliano@apple.com> <dcci@users.noreply.github.com>
-Davide Italiano <ditaliano@apple.com> <dccitaliano@gmail.com>
-Dmitri Gribenko <gribozavr@gmail.com> <dgribenko@apple.com>
-Doug Coleman <doug_coleman@apple.com> <doug.coleman@gmail.com>
-Enrico Granata <egranata@apple.com> <egranata@egranata.apple.com>
-Enrico Granata <egranata@apple.com> <granata.enrico@gmail.com>
-Erik Eckstein <eeckstein@apple.com> <eeckstein@apple.com>
-Erik Eckstein <eeckstein@apple.com> <eeckstein@rad-main.corp.apple.com>
-Erik Verbruggen <erik.verbruggen@me.com> <erikjv@users.noreply.github.com>
-Ewa Matejska <ematejska@apple.com> <ematejska@apple.com>
-Ewa Matejska <ematejska@apple.com> <ematejska@Ewas-MacBook-Pro.local>
-Ewa Matejska <ematejska@apple.com> <ewamatejska@Ewas-iMac.local>
-Florent Bruneau <florent.bruneau@intersec.com> <florent.bruneau_github@m4x.org>
-Francis Ricci <fjricci@fb.com> <francisjricci@gmail.com>
-GauravDS <er.gauravds@gmail.com> <gaurav.sharma@punchh.com>
-Graydon Hoare <ghoare@apple.com> <graydon@users.noreply.github.com>
-Greg Parker <gparker@apple.com> <gparker-github@sealiesoftware.com>
-Guillaume Lessard <dhtnstff@gmail.com> <glessard@users.noreply.github.com>
-Hamish <hamish2knight@gmail.com> <hamish2knight@gmail.com>
-Han Sangjin <tinysun@jssolution.co.kr> <tinysun.net@gmail.com>
-Harlan Haskins <harlan@apple.com> <harlan@harlanhaskins.com>
-Hitster GTD <hitstergtd@users.noreply.github.com> <hitstergtd@users.noreply.github.com>
-Huon Wilson <huon@apple.com> <dbau.pp+github@gmail.com>
-Ingmar Stein <IngmarStein@users.noreply.github.com>
-Itai Ferber <iferber@apple.com> <itai@itaiferber.net>
-Jacob Bandes-Storch <jacob@bandes-stor.ch> <jacob@bandes-storch.net>
-Jacob Mizraji <jmizraji@apple.com> <jacobmizraji@gmail.com>
-Janosch Hildebrand <jnosh@jnosh.com> <jnosh+git@jnosh.com>
-Janosch Hildebrand <jnosh@jnosh.com> <jnosh+github@jnosh.com>
-Javier Soto <jsbustos@twitch.tv> <javier.api@gmail.com>
-Javier Soto <jsbustos@twitch.tv> <javiers@twitter.com>
-Joe <joe@iachieved.it>
-Joe <joewillsher@icloud.com>
-joe DeCapo <joe@polka.cat>
-Joe Groff <jgroff@apple.com> <arcata@gmail.com>
-Joe Shajrawi <shajrawi@apple.com> <joeshajrawi@iMac-2.local>
-Joe Shajrawi <shajrawi@apple.com> <joeshajrawi@Joes-iMac-Pro.local>
-Johannes Weiß <johannesweiss@apple.com> <github@tux4u.de>
-John Regner <john@johnregner.com> <regnerjr@gmail.com>
-Karoy Lorentey <klorentey@apple.com> <karoly@lorentey.hu>
-Keith Smiley <k@keith.so> <keithbsmiley@gmail.com>
-Kevin Ballard <kevin@sb.org> <kevin.ballard@postmates.com>
-Kosuke Ogawa <ogawa_kousuke@aratana.jp> <koogawa.app@gmail.com>
-Kuba Mracek <mracek@apple.com> <jbrecka@apple.com>
-Luiz Fernando Silva <luizinho_mack@yahoo.com.br>
-Luqman Aden <luqman@apple.com> <luqman_aden@apple.com>
-Marcelo Fabri <me@marcelofabri.com> <marcelofabri@users.noreply.github.com>
-Mark Lacey <mark.lacey@apple.com> <rudkx@icloud.com>
-Mark Lacey <mark.lacey@apple.com> <rudkx@users.noreply.github.com>
-Matt Rajca <matt.rajca@me.com> <mattrajca@users.noreply.github.com>
-Max Moiseev <moiseev@apple.com> <maxim.moiseev@gmail.com>
-Max Moiseev <moiseev@apple.com> <moiseev@users.noreply.github.com>
-Maxwell Swadling <maxs@apple.com> <maxwellswadling@gmail.com>
-Maxwell Swadling <maxs@apple.com> <mswadling@apple.com>
-Mayur Raiturkar <mayur@mayur.xyz> <mayurkr@users.noreply.github.com>
-Michael Gottesman <mgottesman@apple.com> <gottesmm@users.noreply.github.com>
-Michael Ilseman <milseman@apple.com> <michael.ilseman@gmail.com>
-Mike Ash <mikeash@apple.com> <mike@mikeash.com>
-Mike Ferris <mferris@apple.com> <mike@lorax.com>
-Mishal Awadah <mawadah@apple.com>
-Mishal Shah <mishal_shah@apple.com> <shahmishal@users.noreply.github.com>
-Nadav Rotem <nrotem@apple.com> <nadavrot@users.noreply.github.com>
-Nate Cook <natecook@apple.com> <nate@Nates-MacBook-Pro.local>
-Nate Cook <natecook@apple.com> <natecook@gmail.com>
-Nate Cook <natecook@apple.com> <natecook1000@users.noreply.github.com>
-Nate Cook <natecook@apple.com> <nmersethcook@apple.com>
-Nathan Lanza <lanza@fb.com> <nathan@lanza.io>
-Nicole Jacque <jacque@apple.com>
-Niels Andriesse <andriesseniels@gmail.com> <nielsandriesse@users.noreply.github.com>
-Paul Meng <mno2@mno2.org> <mno2.csie@gmail.com>
-Pavel Yaskevich <pyaskevich@apple.com> <xedin@apache.org>
-Paweł Szot <pszot@pgs-soft.com>
-Paweł Szot <pszot@pgs-soft.com> <qwertyszot@gmail.com>
-Pete Cooper <peter_cooper@apple.com>
-Philip Ridgeway <pridgeway@vernier.com> <philip.ridgeway@gmail.com>
-Richard Wei <rxwei@apple.com> <rxwei@google.com>
-Rintaro Ishizaki <rishizaki@apple.com> <fs.output@gmail.com>
-Robert Widmann <rwidmann@apple.com> <devteam.codafi@gmail.com>
-Roman Levenstein <rlevenstein@apple.com> <swiftix@users.noreply.github.com>
-Ross Bayer <ross.m.bayer@gmail.com> <Rostepher@users.noreply.github.com>
-Russ Bishop <rbishopjr@apple.com> <russ@plangrid.com>
-Ryan Lovelett <ryan@lovelett.me> <RLovelett@users.noreply.github.com>
-Shawn Erickson <shawn.erickson@citrix.com> <shawnce@gmail.com>
-Slava Pestov <spestov@apple.com> <spestov@rad-main.corp.apple.com>
-Slava Pestov <spestov@apple.com> <sviatoslav.pestov@gmail.com>
-Stephen Canon <scanon@apple.com>
-Stephen Canon <scanon@apple.com> <stephentyrone@gmail.com>
-Sukolsak Sakshuwong <sukolsak@gmail.com>
-Todd Fiala <tfiala@apple.com> <todd.fiala@gmail.com>
-Toni Suter <tonisuter@me.com> <tonisuter@users.noreply.github.com>
-Vedant Kumar <vsk@apple.com> <vk@vedantk.com>
-Xi Ge <xi_ge@apple.com> <xi_ge@rad-main.corp.apple.com>
-Xin Tong <xin_tong@apple.com> <trent.xin.tong@gmail.com>
-Xin Tong <xin_tong@apple.com> <trentxintong@Xins-MacBook-Pro.local>
-Yuka Ezura <ezura@users.noreply.github.com> <2020337+ezura@users.noreply.github.com>
-Yurii Samsoniuk <ura@google.com> <mr.sigito@gmail.com>
-Zac Bowling <zbowling@google.com> <zac@zacbowling.com>
--- a/Telegram/ThirdParty/dispatch/man/CMakeLists.txt	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/man/CMakeLists.txt	1970-01-01 00:00:00.000000000 -0000
@@ -1,23 +0,0 @@
-
-# TODO(compnerd) add symlinks
-if(NOT ENABLE_SWIFT)
-  install(FILES
-            dispatch.3
-            dispatch_after.3
-            dispatch_api.3
-            dispatch_apply.3
-            dispatch_async.3
-            dispatch_data_create.3
-            dispatch_group_create.3
-            dispatch_io_create.3
-            dispatch_io_read.3
-            dispatch_object.3
-            dispatch_once.3
-            dispatch_queue_create.3
-            dispatch_read.3
-            dispatch_semaphore_create.3
-            dispatch_source_create.3
-            dispatch_time.3
-          DESTINATION
-            "${CMAKE_INSTALL_FULL_MANDIR}/man3")
-endif()
--- a/Telegram/ThirdParty/dispatch/man/dispatch.3	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/man/dispatch.3	1970-01-01 00:00:00.000000000 -0000
@@ -1,43 +0,0 @@
-.\" Copyright (c) 2008-2012 Apple Inc. All rights reserved.
-.Dd May 1, 2009
-.Dt dispatch 3
-.Os Darwin
-.Sh NAME
-.Nm dispatch
-.Nd the dispatch framework
-.Sh SYNOPSIS
-.Fd #include <dispatch/dispatch.h>
-.Sh DESCRIPTION
-The dispatch framework allows blocks to be scheduled for asynchronous and
-concurrent execution via the core functions described in
-.Xr dispatch_async 3 and
-.Xr dispatch_apply 3 .
-.Pp
-Dispatch queues are the basic units of organization of blocks. Several queues
-are created by default, and applications may create additional queues for their
-own use. See
-.Xr dispatch_queue_create 3
-for more information.
-.Pp
-Dispatch groups allow applications to track the progress of blocks submitted to
-queues and take action when the blocks complete. See
-.Xr dispatch_group_create 3
-for more information.
-.Pp
-The dispatch framework also provides functions to monitor underlying system
-events and automatically submit event handler blocks to dispatch queues.
-.Sh SEE ALSO
-.Xr dispatch_after 3 ,
-.Xr dispatch_api 3 ,
-.Xr dispatch_apply 3 ,
-.Xr dispatch_async 3 ,
-.Xr dispatch_data_create 3 ,
-.Xr dispatch_group_create 3 ,
-.Xr dispatch_io_create 3 ,
-.Xr dispatch_io_read 3 ,
-.Xr dispatch_object 3 ,
-.Xr dispatch_once 3 ,
-.Xr dispatch_queue_create 3 ,
-.Xr dispatch_semaphore_create 3 ,
-.Xr dispatch_source_create 3 ,
-.Xr dispatch_time 3
--- a/Telegram/ThirdParty/dispatch/man/dispatch_after.3	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/man/dispatch_after.3	1970-01-01 00:00:00.000000000 -0000
@@ -1,69 +0,0 @@
-.\" Copyright (c) 2008-2010 Apple Inc. All rights reserved.
-.Dd May 1, 2009
-.Dt dispatch_after 3
-.Os Darwin
-.Sh NAME
-.Nm dispatch_after
-.Nd schedule blocks for deferred execution
-.Sh SYNOPSIS
-.Fd #include <dispatch/dispatch.h>
-.Ft void
-.Fo dispatch_after
-.Fa "dispatch_time_t when" "dispatch_queue_t queue" "void (^block)(void)"
-.Fc
-.Ft void
-.Fo dispatch_after_f
-.Fa "dispatch_time_t when" "dispatch_queue_t queue" "void *context" "void (*function)(void *)"
-.Fc
-.Sh DESCRIPTION
-The
-.Fn dispatch_after
-function submits the
-.Fa block
-to the given
-.Fa queue
-at the time specified by the
-.Fa when
-parameter.
-The
-.Fa when
-parameter is a value created by
-.Fn dispatch_time
-or
-.Fn dispatch_walltime .
-Submission of the block may be delayed by the system in order to improve power consumption and system performance.
-The system applies a leeway (see
-.Xr dispatch_source_set_timer 3 )
-that is equal to one tenth of the interval between
-.Fa when
-and the time at which the function is called, with the leeway capped to at least one millisecond and at most one minute.
-.Pp
-For a more detailed description about submitting blocks to queues, see
-.Xr dispatch_async 3 .
-.Sh CAVEATS
-.Fn dispatch_after
-retains the passed queue.
-.Pp
-Specifying
-.Vt DISPATCH_TIME_NOW
-as the
-.Fa when
-parameter
-is supported, but is not as efficient as calling
-.Fn dispatch_async .
-.Pp
-The result of passing
-.Vt DISPATCH_TIME_FOREVER
-as the
-.Fa when
-parameter is undefined.
-.Pp
-.Sh FUNDAMENTALS
-The
-.Fn dispatch_after
-function is a wrapper around
-.Fn dispatch_after_f .
-.Sh SEE ALSO
-.Xr dispatch 3 ,
-.Xr dispatch_async 3 ,
-.Xr dispatch_time 3
--- a/Telegram/ThirdParty/dispatch/man/dispatch_api.3	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/man/dispatch_api.3	1970-01-01 00:00:00.000000000 -0000
@@ -1,44 +0,0 @@
-.\" Copyright (c) 2008-2009 Apple Inc. All rights reserved.
-.Dd May 1, 2009
-.Dt dispatch_api 3
-.Os Darwin
-.Sh NAME
-.Nm dispatch_api
-.Nd Designing API using dispatch
-.Sh DESCRIPTION
-The following is a brief summary of some of the common design patterns to
-consider when designing and implementing API in terms of dispatch queues
-and blocks.
-.Pp
-A general recommendation is to allow both a callback block and target dispatch
-queue to be specified. This gives the application the greatest flexibility in
-handling asynchronous events.
-.Pp
-It's also recommended that interfaces take only a single block as the last
-parameter. This is both for consistency across projects, as well as the visual
-aesthetics of multiline blocks that are declared inline. The dispatch queue to
-which the block will be submitted should immediately precede the block argument
-(second-to-last argument). For example:
-.Pp
-.Bd -literal -offset indent
-read_async(file, callback_queue, ^{
-	printf("received callback.\\n");
-});
-.Ed
-.Pp
-When function pointer alternatives to interfaces that take blocks are provided,
-the argument order of the function signature should be identical to the block
-variant; with the exception that the block argument is replaced with a context
-pointer, and a new last parameter is added, which is the function to call.
-.Pp
-The function based callback should pass the context pointer as the first
-argument, and the subsequent arguments should be identical to the block based
-variant (albeit offset by one in order).
-.Pp
-It is also important to use consistent naming. The dispatch API, for example,
-uses the suffix "_f" for function based variants.
-.Pp
-.Sh SEE ALSO
-.Xr dispatch 3 ,
-.Xr dispatch_async 3 ,
-.Xr dispatch_queue_create 3
--- a/Telegram/ThirdParty/dispatch/man/dispatch_apply.3	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/man/dispatch_apply.3	1970-01-01 00:00:00.000000000 -0000
@@ -1,122 +0,0 @@
-.\" Copyright (c) 2008-2017 Apple Inc. All rights reserved.
-.Dd May 1, 2009
-.Dt dispatch_apply 3
-.Os Darwin
-.Sh NAME
-.Nm dispatch_apply
-.Nd schedule blocks for iterative execution
-.Sh SYNOPSIS
-.Fd #include <dispatch/dispatch.h>
-.Ft void
-.Fo dispatch_apply
-.Fa "size_t iterations" "dispatch_queue_t queue" "void (^block)(size_t)"
-.Fc
-.Ft void
-.Fo dispatch_apply_f
-.Fa "size_t iterations" "dispatch_queue_t queue" "void *context" "void (*function)(void *, size_t)"
-.Fc
-.Sh DESCRIPTION
-The
-.Fn dispatch_apply
-function provides data-level concurrency through a "for (;;)" loop like primitive:
-.Bd -literal
-size_t iterations = 10;
-
-// 'idx' is zero indexed, just like:
-// for (idx = 0; idx < iterations; idx++)
-
-dispatch_apply(iterations, DISPATCH_APPLY_AUTO, ^(size_t idx) {
-	printf("%zu\\n", idx);
-});
-.Ed
-.Pp
-Although any queue can be used, it is strongly recommended to use 
-.Vt DISPATCH_APPLY_AUTO
-as the 
-.Vt queue 
-argument to both
-.Fn dispatch_apply
-and
-.Fn dispatch_apply_f , 
-as shown in the example above, since this allows the system to automatically use worker threads
-that match the configuration of the current thread as closely as possible.
-No assumptions should be made about which global concurrent queue will be used.
-.Pp
-Like a "for (;;)" loop, the
-.Fn dispatch_apply
-function is synchronous.
-If asynchronous behavior is desired, wrap the call to
-.Fn dispatch_apply
-with a call to
-.Fn dispatch_async
-against another queue.
-.Pp
-Sometimes, when the block passed to
-.Fn dispatch_apply
-is simple, the use of striding can tune performance.
-Calculating the optimal stride is best left to experimentation.
-Start with a stride of one and work upwards until the desired performance is
-achieved (perhaps using a power of two search):
-.Bd -literal
-#define STRIDE 3
-
-dispatch_apply(count / STRIDE, DISPATCH_APPLY_AUTO, ^(size_t idx) {
-	size_t j = idx * STRIDE;
-	size_t j_stop = j + STRIDE;
-	do {
-		printf("%zu\\n", j++);
-	} while (j < j_stop);
-});
-
-size_t i;
-for (i = count - (count % STRIDE); i < count; i++) {
-	printf("%zu\\n", i);
-}
-.Ed
-.Sh IMPLIED REFERENCES
-Synchronous functions within the dispatch framework hold an implied reference
-on the target queue. In other words, the synchronous function borrows the
-reference of the calling function (this is valid because the calling function
-is blocked waiting for the result of the synchronous function, and therefore
-cannot modify the reference count of the target queue until after the
-synchronous function has returned).
-.Pp
-This is in contrast to asynchronous functions which must retain both the block
-and target queue for the duration of the asynchronous operation (as the calling
-function may immediately release its interest in these objects).
-.Sh FUNDAMENTALS
-.Fn dispatch_apply
-and
-.Fn dispatch_apply_f
-attempt to quickly create enough worker threads to efficiently iterate work in parallel.
-By contrast, a loop that passes work items individually to
-.Fn dispatch_async
-or
-.Fn dispatch_async_f
-will incur more overhead and does not express the desired parallel execution semantics to
-the system, so may not create an optimal number of worker threads for a parallel workload.
-For this reason, prefer to use 
-.Fn dispatch_apply
-or
-.Fn dispatch_apply_f
-when parallel execution is important.
-.Pp
-The
-.Fn dispatch_apply
-function is a wrapper around
-.Fn dispatch_apply_f .
-.Sh CAVEATS
-Unlike
-.Fn dispatch_async ,
-a block submitted to
-.Fn dispatch_apply
-is expected to be either independent or dependent
-.Em only
-on work already performed in lower-indexed invocations of the block. If
-the block's index dependency is non-linear, it is recommended to
-use a for-loop around invocations of
-.Fn dispatch_async .
-.Sh SEE ALSO
-.Xr dispatch 3 ,
-.Xr dispatch_async 3 ,
-.Xr dispatch_queue_create 3
--- a/Telegram/ThirdParty/dispatch/man/dispatch_async.3	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/man/dispatch_async.3	1970-01-01 00:00:00.000000000 -0000
@@ -1,235 +0,0 @@
-.\" Copyright (c) 2008-2012 Apple Inc. All rights reserved.
-.Dd May 1, 2009
-.Dt dispatch_async 3
-.Os Darwin
-.Sh NAME
-.Nm dispatch_async ,
-.Nm dispatch_sync
-.Nd schedule blocks for execution
-.Sh SYNOPSIS
-.Fd #include <dispatch/dispatch.h>
-.Ft void
-.Fo dispatch_async
-.Fa "dispatch_queue_t queue" "void (^block)(void)"
-.Fc
-.Ft void
-.Fo dispatch_sync
-.Fa "dispatch_queue_t queue" "void (^block)(void)"
-.Fc
-.Ft void
-.Fo dispatch_async_f
-.Fa "dispatch_queue_t queue" "void *context" "void (*function)(void *)"
-.Fc
-.Ft void
-.Fo dispatch_sync_f
-.Fa "dispatch_queue_t queue" "void *context" "void (*function)(void *)"
-.Fc
-.Sh DESCRIPTION
-The
-.Fn dispatch_async
-and
-.Fn dispatch_sync
-functions schedule blocks for concurrent execution within the
-.Xr dispatch 3
-framework. Blocks are submitted to a queue which dictates the policy for their
-execution. See
-.Xr dispatch_queue_create 3
-for more information about creating dispatch queues.
-.Pp
-These functions support efficient temporal synchronization, background
-concurrency and data-level concurrency. These same functions can also be used
-for efficient notification of the completion of asynchronous blocks (a.k.a.
-callbacks).
-.Sh TEMPORAL SYNCHRONIZATION
-Synchronization is often required when multiple threads of execution access
-shared data concurrently. The simplest form of synchronization is
-mutual-exclusion (a lock), whereby different subsystems execute concurrently
-until a shared critical section is entered. In the
-.Xr pthread 3
-family of procedures, temporal synchronization is accomplished like so:
-.Bd -literal -offset indent
-int r = pthread_mutex_lock(&my_lock);
-assert(r == 0);
-
-// critical section
-
-r = pthread_mutex_unlock(&my_lock);
-assert(r == 0);
-.Ed
-.Pp
-The
-.Fn dispatch_sync
-function may be used with a serial queue to accomplish the same style of
-synchronization. For example:
-.Bd -literal -offset indent
-dispatch_sync(my_queue, ^{
-	// critical section
-});
-.Ed
-.Pp
-In addition to providing a more concise expression of synchronization, this
-approach is less error prone as the critical section cannot be accidentally
-left without restoring the queue to a reentrant state.
-.Pp
-The
-.Fn dispatch_async
-function may be used to implement deferred critical sections when the result
-of the block is not needed locally. Deferred critical sections have the same
-synchronization properties as the above code, but are non-blocking and
-therefore more efficient to perform. For example:
-.Bd -literal
-dispatch_async(my_queue, ^{
-	// critical section
-});
-.Ed
-.Sh BACKGROUND CONCURRENCY
-.The
-.Fn dispatch_async
-function may be used to execute trivial background tasks on a global concurrent
-queue. For example:
-.Bd -literal
-dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0), ^{
-	// background operation
-});
-.Ed
-.Pp
-This approach is an efficient replacement for
-.Xr pthread_create 3 .
-.Sh COMPLETION CALLBACKS
-Completion callbacks can be accomplished via nested calls to the
-.Fn dispatch_async
-function. It is important to remember to retain the destination queue before the
-first call to
-.Fn dispatch_async ,
-and to release that queue at the end of the completion callback to ensure the
-destination queue is not deallocated while the completion callback is pending.
-For example:
-.Bd -literal
-void
-async_read(object_t obj,
-	void *where, size_t bytes,
-	dispatch_queue_t destination_queue,
-	void (^reply_block)(ssize_t r, int err))
-{
-	// There are better ways of doing async I/O.
-	// This is just an example of nested blocks.
-
-	dispatch_retain(destination_queue);
-
-	dispatch_async(obj->queue, ^{
-		ssize_t r = read(obj->fd, where, bytes);
-		int err = errno;
-
-		dispatch_async(destination_queue, ^{
-			reply_block(r, err);
-		});
-		dispatch_release(destination_queue);
-	});
-}
-.Ed
-.Sh RECURSIVE LOCKS
-While
-.Fn dispatch_sync
-can replace a lock, it cannot replace a recursive lock. Unlike locks, queues
-support both asynchronous and synchronous operations, and those operations are
-ordered by definition. A recursive call to
-.Fn dispatch_sync
-causes a simple deadlock as the currently executing block waits for the next
-block to complete, but the next block will not start until the currently
-running block completes.
-.Pp
-As the dispatch framework was designed, we studied recursive locks. We found
-that the vast majority of recursive locks are deployed retroactively when
-ill-defined lock hierarchies are discovered. As a consequence, the adoption of
-recursive locks often mutates obvious bugs into obscure ones. This study also
-revealed an insight: if reentrancy is unavoidable, then reader/writer locks are
-preferable to recursive locks. Disciplined use of reader/writer locks enable
-reentrancy only when reentrancy is safe (the "read" side of the lock).
-.Pp
-Nevertheless, if it is absolutely necessary, what follows is an imperfect way of
-implementing recursive locks using the dispatch framework:
-.Bd -literal
-void
-sloppy_lock(object_t object, void (^block)(void))
-{
-	if (object->owner == pthread_self()) {
-		return block();
-	}
-	dispatch_sync(object->queue, ^{
-		object->owner = pthread_self();
-		block();
-		object->owner = NULL;
-	});
-}
-.Ed
-.Pp
-The above example does not solve the case where queue A runs on thread X which
-calls
-.Fn dispatch_sync
-against queue B which runs on thread Y which recursively calls
-.Fn dispatch_sync
-against queue A, which deadlocks both examples. This is bug-for-bug compatible
-with nontrivial pthread usage. In fact, nontrivial reentrancy is impossible to
-support in recursive locks once the ultimate level of reentrancy is deployed
-(IPC or RPC).
-.Sh IMPLIED REFERENCES
-Synchronous functions within the dispatch framework hold an implied reference
-on the target queue. In other words, the synchronous function borrows the
-reference of the calling function (this is valid because the calling function
-is blocked waiting for the result of the synchronous function, and therefore
-cannot modify the reference count of the target queue until after the
-synchronous function has returned).
-For example:
-.Bd -literal
-queue = dispatch_queue_create("com.example.queue", NULL);
-assert(queue);
-dispatch_sync(queue, ^{
-	do_something();
-	//dispatch_release(queue); // NOT SAFE -- dispatch_sync() is still using 'queue'
-});
-dispatch_release(queue); // SAFELY balanced outside of the block provided to dispatch_sync()
-.Ed
-.Pp
-This is in contrast to asynchronous functions which must retain both the block
-and target queue for the duration of the asynchronous operation (as the calling
-function may immediately release its interest in these objects).
-.Sh FUNDAMENTALS
-Conceptually,
-.Fn dispatch_sync
-is a convenient wrapper around
-.Fn dispatch_async
-with the addition of a semaphore to wait for completion of the block, and a
-wrapper around the block to signal its completion. See
-.Xr dispatch_semaphore_create 3
-for more information about dispatch semaphores. The actual implementation of the
-.Fn dispatch_sync
-function may be optimized and differ from the above description.
-.Pp
-The
-.Fn dispatch_async
-function is a wrapper around
-.Fn dispatch_async_f .
-The application-defined
-.Fa context
-parameter is passed to the
-.Fa function
-when it is invoked on the target
-.Fa queue .
-.Pp
-The
-.Fn dispatch_sync
-function is a wrapper around
-.Fn dispatch_sync_f .
-The application-defined
-.Fa context
-parameter is passed to the
-.Fa function
-when it is invoked on the target
-.Fa queue .
-.Pp
-.Sh SEE ALSO
-.Xr dispatch 3 ,
-.Xr dispatch_apply 3 ,
-.Xr dispatch_once 3 ,
-.Xr dispatch_queue_create 3 ,
-.Xr dispatch_semaphore_create 3
--- a/Telegram/ThirdParty/dispatch/man/dispatch_benchmark.3	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/man/dispatch_benchmark.3	1970-01-01 00:00:00.000000000 -0000
@@ -1,59 +0,0 @@
-.\" Copyright (c) 2008-2009 Apple Inc. All rights reserved.
-.Dd May 1, 2009
-.Dt dispatch_benchmark 3
-.Os Darwin
-.Sh NAME
-.Nm dispatch_benchmark
-.Nd Measures block execution time
-.Sh SYNOPSIS
-.Fd #include <dispatch/dispatch.h>
-.Ft uint64_t
-.Fo dispatch_benchmark
-.Fa "size_t count" "void (^block)(void)"
-.Fc
-.Ft uint64_t
-.Fo dispatch_benchmark_f
-.Fa "size_t count" "void *context" "void (*function)(void *)"
-.Fc
-.Sh DESCRIPTION
-The
-.Fn dispatch_benchmark
-function executes the given
-.Fa block
-multiple times according to the
-.Fa count
-variable and then returns the average number of nanoseconds per execution.
-This function is for debugging and performance analysis work.
-For the best
-results, pass a high count value to
-.Fn dispatch_benchmark .
-When benchmarking concurrent code, please compare the
-serial version of the code against the concurrent version, and compare the
-concurrent version on different classes of hardware.
-Please look for inflection
-points with various data sets and keep the following facts in mind:
-.Pp
-.Bl -bullet -offset indent -compact
-.It
-Code bound by computational bandwidth may be inferred by proportional
-changes in performance as concurrency is increased.
-.It
-Code bound by memory bandwidth may be inferred by negligible changes in
-performance as concurrency is increased.
-.It
-Code bound by critical sections may be inferred by retrograde changes in
-performance as concurrency is increased.
-.Bl -bullet -offset indent -compact
-.It
-Intentional: locks, mutexes, and condition variables.
-.It
-Accidental: unrelated and frequently modified data on the same cache-line.
-.El
-.El
-.Sh RETURN VALUE
-The
-.Fn dispatch_benchmark
-function returns the average number of nanoseconds the given block takes to
-execute.
-.Sh SEE ALSO
-.Xr dispatch 3
--- a/Telegram/ThirdParty/dispatch/man/dispatch_data_create.3	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/man/dispatch_data_create.3	1970-01-01 00:00:00.000000000 -0000
@@ -1,220 +0,0 @@
-.\" Copyright (c) 2010-2012 Apple Inc. All rights reserved.
-.Dd December 1, 2010
-.Dt dispatch_data_create 3
-.Os Darwin
-.Sh NAME
-.Nm dispatch_data_create ,
-.Nm dispatch_data_create_concat ,
-.Nm dispatch_data_create_subrange ,
-.Nm dispatch_data_create_map ,
-.Nm dispatch_data_apply ,
-.Nm dispatch_data_copy_region ,
-.Nm dispatch_data_get_size
-.Nd create and manipulate dispatch data objects
-.Sh SYNOPSIS
-.Fd #include <dispatch/dispatch.h>
-.Ft dispatch_data_t
-.Fo dispatch_data_create
-.Fa "const void* buffer"
-.Fa "size_t size"
-.Fa "dispatch_queue_t queue"
-.Fa "dispatch_block_t destructor"
-.Fc
-.Ft dispatch_data_t
-.Fo dispatch_data_create_concat
-.Fa "dispatch_data_t data1"
-.Fa "dispatch_data_t data2"
-.Fc
-.Ft dispatch_data_t
-.Fo dispatch_data_create_subrange
-.Fa "dispatch_data_t data"
-.Fa "size_t offset"
-.Fa "size_t length"
-.Fc
-.Ft dispatch_data_t
-.Fo dispatch_data_create_map
-.Fa "dispatch_data_t data"
-.Fa "const void **buffer_ptr"
-.Fa "size_t *size_ptr"
-.Fc
-.Ft bool
-.Fo dispatch_data_apply
-.Fa "dispatch_data_t data"
-.Fa "bool (^applier)(dispatch_data_t, size_t, const void *, size_t)"
-.Fc
-.Ft dispatch_data_t
-.Fo dispatch_data_copy_region
-.Fa "dispatch_data_t data"
-.Fa "size_t location"
-.Fa "size_t *offset_ptr"
-.Fc
-.Ft size_t
-.Fo dispatch_data_get_size
-.Fa "dispatch_data_t data"
-.Fc
-.Vt dispatch_data_t dispatch_data_empty ;
-.Sh DESCRIPTION
-Dispatch data objects are opaque containers of bytes that represent one or more
-regions of memory. They are created either from memory buffers managed by the
-application or the system or from other dispatch data objects. Dispatch data
-objects are immutable and the memory regions they represent are required to
-remain unchanged for the lifetime of all data objects that reference them.
-Dispatch data objects avoid copying the represented memory as much as possible.
-Multiple data objects can represent the same memory regions or subsections
-thereof.
-.Sh CREATION
-The
-.Fn dispatch_data_create
-function creates a new dispatch data object of given
-.Fa size
-from a
-.Fa buffer .
-The provided
-.Fa destructor
-block will be submitted to the specified
-.Fa queue
-when the object reaches the end of its lifecycle, indicating that the system no
-longer references the
-.Fa buffer .
-This allows the application to deallocate
-the associated storage. The
-.Fa queue
-argument is ignored if one of the following predefined destructors is passed:
-.Bl -tag -width DISPATCH_DATA_DESTRUCTOR_DEFAULT -compact -offset indent
-.It DISPATCH_DATA_DESTRUCTOR_FREE
-indicates that the provided buffer can be deallocated with
-.Xr free 3
-directly.
-.It DISPATCH_DATA_DESTRUCTOR_DEFAULT
-indicates that the provided buffer is not managed by the application and should
-be copied into memory managed and automatically deallocated by the system.
-.El
-.Pp
-The
-.Fn dispatch_data_create_concat
-function creates a new data object representing the concatenation of the memory
-regions represented by the provided data objects.
-.Pp
-The
-.Fn dispatch_data_create_subrange
-function creates a new data object representing the sub-region of the provided
-.Fa data
-object specified by the
-.Fa offset
-and
-.Fa length
-parameters.
-.Pp
-The
-.Fn dispatch_data_create_map
-function creates a new data object by mapping the memory represented by the
-provided
-.Fa data
-object as a single contiguous memory region (moving or copying memory as
-necessary). If the
-.Fa buffer_ptr
-and
-.Fa size_ptr
-references are not
-.Dv NULL ,
-they are filled with the location and extent of the contiguous region, allowing
-direct read access to the mapped memory. These values are valid only as long as
-the newly created object has not been released.
-.Sh ACCESS
-The
-.Fn dispatch_data_apply
-function provides read access to represented memory without requiring it to be
-mapped as a single contiguous region. It traverses the memory regions
-represented by the
-.Fa data
-argument in logical order, invokes the specified
-.Fa applier
-block for each region and returns a boolean indicating whether traversal
-completed successfully. The
-.Fa applier
-block is passed the following arguments for each memory region and returns a
-boolean indicating whether traversal should continue:
-.Bl -tag -width "dispatch_data_t rgn" -compact -offset indent
-.It Fa "dispatch_data_t rgn"
-data object representing the region
-.It Fa "size_t offset"
-logical position of the region in
-.Fa data
-.It Vt "const void *loc"
-memory location of the region
-.It Vt "size_t size"
-extent of the region
-.El
-The
-.Fa rgn
-data object is released by the system when the
-.Fa applier
-block returns.
-The associated memory location
-.Fa loc
-is valid only as long as
-.Fa rgn
-has not been deallocated; if
-.Fa loc
-is needed outside of the
-.Fa applier
-block, the
-.Fa rgn
-object must be retained in the block.
-.Pp
-The
-.Fn dispatch_data_copy_region
-function finds the contiguous memory region containing the logical position
-specified by the
-.Fa location
-argument among the regions represented by the provided
-.Fa data
-object and returns a newly created copy of the data object representing that
-region. The variable specified by the
-.Fa offset_ptr
-argument is filled with the logical position where the returned object starts
-in the
-.Fa data
-object.
-.Pp
-The
-.Fn dispatch_data_get_size
-function returns the logical size of the memory region or regions represented
-by the provided
-.Fa data
-object.
-.Sh EMPTY DATA OBJECT
-The
-.Vt dispatch_data_empty
-object is the global singleton object representing a zero-length memory region.
-It is a valid input to any dispatch_data functions that take data object
-parameters.
-.Sh MEMORY MODEL
-Dispatch data objects are retained and released via calls to
-.Fn dispatch_retain
-and
-.Fn dispatch_release .
-Data objects passed as arguments to a dispatch data
-.Sy create
-or
-.Sy copy
-function can be released when the function returns. The newly created object
-holds implicit references to their constituent memory regions as necessary.
-.Pp
-The functions
-.Fn dispatch_data_create_map
-and
-.Fn dispatch_data_apply
-return an interior pointer to represented memory that is only valid as long as
-an associated object has not been released. When Objective-C Automated
-Reference Counting is enabled, care needs to be taken if that object is held in
-a variable with automatic storage. It may need to be annotated with the
-.Li objc_precise_lifetime
-attribute, or stored in a
-.Li __strong
-instance variable instead, to ensure that the object is not released
-prematurely before memory accesses via the interor pointer have been completed.
-.Sh SEE ALSO
-.Xr dispatch 3 ,
-.Xr dispatch_object 3 ,
-.Xr dispatch_io_read 3
--- a/Telegram/ThirdParty/dispatch/man/dispatch_group_create.3	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/man/dispatch_group_create.3	1970-01-01 00:00:00.000000000 -0000
@@ -1,180 +0,0 @@
-.\" Copyright (c) 2008-2012 Apple Inc. All rights reserved.
-.Dd May 1, 2009
-.Dt dispatch_group_create 3
-.Os Darwin
-.Sh NAME
-.Nm dispatch_group_create ,
-.Nm dispatch_group_async ,
-.Nm dispatch_group_wait ,
-.Nm dispatch_group_notify
-.Nd group blocks submitted to queues
-.Sh SYNOPSIS
-.Fd #include <dispatch/dispatch.h>
-.Ft dispatch_group_t
-.Fo dispatch_group_create
-.Fa void
-.Fc
-.Ft void
-.Fo dispatch_group_enter
-.Fa "dispatch_group_t group"
-.Fc
-.Ft void
-.Fo dispatch_group_leave
-.Fa "dispatch_group_t group"
-.Fc
-.Ft long
-.Fo dispatch_group_wait
-.Fa "dispatch_group_t group" "dispatch_time_t timeout"
-.Fc
-.Ft void
-.Fo dispatch_group_notify
-.Fa "dispatch_group_t group" "dispatch_queue_t queue" "void (^block)(void)"
-.Fc
-.Ft void
-.Fo dispatch_group_notify_f
-.Fa "dispatch_group_t group" "dispatch_queue_t queue" "void *context" "void (*function)(void *)"
-.Fc
-.Ft void
-.Fo dispatch_group_async
-.Fa "dispatch_group_t group" "dispatch_queue_t queue" "void (^block)(void)"
-.Fc
-.Ft void
-.Fo dispatch_group_async_f
-.Fa "dispatch_group_t group" "dispatch_queue_t queue" "void *context" "void (*function)(void *)"
-.Fc
-.Sh DESCRIPTION
-A dispatch group is an association of one or more blocks submitted to dispatch
-queues for asynchronous invocation.
-Applications may use dispatch groups to
-wait for the completion of blocks associated with the group.
-.Pp
-The
-.Fn dispatch_group_create
-function returns a new and empty dispatch group.
-.Pp
-The
-.Fn dispatch_group_enter
-and
-.Fn dispatch_group_leave
-functions update the number of blocks running within a group.
-.Pp
-The
-.Fn dispatch_group_wait
-function waits until all blocks associated with the
-.Fa group
-have completed, or until the specified
-.Fa timeout
-has elapsed.
-If the
-.Fa group
-becomes empty within the specified amount of time, the function will return zero
-indicating success. Otherwise, a non-zero return code will be returned.
-When
-.Va DISPATCH_TIME_FOREVER
-is passed as the
-.Fa timeout ,
-calls to this function will wait an unlimited amount of time until the group
-becomes empty and the return value is always zero.
-.Pp
-The
-.Fn dispatch_group_notify
-function provides asynchronous notification of the completion of the blocks
-associated with the
-.Fa group
-by submitting the
-.Fa block
-to the specified
-.Fa queue
-once all blocks associated with the
-.Fa group
-have completed.
-The system holds a reference to the dispatch group while an asynchronous
-notification is pending, therefore it is valid to release the
-.Fa group
-after setting a notification block.
-The group will be empty at the time the notification block is submitted to the
-target queue. The group may either be released with
-.Fn dispatch_release
-or reused for additional operations.
-.Pp
-The
-.Fn dispatch_group_async
-convenience function behaves like so:
-.Bd -literal
-void
-dispatch_group_async(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block)
-{
-	dispatch_retain(group);
-	dispatch_group_enter(group);
-	dispatch_async(queue, ^{
-		block();
-		dispatch_group_leave(group);
-		dispatch_release(group);
-	});
-}
-.Ed
-.Sh RETURN VALUE
-The
-.Fn dispatch_group_create
-function returns NULL on failure and non-NULL on success.
-.Pp
-The
-.Fn dispatch_group_wait
-function returns zero upon success and non-zero after the timeout expires.
-If the timeout is
-.Va DISPATCH_TIME_FOREVER ,
-then
-.Fn dispatch_group_wait
-waits forever and always returns zero.
-.Sh MEMORY MODEL
-Dispatch groups are retained and released via calls to
-.Fn dispatch_retain
-and
-.Fn dispatch_release .
-.Sh FUNDAMENTALS
-The
-.Fn dispatch_group_async
-and
-.Fn dispatch_group_notify
-functions are wrappers around
-.Fn dispatch_group_async_f
-and
-.Fn dispatch_group_notify_f
-respectively.
-.Sh CAVEATS
-In order to ensure deterministic behavior, it is recommended to call
-.Fn dispatch_group_wait
-only once all blocks have been submitted to the group. If it is later
-determined that new blocks should be run, it is recommended not to reuse an
-already-running group, but to create a new group.
-.Pp
-.Fn dispatch_group_wait
-returns as soon as there are exactly zero
-.Em enqueued or running
-blocks associated with a group (more precisely, as soon as every
-.Fn dispatch_group_enter
-call has been balanced by a
-.Fn dispatch_group_leave
-call). If one thread waits for a group while another thread submits
-new blocks to the group, then the count of associated blocks might
-momentarily reach zero before all blocks have been submitted. If this happens,
-.Fn dispatch_group_wait
-will return too early: some blocks associated with the group have finished,
-but some have not yet been submitted or run.
-.Pp
-However, as a special case, a block associated with a group may submit new
-blocks associated with its own group. In this case, the behavior is
-deterministic: a waiting thread will
-.Em not
-wake up until the newly submitted blocks have also finished.
-.Pp
-All of the foregoing also applies to
-.Fn dispath_group_notify
-as well, with "block to be submitted" substituted for "waiting thread".
-.Sh SEE ALSO
-.Xr dispatch 3 ,
-.Xr dispatch_async 3 ,
-.Xr dispatch_object 3 ,
-.Xr dispatch_queue_create 3 ,
-.Xr dispatch_semaphore_create 3 ,
-.Xr dispatch_time 3
--- a/Telegram/ThirdParty/dispatch/man/dispatch_io_create.3	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/man/dispatch_io_create.3	1970-01-01 00:00:00.000000000 -0000
@@ -1,282 +0,0 @@
-.\" Copyright (c) 2010-2013 Apple Inc. All rights reserved.
-.Dd December 1, 2010
-.Dt dispatch_io_create 3
-.Os Darwin
-.Sh NAME
-.Nm dispatch_io_create ,
-.Nm dispatch_io_create_with_path ,
-.Nm dispatch_io_close ,
-.Nm dispatch_io_set_high_water ,
-.Nm dispatch_io_set_low_water ,
-.Nm dispatch_io_set_interval ,
-.Nm dispatch_io_barrier
-.Nd open, close and configure dispatch I/O channels
-.Sh SYNOPSIS
-.Fd #include <dispatch/dispatch.h>
-.Ft dispatch_io_t
-.Fo dispatch_io_create
-.Fa "dispatch_io_type_t type"
-.Fa "int fd"
-.Fa "dispatch_queue_t queue"
-.Fa "void (^cleanup_handler)(int error)"
-.Fc
-.Ft dispatch_io_t
-.Fo dispatch_io_create_with_path
-.Fa "dispatch_io_type_t type"
-.Fa "const char *path"
-.Fa "int oflag"
-.Fa "mode_t mode"
-.Fa "dispatch_queue_t queue"
-.Fa "void (^cleanup_handler)(int error)"
-.Fc
-.Ft void
-.Fo dispatch_io_close
-.Fa "dispatch_io_t channel"
-.Fa "dispatch_io_close_flags_t flags"
-.Fc
-.Ft void
-.Fo dispatch_io_set_high_water
-.Fa "dispatch_io_t channel"
-.Fa "size_t high_water"
-.Fc
-.Ft void
-.Fo dispatch_io_set_low_water
-.Fa "dispatch_io_t channel"
-.Fa "size_t low_water"
-.Fc
-.Ft void
-.Fo dispatch_io_set_interval
-.Fa "dispatch_io_t channel"
-.Fa "uint64_t interval"
-.Fa "dispatch_io_interval_flags_t flags"
-.Fc
-.Ft void
-.Fo dispatch_io_barrier
-.Fa "dispatch_io_t channel"
-.Fa "void (^barrier)(void)"
-.Fc
-.Sh DESCRIPTION
-The dispatch I/O framework is an API for asynchronous read and write I/O
-operations. It is an application of the ideas and idioms present in the
-.Xr dispatch 3
-framework to device I/O. Dispatch I/O enables an application to more easily
-avoid blocking I/O operations and allows it to more directly express its I/O
-requirements than by using the raw POSIX file API. Dispatch I/O will make a
-best effort to optimize how and when asynchronous I/O operations are performed
-based on the capabilities of the targeted device.
-.Pp
-This page provides details on how to create and configure dispatch I/O
-channels. Reading from and writing to these channels is covered in the
-.Xr dispatch_io_read 3
-page. The dispatch I/O framework also provides the convenience functions
-.Xr dispatch_read 3
-and
-.Xr dispatch_write 3
-for uses that do not require the full functionality provided by I/O channels.
-.Sh FUNDAMENTALS
-A dispatch I/O channel represents the asynchronous I/O policy applied to a file
-descriptor and encapsulates it for the purposes of ownership tracking while
-I/O operations are ongoing.
-.Sh CHANNEL TYPES
-Dispatch I/O channels can have one of the following types:
-.Bl -tag -width DISPATCH_IO_STREAM -compact -offset indent
-.It DISPATCH_IO_STREAM
-channels that represent a stream of bytes and do not support reads and writes
-at arbitrary offsets, such as pipes or sockets. Channels of this type perform
-read and write operations sequentially at the current file pointer position and
-ignore any offset specified. Depending on the underlying file descriptor, read
-operations may be performed simultaneously with write operations.
-.It DISPATCH_IO_RANDOM
-channels that represent random access files on disk. Only supported for
-seekable file descriptors and paths. Channels of this type may perform
-submitted read and write operations concurrently at the specified offset
-(interpreted relative to the position of the file pointer when the channel was
-created).
-.El
-.Sh CHANNEL OPENING AND CLOSING
-The
-.Fn dispatch_io_create
-and
-.Fn dispatch_io_create_with_path
-functions create a dispatch I/O channel of provided
-.Fa type
-from a file descriptor
-.Fa fd
-or an absolute pathname, respectively. They can be thought of as analogous to
-the
-.Xr fdopen 3
-POSIX function and the
-.Xr fopen 3
-function in the standard C library. For a channel created from a pathname, the
-provided
-.Fa path ,
-.Fa oflag
-and
-.Fa mode
-parameters will be passed to
-.Xr open 2
-when the first I/O operation on the channel is ready to execute.
-.Pp
-The provided
-.Fa cleanup_handler
-block will be submitted to the specified
-.Fa queue
-when all I/O operations on the channel have completed and it is closed or
-reaches the end of its lifecycle. If an error occurs during channel creation,
-the
-.Fa cleanup_handler
-block will be submitted immediately and passed an
-.Fa error
-parameter with the POSIX error encountered. If an invalid
-.Fa type
-or a non-absolute
-.Fa path
-argument is specified, these functions will return NULL and the
-.Fa cleanup_handler
-will not be invoked. After successfully creating a dispatch I/O channel from a
-file descriptor, the application must take care not to modify that file
-descriptor until the associated
-.Fa cleanup_handler
-is invoked, see
-.Sx "FILEDESCRIPTOR OWNERSHIP"
-for details.
-.Pp
-The
-.Fn dispatch_io_close
-function closes a dispatch I/O channel to new submissions of I/O operations. If
-.Dv DISPATCH_IO_STOP
-is passed in the
-.Fa flags
-parameter, the system will in addition not perform the I/O operations already
-submitted to the channel that are still pending and will make a best effort to
-interrupt any ongoing operations. Handlers for operations so affected will be
-passed the
-.Er ECANCELED
-error code, along with any partial results.
-.Sh CHANNEL CONFIGURATION
-Dispatch I/O channels have high-water mark, low-water mark and interval
-configuration settings that determine if and when partial results from I/O
-operations are delivered via their associated I/O handlers.
-.Pp
-The
-.Fn dispatch_io_set_high_water
-and
-.Fn dispatch_io_set_low_water
-functions configure the water mark settings of a
-.Fa channel .
-The system will read
-or write at least the number of bytes specified by
-.Fa low_water
-before submitting an I/O handler with partial results, and will make a best
-effort to submit an I/O handler as soon as the number of bytes read or written
-reaches
-.Fa high_water .
-.Pp
-The
-.Fn dispatch_io_set_interval
-function configures the time
-.Fa interval
-at which I/O handlers are submitted (measured in nanoseconds). If
-.Dv DISPATCH_IO_STRICT_INTERVAL
-is passed in the
-.Fa flags
-parameter, the interval will be strictly observed even if there is an
-insufficient amount of data to deliver; otherwise delivery will be skipped for
-intervals where the amount of available data is inferior to the channel's
-low-water mark. Note that the system may defer enqueueing interval I/O handlers
-by a small unspecified amount of leeway in order to align with other system
-activity for improved system performance or power consumption.
-.Pp
-.Sh DATA DELIVERY
-The size of data objects passed to I/O handlers for a channel will never be
-larger than the high-water mark set on the channel; it will also never be
-smaller than the low-water mark, except in the following cases:
-.Bl -dash -offset indent -compact
-.It
-the final handler invocation for an I/O operation
-.It
-EOF was encountered
-.It
-the channel has an interval with the
-.Dv DISPATCH_IO_STRICT_INTERVAL
-flag set
-.El
-Bear in mind that dispatch I/O channels will typically deliver amounts of data
-significantly higher than the low-water mark. The default value for the
-low-water mark is unspecified, but must be assumed to allow intermediate
-handler invocations. The default value for the high-water mark is
-unlimited (i.e.\&
-.Dv SIZE_MAX ) .
-Channels that require intermediate results of fixed size should have both the
-low-water and the high-water mark set to that size. Channels that do not wish
-to receive any intermediate results should have the low-water mark set to
-.Dv SIZE_MAX .
-.Pp
-.Sh FILEDESCRIPTOR OWNERSHIP
-When an application creates a dispatch I/O channel from a file descriptor with
-the
-.Fn dispatch_io_create
-function, the system takes control of that file descriptor until the channel is
-closed, an error occurs on the file descriptor or all references to the channel
-are released. At that time the channel's cleanup handler will be enqueued and
-control over the file descriptor relinquished, making it safe for the
-application to
-.Xr close 2
-the file descriptor. While a file descriptor is under the control of a dispatch
-I/O channel, file descriptor flags such as
-.Dv O_NONBLOCK
-will be modified by the system on behalf of the application. It is an error for
-the application to modify a file descriptor directly while it is under the
-control of a dispatch I/O channel, but it may create further I/O channels
-from that file descriptor or use the
-.Xr dispatch_read 3
-and
-.Xr dispatch_write 3
-convenience functions with that file descriptor. If multiple I/O channels have
-been created from the same file descriptor, all the associated cleanup handlers
-will be submitted together once the last channel has been closed resp.\& all
-references to those channels have been released. If convenience functions have
-also been used on that file descriptor, submission of their handlers will be
-tied to the submission of the channel cleanup handlers as well.
-.Pp
-.Sh BARRIER OPERATIONS
-The
-.Fn dispatch_io_barrier
-function schedules a barrier operation on an I/O channel. The specified barrier
-block will be run once, after all current I/O operations (such as
-.Xr read 2 or
-.Xr write 2 )
-on the underlying
-file descriptor have finished. No new I/O operations will start until the
-barrier block finishes.
-.Pp
-The barrier block may operate on the underlying file descriptor with functions
-like
-.Xr fsync 2
-or
-.Xr lseek 2 .
-As discussed in the
-.Sx FILEDESCRIPTOR OWNERSHIP
-section, the barrier block must not
-.Xr close 2
-the file descriptor, and if it changes any flags on the file descriptor, it
-must restore them before finishing.
-.Pp
-There is no synchronization between a barrier block and any
-.Xr dispatch_io_read 3
-or
-.Xr dispatch_io_write 3
-handler blocks; they may be running at the same time. The barrier block itself
-is responsible for any required synchronization.
-.Sh MEMORY MODEL
-Dispatch I/O channel objects are retained and released via calls to
-.Fn dispatch_retain
-and
-.Fn dispatch_release .
-.Sh SEE ALSO
-.Xr dispatch 3 ,
-.Xr dispatch_io_read 3 ,
-.Xr dispatch_object 3 ,
-.Xr dispatch_read 3 ,
-.Xr fopen 3 ,
-.Xr open 2
--- a/Telegram/ThirdParty/dispatch/man/dispatch_io_read.3	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/man/dispatch_io_read.3	1970-01-01 00:00:00.000000000 -0000
@@ -1,151 +0,0 @@
-.\" Copyright (c) 2010 Apple Inc. All rights reserved.
-.Dd December 1, 2010
-.Dt dispatch_io_read 3
-.Os Darwin
-.Sh NAME
-.Nm dispatch_io_read ,
-.Nm dispatch_io_write
-.Nd submit read and write operations to dispatch I/O channels
-.Sh SYNOPSIS
-.Fd #include <dispatch/dispatch.h>
-.Ft void
-.Fo dispatch_io_read
-.Fa "dispatch_io_t channel"
-.Fa "off_t offset"
-.Fa "size_t length"
-.Fa "dispatch_queue_t queue"
-.Fa "void (^handler)(bool done, dispatch_data_t data, int error)"
-.Fc
-.Ft void
-.Fo dispatch_io_write
-.Fa "dispatch_io_t channel"
-.Fa "off_t offset"
-.Fa "dispatch_data_t data"
-.Fa "dispatch_queue_t queue"
-.Fa "void (^handler)(bool done, dispatch_data_t data, int error)"
-.Fc
-.Sh DESCRIPTION
-The dispatch I/O framework is an API for asynchronous read and write I/O
-operations. It is an application of the ideas and idioms present in the
-.Xr dispatch 3
-framework to device I/O. Dispatch I/O enables an application to more easily
-avoid blocking I/O operations and allows it to more directly express its I/O
-requirements than by using the raw POSIX file API. Dispatch I/O will make a
-best effort to optimize how and when asynchronous I/O operations are performed
-based on the capabilities of the targeted device.
-.Pp
-This page provides details on how to read from and write to dispatch I/O
-channels. Creation and configuration of these channels is covered in the
-.Xr dispatch_io_create 3
-page. The dispatch I/O framework also provides the convenience functions
-.Xr dispatch_read 3
-and
-.Xr dispatch_write 3
-for uses that do not require the full functionality provided by I/O channels.
-.Pp
-.Sh FUNDAMENTALS
-The
-.Fn dispatch_io_read
-and
-.Fn dispatch_io_write
-functions are used to perform asynchronous read and write operations on
-dispatch I/O channels. They can be thought of as asynchronous versions of the
-.Xr fread 3
-and
-.Xr fwrite 3
-functions in the standard C library.
-.Sh READ OPERATIONS
-The
-.Fn dispatch_io_read
-function schedules an I/O read operation on the specified dispatch I/O
-.Va channel .
-As results from the read operation become available, the provided
-.Va handler
-block will be submitted to the specified
-.Va queue .
-The block will be passed a dispatch data object representing the data that has
-been read since the handler's previous invocation.
-.Pp
-The
-.Va offset
-parameter indicates where the read operation should begin. For a channel of
-.Dv DISPATCH_IO_RANDOM
-type it is interpreted relative to the position of the file pointer when the
-channel was created, for a channel of
-.Dv DISPATCH_IO_STREAM
-type it is ignored and the read operation will begin at the current file
-pointer position.
-.Pp
-The
-.Va length
-parameter indicates the number of bytes that should be read from the I/O
-channel. Pass
-.Dv SIZE_MAX
-to keep reading until EOF is encountered (for a channel created from a
-disk-based file this happens when reading past the end of the physical file).
-.Sh WRITE OPERATIONS
-The
-.Fn dispatch_io_write
-function schedules an I/O write operation on the specified dispatch I/O
-.Va channel .
-As the write operation progresses, the provided
-.Va handler
-block will be submitted to the specified
-.Va queue .
-The block will be passed a dispatch data object representing the data that
-remains to be written as part of this I/O operation.
-.Pp
-The
-.Va offset
-parameter indicates where the write operation should begin. It is interpreted
-as for read operations above.
-.Pp
-The
-.Va data
-parameter specifies the location and amount of data to be written, encapsulated
-as a dispatch data object. The object is retained by the system until the write
-operation is complete.
-.Sh I/O HANDLER BLOCKS
-Dispatch I/O handler blocks submitted to a channel via the
-.Fn dispatch_io_read
-or
-.Fn dispatch_io_write
-functions will be executed one or more times depending on system load and the
-channel's configuration settings (see
-.Xr dispatch_io_create 3
-for details). The handler block need not be reentrant safe,
-no new I/O handler instance is submitted until the previously enqueued handler
-block has returned.
-.Pp
-The dispatch
-.Va data
-object passed to an I/O handler block will be released by the system when the
-block returns, if access to the memory buffer it represents is needed outside
-of the handler, the handler block must retain the data object or create a new
-(e.g.\& concatenated) data object from it (see
-.Xr dispatch_data_create 3
-for details).
-.Pp
-Once an I/O handler block is invoked with the
-.Va done
-flag set, the associated I/O operation is complete and that handler block will
-not be run again. If an unrecoverable error occurs while performing the I/O
-operation, the handler block will be submitted with the
-.Va done
-flag set and the appropriate POSIX error code in the
-.Va error
-parameter. An invocation of a handler block with the
-.Va done
-flag set, zero
-.Va error
-and
-.Va data
-set to
-.Vt dispatch_data_empty
-indicates that the I/O operation has encountered EOF.
-.Sh SEE ALSO
-.Xr dispatch 3 ,
-.Xr dispatch_data_create 3 ,
-.Xr dispatch_io_create 3 ,
-.Xr dispatch_read 3 ,
-.Xr fread 3
--- a/Telegram/ThirdParty/dispatch/man/dispatch_object.3	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/man/dispatch_object.3	1970-01-01 00:00:00.000000000 -0000
@@ -1,190 +0,0 @@
-.\" Copyright (c) 2008-2012 Apple Inc. All rights reserved.
-.Dd March 1, 2012
-.Dt dispatch_object 3
-.Os Darwin
-.Sh NAME
-.Nm dispatch_object
-.Nd General manipulation of dispatch objects
-.Sh SYNOPSIS
-.Fd #include <dispatch/dispatch.h>
-.Ft void
-.Fo dispatch_retain
-.Fa "dispatch_object_t object"
-.Fc
-.Ft void
-.Fo dispatch_release
-.Fa "dispatch_object_t object"
-.Fc
-.Ft void
-.Fo dispatch_suspend
-.Fa "dispatch_object_t object"
-.Fc
-.Ft void
-.Fo dispatch_resume
-.Fa "dispatch_object_t object"
-.Fc
-.Ft void
-.Fo dispatch_activate
-.Fa "dispatch_object_t object"
-.Fc
-.Ft "void *"
-.Fo dispatch_get_context
-.Fa "dispatch_object_t object"
-.Fc
-.Ft void
-.Fo dispatch_set_context
-.Fa "dispatch_object_t object"
-.Fa "void *context"
-.Fc
-.Ft void
-.Fo dispatch_set_finalizer_f
-.Fa "dispatch_object_t object"
-.Fa "dispatch_function_t finalizer"
-.Fc
-.Sh DESCRIPTION
-Dispatch objects share functions for coordinating memory management, suspension,
-cancellation and context pointers.
-.Sh MEMORY MANAGEMENT
-Objects returned by creation functions in the dispatch framework may be
-uniformly retained and released with the functions
-.Fn dispatch_retain
-and
-.Fn dispatch_release
-respectively.
-.Pp
-The dispatch framework does not guarantee that any given client has the last or
-only reference to a given object. Objects may be retained internally by the
-system.
-.Ss INTEGRATION WITH OBJECTIVE-C
-.Bd -filled -offset indent
-When building with an Objective-C or Objective-C++ compiler, dispatch objects
-are declared as Objective-C types. This results in the following differences
-compared to building as plain C/C++:
-.Bl -dash
-.It
-if Objective-C Automated Reference Counting is enabled, dispatch objects are
-memory managed by the Objective-C runtime and explicit calls to the
-.Fn dispatch_retain
-and
-.Fn dispatch_release
-functions will produce build errors.
-.Pp
-.Em Note :
-when ARC is enabled, care needs to be taken with dispatch API returning an
-interior pointer that is only valid as long as an associated object has not
-been released. If that object is held in a variable with automatic storage, it
-may need to be annotated with the
-.Li objc_precise_lifetime
-attribute, or stored in a
-.Li __strong
-instance variable instead, to ensure that the object is not prematurely
-released. The functions returning interior pointers are
-.Xr dispatch_data_create_map 3
-and
-.Xr dispatch_data_apply 3 .
-.It
-the Blocks runtime automatically retains and releases dispatch objects captured
-by blocks upon
-.Fn Block_copy
-and
-.Fn Block_release ,
-e.g.\& as performed during asynchronous execution of a block via
-.Xr dispatch_async 3 .
-.Pp
-.Em Note :
-retain cycles may be encountered if dispatch source objects are captured by
-their handler blocks; these cycles can be broken by declaring the captured
-object
-.Li __weak
-or by calling
-.Xr dispatch_source_cancel 3
-to cause its handler blocks to be released explicitly.
-.It
-dispatch objects can be added directly to Cocoa collections, and their
-lifetime is tracked by the Objective-C static analyzer.
-.El
-.Pp
-Integration of dispatch objects with Objective-C requires targeting Mac\ OS\ X
-10.8 or later, and is disabled when building for the legacy Objective-C runtime.
-It can also be disabled manually by using compiler options to define the
-.Dv OS_OBJECT_USE_OBJC
-preprocessor macro to
-.Li 0 .
-.Ed
-.Pp
-.Em Important :
-When building with a plain C/C++ compiler or when integration with Objective-C
-is disabled, dispatch objects are
-.Em not
-automatically retained and released when captured by a block. Therefore, when a
-dispatch object is captured by a block that will be executed asynchronously,
-the object must be manually retained and released:
-.Pp
-.Bd -literal -offset indent
-dispatch_retain(object);
-dispatch_async(queue, ^{
-	do_something_with_object(object);
-	dispatch_release(object);
-});
-.Ed
-.Sh ACTIVATION
-Dispatch objects such as queues and sources may be created in an inactive
-state. Objects in this state must be activated before any blocks
-associated with them will be invoked. Calling
-.Fn dispatch_activate
-on an active object has no effect.
-.Pp
-Changing attributes such as the target queue or a source handler is no longer permitted
-once the object has been activated (see
-.Xr dispatch_set_target_queue 3 ,
-.Xr dispatch_source_set_event_handler 3 ).
-.Sh SUSPENSION
-The invocation of blocks on dispatch queues or dispatch sources may be suspended
-or resumed with the functions
-.Fn dispatch_suspend
-and
-.Fn dispatch_resume
-respectively. Other dispatch objects do not support suspension.
-.Pp
-The dispatch framework always checks the suspension status before executing a
-block, but such changes never affect a block during execution (non-preemptive).
-Therefore the suspension of an object is asynchronous, unless it is performed
-from the context of the target queue for the given object.
-The result of suspending or resuming an object that is not a dispatch queue or
-a dispatch source is undefined.
-.Pp
-.Em Important :
-suspension applies to all aspects of the dispatch object life cycle, including
-the finalizer function and cancellation handler. Suspending an object causes it
-to be retained and resuming an object causes it to be released. Therefore it is
-important to balance calls to
-.Fn dispatch_suspend
-and
-.Fn dispatch_resume
-such that the dispatch object is fully resumed when the last reference is
-released. The result of releasing all references to a dispatch object while in
-an inactive or suspended state is undefined.
-.Sh CONTEXT POINTERS
-Dispatch objects support supplemental context pointers. The value of the
-context pointer may be retrieved and updated with
-.Fn dispatch_get_context
-and
-.Fn dispatch_set_context
-respectively.
-The
-.Fn dispatch_set_finalizer_f
-specifies an optional per-object finalizer function that is invoked
-asynchronously if the context pointer is not NULL when the last
-reference to the object is released.
-This gives the
-application an opportunity to free the context data associated with the object.
-The finalizer will be run on the object's target queue.
-.Sh SEE ALSO
-.Xr dispatch 3 ,
-.Xr dispatch_async 3 ,
-.Xr dispatch_group_create 3 ,
-.Xr dispatch_queue_create 3 ,
-.Xr dispatch_semaphore_create 3 ,
-.Xr dispatch_set_target_queue 3 ,
-.Xr dispatch_source_cancel 3 ,
-.Xr dispatch_source_create 3
--- a/Telegram/ThirdParty/dispatch/man/dispatch_once.3	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/man/dispatch_once.3	1970-01-01 00:00:00.000000000 -0000
@@ -1,46 +0,0 @@
-.\" Copyright (c) 2008-2009 Apple Inc. All rights reserved.
-.Dd May 1, 2009
-.Dt dispatch_once 3
-.Os Darwin
-.Sh NAME
-.Nm dispatch_once
-.Nd execute a block only once
-.Sh SYNOPSIS
-.Fd #include <dispatch/dispatch.h>
-.Ft void
-.Fo dispatch_once
-.Fa "dispatch_once_t *predicate" "void (^block)(void)"
-.Fc
-.Ft void
-.Fo dispatch_once_f
-.Fa "dispatch_once_t *predicate" "void *context" "void (*function)(void *)"
-.Fc
-.Sh DESCRIPTION
-The
-.Fn dispatch_once
-function provides a simple and efficient mechanism to run an initializer
-exactly once, similar to
-.Xr pthread_once 3 .
-Well designed code hides the use of lazy initialization.
-For example:
-.Bd -literal
-FILE *getlogfile(void)
-{
-	static dispatch_once_t pred;
-	static FILE *logfile;
-
-	dispatch_once(&pred, ^{
-		logfile = fopen(MY_LOG_FILE, "a");
-	});
-
-	return logfile;
-}
-.Ed
-.Pp
-.Sh FUNDAMENTALS
-The
-.Fn dispatch_once
-function is a wrapper around
-.Fn dispatch_once_f .
-.Sh SEE ALSO
-.Xr dispatch 3
--- a/Telegram/ThirdParty/dispatch/man/dispatch_queue_create.3	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/man/dispatch_queue_create.3	1970-01-01 00:00:00.000000000 -0000
@@ -1,371 +0,0 @@
-.\" Copyright (c) 2008-2012 Apple Inc. All rights reserved.
-.Dd May 1, 2008
-.Dt dispatch_queue_create 3
-.Os Darwin
-.Sh NAME
-.Nm dispatch_queue_create ,
-.Nm dispatch_queue_get_label ,
-.Nm dispatch_get_current_queue ,
-.Nm dispatch_get_global_queue ,
-.Nm dispatch_get_main_queue ,
-.Nm dispatch_main ,
-.Nm dispatch_set_target_queue
-.Nd where blocks are scheduled for execution
-.Sh SYNOPSIS
-.Fd #include <dispatch/dispatch.h>
-.Ft dispatch_queue_t
-.Fo dispatch_queue_create
-.Fa "const char *label" "dispatch_queue_attr_t attr"
-.Fc
-.Ft "const char *"
-.Fo dispatch_queue_get_label
-.Fa "dispatch_queue_t queue"
-.Fc
-.Ft dispatch_queue_t
-.Fo dispatch_get_global_queue
-.Fa "long priority"
-.Fa "unsigned long flags"
-.Fc
-.Ft dispatch_queue_t
-.Fo dispatch_get_main_queue
-.Fa void
-.Fc
-.Ft void
-.Fo dispatch_main
-.Fa void
-.Fc
-.Ft void
-.Fo dispatch_set_target_queue
-.Fa "dispatch_object_t object"
-.Fa "dispatch_queue_t target"
-.Fc
-.Sh DESCRIPTION
-Queues are the fundamental mechanism for scheduling blocks for execution within
-the
-.Xr dispatch 3
-framework.
-.Pp
-All blocks submitted to dispatch queues are dequeued in FIFO order.
-Queues created with the
-.Dv DISPATCH_QUEUE_SERIAL
-attribute wait for the previously dequeued block to complete before dequeuing
-the next block. A queue with this FIFO completion behavior is usually simply
-described as a "serial queue." All memory writes performed by a block dispatched
-to a serial queue are guaranteed to be visible to subsequent blocks dispatched
-to the same queue. Queues are not bound to any specific thread of execution and
-blocks submitted to independent queues may execute concurrently.
-.Pp
-Queues created with the
-.Dv DISPATCH_QUEUE_CONCURRENT
-attribute may execute dequeued blocks concurrently and support barrier blocks
-submitted with the dispatch barrier API.
-.Sh CREATION
-Queues are created with the
-.Fn dispatch_queue_create
-function. Queues, like all dispatch objects, are reference counted and newly
-created queues have a reference count of one.
-.Pp
-The optional
-.Fa label
-argument is used to describe the purpose of the queue and is useful during
-debugging and performance analysis. If a label is provided, it is copied.
-By convention, clients should pass a reverse DNS style label. For example:
-.Pp
-.Bd -literal -offset indent
-my_queue = dispatch_queue_create("com.example.subsystem.taskXYZ",
-				 DISPATCH_QUEUE_SERIAL);
-.Ed
-.Pp
-The
-.Fa attr
-argument specifies the type of queue to create and must be either
-.Dv DISPATCH_QUEUE_SERIAL
-or
-.Dv DISPATCH_QUEUE_CONCURRENT .
-.Pp
-The
-.Fn dispatch_queue_get_label
-function returns the label provided when the given
-.Fa queue
-was created (or an empty C string if no label was provided at creation).
-Passing the constant
-.Dv DISPATCH_CURRENT_QUEUE_LABEL
-to
-.Fn dispatch_queue_get_label
-returns the label of the current queue.
-.Sh SUSPENSION
-Queues may be temporarily suspended and resumed with the functions
-.Fn dispatch_suspend
-and
-.Fn dispatch_resume
-respectively. Suspension is checked prior to block execution and is
-.Em not
-preemptive.
-.Sh MAIN QUEUE
-The dispatch framework provides a default serial queue for the application to
-use. This queue is accessed via the
-.Fn dispatch_get_main_queue
-function.
-.Pp
-Programs must call
-.Fn dispatch_main
-at the end of
-.Fn main
-in order to process blocks submitted to the main queue. (See the
-.Sx COMPATIBILITY
-section for exceptions.) The
-.Fn dispatch_main
-function never returns.
-.Sh GLOBAL CONCURRENT QUEUES
-Unlike the main queue or queues allocated with
-.Fn dispatch_queue_create ,
-the global concurrent queues schedule blocks as soon as threads become
-available (non-FIFO completion order). Four global concurrent queues are
-provided, representing the following priority bands:
-.Bl -bullet -compact -offset indent
-.It
-DISPATCH_QUEUE_PRIORITY_HIGH
-.It
-DISPATCH_QUEUE_PRIORITY_DEFAULT
-.It
-DISPATCH_QUEUE_PRIORITY_LOW
-.It
-DISPATCH_QUEUE_PRIORITY_BACKGROUND
-.El
-.Pp
-The priority of a global concurrent queue controls the scheduling priority of
-the threads created by the system to invoke the blocks submitted to that queue.
-Global queues with lower priority will be scheduled for execution after all
-global queues with higher priority have been scheduled. Additionally, items on
-the background priority global queue will execute on threads with background
-state as described in
-.Xr setpriority 2
-(i.e.\& disk I/O is throttled and the thread's scheduling priority is set to
-lowest value).
-.Pp
-Use the
-.Fn dispatch_get_global_queue
-function to obtain the global queue of given priority. The
-.Fa flags
-argument is reserved for future use and must be zero. Passing any value other
-than zero may result in a NULL return value.
-.Sh TARGET QUEUE
-The
-.Fn dispatch_set_target_queue
-function updates the target queue of the given dispatch object. The target
-queue of an object is responsible for processing the object.
-.Pp
-The new target queue is retained by the given object before the previous target
-queue is released. The new target queue setting will take effect between block
-executions on the object, but not in the middle of any existing block executions
-(non-preemptive).
-.Pp
-The default target queue of all dispatch objects created by the application is
-the default priority global concurrent queue. To reset an object's target queue
-to the default, pass the
-.Dv DISPATCH_TARGET_QUEUE_DEFAULT
-constant to
-.Fn dispatch_set_target_queue .
-.Pp
-The priority of a dispatch queue is inherited from its target queue.
-In order to change the priority of a queue created with
-.Fn dispatch_queue_create ,
-use the
-.Fn dispatch_get_global_queue
-function to obtain a target queue of the desired priority.
-.Pp
-Blocks submitted to a serial queue whose target queue is another serial queue
-will not be invoked concurrently with blocks submitted to the target queue or
-to any other queue with that same target queue.
-.Pp
-The target queue of a dispatch source specifies where its event handler and
-cancellation handler blocks will be submitted. See
-.Xr dispatch_source_create 3
-for more information about dispatch sources.
-.Pp
-The target queue of a dispatch I/O channel specifies the priority of the global
-queue where its I/O operations are executed. See
-.Xr dispatch_io_create 3
-for more information about dispatch I/O channels.
-.Pp
-For all other dispatch object types, the only function of the target queue is
-to determine where an object's finalizer function is invoked.
-.Pp
-The result of passing the main queue or a global concurrent queue as the first
-argument of
-.Fn dispatch_set_target_queue
-is undefined.
-.Pp
-Directly or indirectly setting the target queue of a dispatch queue to itself is
-undefined.
-.Sh DEPRECATED FUNCTIONS
-The following functions are deprecated and will be removed in a future release:
-.Bl -item
-.It
-.Ft dispatch_queue_t
-.Fn dispatch_get_current_queue void ;
-.El
-.Pp
-.Fn dispatch_get_current_queue
-always returns a valid queue. When called from within a block
-submitted to a dispatch queue, that queue will be returned. If this function is
-called from the main thread before
-.Fn dispatch_main
-is called, then the result of
-.Fn dispatch_get_main_queue
-is returned. In all other cases, the default target queue will be returned.
-.Pp
-The use of
-.Fn dispatch_get_current_queue
-is strongly discouraged except for debugging and logging purposes. Code must not
-make any assumptions about the queue returned, unless it is one of the global
-queues or a queue the code has itself created. The returned queue may have
-arbitrary policies that may surprise code that tries to schedule work with the
-queue. The list of policies includes, but is not limited to, queue width (i.e.
-serial vs. concurrent), scheduling priority, security credential or filesystem
-configuration. This function is deprecated and will be removed in a future
-release.
-.Pp
-It is equally unsafe for code to assume that synchronous execution onto a queue
-is safe from deadlock if that queue is not the one returned by
-.Fn dispatch_get_current_queue .
-.Pp
-The result of
-.Fn dispatch_get_main_queue
-may or may not equal the result of
-.Fn dispatch_get_current_queue
-when called on the main thread. Comparing the two is not a valid way to test
-whether code is executing on the main thread. Foundation/AppKit programs should
-use [NSThread isMainThread]. POSIX programs may use
-.Xr pthread_main_np 3 .
-.Pp
-.Fn dispatch_get_current_queue
-may return a queue owned by a different subsystem which has already had all
-external references to it released. While such a queue will continue to exist
-until all blocks submitted to it have completed, attempting to retain it is
-forbidden and will trigger an assertion. If Objective-C Automatic Reference
-Counting is enabled, any use of the object returned by
-.Fn dispatch_get_current_queue
-will cause retain calls to be automatically generated, so the use of
-.Fn dispatch_get_current_queue
-for any reason in code built with ARC is particularly strongly discouraged.
-.Sh COMPATIBILITY
-Cocoa applications need not call
-.Fn dispatch_main .
-Blocks submitted to the main queue will be executed as part of the "common
-modes" of the application's main NSRunLoop or CFRunLoop.
-However, blocks submitted to the main queue in applications using
-.Fn dispatch_main
-are not guaranteed to execute on the main thread.
-.Pp
-The dispatch framework is a pure C level API. As a result, it does not catch
-exceptions generated by higher level languages such as Objective-C or C++.
-Applications
-.Em MUST
-catch all exceptions before returning from a block submitted to a dispatch
-queue; otherwise the process will be terminated with an uncaught exception.
-.Pp
-The dispatch framework manages the relationship between dispatch queues and
-threads of execution. As a result, applications
-.Em MUST NOT
-delete or mutate objects that they did not create. The following interfaces
-.Em MUST NOT
-be called by blocks submitted to a dispatch queue:
-.Bl -bullet -offset indent
-.It
-.Fn pthread_cancel
-.It
-.Fn pthread_detach
-.It
-.Fn pthread_join
-.It
-.Fn pthread_kill
-.It
-.Fn pthread_exit
-.El
-.Pp
-Applications
-.Em MAY
-call the following interfaces from a block submitted to a dispatch queue if
-and only if they restore the thread to its original state before returning:
-.Bl -bullet -offset indent
-.It
-.Fn pthread_setcancelstate
-.It
-.Fn pthread_setcanceltype
-.It
-.Fn pthread_setschedparam
-.It
-.Fn pthread_sigmask
-.It
-.Fn pthread_setugid_np
-.El
-.Pp
-Applications
-.Em MUST NOT
-rely on the following interfaces returning predictable results between
-invocations of blocks submitted to a dispatch queue:
-.Bl -bullet -offset indent
-.It
-.Fn pthread_self
-.It
-.Fn pthread_getschedparam
-.It
-.Fn pthread_get_stacksize_np
-.It
-.Fn pthread_get_stackaddr_np
-.It
-.Fn pthread_mach_thread_np
-.It
-.Fn pthread_from_mach_thread_np
-.El
-.Pp
-While the result of
-.Fn pthread_self
-may change between invocations of blocks, the value will not change during the
-execution of any single block. Because the underlying thread may change beteween
-block invocations on a single queue, using per-thread data as an out-of-band
-return value is error prone. In other words, the result of calling
-.Fn pthread_setspecific
-and
-.Fn pthread_getspecific
-is well defined within a signle block, but not across multiple blocks. Also,
-one cannot make any assumptions about when the destructor passed to
-.Fn pthread_key_create
-is called. The destructor may be called between the invocation of blocks on
-the same queue, or during the idle state of a process.
-.Pp
-The following example code correctly handles per-thread return values:
-.Bd -literal -offset indent
-__block int r;
-__block int e;
-dispatch_sync(queue, ^{
-	r = kill(1, 0);
-	// Copy the per-thread return value to the callee thread
-	e = errno;
-});
-printf("kill(1,0) returned %d and errno %d\n", r, e);
-.Ed
-.Pp
-Note that in the above example
-.Va errno
-is a per-thread variable and must be copied out explicitly as the block may be
-invoked on different thread of execution than the caller. Another example of
-per-thread data that would need to be copied is the use of
-.Fn getpwnam
-instead of
-.Fn getpwnam_r .
-.Pp
-As an optimization,
-.Fn dispatch_sync
-invokes the block on the current thread when possible. In this case, the thread
-specific data such as
-.Va errno
-may persist from the block until back to the caller. Great care should be taken
-not to accidentally rely on this side-effect.
-.Pp
-.Sh SEE ALSO
-.Xr dispatch 3 ,
-.Xr dispatch_async 3 ,
-.Xr dispatch_object 3 ,
-.Xr dispatch_source_create 3
--- a/Telegram/ThirdParty/dispatch/man/dispatch_read.3	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/man/dispatch_read.3	1970-01-01 00:00:00.000000000 -0000
@@ -1,123 +0,0 @@
-.\" Copyright (c) 2010 Apple Inc. All rights reserved.
-.Dd December 1, 2010
-.Dt dispatch_read 3
-.Os Darwin
-.Sh NAME
-.Nm dispatch_read ,
-.Nm dispatch_write
-.Nd asynchronously read from and write to file descriptors
-.Sh SYNOPSIS
-.Fd #include <dispatch/dispatch.h>
-.Ft void
-.Fo dispatch_read
-.Fa "int fd"
-.Fa "size_t length"
-.Fa "dispatch_queue_t queue"
-.Fa "void (^handler)(dispatch_data_t data, int error)"
-.Fc
-.Ft void
-.Fo dispatch_write
-.Fa "int fd"
-.Fa "dispatch_data_t data"
-.Fa "dispatch_queue_t queue"
-.Fa "void (^handler)(dispatch_data_t data, int error))"
-.Fc
-.Sh DESCRIPTION
-The
-.Fn dispatch_read
-and
-.Fn dispatch_write
-functions asynchronously read from and write to POSIX file descriptors. They
-can be thought of as asynchronous, callback-based versions of the
-.Fn fread
-and
-.Fn fwrite
-functions provided by the standard C library. They are convenience functions
-based on the
-.Xr dispatch_io_read 3
-and
-.Xr dispatch_io_write 3
-functions, intended for simple one-shot read or write requests. Multiple
-request on the same file desciptor are better handled with the full underlying
-dispatch I/O channel functions.
-.Sh BEHAVIOR
-The
-.Fn dispatch_read
-function schedules an asynchronous read operation on the file descriptor
-.Va fd .
-Once the file descriptor is readable, the system will read as much data as is
-currently available, up to the specified
-.Va length ,
-starting at the current file pointer position. The given
-.Va handler
-block will be submitted to
-.Va queue
-when the operation completes or an error occurs. The block will be passed a
-dispatch
-.Va data
-object with the result of the read operation. If an error occurred while
-reading from the file descriptor, the
-.Va error
-parameter to the block will be set to the appropriate POSIX error code and
-.Va data
-will contain any data that could be read successfully. If the file pointer
-position is at end-of-file, emtpy
-.Va data
-and zero
-.Va error
-will be passed to the handler block.
-.Pp
-The
-.Fn dispatch_write
-function schedules an asynchronous write operation on the file descriptor
-.Va fd .
-The system will attempt to write the entire contents of the provided
-.Va data
-object to
-.Va fd
-at the current file pointer position. The given
-.Va handler
-block will be submitted to
-.Va queue
-when the operation completes or an error occurs. If the write operation
-completed successfully, the
-.Va error
-parameter to the block will be set to zero, otherwise it will be set to the
-appropriate POSIX error code and the
-.Va data
-parameter will contain any data that could not be written.
-.Sh CAVEATS
-The
-.Va data
-object passed to a
-.Va handler
-block is released by the system when the block returns. If
-.Va data
-is needed outside of the handler block, it must concatenate, copy, or retain
-it.
-.Pp
-Once an asynchronous read or write operation has been submitted on a file
-descriptor
-.Va fd ,
-the system takes control of that file descriptor until the
-.Va handler
-block is executed. During this time the application must not manipulate
-.Va fd
-directly, in particular it is only safe to close
-.Va fd
-from the handler block (or after it has returned).
-.Pp
-If multiple asynchronous read or write operations are submitted to the same
-file descriptor, they will be performed in order, but their handlers will only
-be submitted once all operations have completed and control over the file
-descriptor has been relinquished. For details on this and on the interaction
-with dispatch I/O channels created from the same file descriptor, see
-.Sx FILEDESCRIPTOR OWNERSHIP
-in
-.Xr dispatch_io_create 3 .
-.Sh SEE ALSO
-.Xr dispatch 3 ,
-.Xr dispatch_data_create 3 ,
-.Xr dispatch_io_create 3 ,
-.Xr dispatch_io_read 3 ,
-.Xr fread 3
--- a/Telegram/ThirdParty/dispatch/man/dispatch_semaphore_create.3	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/man/dispatch_semaphore_create.3	1970-01-01 00:00:00.000000000 -0000
@@ -1,121 +0,0 @@
-.\" Copyright (c) 2008-2012 Apple Inc. All rights reserved.
-.Dd May 1, 2009
-.Dt dispatch_semaphore_create 3
-.Os Darwin
-.Sh NAME
-.Nm dispatch_semaphore_create ,
-.Nm dispatch_semaphore_signal ,
-.Nm dispatch_semaphore_wait
-.Nd synchronized counting semaphore
-.Sh SYNOPSIS
-.Fd #include <dispatch/dispatch.h>
-.Ft dispatch_semaphore_t
-.Fo dispatch_semaphore_create
-.Fa "long count"
-.Fc
-.Ft long
-.Fo dispatch_semaphore_signal
-.Fa "dispatch_semaphore_t semaphore"
-.Fc
-.Ft long
-.Fo dispatch_semaphore_wait
-.Fa "dispatch_semaphore_t semaphore" "dispatch_time_t timeout"
-.Fc
-.Sh DESCRIPTION
-Dispatch semaphores are used to synchronize threads.
-.Pp
-The
-.Fn dispatch_semaphore_wait
-function decrements the semaphore. If the resulting value is less than zero,
-it waits for a signal from a thread that increments the semaphore by calling
-.Fn dispatch_semaphore_signal
-before returning.
-The
-.Fa timeout
-parameter is creatable with the
-.Xr dispatch_time 3
-or
-.Xr dispatch_walltime 3
-functions. If the timeout is reached without a signal being received, the semaphore
-is re-incremented before the function returns.
-.Pp
-The
-.Fn dispatch_semaphore_signal
-function increments the counting semaphore. If the previous value was less than zero,
-it wakes one of the threads that are waiting in
-.Fn dispatch_semaphore_wait
-before returning.
-.Sh COMPLETION SYNCHRONIZATION
-If the
-.Fa count
-parameter is equal to zero, then the semaphore is useful for synchronizing
-completion of work.
-For example:
-.Bd -literal -offset indent
-sema = dispatch_semaphore_create(0);
-
-dispatch_async(queue, ^{
-	foo();
-	dispatch_semaphore_signal(sema);
-});
-
-bar();
-
-dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);
-.Ed
-.Sh FINITE RESOURCE POOL
-If the
-.Fa count
-parameter is greater than zero, then the semaphore is useful for managing a
-finite pool of resources.
-For example, a library that wants to limit Unix descriptor usage:
-.Bd -literal -offset indent
-sema = dispatch_semaphore_create(getdtablesize() / 4);
-.Ed
-.Pp
-At each Unix FD allocation:
-.Bd -literal -offset indent
-dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);
-fd = open("/etc/services", O_RDONLY);
-.Ed
-.Pp
-When each FD is closed:
-.Bd -literal -offset indent
-close(fd);
-dispatch_semaphore_signal(sema);
-.Ed
-.Sh RETURN VALUES
-The
-.Fn dispatch_semaphore_create
-function returns NULL if no memory is available or if the
-.Fa count
-parameter is less than zero.
-.Pp
-The
-.Fn dispatch_semaphore_signal
-function returns non-zero when a thread is woken.
-Otherwise, zero is returned.
-.Pp
-The
-.Fn dispatch_semaphore_wait
-function returns zero upon success and non-zero after the timeout expires. If
-the timeout is DISPATCH_TIME_FOREVER, then
-.Fn dispatch_semaphore_wait
-waits forever and always returns zero.
-.Sh MEMORY MODEL
-Dispatch semaphores are retained and released via calls to
-.Fn dispatch_retain
-and
-.Fn dispatch_release .
-.Sh CAVEATS
-Unbalanced dispatch semaphores cannot be released.
-For a given semaphore, calls to
-.Fn dispatch_semaphore_signal
-and
-.Fn dispatch_semaphore_wait
-must be balanced before
-.Fn dispatch_release
-is called on it.
-.Sh SEE ALSO
-.Xr dispatch 3 ,
-.Xr dispatch_object 3
--- a/Telegram/ThirdParty/dispatch/man/dispatch_source_create.3	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/man/dispatch_source_create.3	1970-01-01 00:00:00.000000000 -0000
@@ -1,587 +0,0 @@
-.\" Copyright (c) 2008-2013 Apple Inc. All rights reserved.
-.Dd May 1, 2009
-.Dt dispatch_source_create 3
-.Os Darwin
-.Sh NAME
-.Nm dispatch_source_create
-.Nd dispatch event sources
-.Sh SYNOPSIS
-.Fd #include <dispatch/dispatch.h>
-.Ft dispatch_source_t
-.Fo dispatch_source_create
-.Fa "dispatch_source_type_t type"
-.Fa "uintptr_t handle"
-.Fa "unsigned long mask"
-.Fa "dispatch_queue_t queue"
-.Fc
-.Ft void
-.Fo dispatch_source_set_event_handler
-.Fa "dispatch_source_t source"
-.Fa "void (^block)(void)"
-.Fc
-.Ft void
-.Fo dispatch_source_set_event_handler_f
-.Fa "dispatch_source_t source"
-.Fa "void (*function)(void *)"
-.Fc
-.Ft void
-.Fo dispatch_source_set_registration_handler
-.Fa "dispatch_source_t source"
-.Fa "void (^block)(void)"
-.Fc
-.Ft void
-.Fo dispatch_source_set_registration_handler_f
-.Fa "dispatch_source_t source"
-.Fa "void (*function)(void *)"
-.Fc
-.Ft void
-.Fo dispatch_source_set_cancel_handler
-.Fa "dispatch_source_t source"
-.Fa "void (^block)(void)"
-.Fc
-.Ft void
-.Fo dispatch_source_set_cancel_handler_f
-.Fa "dispatch_source_t source"
-.Fa "void (*function)(void *)"
-.Fc
-.Ft void
-.Fo dispatch_source_cancel
-.Fa "dispatch_source_t source"
-.Fc
-.Ft long
-.Fo dispatch_source_testcancel
-.Fa "dispatch_source_t source"
-.Fc
-.Ft uintptr_t
-.Fo dispatch_source_get_handle
-.Fa "dispatch_source_t source"
-.Fc
-.Ft "unsigned long"
-.Fo dispatch_source_get_mask
-.Fa "dispatch_source_t source"
-.Fc
-.Ft "unsigned long"
-.Fo dispatch_source_get_data
-.Fa "dispatch_source_t source"
-.Fc
-.Ft void
-.Fo dispatch_source_merge_data
-.Fa "dispatch_source_t source"
-.Fa "unsigned long data"
-.Fc
-.Ft void
-.Fo dispatch_source_set_timer
-.Fa "dispatch_source_t source"
-.Fa "dispatch_time_t start"
-.Fa "uint64_t interval"
-.Fa "uint64_t leeway"
-.Fc
-.Sh DESCRIPTION
-Dispatch event sources may be used to monitor a variety of system objects and
-events including file descriptors, mach ports, processes, virtual filesystem
-nodes, signal delivery and timers.
-.Pp
-When a state change occurs, the dispatch source will submit its event handler
-block to its target queue.
-.Pp
-The
-.Fn dispatch_source_create
-function creates a new dispatch source object that may be retained and released
-with calls to
-.Fn dispatch_retain
-and
-.Fn dispatch_release
-respectively. The
-.Fa queue
-parameter specifies the target queue of the new source object, it will
-be retained by the source object. Pass the
-.Dv DISPATCH_TARGET_QUEUE_DEFAULT
-constant to use the default target queue (the default priority global
-concurrent queue).
-.Pp
-Newly created sources are created in a suspended state. After the source has
-been configured by setting an event handler, cancellation handler, registration
-handler, context,
-etc., the source must be activated by a call to
-.Fn dispatch_resume
-before any events will be delivered.
-.Pp
-Dispatch sources may be one of the following types:
-.Bl -bullet -compact -offset indent
-.It
-DISPATCH_SOURCE_TYPE_DATA_ADD
-.It
-DISPATCH_SOURCE_TYPE_DATA_OR
-.It
-DISPATCH_SOURCE_TYPE_DATA_REPLACE
-.It
-DISPATCH_SOURCE_TYPE_MACH_SEND
-.It
-DISPATCH_SOURCE_TYPE_MACH_RECV
-.It
-DISPATCH_SOURCE_TYPE_MEMORYPRESSURE
-.It
-DISPATCH_SOURCE_TYPE_PROC
-.It
-DISPATCH_SOURCE_TYPE_READ
-.It
-DISPATCH_SOURCE_TYPE_SIGNAL
-.It
-DISPATCH_SOURCE_TYPE_TIMER
-.It
-DISPATCH_SOURCE_TYPE_VNODE
-.It
-DISPATCH_SOURCE_TYPE_WRITE
-.El
-.Pp
-The
-.Fa handle
-and
-.Fa mask
-arguments to
-.Fn dispatch_source_create
-and the return values of the
-.Fn dispatch_source_get_handle ,
-.Fn dispatch_source_get_mask ,
-and
-.Fn dispatch_source_get_data
-functions should be interpreted according to the type of the dispatch source.
-.Pp
-The
-.Fn dispatch_source_get_handle
-function
-returns the underlying handle to the dispatch source (i.e. file descriptor,
-mach port, process identifer, etc.). The result of this function may be cast
-directly to the underlying type.
-.Pp
-The
-.Fn dispatch_source_get_mask
-function
-returns the set of flags that were specified at source creation time via the
-.Fa mask
-argument.
-.Pp
-The
-.Fn dispatch_source_get_data
-function returns the currently pending data for the dispatch source.
-This function should only be called from within the source's event handler.
-The result of calling this function from any other context is undefined.
-.Pp
-The
-.Fn dispatch_source_merge_data
-function is intended for use with the
-.Vt DISPATCH_SOURCE_TYPE_DATA_ADD ,
-.Vt DISPATCH_SOURCE_TYPE_DATA_OR
-and
-.Vt DISPATCH_SOURCE_TYPE_DATA_REPLACE
-source types. The result of using this function with any other source type is
-undefined. Data merging is performed according to the source type:
-.Bl -tag -width "XXDISPATCH_SOURCE_TYPE_DATA_REPLACE" -compact -offset indent
-.It \(bu DISPATCH_SOURCE_TYPE_DATA_ADD
-.Vt data
-is atomically added to the source's data
-.It \(bu DISPATCH_SOURCE_TYPE_DATA_OR
-.Vt data
-is atomically bitwise ORed into the source's data
-.It \(bu DISPATCH_SOURCE_TYPE_DATA_REPLACE
-.Vt data
-atomically replaces the source's data.
-.El
-.Pp
-If the source data value resulting from the merge operation is 0, the source
-handler will not be invoked. This can happen if:
-.Bl -bullet -compact -offset indent
-.It
-the atomic addition wraps for sources of type
-.Vt DISPATCH_SOURCE_TYPE_DATA_ADD ,
-.It
-0 is merged for sources of type
-.Vt DISPATCH_SOURCE_TYPE_DATA_REPLACE .
-.El
-.Pp
-.Sh SOURCE EVENT HANDLERS
-In order to receive events from the dispatch source, an event handler should be
-specified via
-.Fn dispatch_source_set_event_handler .
-The event handler block is submitted to the source's target queue when the state
-of the underlying system handle changes, or when an event occurs. If a source
-is resumed with no event handler block set, events will be quietly ignored.
-If the event handler block is changed while the source is suspended, or from a
-block running on a serial queue that is the source's target queue, then the next
-event handler invocation will use the new block.
-.Pp
-Dispatch sources may be suspended or resumed independently of their target
-queues using
-.Fn dispatch_suspend
-and
-.Fn dispatch_resume
-on the dispatch source directly. The data describing events which occur while a
-source is suspended are coalesced and delivered once the source is resumed.
-.Pp
-The
-.Fa handler
-block
-need not be reentrant safe, as it is not resubmitted to the target
-.Fa queue
-until any prior invocation for that dispatch source has completed.
-When the handler is set, the dispatch source will perform a
-.Fn Block_copy
-on the
-.Fa handler
-block.
-.Pp
-To unset the event handler, call
-.Fn dispatch_source_set_event_handler_f
-and pass NULL as
-.Fa function .
-This unsets the event handler regardless of whether the handler
-was a function pointer or a block. Registration and cancellation handlers
-(see below) may be unset in the same way, but as noted below, a cancellation
-handler may be required.
-.Sh REGISTRATION
-When 
-.Fn dispatch_resume
-is called on a suspended or newly created source, there may be a brief delay
-before the source is ready to receive events from the underlying system handle.
-During this delay, the event handler will not be invoked, and events will be
-missed.
-.Pp
-Once the dispatch source is registered with the underlying system and is ready
-to process all events its optional registration handler will be submitted to
-its target queue. This registration handler may be specified via
-.Fn dispatch_source_set_registration_handler .
-.Pp
-The event handler will not be called until the registration handler finishes.
-If the source is canceled (see below) before it is registered,
-its registration handler will not be called.
-.Pp
-.Sh CANCELLATION
-The
-.Fn dispatch_source_cancel
-function asynchronously cancels the dispatch source, preventing any further
-invocation of its event handler block. Cancellation does not interrupt a
-currently executing handler block (non-preemptive). If a source is canceled
-before the first time it is resumed, its event handler will never be called.
-(In this case, note that the source must be resumed before it can be released.)
-.Pp
-The
-.Fn dispatch_source_testcancel
-function may be used to determine whether the specified source has been
-canceled. A non-zero value will be returned if the source is canceled.
-.Pp
-When a dispatch source is canceled its optional cancellation handler will be
-submitted to its target queue. The cancellation handler may be specified via
-.Fn dispatch_source_set_cancel_handler .
-This cancellation handler is invoked only once, and only as a direct consequence
-of calling
-.Fn dispatch_source_cancel .
-.Pp
-.Em Important:
-a cancellation handler is required for file descriptor and mach port based
-sources in order to safely close the descriptor or destroy the port. Closing the
-descriptor or port before the cancellation handler has run may result in a race
-condition: if a new descriptor is allocated with the same value as the recently
-closed descriptor while the source's event handler is still running, the event
-handler may read/write data to the wrong descriptor.
-.Pp
-.Sh DISPATCH SOURCE TYPES
-The following section contains a summary of supported dispatch event types and
-the interpretation of their parameters and returned data.
-.Pp
-.Vt DISPATCH_SOURCE_TYPE_DATA_ADD ,
-.Vt DISPATCH_SOURCE_TYPE_DATA_OR ,
-.Vt DISPATCH_SOURCE_TYPE_DATA_REPLACE
-.Pp
-Sources of this type allow applications to manually trigger the source's event
-handler via a call to
-.Fn dispatch_source_merge_data .
-The data will be merged with the source's pending data via an atomic add or
-atomic bitwise OR, or direct replacement (based on the source's type), and the
-event handler block will be submitted to the source's target queue. The
-.Fa data
-is application defined. These sources have no
-.Fa handle
-or
-.Fa mask
-and zero should be used.
-.Pp
-.Vt DISPATCH_SOURCE_TYPE_MACH_SEND
-.Pp
-Sources of this type monitor a mach port with a send right for state changes.
-The
-.Fa handle
-is the mach port (mach_port_t) to monitor and the
-.Fa mask
-may be:
-.Bl -tag -width "XXDISPATCH_PROC_SIGNAL" -compact -offset indent
-.It \(bu DISPATCH_MACH_SEND_DEAD
-The port's corresponding receive right has been destroyed
-.El
-.Pp
-The data returned by
-.Fn dispatch_source_get_data
-is a bitmask that indicates which of the events in the
-.Fa mask
-were observed.  Note that because this source type will request notifications on
-the provided port, it should not be mixed with the use of
-.Fn mach_port_request_notification
-on the same port.
-.Pp
-.Vt DISPATCH_SOURCE_TYPE_MACH_RECV
-.Pp
-Sources of this type monitor a mach port with a receive right for state changes.
-The
-.Fa handle
-is the mach port (mach_port_t) to monitor and the
-.Fa mask
-is unused and should be zero.
-The event handler block will be submitted to the target queue when a message
-on the mach port is waiting to be received.
-.Pp
-.Vt DISPATCH_SOURCE_TYPE_MEMORYPRESSURE
-.Pp
-Sources of this type monitor the system memory pressure condition for state
-changes.  The
-.Fa handle
-is unused and should be zero. The
-.Fa mask
-may be one or more of the following:
-.Bl -tag -width "XXDISPATCH_MEMORYPRESSURE_CRITICAL" -compact -offset indent
-.It \(bu DISPATCH_MEMORYPRESSURE_NORMAL
-The system memory pressure condition has returned to normal.
-.It \(bu DISPATCH_MEMORYPRESSURE_WARN
-The system memory pressure condition has changed to warning.
-.It \(bu DISPATCH_MEMORYPRESSURE_CRITICAL
-The system memory pressure condition has changed to critical.
-.El
-.Pp
-The data returned by
-.Fn dispatch_source_get_data
-indicates which of the events in the
-.Fa mask
-were observed.
-.Pp
-Elevated memory pressure is a system-wide condition that applications
-registered for this source should react to by changing their future memory use
-behavior, e.g. by reducing cache sizes of newly initiated operations until
-memory pressure returns back to normal.
-.Pp
-However, applications should
-.Em NOT
-traverse and discard existing caches for past operations when the system memory
-pressure enters an elevated state, as that is likely to trigger VM operations
-that will further aggravate system memory pressure.
-.Pp
-.Vt DISPATCH_SOURCE_TYPE_PROC
-.Pp
-Sources of this type monitor processes for state changes.
-The
-.Fa handle
-is the process identifier (pid_t) of the process to monitor and the
-.Fa mask
-may be one or more of the following:
-.Bl -tag -width "XXDISPATCH_PROC_SIGNAL" -compact -offset indent
-.It \(bu DISPATCH_PROC_EXIT
-The process has exited and is available to
-.Xr wait 2 .
-.It \(bu DISPATCH_PROC_FORK
-The process has created one or more child processes.
-.It \(bu DISPATCH_PROC_EXEC
-The process has become another executable image via a call to
-.Xr execve 2
-or
-.Xr posix_spawn 2 .
-.It \(bu DISPATCH_PROC_SIGNAL
-A signal was delivered to the process.
-.El
-.Pp
-The data returned by
-.Fn dispatch_source_get_data
-is a bitmask that indicates which of the events in the
-.Fa mask
-were observed.
-.Pp
-.Vt DISPATCH_SOURCE_TYPE_READ
-.Pp
-Sources of this type monitor file descriptors for pending data.
-The
-.Fa handle
-is the file descriptor (int) to monitor and the
-.Fa mask
-is unused and should be zero.
-.Pp
-The data returned by
-.Fn dispatch_source_get_data
-is an estimated number of bytes available to be read from the descriptor. This
-estimate should be treated as a suggested
-.Em minimum
-read buffer size. There are no guarantees that a complete read of this size
-will be performed.
-.Pp
-Users of this source type are strongly encouraged to perform non-blocking I/O
-and handle any truncated reads or error conditions that may occur. See
-.Xr fcntl 2
-for additional information about setting the
-.Vt O_NONBLOCK
-flag on a file descriptor.
-.Pp
-.Vt DISPATCH_SOURCE_TYPE_SIGNAL
-.Pp
-Sources of this type monitor signals delivered to the current process. The
-.Fa handle
-is the signal number to monitor (int) and the
-.Fa mask
-is unused and should be zero.
-.Pp
-The data returned by
-.Fn dispatch_source_get_data
-is the number of signals received since the last invocation of the event handler
-block.
-.Pp
-Unlike signal handlers specified via
-.Fn sigaction ,
-the execution of the event handler block does not interrupt the current thread
-of execution; therefore the handler block is not limited to the use of signal
-safe interfaces defined in
-.Xr sigaction 2 .
-Furthermore, multiple observers of a given signal are supported; thus allowing
-applications and libraries to cooperate safely. However, a dispatch source
-.Em does not
-install a signal handler or otherwise alter the behavior of signal delivery.
-Therefore, applications must ignore or at least catch any signal that terminates
-a process by default. For example, near the top of
-.Fn main :
-.Bd -literal -offset ident
-signal(SIGTERM, SIG_IGN);
-.Ed
-.Pp
-.Vt DISPATCH_SOURCE_TYPE_TIMER
-.Pp
-Sources of this type periodically submit the event handler block to the target
-queue. The
-.Fa handle
-argument is unused and should be zero.
-.Pp
-The data returned by
-.Fn dispatch_source_get_data
-is the number of times the timer has fired since the last invocation of the
-event handler block.
-.Pp
-The timer parameters are configured with the
-.Fn dispatch_source_set_timer
-function. Once this function returns, any pending source data accumulated for
-the previous timer parameters has been cleared; the next fire of the timer will
-occur at
-.Fa start ,
-and every
-.Fa interval
-nanoseconds thereafter until the timer source is canceled.
-.Pp
-Any fire of the timer may be delayed by the system in order to improve power
-consumption and system performance. The upper limit to the allowable delay may
-be configured with the
-.Fa leeway
-argument, the lower limit is under the control of the system.
-.Pp
-For the initial timer fire at
-.Fa start ,
-the upper limit to the allowable delay is set to
-.Fa leeway
-nanoseconds. For the subsequent timer fires at
-.Fa start
-.Li "+ N *"
-.Fa interval ,
-the upper limit is
-.Li MIN(
-.Fa leeway ,
-.Fa interval
-.Li "/ 2 )" .
-.Pp
-The lower limit to the allowable delay may vary with process state such as
-visibility of application UI. If the specified timer source was created with a
-.Fa mask
-of
-.Vt DISPATCH_TIMER_STRICT ,
-the system will make a best effort to strictly observe the provided
-.Fa leeway
-value even if it is smaller than the current lower limit. Note that a minimal
-amount of delay is to be expected even if this flag is specified.
-.Pp
-The
-.Fa start
-argument also determines which clock will be used for the timer: If
-.Fa start
-is
-.Vt DISPATCH_TIME_NOW
-or was created with
-.Xr dispatch_time 3 ,
-the timer is based on up time (which is obtained from
-.Fn mach_absolute_time
-on Apple platforms).
-If
-.Fa start
-was created with
-.Xr dispatch_walltime 3 ,
-the timer is based on
-.Xr gettimeofday 3 .
-.Pp
-.Vt DISPATCH_SOURCE_TYPE_VNODE
-.Pp
-Sources of this type monitor the virtual filesystem nodes for state changes.
-The
-.Fa handle
-is a file descriptor (int) referencing the node to monitor, and
-the
-.Fa mask
-may be one or more of the following:
-.Bl -tag -width "XXDISPATCH_VNODE_ATTRIB" -compact -offset indent
-.It \(bu DISPATCH_VNODE_DELETE
-The referenced node was removed from the filesystem namespace via
-.Xr unlink 2 .
-.It \(bu DISPATCH_VNODE_WRITE
-A write to the referenced file occurred.
-.It \(bu DISPATCH_VNODE_EXTEND
-The referenced file was extended.
-.It \(bu DISPATCH_VNODE_ATTRIB
-The metadata attributes of the referenced node have changed.
-.It \(bu DISPATCH_VNODE_LINK
-The link count on the referenced node has changed.
-.It \(bu DISPATCH_VNODE_RENAME
-The referenced node was renamed.
-.It \(bu DISPATCH_VNODE_REVOKE
-Access to the referenced node was revoked via
-.Xr revoke 2
-or the underlying fileystem was unmounted.
-.It \(bu DISPATCH_VNODE_FUNLOCK
-The referenced file was unlocked by
-.Xr flock 2
-or
-.Xr close 2 .
-.El
-.Pp
-The data returned by
-.Fn dispatch_source_get_data
-is a bitmask that indicates which of the events in the
-.Fa mask
-were observed.
-.Pp
-.Vt DISPATCH_SOURCE_TYPE_WRITE
-.Pp
-Sources of this type monitor file descriptors for available write buffer space.
-The
-.Fa handle
-is the file descriptor (int) to monitor and the
-.Fa mask
-is unused and should be zero.
-.Pp
-Users of this source type are strongly encouraged to perform non-blocking I/O
-and handle any truncated reads or error conditions that may occur. See
-.Xr fcntl 2
-for additional information about setting the
-.Vt O_NONBLOCK
-flag on a file descriptor.
-.Pp
-.Sh SEE ALSO
-.Xr dispatch 3 ,
-.Xr dispatch_object 3 ,
-.Xr dispatch_queue_create 3
--- a/Telegram/ThirdParty/dispatch/man/dispatch_time.3	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/man/dispatch_time.3	1970-01-01 00:00:00.000000000 -0000
@@ -1,130 +0,0 @@
-.\" Copyright (c) 2008-2013 Apple Inc. All rights reserved.
-.Dd May 1, 2009
-.Dt dispatch_time 3
-.Os Darwin
-.Sh NAME
-.Nm dispatch_time ,
-.Nm dispatch_walltime
-.Nd Calculate temporal milestones
-.Sh SYNOPSIS
-.Fd #include <dispatch/dispatch.h>
-.Vt static const dispatch_time_t DISPATCH_TIME_NOW = 0ull ;
-.Vt static const dispatch_time_t DISPATCH_WALLTIME_NOW = ~1ull ;
-.Vt static const dispatch_time_t DISPATCH_TIME_FOREVER = ~0ull ;
-.Ft dispatch_time_t
-.Fo dispatch_time
-.Fa "dispatch_time_t base" "int64_t offset"
-.Fc
-.Ft dispatch_time_t
-.Fo dispatch_walltime
-.Fa "struct timespec *base" "int64_t offset"
-.Fc
-.Sh DESCRIPTION
-The
-.Fn dispatch_time
-and
-.Fn dispatch_walltime
-functions provide a simple mechanism for expressing temporal milestones for use
-with dispatch functions that need timeouts or operate on a schedule.
-.Pp
-The
-.Fa dispatch_time_t
-type is a semi-opaque integer, with only the special values
-.Vt DISPATCH_TIME_NOW ,
-.Vt DISPATCH_WALLTIME_NOW
-and
-.Vt DISPATCH_TIME_FOREVER
-being externally defined. All other values are represented using an internal
-format that is not safe for integer arithmetic or comparison.
-The internal format is subject to change.
-.Pp
-The
-.Fn dispatch_time
-function returns a milestone relative to an existing milestone after adding
-.Fa offset
-nanoseconds.
-If the
-.Fa base
-parameter maps internally to a wall clock or is
-.Vt DISPATCH_WALLTIME_NOW ,
-then the returned value is relative to the wall clock.
-Otherwise, if
-.Fa base
-is
-.Vt DISPATCH_TIME_NOW ,
-then the current time of the default host clock is used. On Apple platforms,
-the value of the default host clock is obtained from
-.Vt mach_absolute_time() .
-.Pp
-The
-.Fn dispatch_walltime
-function is useful for creating a milestone relative to a fixed point in time
-using the wall clock, as specified by the optional
-.Fa base
-parameter. If
-.Fa base
-is NULL, then the current time of the wall clock is used.
-.Vt dispatch_walltime(NULL, offset)
-is equivalent to
-.Vt dispatch_time(DISPATCH_WALLTIME_NOW, offset) .
-.Sh EDGE CONDITIONS
-The
-.Fn dispatch_time
-and
-.Fn dispatch_walltime
-functions detect overflow and underflow conditions when applying the
-.Fa offset
-parameter.
-.Pp
-Overflow causes
-.Vt DISPATCH_TIME_FOREVER
-to be returned. When
-.Fa base
-is
-.Vt DISPATCH_TIME_FOREVER ,
-then the
-.Fa offset
-parameter is ignored.
-.Pp
-Underflow causes the smallest representable value to be
-returned for a given clock.
-.Sh EXAMPLES
-Create a milestone two seconds in the future, relative to the default clock:
-.Bd -literal -offset indent
-milestone = dispatch_time(DISPATCH_TIME_NOW, 2 * NSEC_PER_SEC);
-.Ed
-.Pp
-Create a milestone two seconds in the future, in wall clock time:
-.Bd -literal -offset indent
-milestone = dispatch_time(DISPATCH_WALLTIME_NOW, 2 * NSEC_PER_SEC);
-.Ed
-.Pp
-Create a milestone for use as an infinite timeout:
-.Bd -literal -offset indent
-milestone = DISPATCH_TIME_FOREVER;
-.Ed
-.Pp
-Create a milestone on Tuesday, January 19, 2038:
-.Bd -literal -offset indent
-struct timespec ts;
-ts.tv_sec = 0x7FFFFFFF;
-ts.tv_nsec = 0;
-milestone = dispatch_walltime(&ts, 0);
-.Ed
-.Pp
-Use a negative delta to create a milestone an hour before the one above:
-.Bd -literal -offset indent
-milestone = dispatch_walltime(&ts, -60 * 60 * NSEC_PER_SEC);
-.Ed
-.Sh RETURN VALUE
-These functions return an abstract value for use with
-.Fn dispatch_after ,
-.Fn dispatch_group_wait ,
-.Fn dispatch_semaphore_wait ,
-or
-.Fn dispatch_source_set_timer .
-.Sh SEE ALSO
-.Xr dispatch 3 ,
-.Xr dispatch_after 3 ,
-.Xr dispatch_group_create 3 ,
-.Xr dispatch_semaphore_create 3
--- a/Telegram/ThirdParty/dispatch/os/CMakeLists.txt	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/os/CMakeLists.txt	1970-01-01 00:00:00.000000000 -0000
@@ -1,11 +0,0 @@
-
-# TODO(compnerd) ensure that object_private.h voucher_activity_private.h
-# voucher_private.h are included in the source tarball
-
-install(FILES
-          object.h
-          generic_unix_base.h
-          generic_win_base.h
-        DESTINATION
-          "${INSTALL_OS_HEADERS_DIR}")
-
--- a/Telegram/ThirdParty/dispatch/os/firehose_buffer_private.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/os/firehose_buffer_private.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,161 +0,0 @@
-/*
- * Copyright (c) 2015 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#ifndef __FIREHOSE_BUFFER_PRIVATE__
-#define __FIREHOSE_BUFFER_PRIVATE__
-
-#if OS_FIREHOSE_SPI
-#ifdef KERNEL
-#include <stdint.h>
-#else
-#include <os/base.h>
-#include <os/availability.h>
-#include <os/base_private.h>
-#include <dispatch/dispatch.h>
-#endif
-
-#define OS_FIREHOSE_SPI_VERSION 20180226
-
-/*!
- * @group Firehose SPI
- * SPI intended for logd only
- * Layout of structs is subject to change without notice
- */
-
-#define FIREHOSE_BUFFER_LIBTRACE_HEADER_SIZE	2048ul
-#define FIREHOSE_BUFFER_KERNEL_MIN_CHUNK_COUNT	16
-#define FIREHOSE_BUFFER_KERNEL_MAX_CHUNK_COUNT	64
-
-typedef struct firehose_buffer_range_s {
-	uint16_t fbr_offset; // offset from the start of the buffer
-	uint16_t fbr_length;
-} *firehose_buffer_range_t;
-
-#ifdef KERNEL
-
-typedef struct firehose_chunk_s *firehose_chunk_t;
-
-// implemented by the kernel
-extern void __firehose_buffer_push_to_logd(firehose_buffer_t fb, bool for_io);
-extern void __firehose_critical_region_enter(void);
-extern void __firehose_critical_region_leave(void);
-extern void __firehose_allocate(vm_offset_t *addr, vm_size_t size);
-extern uint8_t __firehose_buffer_kernel_chunk_count;
-extern uint8_t __firehose_num_kernel_io_pages;
-
-#define FIREHOSE_BUFFER_KERNEL_DEFAULT_CHUNK_COUNT FIREHOSE_BUFFER_KERNEL_MIN_CHUNK_COUNT
-#define FIREHOSE_BUFFER_KERNEL_DEFAULT_IO_PAGES    8
-
-#define FIREHOSE_BUFFER_KERNEL_CHUNK_COUNT __firehose_buffer_kernel_chunk_count
-#define FIREHOSE_BUFFER_CHUNK_PREALLOCATED_COUNT (__firehose_buffer_kernel_chunk_count - 1) // the first chunk is the header
-
-// exported for the kernel
-firehose_tracepoint_t
-__firehose_buffer_tracepoint_reserve(uint64_t stamp, firehose_stream_t stream,
-		uint16_t pubsize, uint16_t privsize, uint8_t **privptr);
-
-void
-__firehose_buffer_tracepoint_flush(firehose_tracepoint_t vat,
-		firehose_tracepoint_id_u vatid);
-
-firehose_buffer_t
-__firehose_buffer_create(size_t *size);
-
-void
-__firehose_merge_updates(firehose_push_reply_t update);
-
-int
-__firehose_kernel_configuration_valid(uint8_t chunk_count, uint8_t io_pages);
-
-#else
-
-#define __firehose_critical_region_enter()
-#define __firehose_critical_region_leave()
-
-OS_EXPORT
-const uint32_t _firehose_spi_version;
-
-OS_ALWAYS_INLINE
-static inline const uint8_t *
-_firehose_tracepoint_reader_init(firehose_chunk_t fc, const uint8_t **endptr)
-{
-	const uint8_t *start = fc->fc_data;
-	const uint8_t *end = fc->fc_start + fc->fc_pos.fcp_next_entry_offs;
-
-	if (end > fc->fc_start + FIREHOSE_CHUNK_SIZE) {
-		end = start;
-	}
-	*endptr = end;
-	return start;
-}
-
-OS_ALWAYS_INLINE
-static inline firehose_tracepoint_t
-_firehose_tracepoint_reader_next(const uint8_t **ptr, const uint8_t *end)
-{
-	const uint16_t ft_size = offsetof(struct firehose_tracepoint_s, ft_data);
-	struct ft_unaligned_s {
-		struct firehose_tracepoint_s ft;
-	} __attribute__((packed, aligned(1))) *uft;
-
-	do {
-		uft = (struct ft_unaligned_s *)*ptr;
-		if (uft->ft.ft_data >= end) {
-			// reached the end
-			return NULL;
-		}
-		if (!uft->ft.ft_length) {
-			// tracepoint write didn't even start
-			return NULL;
-		}
-		if (uft->ft.ft_length > end - uft->ft.ft_data) {
-			// invalid length
-			return NULL;
-		}
-		*ptr += roundup(ft_size + uft->ft.ft_length, 8);
-		// test whether write of the tracepoint was finished
-	} while (os_unlikely(uft->ft.ft_id.ftid_value == 0));
-
-	return (firehose_tracepoint_t)uft;
-}
-
-#define firehose_tracepoint_foreach(ft, fbc) \
-		for (const uint8_t *end, *p = _firehose_tracepoint_reader_init(fbc, &end); \
-				((ft) = _firehose_tracepoint_reader_next(&p, end)); )
-
-OS_ALWAYS_INLINE
-static inline bool
-firehose_buffer_range_validate(firehose_chunk_t fc, firehose_tracepoint_t ft,
-		firehose_buffer_range_t range)
-{
-	if (range->fbr_offset + range->fbr_length > FIREHOSE_CHUNK_SIZE) {
-		return false;
-	}
-	if (fc->fc_start + range->fbr_offset < ft->ft_data + ft->ft_length) {
-		return false;
-	}
-	return true;
-}
-
-#endif // !KERNEL
-
-#endif // OS_FIREHOSE_SPI
-
-#endif // __FIREHOSE_BUFFER_PRIVATE__
--- a/Telegram/ThirdParty/dispatch/os/firehose_server_private.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/os/firehose_server_private.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,484 +0,0 @@
-/*
- * Copyright (c) 2015 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#ifndef __FIREHOSE_SERVER_PRIVATE__
-#define __FIREHOSE_SERVER_PRIVATE__
-
-#include <os/base.h>
-#include <dispatch/dispatch.h>
-#include "firehose_buffer_private.h"
-
-#if OS_FIREHOSE_SPI
-/*!
- * @group Firehose SPI
- * SPI intended for logd only
- */
-
-#pragma mark - Firehose Client
-
-/*!
- * @typedef firehose_client_t
- *
- * @abstract
- * Represents a firehose client.
- *
- * @discussion
- * Firehose client objects are os_object_t's, and it's legal to retain/release
- * them with os_retain / os_release.
- */
-OS_OBJECT_DECL_CLASS(firehose_client);
-
-/*!
- * @typedef firehose_event_t
- *
- * @const FIREHOSE_EVENT_NONE
- * Never passed to callbacks, meaningful for
- * firehose_client_metadata_stream_peek.
- *
- * @const FIREHOSE_EVENT_CLIENT_CONNECTED
- * A new client has connected
- *
- * This is the first event delivered, and no event is delivered until
- * the handler of that event returns
- *
- * The `page` argument is really a firehose_client_connected_info_t.  The
- * `fc_pos` argument is not meaningful.
- *
- * @const FIREHOSE_EVENT_CLIENT_DIED
- * The specified client is gone and will not flush new buffers
- *
- * This is the last event delivered, it is never called before all other
- * event handlers have returned. This event is generated even when a
- * FIREHOSE_EVENT_CLIENT_CORRUPTED event has been generated.
- *
- * @const FIREHOSE_EVENT_IO_BUFFER_RECEIVED
- * A new buffer needs to be pushed; `page` is set to that buffer, and `fc_pos`
- * to its chunk position header.
- *
- * This event can be sent concurrently wrt FIREHOSE_EVENT_MEM_BUFFER_RECEIVED
- * events.
- *
- * @const FIREHOSE_EVENT_MEM_BUFFER_RECEIVED
- * A new buffer needs to be pushed; `page` is set to that buffer, and `fc_pos`
- * to its chunk position header.
- *
- * This event can be sent concurrently wrt FIREHOSE_EVENT_IO_BUFFER_RECEIVED
- * events.
- *
- * @const FIREHOSE_EVENT_CLIENT_CORRUPTED
- * This event is received when a client is found being corrupted.
- * `page` is set to the buffer header page, and `fc_pos` is not meaningful. When
- * this event is received, logs have likely been lost for this client.
- *
- * This buffer isn't really a proper firehose buffer page, but its content may
- * be useful for debugging purposes.
- *
- * @const FIREHOSE_EVENT_CLIENT_FINALIZE
- * This event is received when a firehose client structure is about to be
- * destroyed. Only firehose_client_get_context() can ever be called with
- * the passed firehose client. The `page` argument is NULL for this event, and
- * the `fc_pos` argument is not meaningful.
- *
- * The event is sent from the context that is dropping the last refcount
- * of the client.
- */
-OS_ENUM(firehose_event, unsigned long,
-	FIREHOSE_EVENT_NONE = 0,
-	FIREHOSE_EVENT_CLIENT_CONNECTED,
-	FIREHOSE_EVENT_CLIENT_DIED,
-	FIREHOSE_EVENT_IO_BUFFER_RECEIVED,
-	FIREHOSE_EVENT_MEM_BUFFER_RECEIVED,
-	FIREHOSE_EVENT_CLIENT_CORRUPTED,
-	FIREHOSE_EVENT_CLIENT_FINALIZE,
-);
-
-#define FIREHOSE_CLIENT_CONNECTED_INFO_VERSION  1
-
-/*!
- * @typedef firehose_client_connected_info
- *
- * @abstract
- * Type of the data passed to CLIENT_CONNECTED events.
- */
-typedef struct firehose_client_connected_info_s {
-	unsigned long fcci_version;
-	// version 1
-	const void *fcci_data;
-	size_t fcci_size;
-} *firehose_client_connected_info_t;
-
-/*!
- * @function firehose_client_get_unique_pid
- *
- * @abstract
- * Returns the unique pid of the specified firehose client
- *
- * @param client
- * The specified client.
- *
- * @param pid
- * The pid for this client.
- *
- * @returns
- * The unique pid of the specified client.
- */
-OS_NOTHROW OS_NONNULL1
-uint64_t
-firehose_client_get_unique_pid(firehose_client_t client, pid_t *pid);
-
-/*!
- * @function firehose_client_get_pid_version
- *
- * @abstract
- * Returns the pid version for that client.
- *
- * @param client
- * The specified client.
- */
-OS_NOTHROW OS_NONNULL1
-int
-firehose_client_get_pid_version(firehose_client_t client);
-
-/*!
- * @function firehose_client_get_euid
- *
- * @abstract
- * Returns the EUID for that client as discovered at connect time.
- *
- * @param client
- * The specified client.
- */
-OS_NOTHROW OS_NONNULL1
-uid_t
-firehose_client_get_euid(firehose_client_t client);
-
-/*!
- * @function firehose_client_get_metadata_buffer
- *
- * @abstract
- * Returns the metadata buffer for the specified firehose client
- *
- * @param client
- * The specified client.
- *
- * @param size
- * The size of the metadata buffer.
- *
- * @returns
- * The pointer to the buffer.
- */
-OS_NOTHROW OS_NONNULL_ALL
-void *
-firehose_client_get_metadata_buffer(firehose_client_t client, size_t *size);
-
-/*!
- * @function firehose_client_get_context
- *
- * @abstract
- * Gets the context for the specified client.
- *
- * @param client
- * The specified client.
- *
- * @returns
- * The context set for the client with firehose_client_set_context
- */
-OS_NOTHROW OS_NONNULL1
-void *
-firehose_client_get_context(firehose_client_t client);
-
-/*!
- * @function firehose_client_set_strings_cached
- *
- * @abstract
- * Marks a given client as having strings cached already.
- *
- * @param client
- * The specified client.
- */
-OS_NOTHROW OS_NONNULL1
-void
-firehose_client_set_strings_cached(firehose_client_t client);
-
-/*!
- * @function firehose_client_set_context
- *
- * @abstract
- * Sets the context for the specified client.
- *
- * @discussion
- * Setting the context exchanges the context pointer, but the client must
- * ensure proper synchronization with possible getters.
- *
- * The lifetime of the context is under the control of the API user,
- * it is suggested to destroy the context when the CLIENT_DIED event is
- * received.
- *
- * @param client
- * The specified client.
- *
- * @param ctxt
- * The new context to set.
- *
- * @returns
- * The previous context set for the client.
- */
-OS_NOTHROW OS_NONNULL1
-void *
-firehose_client_set_context(firehose_client_t client, void *ctxt);
-
-/*!
- * @function firehose_client_initiate_quarantine
- *
- * @abstract
- * Starts the procedure to move the given client to the high volume quarantine
- *
- * @discussion
- * When the client is in the high volume quarantine, their firehose chunks
- * have the fcp_quarantined bit set to 1.
- *
- * @param client
- * The specified client.
- */
-OS_NOTHROW OS_NONNULL1
-void
-firehose_client_initiate_quarantine(firehose_client_t client);
-
-/*!
- * @function firehose_client_metadata_stream_peek
- *
- * @abstract
- * Peek at the metadata stream in flight buffers for a given client
- *
- * @discussion
- * This function should never be called from the context of a snapshot
- * handler.
- *
- * @param client
- * The specified client
- *
- * @param context
- * If this function is called synchronously from the handler passed to
- * firehose_server_init, then `context` should be the event being processed.
- * Else pass FIREHOSE_EVENT_NONE.
- *
- * @param peek_should_start
- * Handler that is called prior to peeking to solve the race of metadata
- * buffers not beeing processed yet at first lookup time, and being processed
- * before the peek enumeration starts.
- *
- * If the handler returns false, then the enumeration doesn't start.
- * If the race cannot happen, pass NULL.
- *
- * @param peek
- * Handler that will receive all the live metadata buffers for this process.
- * If the handler returns false, the enumeration is interrupted.
- */
-OS_NOTHROW OS_NONNULL1 OS_NONNULL4
-void
-firehose_client_metadata_stream_peek(firehose_client_t client,
-		firehose_event_t context, OS_NOESCAPE bool (^peek_should_start)(void),
-		OS_NOESCAPE bool (^peek)(firehose_chunk_t fbc));
-
-#pragma mark - Firehose Server
-
-/*!
- * @typedef firehose_handler_t
- *
- * @abstract
- * Type of the handler block for firehose_server_init()
- */
-typedef void (^firehose_handler_t)(firehose_client_t client,
-		firehose_event_t event, firehose_chunk_t page,
-		firehose_chunk_pos_u fc_pos);
-
-/*!
- * @function firehose_server_init
- *
- * @abstract
- * Initializes the firehose MiG server
- *
- * @discussion
- * Initializes the firehose MiG server by boostrap registering the services
- * and creating dispatch_sources for the same.
- */
-OS_NOTHROW
-void
-firehose_server_init(mach_port_t firehose_comm_port,
-		firehose_handler_t handler);
-
-/*!
- * @function firehose_server_assert_spi_version
- *
- * @abstract
- * Checks that libdispatch and firehose components all match
- *
- * @discussion
- * Will assert that all the components have the same SPI versions
- */
-OS_NOTHROW
-void
-firehose_server_assert_spi_version(uint32_t spi_version);
-
-/*!
- * @function firehose_server_has_ever_flushed_pages
- *
- * @abstract
- * Checks whether the firehose server has ever flushed any pages this boot.
- *
- * @discussion
- * Must be called after firehose_server_init() and before calling
- * firehose_server_resume().
- */
-OS_NOTHROW
-bool
-firehose_server_has_ever_flushed_pages(void);
-
-/*!
- * @function firehose_server_resume
- *
- * @abstract
- * Allows firehose events to flow
- *
- * @discussion
- * Must be called after firehose_server_init()
- */
-OS_NOTHROW
-void
-firehose_server_resume(void);
-
-/*!
- * @function firehose_server_cancel
- *
- * @abstract
- * Cancels the server, disconnects all clients, and prevents new connections.
- */
-OS_NOTHROW
-void
-firehose_server_cancel(void);
-
-/*!
- * @function firehose_server_set_logging_prefs
- *
- * @abstract
- * Publishes a new preferences buffer.
- *
- * @description
- * The server will take ownership of this buffer and will
- * call munmap() on the previous one that was stored.
- */
-OS_NOTHROW
-void
-firehose_server_set_logging_prefs(void *pointer, size_t length,
-		os_block_t block);
-
-/*!
- * @typedef firehose_server_queue_t
- *
- * @abstract
- * Values to pass to firehose_server_get_queue()
- */
-OS_ENUM(firehose_server_queue, unsigned long,
-	FIREHOSE_SERVER_QUEUE_UNKNOWN,
-	FIREHOSE_SERVER_QUEUE_IO,
-	FIREHOSE_SERVER_QUEUE_MEMORY,
-);
-
-/*!
- * @function firehose_server_copy_queue
- *
- * @abstract
- * Returns internal queues to the firehose server subsystem.
- */
-OS_NOTHROW OS_OBJECT_RETURNS_RETAINED
-dispatch_queue_t
-firehose_server_copy_queue(firehose_server_queue_t which);
-
-/*!
- * @function firehose_server_quarantined_suspend
- *
- * @abstract
- * Suspends processing of quarantined clients until
- * firehose_server_quarantined_resume() is called for the same queue.
- *
- * @discussion
- * Suspending processing of quarantined clients causes firehose_snapshot()
- * to block until the processing is enabled again.
- *
- * However if this is used to pace the processing, it is a good idea to disable
- * this pacing until the snapshot has completed.
- *
- * Similarly, quarantine suspension must be off during shutdown.
- */
-OS_NOTHROW
-void
-firehose_server_quarantined_suspend(firehose_server_queue_t q);
-
-/*!
- * @function firehose_server_quarantined_resume
- *
- * @abstract
- * Resumes processing of quarantined clients.
- */
-OS_NOTHROW
-void
-firehose_server_quarantined_resume(firehose_server_queue_t q);
-
-#pragma mark - Firehose Snapshot
-
-/*!
- * @typedef firehose_snapshot_event
- */
-OS_ENUM(firehose_snapshot_event, unsigned long,
-	FIREHOSE_SNAPSHOT_EVENT_IO_START = 1,
-	FIREHOSE_SNAPSHOT_EVENT_MEM_START,
-	FIREHOSE_SNAPSHOT_EVENT_IO_BUFFER,
-	FIREHOSE_SNAPSHOT_EVENT_MEM_BUFFER,
-	FIREHOSE_SNAPSHOT_EVENT_COMPLETE,
-);
-
-/*!
- * @typedef firehose_snapshot_handler_t
- *
- * @abstract
- * Type of the handler block for firehose_snapshot
- */
-typedef void (^firehose_snapshot_handler_t)(firehose_client_t client,
-		firehose_snapshot_event_t event, firehose_chunk_t page,
-		firehose_chunk_pos_u fc_pos);
-
-/*!
- * @function firehose_snapshot
- *
- * @abstract
- * Gather a snapshot for the current firehose state.
- *
- * @discussion
- * This function can be called several times, in which case snapshots are taken
- * one after the other. If coalescing is desired, it has to be built around this
- * call.
- */
-OS_NOTHROW
-void
-firehose_snapshot(firehose_snapshot_handler_t handler);
-
-#endif // OS_FIREHOSE_SPI
-
-#endif // __FIREHOSE_SERVER_PRIVATE__
--- a/Telegram/ThirdParty/dispatch/os/generic_unix_base.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/os/generic_unix_base.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,128 +0,0 @@
-/*
- * This source file is part of the Swift.org open source project
- *
- * Copyright (c) 2015 Apple Inc. and the Swift project authors
- *
- * Licensed under Apache License v2.0 with Runtime Library Exception
- *
- * See https://swift.org/LICENSE.txt for license information
- * See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
- *
- */
-
-#ifndef __OS_GENERIC_UNIX_BASE__
-#define __OS_GENERIC_UNIX_BASE__
-
-#if __has_include(<sys/sysmacros.h>)
-#include <sys/sysmacros.h>
-#endif
-
-#if defined(__FreeBSD__)
-#include <libutil.h>
-#include <fcntl.h>
-#endif
-#include <sys/param.h>
-
-#if __has_include(<sys/cdefs.h>)
-#include <sys/cdefs.h>
-#endif
-
-#ifndef API_AVAILABLE
-#define API_AVAILABLE(...)
-#endif
-#ifndef API_DEPRECATED
-#define API_DEPRECATED(...)
-#endif
-#ifndef API_UNAVAILABLE
-#define API_UNAVAILABLE(...)
-#endif
-#ifndef API_DEPRECATED_WITH_REPLACEMENT
-#define API_DEPRECATED_WITH_REPLACEMENT(...)
-#endif
-
-#if __GNUC__
-#define OS_EXPECT(x, v) __builtin_expect((x), (v))
-#define OS_UNUSED __attribute__((__unused__))
-#else
-#define OS_EXPECT(x, v) (x)
-#define OS_UNUSED
-#endif
-
-#ifndef os_likely
-#define os_likely(x) OS_EXPECT(!!(x), 1)
-#endif
-#ifndef os_unlikely
-#define os_unlikely(x) OS_EXPECT(!!(x), 0)
-#endif
-
-#if __has_feature(assume_nonnull)
-#define OS_ASSUME_NONNULL_BEGIN _Pragma("clang assume_nonnull begin")
-#define OS_ASSUME_NONNULL_END   _Pragma("clang assume_nonnull end")
-#else
-#define OS_ASSUME_NONNULL_BEGIN
-#define OS_ASSUME_NONNULL_END
-#endif
-
-#if __has_builtin(__builtin_assume)
-#define OS_COMPILER_CAN_ASSUME(expr) __builtin_assume(expr)
-#else
-#define OS_COMPILER_CAN_ASSUME(expr) ((void)(expr))
-#endif
-
-#if __has_feature(attribute_availability_swift)
-// equivalent to __SWIFT_UNAVAILABLE from Availability.h
-#define OS_SWIFT_UNAVAILABLE(_msg) \
-		__attribute__((__availability__(swift, unavailable, message=_msg)))
-#else
-#define OS_SWIFT_UNAVAILABLE(_msg)
-#endif
-
-#if __has_attribute(swift_private)
-# define OS_REFINED_FOR_SWIFT __attribute__((__swift_private__))
-#else
-# define OS_REFINED_FOR_SWIFT
-#endif
-
-#if __has_attribute(swift_name)
-# define OS_SWIFT_NAME(_name) __attribute__((__swift_name__(#_name)))
-#else
-# define OS_SWIFT_NAME(_name)
-#endif
-
-#define __OS_STRINGIFY(s) #s
-#define OS_STRINGIFY(s) __OS_STRINGIFY(s)
-#define __OS_CONCAT(x, y) x ## y
-#define OS_CONCAT(x, y) __OS_CONCAT(x, y)
-
-#if __has_feature(objc_fixed_enum) || __has_extension(cxx_strong_enums)
-#define OS_ENUM(_name, _type, ...) \
-typedef enum : _type { __VA_ARGS__ } _name##_t
-#else
-#define OS_ENUM(_name, _type, ...) \
-enum { __VA_ARGS__ }; typedef _type _name##_t
-#endif
-
-/*
- * Stub out misc linking and compilation attributes
- */
-
-#ifdef OS_EXPORT
-#undef OS_EXPORT
-#endif
-#define OS_EXPORT
-
-#ifdef OS_WARN_RESULT_NEEDS_RELEASE
-#undef OS_WARN_RESULT_NEEDS_RELEASE
-#endif
-
-#ifdef OS_WARN_RESULT
-#undef OS_WARN_RESULT
-#endif
-#define OS_WARN_RESULT
-
-#ifdef OS_NOTHROW
-#undef OS_NOTHROW
-#endif
-#define OS_NOTHROW
-
-#endif /* __OS_GENERIC_UNIX_BASE__ */
--- a/Telegram/ThirdParty/dispatch/os/generic_win_base.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/os/generic_win_base.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,132 +0,0 @@
-/*
- * This source file is part of the Swift.org open source project
- *
- * Copyright (c) 2015 Apple Inc. and the Swift project authors
- *
- * Licensed under Apache License v2.0 with Runtime Library Exception
- *
- * See https://swift.org/LICENSE.txt for license information
- * See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
- *
- */
-
-#ifndef __OS_GENERIC_WIN_BASE__
-#define __OS_GENERIC_WIN_BASE__
-
-// Unices provide `roundup` via sys/param.h
-#define roundup(x, y) ((((x) + ((y) - 1)) / (y)) * (y))
-// Unices provide `MAX` via sys/param.h
-#define MAX(a,b) (((a)>(b))?(a):(b))
-// Unices provide `MIN` via sys/param.h
-#define MIN(a,b) (((a)<(b))?(a):(b))
-// Unices provide `howmany` via sys/param.h
-#define howmany(x, y)  (((x) + ((y) - 1)) / (y))
-
-typedef int mode_t;
-typedef void pthread_attr_t;
-
-#if defined(__cplusplus)
-#define __BEGIN_DECLS extern "C" {
-#define __END_DECLS }
-#else
-#define __BEGIN_DECLS
-#define __END_DECLS
-#endif
-
-#ifndef API_AVAILABLE
-#define API_AVAILABLE(...)
-#endif
-#ifndef API_DEPRECATED
-#define API_DEPRECATED(...)
-#endif
-#ifndef API_UNAVAILABLE
-#define API_UNAVAILABLE(...)
-#endif
-#ifndef API_DEPRECATED_WITH_REPLACEMENT
-#define API_DEPRECATED_WITH_REPLACEMENT(...)
-#endif
-
-#if !defined(__has_attribute)
-#define __has_attribute(attibute) 0
-#endif
-
-#if !defined(__has_builtin)
-#define __has_builtin(builtin) 0
-#endif
-
-#if !defined(__has_feature)
-#define __has_feature(feature) 0
-#endif
-
-#if __has_builtin(__builtin_expect)
-#define OS_EXPECT(expression, value) __builtin_expect((expression), (value))
-#else
-#define OS_EXPECT(expression, value) (expression)
-#endif
-
-#if __has_attribute(__unused__)
-#define OS_UNUSED __attribute__((__unused__))
-#else
-#define OS_UNUSED
-#endif
-
-#ifndef os_likely
-#define os_likely(expression) OS_EXPECT(!!(expression), 1)
-#endif
-#ifndef os_unlikely
-#define os_unlikely(expression) OS_EXPECT(!!(expression), 0)
-#endif
-
-#if __has_feature(assume_nonnull)
-#define OS_ASSUME_NONNULL_BEGIN _Pragma("clang assume_nonnull begin")
-#define OS_ASSUME_NONNULL_END   _Pragma("clang assume_nonnull end")
-#else
-#define OS_ASSUME_NONNULL_BEGIN
-#define OS_ASSUME_NONNULL_END
-#endif
-
-#if __has_builtin(__builtin_assume)
-#define OS_COMPILER_CAN_ASSUME(expr) __builtin_assume(expr)
-#else
-#define OS_COMPILER_CAN_ASSUME(expr) ((void)(expr))
-#endif
-
-#if __has_feature(attribute_availability_swift)
-// equivalent to __SWIFT_UNAVAILABLE from Availability.h
-#define OS_SWIFT_UNAVAILABLE(msg)                                              \
-  __attribute__((__availability__(swift, unavailable, message = msg)))
-#else
-#define OS_SWIFT_UNAVAILABLE(msg)
-#endif
-
-#define __OS_STRINGIFY(s) #s
-#define OS_STRINGIFY(s) __OS_STRINGIFY(s)
-
-#if __has_feature(objc_fixed_enum) || __has_extension(cxx_strong_enums)
-#define OS_ENUM(name, type, ...) typedef enum : type { __VA_ARGS__ } name##_t
-#else
-#define OS_ENUM(name, type, ...)                                               \
-  enum { __VA_ARGS__ };                                                        \
-  typedef type name##_t
-#endif
-
-#ifdef OS_EXPORT
-#undef OS_EXPORT
-#endif
-#define OS_EXPORT __declspec(dllexport)
-
-#ifdef OS_WARN_RESULT_NEEDS_RELEASE
-#undef OS_WARN_RESULT_NEEDS_RELEASE
-#endif
-
-#ifdef OS_WARN_RESULT
-#undef OS_WARN_RESULT
-#endif
-#define OS_WARN_RESULT
-
-#ifdef OS_NOTHROW
-#undef OS_NOTHROW
-#endif
-#define OS_NOTHROW
-
-#endif
--- a/Telegram/ThirdParty/dispatch/os/object.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/os/object.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,272 +0,0 @@
-/*
- * Copyright (c) 2011-2014 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#ifndef __OS_OBJECT__
-#define __OS_OBJECT__
-
-#ifdef __APPLE__
-#include <Availability.h>
-#include <os/availability.h>
-#include <TargetConditionals.h>
-#include <os/base.h>
-#elif defined(_WIN32)
-#include <os/generic_win_base.h>
-#elif defined(__unix__)
-#include <os/generic_unix_base.h>
-#endif
-
-/*!
- * @header
- *
- * @preprocinfo
- * By default, libSystem objects such as GCD and XPC objects are declared as
- * Objective-C types when building with an Objective-C compiler. This allows
- * them to participate in ARC, in RR management by the Blocks runtime and in
- * leaks checking by the static analyzer, and enables them to be added to Cocoa
- * collections.
- *
- * NOTE: this requires explicit cancellation of dispatch sources and xpc
- *       connections whose handler blocks capture the source/connection object,
- *       resp. ensuring that such captures do not form retain cycles (e.g. by
- *       declaring the source as __weak).
- *
- * To opt-out of this default behavior, add -DOS_OBJECT_USE_OBJC=0 to your
- * compiler flags.
- *
- * This mode requires a platform with the modern Objective-C runtime, the
- * Objective-C GC compiler option to be disabled, and at least a Mac OS X 10.8
- * or iOS 6.0 deployment target.
- */
-
-#ifndef OS_OBJECT_HAVE_OBJC_SUPPORT
-#if !defined(__OBJC__) || defined(__OBJC_GC__)
-#  define OS_OBJECT_HAVE_OBJC_SUPPORT 0
-#elif !defined(TARGET_OS_MAC) || !TARGET_OS_MAC
-#  define OS_OBJECT_HAVE_OBJC_SUPPORT 0
-#elif TARGET_OS_IOS && __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_6_0
-#  define OS_OBJECT_HAVE_OBJC_SUPPORT 0
-#elif TARGET_OS_MAC && !TARGET_OS_IPHONE
-#  if __MAC_OS_X_VERSION_MIN_REQUIRED < __MAC_10_8
-#  define OS_OBJECT_HAVE_OBJC_SUPPORT 0
-#  elif defined(__i386__) && __MAC_OS_X_VERSION_MIN_REQUIRED < __MAC_10_12
-#  define OS_OBJECT_HAVE_OBJC_SUPPORT 0
-#  else
-#  define OS_OBJECT_HAVE_OBJC_SUPPORT 1
-#  endif
-#else
-#  define OS_OBJECT_HAVE_OBJC_SUPPORT 1
-#endif
-#endif // OS_OBJECT_HAVE_OBJC_SUPPORT
-
-#if OS_OBJECT_HAVE_OBJC_SUPPORT
-#if defined(__swift__) && __swift__ && !OS_OBJECT_USE_OBJC
-#define OS_OBJECT_USE_OBJC 1
-#endif
-#ifndef OS_OBJECT_USE_OBJC
-#define OS_OBJECT_USE_OBJC 1
-#endif
-#elif defined(OS_OBJECT_USE_OBJC) && OS_OBJECT_USE_OBJC
-/* Unsupported platform for OS_OBJECT_USE_OBJC=1 */
-#undef OS_OBJECT_USE_OBJC
-#define OS_OBJECT_USE_OBJC 0
-#else
-#define OS_OBJECT_USE_OBJC 0
-#endif
-
-#ifndef OS_OBJECT_SWIFT3
-#if defined(SWIFT_SDK_OVERLAY_DISPATCH_EPOCH) && \
-		SWIFT_SDK_OVERLAY_DISPATCH_EPOCH >= 2
-#define OS_OBJECT_SWIFT3 1
-#else
-#define OS_OBJECT_SWIFT3 0
-#endif // SWIFT_SDK_OVERLAY_DISPATCH_EPOCH >= 2
-#endif // OS_OBJECT_SWIFT3
-
-#if OS_OBJECT_USE_OBJC
-#import <objc/NSObject.h>
-#if __has_attribute(objc_independent_class)
-#define OS_OBJC_INDEPENDENT_CLASS __attribute__((objc_independent_class))
-#endif // __has_attribute(objc_independent_class)
-#ifndef OS_OBJC_INDEPENDENT_CLASS
-#define OS_OBJC_INDEPENDENT_CLASS
-#endif
-#define OS_OBJECT_CLASS(name) OS_##name
-#define OS_OBJECT_DECL_PROTOCOL(name, ...) \
-		@protocol OS_OBJECT_CLASS(name) __VA_ARGS__ \
-		@end
-#define OS_OBJECT_CLASS_IMPLEMENTS_PROTOCOL_IMPL(name, proto) \
-		@interface name () <proto> \
-		@end
-#define OS_OBJECT_CLASS_IMPLEMENTS_PROTOCOL(name, proto) \
-		OS_OBJECT_CLASS_IMPLEMENTS_PROTOCOL_IMPL( \
-				OS_OBJECT_CLASS(name), OS_OBJECT_CLASS(proto))
-#define OS_OBJECT_DECL_IMPL(name, ...) \
-		OS_OBJECT_DECL_PROTOCOL(name, __VA_ARGS__) \
-		typedef NSObject<OS_OBJECT_CLASS(name)> \
-				* OS_OBJC_INDEPENDENT_CLASS name##_t
-#define OS_OBJECT_DECL_BASE(name, ...) \
-		@interface OS_OBJECT_CLASS(name) : __VA_ARGS__ \
-		- (instancetype)init OS_SWIFT_UNAVAILABLE("Unavailable in Swift"); \
-		@end
-#define OS_OBJECT_DECL_IMPL_CLASS(name, ...) \
-		OS_OBJECT_DECL_BASE(name, ## __VA_ARGS__) \
-		typedef OS_OBJECT_CLASS(name) \
-				* OS_OBJC_INDEPENDENT_CLASS name##_t
-#define OS_OBJECT_DECL(name, ...) \
-		OS_OBJECT_DECL_IMPL(name, <NSObject>)
-#define OS_OBJECT_DECL_SUBCLASS(name, super) \
-		OS_OBJECT_DECL_IMPL(name, <OS_OBJECT_CLASS(super)>)
-#if __has_attribute(ns_returns_retained)
-#define OS_OBJECT_RETURNS_RETAINED __attribute__((__ns_returns_retained__))
-#else
-#define OS_OBJECT_RETURNS_RETAINED
-#endif
-#if __has_attribute(ns_consumed)
-#define OS_OBJECT_CONSUMED __attribute__((__ns_consumed__))
-#else
-#define OS_OBJECT_CONSUMED
-#endif
-#if __has_feature(objc_arc)
-#define OS_OBJECT_BRIDGE __bridge
-#define OS_WARN_RESULT_NEEDS_RELEASE
-#else
-#define OS_OBJECT_BRIDGE
-#define OS_WARN_RESULT_NEEDS_RELEASE OS_WARN_RESULT
-#endif
-#if __has_attribute(objc_runtime_visible) && \
-		((defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && \
-		__MAC_OS_X_VERSION_MIN_REQUIRED < __MAC_10_12) || \
-		(defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && \
-		!defined(__TV_OS_VERSION_MIN_REQUIRED) && \
-		!defined(__WATCH_OS_VERSION_MIN_REQUIRED) && \
-		__IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_10_0) || \
-		(defined(__TV_OS_VERSION_MIN_REQUIRED) && \
-		__TV_OS_VERSION_MIN_REQUIRED < __TVOS_10_0) || \
-		(defined(__WATCH_OS_VERSION_MIN_REQUIRED) && \
-		__WATCH_OS_VERSION_MIN_REQUIRED < __WATCHOS_3_0))
-/*
- * To provide backward deployment of ObjC objects in Swift on pre-10.12
- * SDKs, OS_object classes can be marked as OS_OBJECT_OBJC_RUNTIME_VISIBLE.
- * When compiling with a deployment target earlier than OS X 10.12 (iOS 10.0, 
- * tvOS 10.0, watchOS 3.0) the Swift compiler will only refer to this type at
- * runtime (using the ObjC runtime).
- */
-#define OS_OBJECT_OBJC_RUNTIME_VISIBLE __attribute__((objc_runtime_visible))
-#else
-#define OS_OBJECT_OBJC_RUNTIME_VISIBLE
-#endif
-#ifndef OS_OBJECT_USE_OBJC_RETAIN_RELEASE
-#if defined(__clang_analyzer__)
-#define OS_OBJECT_USE_OBJC_RETAIN_RELEASE 1
-#elif __has_feature(objc_arc) && !OS_OBJECT_SWIFT3
-#define OS_OBJECT_USE_OBJC_RETAIN_RELEASE 1
-#else
-#define OS_OBJECT_USE_OBJC_RETAIN_RELEASE 0
-#endif
-#endif
-#if OS_OBJECT_SWIFT3
-#define OS_OBJECT_DECL_SWIFT(name) \
-		OS_EXPORT OS_OBJECT_OBJC_RUNTIME_VISIBLE \
-		OS_OBJECT_DECL_IMPL_CLASS(name, NSObject)
-#define OS_OBJECT_DECL_SUBCLASS_SWIFT(name, super) \
-		OS_EXPORT OS_OBJECT_OBJC_RUNTIME_VISIBLE \
-		OS_OBJECT_DECL_IMPL_CLASS(name, OS_OBJECT_CLASS(super))
-OS_EXPORT OS_OBJECT_OBJC_RUNTIME_VISIBLE
-OS_OBJECT_DECL_BASE(object, NSObject);
-#endif // OS_OBJECT_SWIFT3
-#else
-/*! @parseOnly */
-#define OS_OBJECT_RETURNS_RETAINED
-/*! @parseOnly */
-#define OS_OBJECT_CONSUMED
-/*! @parseOnly */
-#define OS_OBJECT_BRIDGE
-/*! @parseOnly */
-#define OS_WARN_RESULT_NEEDS_RELEASE OS_WARN_RESULT
-/*! @parseOnly */
-#define OS_OBJECT_OBJC_RUNTIME_VISIBLE
-#define OS_OBJECT_USE_OBJC_RETAIN_RELEASE 0
-#endif
-
-#if OS_OBJECT_SWIFT3
-#define OS_OBJECT_DECL_CLASS(name) \
-		OS_OBJECT_DECL_SUBCLASS_SWIFT(name, object)
-#elif OS_OBJECT_USE_OBJC
-#define OS_OBJECT_DECL_CLASS(name) \
-		OS_OBJECT_DECL(name)
-#else
-#define OS_OBJECT_DECL_CLASS(name) \
-		typedef struct name##_s *name##_t
-#endif
-
-#define OS_OBJECT_GLOBAL_OBJECT(type, object) ((OS_OBJECT_BRIDGE type)&(object))
-
-__BEGIN_DECLS
-
-/*!
- * @function os_retain
- *
- * @abstract
- * Increment the reference count of an os_object.
- *
- * @discussion
- * On a platform with the modern Objective-C runtime this is exactly equivalent
- * to sending the object the -[retain] message.
- *
- * @param object
- * The object to retain.
- *
- * @result
- * The retained object.
- */
-API_AVAILABLE(macos(10.10), ios(8.0))
-OS_EXPORT OS_SWIFT_UNAVAILABLE("Can't be used with ARC")
-void*
-os_retain(void *object);
-#if OS_OBJECT_USE_OBJC
-#undef os_retain
-#define os_retain(object) [object retain]
-#endif
-
-/*!
- * @function os_release
- *
- * @abstract
- * Decrement the reference count of a os_object.
- *
- * @discussion
- * On a platform with the modern Objective-C runtime this is exactly equivalent
- * to sending the object the -[release] message.
- *
- * @param object
- * The object to release.
- */
-API_AVAILABLE(macos(10.10), ios(8.0))
-OS_EXPORT
-void OS_SWIFT_UNAVAILABLE("Can't be used with ARC")
-os_release(void *object);
-#if OS_OBJECT_USE_OBJC
-#undef os_release
-#define os_release(object) [object release]
-#endif
-
-__END_DECLS
-
-#endif
--- a/Telegram/ThirdParty/dispatch/os/object_private.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/os/object_private.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,205 +0,0 @@
-/*
- * Copyright (c) 2011-2012 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-/*
- * IMPORTANT: This header file describes INTERNAL interfaces to libdispatch
- * which are subject to change in future releases of Mac OS X. Any applications
- * relying on these interfaces WILL break.
- */
-
-#ifndef __OS_OBJECT_PRIVATE__
-#define __OS_OBJECT_PRIVATE__
-
-#include <os/object.h>
-#include <stddef.h>
-#include <stdint.h>
-
-#if __GNUC__
-#define OS_OBJECT_NOTHROW __attribute__((__nothrow__))
-#define OS_OBJECT_NONNULL __attribute__((__nonnull__))
-#define OS_OBJECT_WARN_RESULT __attribute__((__warn_unused_result__))
-#define OS_OBJECT_MALLOC __attribute__((__malloc__))
-#ifndef OS_OBJECT_EXPORT
-#define OS_OBJECT_EXPORT extern __attribute__((visibility("default")))
-#endif
-#else
-/*! @parseOnly */
-#define OS_OBJECT_NOTHROW
-/*! @parseOnly */
-#define OS_OBJECT_NONNULL
-/*! @parseOnly */
-#define OS_OBJECT_WARN_RESULT
-/*! @parseOnly */
-#define OS_OBJECT_MALLOC
-#ifndef OS_OBJECT_EXPORT
-/*! @parseOnly */
-#define OS_OBJECT_EXPORT extern
-#endif
-#endif
-
-#if OS_OBJECT_USE_OBJC && __has_feature(objc_arc)
-#define _OS_OBJECT_OBJC_ARC 1
-#else
-#define _OS_OBJECT_OBJC_ARC 0
-#endif
-
-#define _OS_OBJECT_GLOBAL_REFCNT INT_MAX
-
-#define _OS_OBJECT_HEADER(isa, ref_cnt, xref_cnt) \
-        isa; /* must be pointer-sized */ \
-        int volatile ref_cnt; \
-        int volatile xref_cnt
-
-#if OS_OBJECT_HAVE_OBJC_SUPPORT
-#define OS_OBJECT_CLASS_SYMBOL(name) OS_##name##_class
-#if TARGET_OS_MAC && !TARGET_OS_SIMULATOR && defined(__i386__)
-#define OS_OBJECT_HAVE_OBJC1 1
-#define OS_OBJECT_HAVE_OBJC2 0
-#define OS_OBJC_CLASS_RAW_SYMBOL_NAME(name) \
-		".objc_class_name_" OS_STRINGIFY(name)
-#define _OS_OBJECT_CLASS_HEADER() \
-		const void *_os_obj_objc_isa
-#else
-#define OS_OBJECT_HAVE_OBJC1 0
-#define OS_OBJECT_HAVE_OBJC2 1
-#define OS_OBJC_CLASS_RAW_SYMBOL_NAME(name) "_OBJC_CLASS_$_" OS_STRINGIFY(name)
-// Must match size of compiler-generated OBJC_CLASS structure rdar://10640168
-#define _OS_OBJECT_CLASS_HEADER() \
-		void *_os_obj_objc_class_t[5]
-#endif
-#define OS_OBJECT_OBJC_CLASS_DECL(name) \
-		extern void *OS_OBJECT_CLASS_SYMBOL(name) \
-				__asm__(OS_OBJC_CLASS_RAW_SYMBOL_NAME(OS_OBJECT_CLASS(name)))
-#else
-#define OS_OBJECT_HAVE_OBJC1 0
-#define OS_OBJECT_HAVE_OBJC2 0
-#define _OS_OBJECT_CLASS_HEADER() \
-		void (*_os_obj_xref_dispose)(_os_object_t); \
-		void (*_os_obj_dispose)(_os_object_t)
-#endif
-
-#define OS_OBJECT_CLASS(name) OS_##name
-
-#if OS_OBJECT_USE_OBJC && OS_OBJECT_SWIFT3
-@interface OS_OBJECT_CLASS(object) (OSObjectPrivate)
-- (void)_xref_dispose;
-- (void)_dispose;
-@end
-OS_OBJECT_DECL_PROTOCOL(object, <NSObject>);
-typedef OS_OBJECT_CLASS(object) *_os_object_t;
-#define _OS_OBJECT_DECL_SUBCLASS_INTERFACE(name, super) \
-		@interface OS_OBJECT_CLASS(name) : OS_OBJECT_CLASS(super) \
-		<OS_OBJECT_CLASS(name)> \
-		@end
-#define _OS_OBJECT_DECL_PROTOCOL(name, super) \
-		OS_OBJECT_DECL_PROTOCOL(name, <OS_OBJECT_CLASS(super)>)
-#define _OS_OBJECT_CLASS_IMPLEMENTS_PROTOCOL(name, super) \
-		OS_OBJECT_CLASS_IMPLEMENTS_PROTOCOL(name, super)
-#elif OS_OBJECT_USE_OBJC
-API_AVAILABLE(macos(10.8), ios(6.0))
-OS_OBJECT_EXPORT
-@interface OS_OBJECT_CLASS(object) : NSObject
-- (void)_xref_dispose;
-- (void)_dispose;
-@end
-typedef OS_OBJECT_CLASS(object) *_os_object_t;
-#define _OS_OBJECT_DECL_SUBCLASS_INTERFACE(name, super) \
-		@interface OS_OBJECT_CLASS(name) : OS_OBJECT_CLASS(super) \
-		<OS_OBJECT_CLASS(name)> \
-		@end
-#else
-#define _OS_OBJECT_DECL_SUBCLASS_INTERFACE(name, super)
-#define _OS_OBJECT_DECL_PROTOCOL(name, super)
-#define _OS_OBJECT_CLASS_IMPLEMENTS_PROTOCOL(name, super)
-typedef struct _os_object_s *_os_object_t;
-#endif
-
-OS_ASSUME_NONNULL_BEGIN
-
-__BEGIN_DECLS
-
-#if !_OS_OBJECT_OBJC_ARC
-
-API_AVAILABLE(macos(10.8), ios(6.0))
-OS_OBJECT_EXPORT OS_OBJECT_MALLOC OS_OBJECT_WARN_RESULT OS_OBJECT_NOTHROW
-OS_SWIFT_UNAVAILABLE("Unavailable in Swift")
-_os_object_t
-_os_object_alloc(const void *cls, size_t size);
-
-API_AVAILABLE(macos(10.8), ios(6.0))
-OS_OBJECT_EXPORT OS_OBJECT_MALLOC OS_OBJECT_WARN_RESULT OS_OBJECT_NOTHROW
-OS_SWIFT_UNAVAILABLE("Unavailable in Swift")
-_os_object_t
-_os_object_alloc_realized(const void *cls, size_t size);
-
-API_AVAILABLE(macos(10.8), ios(6.0))
-OS_OBJECT_EXPORT OS_OBJECT_NONNULL OS_OBJECT_NOTHROW
-OS_SWIFT_UNAVAILABLE("Unavailable in Swift")
-void _os_object_dealloc(_os_object_t object);
-
-API_AVAILABLE(macos(10.8), ios(6.0))
-OS_OBJECT_EXPORT OS_OBJECT_NONNULL OS_OBJECT_NOTHROW
-OS_SWIFT_UNAVAILABLE("Unavailable in Swift")
-_os_object_t
-_os_object_retain(_os_object_t object);
-
-API_AVAILABLE(macos(10.8), ios(6.0))
-OS_OBJECT_EXPORT OS_OBJECT_NONNULL OS_OBJECT_NOTHROW
-OS_SWIFT_UNAVAILABLE("Unavailable in Swift")
-_os_object_t
-_os_object_retain_with_resurrect(_os_object_t obj);
-
-API_AVAILABLE(macos(10.8), ios(6.0))
-OS_OBJECT_EXPORT OS_OBJECT_NONNULL OS_OBJECT_NOTHROW
-OS_SWIFT_UNAVAILABLE("Unavailable in Swift")
-void
-_os_object_release(_os_object_t object);
-
-API_AVAILABLE(macos(10.8), ios(6.0))
-OS_OBJECT_EXPORT OS_OBJECT_NONNULL OS_OBJECT_NOTHROW
-OS_SWIFT_UNAVAILABLE("Unavailable in Swift")
-_os_object_t
-_os_object_retain_internal(_os_object_t object);
-
-API_AVAILABLE(macos(10.8), ios(6.0))
-OS_OBJECT_EXPORT OS_OBJECT_NONNULL OS_OBJECT_NOTHROW
-OS_SWIFT_UNAVAILABLE("Unavailable in Swift")
-void
-_os_object_release_internal(_os_object_t object);
-
-API_AVAILABLE(macos(10.13), ios(11.0), tvos(11.0), watchos(4.0))
-OS_OBJECT_EXPORT OS_OBJECT_NONNULL OS_OBJECT_NOTHROW
-OS_SWIFT_UNAVAILABLE("Unavailable in Swift")
-_os_object_t
-_os_object_retain_internal_n(_os_object_t object, uint16_t n);
-
-API_AVAILABLE(macos(10.13), ios(11.0), tvos(11.0), watchos(4.0))
-OS_OBJECT_EXPORT OS_OBJECT_NONNULL OS_OBJECT_NOTHROW
-OS_SWIFT_UNAVAILABLE("Unavailable in Swift")
-void
-_os_object_release_internal_n(_os_object_t object, uint16_t n);
-
-#endif // !_OS_OBJECT_OBJC_ARC
-
-__END_DECLS
-
-OS_ASSUME_NONNULL_END
-
-#endif
--- a/Telegram/ThirdParty/dispatch/os/voucher_activity_private.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/os/voucher_activity_private.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,373 +0,0 @@
-/*
- * Copyright (c) 2013-2015 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#ifndef __OS_VOUCHER_ACTIVITY_PRIVATE__
-#define __OS_VOUCHER_ACTIVITY_PRIVATE__
-
-#if OS_VOUCHER_ACTIVITY_SPI
-#if __has_include(<mach/mach_time.h>)
-#include <mach/mach_time.h>
-#include <firehose/tracepoint_private.h>
-#endif
-#if __APPLE__
-#include <os/base.h>
-#include <os/availability.h>
-#endif
-#include <sys/uio.h>
-#include <os/object.h>
-#include "voucher_private.h"
-
-#define OS_VOUCHER_ACTIVITY_SPI_VERSION 20161003
-
-#if OS_VOUCHER_WEAK_IMPORT
-#define OS_VOUCHER_EXPORT OS_EXPORT OS_WEAK_IMPORT
-#else
-#define OS_VOUCHER_EXPORT OS_EXPORT
-#endif
-
-__BEGIN_DECLS
-
-/*!
- * @const VOUCHER_CURRENT
- * Shorthand for the currently adopted voucher
- *
- * This value can only be used as an argument to functions, and is never
- * actually returned. It looks enough like a tagged pointer object that ARC
- * won't crash if this is assigned to a temporary variable.
- */
-#define VOUCHER_CURRENT		((OS_OBJECT_BRIDGE voucher_t)(void *)~2ul)
-
-/*!
- * @function voucher_get_activity_id
- *
- * @abstract
- * Returns the activity_id associated with the specified voucher at the time
- * of the call.
- *
- * @discussion
- * When the passed voucher is VOUCHER_CURRENT this returns the current
- * activity ID.
- *
- * @param voucher
- * The specified voucher.
- *
- * @param parent_id
- * An out parameter to return the parent ID of the returned activity ID.
- *
- * @result
- * The current activity identifier, if any. When 0 is returned, parent_id will
- * also always be 0.
- */
-API_AVAILABLE(macos(10.12), ios(10.0), tvos(10.0), watchos(3.0))
-OS_VOUCHER_EXPORT OS_NOTHROW
-firehose_activity_id_t
-voucher_get_activity_id(voucher_t voucher, firehose_activity_id_t *parent_id);
-
-/*!
- * @function voucher_get_activity_id_and_creator
- *
- * @abstract
- * Returns the activity_id associated with the specified voucher at the time
- * of the call.
- *
- * @discussion
- * When the passed voucher is VOUCHER_CURRENT this returns the current
- * activity ID.
- *
- * @param voucher
- * The specified voucher.
- *
- * @param creator_pid
- * The unique pid of the process that created the returned activity ID if any.
- *
- * @param parent_id
- * An out parameter to return the parent ID of the returned activity ID.
- *
- * @result
- * The current activity identifier, if any. When 0 is returned, parent_id will
- * also always be 0.
- */
-API_AVAILABLE(macos(10.12), ios(10.0), tvos(10.0), watchos(3.0))
-OS_VOUCHER_EXPORT OS_NOTHROW
-firehose_activity_id_t
-voucher_get_activity_id_and_creator(voucher_t voucher, uint64_t *creator_pid,
-		firehose_activity_id_t *parent_id);
-
-/*!
- * @function voucher_activity_create_with_data
- *
- * @abstract
- * Creates a voucher object with a new activity identifier.
- *
- * @discussion
- * As part of voucher transport, activities are automatically propagated by the
- * system to other threads and processes (across IPC).
- *
- * When a voucher with an activity identifier is applied to a thread, work
- * on that thread is done on behalf of this activity.
- *
- * @param trace_id
- * Tracepoint identifier returned by voucher_activity_trace_id(), intended for
- * identification of the automatic tracepoint generated as part of creating the
- * new activity.
- *
- * @param base
- * The base voucher used to create the activity. If the base voucher has an
- * activity identifier, then the created activity will be parented to that one.
- * If the passed in base has no activity identifier, the activity identifier
- * will be a top-level one, on behalf of the process that created the base
- * voucher.
- *
- * If base is VOUCHER_NONE, the activity is a top-level one, on behalf of the
- * current process.
- *
- * If base is VOUCHER_CURRENT, then the activity is naturally based on the
- * one currently applied to the current thread (the one voucher_copy() would
- * return).
- *
- * @param flags
- * See voucher_activity_flag_t documentation for effect.
- *
- * @param pubdata
- * Pointer to packed buffer of tracepoint data.
- *
- * @param publen
- * Length of data at 'pubdata'.
- *
- * @result
- * A new voucher with an activity identifier.
- */
-API_AVAILABLE(macos(10.12.4), ios(10.3), tvos(10.2), watchos(3.2))
-OS_VOUCHER_EXPORT OS_OBJECT_RETURNS_RETAINED OS_WARN_RESULT OS_NOTHROW
-voucher_t
-voucher_activity_create_with_data(firehose_tracepoint_id_t *trace_id,
-		voucher_t base, firehose_activity_flags_t flags,
-		const void *pubdata, size_t publen);
-
-API_DEPRECATED_WITH_REPLACEMENT("voucher_activity_create_with_data",
-		macos(10.12,10.12.4), ios(10.0,10.3), tvos(10.0,10.2), watchos(3.0,3.2))
-OS_VOUCHER_EXPORT OS_OBJECT_RETURNS_RETAINED OS_WARN_RESULT OS_NOTHROW
-voucher_t
-voucher_activity_create_with_location(firehose_tracepoint_id_t *trace_id,
-		voucher_t base, firehose_activity_flags_t flags, uint64_t location);
-
-/*!
- * @group Voucher Activity Trace SPI
- * SPI intended for libtrace only
- */
-
-/*!
- * @function voucher_activity_id_allocate
- *
- * @abstract
- * Allocate a new system-wide unique activity ID.
- *
- * @param flags
- * The bottom-most 8 bits of the flags will be used to generate the ID.
- * See firehose_activity_flags_t.
- */
-API_AVAILABLE(macos(10.13), ios(11.0), tvos(11.0), watchos(4.0))
-OS_VOUCHER_EXPORT OS_NOTHROW
-firehose_activity_id_t
-voucher_activity_id_allocate(firehose_activity_flags_t flags);
-
-/*!
- * @function voucher_activity_flush
- *
- * @abstract
- * Force flushing the specified stream.
- *
- * @discussion
- * This maks all the buffers currently being written to as full, so that
- * their current content is pushed in a timely fashion.
- *
- * When this call returns, the actual flush may or may not yet have happened.
- *
- * @param stream
- * The stream to flush.
- */
-API_AVAILABLE(macos(10.12), ios(10.0), tvos(10.0), watchos(3.0))
-OS_VOUCHER_EXPORT OS_NOTHROW
-void
-voucher_activity_flush(firehose_stream_t stream);
-
-/*!
- * @function voucher_activity_trace
- *
- * @abstract
- * Add a tracepoint to the specified stream.
- *
- * @param stream
- * The stream to trace this entry into.
- *
- * @param trace_id
- * Tracepoint identifier returned by voucher_activity_trace_id()
- *
- * @param timestamp
- * The mach_approximate_time()/mach_absolute_time() value for this tracepoint.
- *
- * @param pubdata
- * Pointer to packed buffer of tracepoint data.
- *
- * @param publen
- * Length of data at 'pubdata'.
- */
-API_AVAILABLE(macos(10.12), ios(10.0), tvos(10.0), watchos(3.0))
-OS_VOUCHER_EXPORT OS_NOTHROW OS_NONNULL4
-firehose_tracepoint_id_t
-voucher_activity_trace(firehose_stream_t stream,
-		firehose_tracepoint_id_t trace_id, uint64_t timestamp,
-		const void *pubdata, size_t publen);
-
-/*!
- * @function voucher_activity_trace_v
- *
- * @abstract
- * Add a tracepoint to the specified stream, with private data.
- *
- * @param stream
- * The stream to trace this entry into.
- *
- * @param trace_id
- * Tracepoint identifier returned by voucher_activity_trace_id()
- *
- * @param timestamp
- * The mach_approximate_time()/mach_absolute_time() value for this tracepoint.
- *
- * @param iov
- * Array of `struct iovec` pointing to the data to layout.
- * The total size of this iovec must span exactly `publen + privlen` bytes.
- * The `publen` boundary must coincide with the end of an iovec (each iovec
- * must either be pure public or pure private data).
- *
- * @param publen
- * Total length of data to read from the iovec for the public data.
- *
- * @param privlen
- * Length of data to read from the iovec after the public data for the private
- * data.
- */
-API_AVAILABLE(macos(10.12.4), ios(10.3), tvos(10.2), watchos(3.2))
-OS_VOUCHER_EXPORT OS_NOTHROW OS_NONNULL4
-firehose_tracepoint_id_t
-voucher_activity_trace_v(firehose_stream_t stream,
-		firehose_tracepoint_id_t trace_id, uint64_t timestamp,
-		const struct iovec *iov, size_t publen, size_t privlen);
-
-#define VOUCHER_ACTIVITY_TRACE_FLAG_UNRELIABLE 0x01
-
-API_AVAILABLE(macos(10.14), ios(12.0), tvos(12.0), watchos(5.0))
-OS_VOUCHER_EXPORT OS_NOTHROW OS_NONNULL4
-firehose_tracepoint_id_t
-voucher_activity_trace_v_2(firehose_stream_t stream,
-		firehose_tracepoint_id_t trace_id, uint64_t timestamp,
-		const struct iovec *iov, size_t publen, size_t privlen, uint32_t flags);
-
-typedef const struct voucher_activity_hooks_s {
-#define VOUCHER_ACTIVITY_HOOKS_VERSION     5
-	long vah_version;
-	mach_port_t (*vah_get_logd_port)(void);
-	dispatch_mach_handler_function_t vah_debug_channel_handler;
-	kern_return_t (*vah_get_reconnect_info)(mach_vm_address_t *, mach_vm_size_t *);
-	void (*vah_metadata_init)(void *metadata_buffer, size_t size);
-	void (*vah_quarantine_starts)(void);
-} *voucher_activity_hooks_t;
-
-/*!
- * @function voucher_activity_initialize_4libtrace
- *
- * @abstract
- * Configure upcall hooks for libtrace.
- *
- * @param hooks
- * A pointer to a voucher_activity_hooks_s structure.
- */
-API_AVAILABLE(macos(10.12), ios(10.0), tvos(10.0), watchos(3.0))
-OS_VOUCHER_EXPORT OS_NOTHROW OS_NONNULL_ALL
-void
-voucher_activity_initialize_4libtrace(voucher_activity_hooks_t hooks);
-
-/*!
- * @function voucher_activity_get_metadata_buffer
- *
- * @abstract
- * Return address and length of buffer in the process trace memory area
- * reserved for libtrace metadata.
- *
- * @param length
- * Pointer to size_t variable, filled with length of metadata buffer.
- *
- * @result
- * Address of metadata buffer.
- */
-API_AVAILABLE(macos(10.10), ios(8.0))
-OS_VOUCHER_EXPORT OS_WARN_RESULT OS_NOTHROW OS_NONNULL_ALL
-void *
-voucher_activity_get_metadata_buffer(size_t *length);
-
-/*!
- * @function voucher_activity_get_logging_preferences
- *
- * @abstract
- * Return address and length of vm_map()ed configuration data for the logging
- * subsystem.
- *
- * @discussion
- * The data must be deallocated with vm_deallocate().
- *
- * @param length
- * Pointer to size_t variable, filled with length of preferences buffer.
- *
- * @result
- * Address of preferences buffer, returns NULL on error.
- */
-API_AVAILABLE(macos(10.14), ios(12.0), tvos(12.0), watchos(5.0), bridgeos(3.0))
-OS_VOUCHER_EXPORT OS_WARN_RESULT OS_NOTHROW OS_NONNULL_ALL
-void *
-voucher_activity_get_logging_preferences(size_t *length);
-
-/*!
- * @function voucher_activity_should_send_strings
- *
- * @abstract
- * Returns whether the client should send the strings or not.
- */
-API_AVAILABLE(macos(10.14), ios(12.0), tvos(12.0), watchos(5.0), bridgeos(4.0))
-OS_VOUCHER_EXPORT OS_WARN_RESULT OS_NOTHROW
-bool
-voucher_activity_should_send_strings(void);
-
-/*!
- * @function voucher_get_activity_id_4dyld
- *
- * @abstract
- * Return the current voucher activity ID. Available for the dyld client stub
- * only.
- */
-API_AVAILABLE(macos(10.12), ios(10.0), tvos(10.0), watchos(3.0))
-OS_VOUCHER_EXPORT OS_WARN_RESULT OS_NOTHROW
-firehose_activity_id_t
-voucher_get_activity_id_4dyld(void);
-
-__END_DECLS
-
-#endif // OS_VOUCHER_ACTIVITY_SPI
-
-#endif // __OS_VOUCHER_ACTIVITY_PRIVATE__
--- a/Telegram/ThirdParty/dispatch/os/voucher_private.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/os/voucher_private.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,641 +0,0 @@
-/*
- * Copyright (c) 2013-2014 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#ifndef __OS_VOUCHER_PRIVATE__
-#define __OS_VOUCHER_PRIVATE__
-
-#if __APPLE__
-#include <os/base.h>
-#include <os/availability.h>
-#endif
-#if __has_include(<mach/mach.h>)
-#include <os/object.h>
-#include <mach/mach.h>
-#endif
-#if __has_include(<bank/bank_types.h>)
-#include <bank/bank_types.h>
-#endif
-#if __has_include(<sys/persona.h>)
-#include <sys/persona.h>
-#endif
-
-#ifndef __DISPATCH_BUILDING_DISPATCH__
-#include <dispatch/dispatch.h>
-#endif /* !__DISPATCH_BUILDING_DISPATCH__ */
-
-#define OS_VOUCHER_SPI_VERSION 20150630
-
-#if OS_VOUCHER_WEAK_IMPORT
-#define OS_VOUCHER_EXPORT OS_EXPORT OS_WEAK_IMPORT
-#else
-#define OS_VOUCHER_EXPORT OS_EXPORT
-#endif
-
-DISPATCH_ASSUME_NONNULL_BEGIN
-
-__BEGIN_DECLS
-
-/*!
- * @group Voucher Transport SPI
- * SPI intended for clients that need to transport vouchers.
- */
-
-/*!
- * @typedef voucher_t
- *
- * @abstract
- * Vouchers are immutable sets of key/value attributes that can be adopted on a
- * thread in the current process or sent to another process.
- *
- * @discussion
- * Voucher objects are os_objects (c.f. <os/object.h>). They are memory-managed
- * with the os_retain()/os_release() functions or -[retain]/-[release] methods.
- */
-OS_OBJECT_DECL_CLASS(voucher);
-
-/*!
- * @const VOUCHER_NULL
- * Represents the empty base voucher with no attributes.
- */
-#define VOUCHER_NULL		((voucher_t)0)
-/*!
- * @const VOUCHER_INVALID
- * Represents an invalid voucher
- */
-#define VOUCHER_INVALID		((voucher_t)-1)
-
-/*!
- * @function voucher_adopt
- *
- * @abstract
- * Adopt the specified voucher on the current thread and return the voucher
- * that had been adopted previously.
- *
- * @discussion
- * Adopted vouchers are automatically carried forward by the system to other
- * threads and processes (across IPC).
- *
- * Consumes a reference to the specified voucher.
- * Returns a reference to the previous voucher.
- *
- * @param voucher
- * The voucher object to adopt on the current thread.
- *
- * @result
- * The previously adopted voucher object.
- */
-API_AVAILABLE(macos(10.10), ios(8.0))
-OS_VOUCHER_EXPORT OS_OBJECT_RETURNS_RETAINED OS_WARN_RESULT_NEEDS_RELEASE
-OS_NOTHROW
-voucher_t _Nullable
-voucher_adopt(voucher_t _Nullable voucher OS_OBJECT_CONSUMED);
-
-/*!
- * @function voucher_copy
- *
- * @abstract
- * Returns a reference to the voucher that had been adopted previously on the
- * current thread (or carried forward by the system).
- *
- * @result
- * The currently adopted voucher object.
- */
-API_AVAILABLE(macos(10.10), ios(8.0))
-OS_VOUCHER_EXPORT OS_OBJECT_RETURNS_RETAINED OS_WARN_RESULT OS_NOTHROW
-voucher_t _Nullable
-voucher_copy(void);
-
-/*!
- * @function voucher_copy_without_importance
- *
- * @abstract
- * Returns a reference to a voucher object with all the properties of the
- * voucher that had been adopted previously on the current thread, but
- * without the importance properties that are frequently attached to vouchers
- * carried with IPC requests. Importance properties may elevate the scheduling
- * of threads that adopt or retain the voucher while they service the request.
- * See xpc_transaction_begin(3) for further details on importance.
- *
- * @result
- * A copy of the currently adopted voucher object, with importance removed.
- */
-API_AVAILABLE(macos(10.10), ios(8.0))
-OS_VOUCHER_EXPORT OS_OBJECT_RETURNS_RETAINED OS_WARN_RESULT OS_NOTHROW
-voucher_t _Nullable
-voucher_copy_without_importance(void);
-
-/*!
- * @function voucher_replace_default_voucher
- *
- * @abstract
- * Replace process attributes of default voucher (used for IPC by this process
- * when no voucher is adopted on the sending thread) with the process attributes
- * of the voucher adopted on the current thread.
- *
- * @discussion
- * This allows a daemon to indicate from the context of an incoming IPC request
- * that all future outgoing IPC from the process should be marked as acting
- * "on behalf of" the sending process of the current IPC request (as long as the
- * thread sending that outgoing IPC is not itself in the direct context of an
- * IPC request, i.e. no voucher is adopted).
- *
- * If no voucher is adopted on the current thread or the current voucher does
- * not contain any process attributes, the default voucher is reset to the
- * default process attributes for the current process.
- *
- * CAUTION: Do NOT use this SPI without contacting the Darwin Runtime team.
- */
-API_AVAILABLE(macos(10.10), ios(8.0))
-OS_VOUCHER_EXPORT OS_NOTHROW
-void
-voucher_replace_default_voucher(void);
-
-/*!
- * @function voucher_decrement_importance_count4CF
- *
- * @abstract
- * Decrement external importance count of the mach voucher in the specified
- * voucher object.
- *
- * @discussion
- * This is only intended for use by CoreFoundation to explicitly manage the
- * App Nap state of an application following reception of a de-nap IPC message.
- *
- * CAUTION: Do NOT use this SPI without contacting the Darwin Runtime team.
- */
-API_AVAILABLE(macos(10.10), ios(8.0))
-OS_VOUCHER_EXPORT OS_NOTHROW
-void
-voucher_decrement_importance_count4CF(voucher_t _Nullable voucher);
-
-/*!
- * @group Voucher dispatch block SPI
- */
-
-/*!
- * @typedef dispatch_block_flags_t
- * SPI Flags to pass to the dispatch_block_create* functions.
- *
- * @const DISPATCH_BLOCK_NO_VOUCHER
- * Flag indicating that a dispatch block object should not be assigned a voucher
- * object. If invoked directly, the block object will be executed with the
- * voucher adopted on the calling thread. If the block object is submitted to a
- * queue, this replaces the default behavior of associating the submitted block
- * instance with the voucher adopted at the time of submission.
- * This flag is ignored if used with the dispatch_block_create_with_voucher*()
- * functions.
- *
- */
-#define DISPATCH_BLOCK_NO_VOUCHER (0x40ul)
-
-#define DISPATCH_BLOCK_IF_LAST_RESET_QUEUE_QOS_OVERRIDE (0x80ul)
-
-/*!
- * @function dispatch_block_create_with_voucher
- *
- * @abstract
- * Create a new dispatch block object on the heap from an existing block and
- * the given flags, and assign it the specified voucher object.
- *
- * @discussion
- * The provided block is Block_copy'ed to the heap, it and the specified voucher
- * object are retained by the newly created dispatch block object.
- *
- * The returned dispatch block object is intended to be submitted to a dispatch
- * queue with dispatch_async() and related functions, but may also be invoked
- * directly. Both operations can be performed an arbitrary number of times but
- * only the first completed execution of a dispatch block object can be waited
- * on with dispatch_block_wait() or observed with dispatch_block_notify().
- *
- * The returned dispatch block will be executed with the specified voucher
- * adopted for the duration of the block body.
- *
- * If the returned dispatch block object is submitted to a dispatch queue, the
- * submitted block instance will be associated with the QOS class current at the
- * time of submission, unless one of the following flags assigned a specific QOS
- * class (or no QOS class) at the time of block creation:
- *  - DISPATCH_BLOCK_ASSIGN_CURRENT
- *  - DISPATCH_BLOCK_NO_QOS_CLASS
- *  - DISPATCH_BLOCK_DETACHED
- * The QOS class the block object will be executed with also depends on the QOS
- * class assigned to the queue and which of the following flags was specified or
- * defaulted to:
- *  - DISPATCH_BLOCK_INHERIT_QOS_CLASS (default for asynchronous execution)
- *  - DISPATCH_BLOCK_ENFORCE_QOS_CLASS (default for synchronous execution)
- * See description of dispatch_block_flags_t for details.
- *
- * If the returned dispatch block object is submitted directly to a serial queue
- * and is configured to execute with a specific QOS class, the system will make
- * a best effort to apply the necessary QOS overrides to ensure that blocks
- * submitted earlier to the serial queue are executed at that same QOS class or
- * higher.
- *
- * @param flags
- * Configuration flags for the block object.
- * Passing a value that is not a bitwise OR of flags from dispatch_block_flags_t
- * results in NULL being returned. The DISPATCH_BLOCK_NO_VOUCHER flag is
- * ignored.
- *
- * @param voucher
- * A voucher object or NULL.
- *
- * @param block
- * The block to create the dispatch block object from.
- *
- * @result
- * The newly created dispatch block object, or NULL.
- * When not building with Objective-C ARC, must be released with a -[release]
- * message or the Block_release() function.
- */
-API_AVAILABLE(macos(10.10), ios(8.0))
-DISPATCH_EXPORT DISPATCH_NONNULL3 DISPATCH_RETURNS_RETAINED_BLOCK
-DISPATCH_WARN_RESULT DISPATCH_NOTHROW
-dispatch_block_t
-dispatch_block_create_with_voucher(dispatch_block_flags_t flags,
-		voucher_t _Nullable voucher, dispatch_block_t block);
-
-/*!
- * @function dispatch_block_create_with_voucher_and_qos_class
- *
- * @abstract
- * Create a new dispatch block object on the heap from an existing block and
- * the given flags, and assign it the specified voucher object, QOS class and
- * relative priority.
- *
- * @discussion
- * The provided block is Block_copy'ed to the heap, it and the specified voucher
- * object are retained by the newly created dispatch block object.
- *
- * The returned dispatch block object is intended to be submitted to a dispatch
- * queue with dispatch_async() and related functions, but may also be invoked
- * directly. Both operations can be performed an arbitrary number of times but
- * only the first completed execution of a dispatch block object can be waited
- * on with dispatch_block_wait() or observed with dispatch_block_notify().
- *
- * The returned dispatch block will be executed with the specified voucher
- * adopted for the duration of the block body.
- *
- * If invoked directly, the returned dispatch block object will be executed with
- * the assigned QOS class as long as that does not result in a lower QOS class
- * than what is current on the calling thread.
- *
- * If the returned dispatch block object is submitted to a dispatch queue, the
- * QOS class it will be executed with depends on the QOS class assigned to the
- * block, the QOS class assigned to the queue and which of the following flags
- * was specified or defaulted to:
- *  - DISPATCH_BLOCK_INHERIT_QOS_CLASS: default for asynchronous execution
- *  - DISPATCH_BLOCK_ENFORCE_QOS_CLASS: default for synchronous execution
- * See description of dispatch_block_flags_t for details.
- *
- * If the returned dispatch block object is submitted directly to a serial queue
- * and is configured to execute with a specific QOS class, the system will make
- * a best effort to apply the necessary QOS overrides to ensure that blocks
- * submitted earlier to the serial queue are executed at that same QOS class or
- * higher.
- *
- * @param flags
- * Configuration flags for the block object.
- * Passing a value that is not a bitwise OR of flags from dispatch_block_flags_t
- * results in NULL being returned. The DISPATCH_BLOCK_NO_VOUCHER and
- * DISPATCH_BLOCK_NO_QOS flags are ignored.
- *
- * @param voucher
- * A voucher object or NULL.
- *
- * @param qos_class
- * A QOS class value:
- *  - QOS_CLASS_USER_INTERACTIVE
- *  - QOS_CLASS_USER_INITIATED
- *  - QOS_CLASS_DEFAULT
- *  - QOS_CLASS_UTILITY
- *  - QOS_CLASS_BACKGROUND
- *  - QOS_CLASS_UNSPECIFIED
- * Passing QOS_CLASS_UNSPECIFIED is equivalent to specifying the
- * DISPATCH_BLOCK_NO_QOS_CLASS flag. Passing any other value results in NULL
- * being returned.
- *
- * @param relative_priority
- * A relative priority within the QOS class. This value is a negative
- * offset from the maximum supported scheduler priority for the given class.
- * Passing a value greater than zero or less than QOS_MIN_RELATIVE_PRIORITY
- * results in NULL being returned.
- *
- * @param block
- * The block to create the dispatch block object from.
- *
- * @result
- * The newly created dispatch block object, or NULL.
- * When not building with Objective-C ARC, must be released with a -[release]
- * message or the Block_release() function.
- */
-API_AVAILABLE(macos(10.10), ios(8.0))
-DISPATCH_EXPORT DISPATCH_NONNULL5 DISPATCH_RETURNS_RETAINED_BLOCK
-DISPATCH_WARN_RESULT DISPATCH_NOTHROW
-dispatch_block_t
-dispatch_block_create_with_voucher_and_qos_class(dispatch_block_flags_t flags,
-		voucher_t _Nullable voucher, dispatch_qos_class_t qos_class,
-		int relative_priority, dispatch_block_t block);
-
-/*!
- * @group Voucher dispatch queue SPI
- */
-
-/*!
- * @function dispatch_queue_create_with_accounting_override_voucher
- *
- * @abstract
- * Deprecated, do not use, will abort process if called.
- */
-API_DEPRECATED("removed SPI", \
-		macos(10.11,10.13), ios(9.0,11.0), watchos(2.0,4.0), tvos(9.0,11.0))
-DISPATCH_EXPORT DISPATCH_MALLOC DISPATCH_RETURNS_RETAINED DISPATCH_WARN_RESULT
-DISPATCH_NOTHROW
-dispatch_queue_t
-dispatch_queue_create_with_accounting_override_voucher(
-		const char *_Nullable label,
-		dispatch_queue_attr_t _Nullable attr,
-		voucher_t _Nullable voucher);
-
-#if __has_include(<mach/mach.h>)
-/*!
- * @group Voucher Mach SPI
- * SPI intended for clients that need to interact with mach messages or mach
- * voucher ports directly.
- */
-
-/*!
- * @function voucher_create_with_mach_msg
- *
- * @abstract
- * Creates a new voucher object from a mach message carrying a mach voucher port
- *
- * @discussion
- * Ownership of the mach voucher port in the message is transfered to the new
- * voucher object and the message header mach voucher field is cleared.
- *
- * @param msg
- * The mach message to query.
- *
- * @result
- * The newly created voucher object or NULL if the message was not carrying a
- * mach voucher.
- */
-API_AVAILABLE(macos(10.10), ios(8.0))
-OS_VOUCHER_EXPORT OS_OBJECT_RETURNS_RETAINED OS_WARN_RESULT OS_NOTHROW
-voucher_t _Nullable
-voucher_create_with_mach_msg(mach_msg_header_t *msg);
-
-/*!
- * @function voucher_kvoucher_debug
- *
- * @abstract
- * Writes a human-readable representation of a voucher to a memory buffer.
- *
- * @discussion
- * The formatted representation of the voucher is written starting at a given
- * offset in the buffer. If the remaining space in the buffer is too small, the
- * output is truncated. Nothing is written before buf[offset] or at or beyond
- * buf[bufsize].
- *
- * @param task
- * The task port for the task that owns the voucher port.
- *
- * @param voucher
- * The voucher port name.
- *
- * @param buf
- * The buffer to which the formatted representation of the voucher should be
- * written.
- *
- * @param bufsiz
- * The size of the buffer.
- *
- * @param offset
- * The offset of the first byte in the buffer to be used for output.
- *
- * @param prefix
- * A string to be written at the start of each line of formatted output.
- * Typically used to generate leading whitespace for indentation. Use NULL if
- * no prefix is required.
- *
- * @param max_hex_data
- * The maximum number of bytes of hex data to be formatted for voucher content
- * that is not of type MACH_VOUCHER_ATTR_KEY_ATM, MACH_VOUCHER_ATTR_KEY_BANK
- * or MACH_VOUCHER_ATTR_KEY_IMPORTANCE.
- *
- * @result
- * The offset of the first byte in the buffer following the formatted voucher
- * representation.
- */
-API_AVAILABLE(macos(10.14), ios(12.0), tvos(12.0), watchos(5.0))
-OS_VOUCHER_EXPORT OS_WARN_RESULT OS_NOTHROW DISPATCH_COLD
-size_t
-voucher_kvoucher_debug(mach_port_t task, mach_port_name_t voucher, char *buf,
-		   size_t bufsiz, size_t offset, char * _Nullable prefix,
-		   size_t max_hex_data) ;
-
-/*!
- * @group Voucher Persona SPI
- * SPI intended for clients that need to interact with personas.
- */
-
-struct proc_persona_info;
-
-/*!
- * @function voucher_get_current_persona
- *
- * @abstract
- * Returns the persona identifier for the current thread.
- *
- * @discussion
- * Retrieve the persona identifier from the currently adopted voucher.
- *
- * If the thread has not adopted a voucher, or the current voucher does not
- * contain persona information, this function returns the persona identifier
- * of the current process.
- *
- * If the process is not running under a persona, then this returns
- * PERSONA_ID_NONE.
- *
- * @result
- * The persona identifier for the current voucher,
- * or the persona identifier of the current process
- * or PERSONA_ID_NONE
- */
-API_AVAILABLE(macos(10.14), ios(9.2))
-OS_VOUCHER_EXPORT OS_WARN_RESULT OS_NOTHROW
-uid_t
-voucher_get_current_persona(void);
-
-/*!
- * @function voucher_get_current_persona_originator_info
- *
- * @abstract
- * Retrieve the ’originator’ process persona info for the currently adopted
- * voucher.
- *
- * @discussion
- * If there is no currently adopted voucher, or no PERSONA_TOKEN attribute
- * in that voucher, this function fails.
- *
- * @param persona_info
- * The proc_persona_info structure to fill in case of success
- *
- * @result
- * 0 on success: currently adopted voucher has a PERSONA_TOKEN
- * -1 on failure: persona_info is untouched/uninitialized
- */
-API_AVAILABLE(macos(10.14), ios(9.2))
-OS_VOUCHER_EXPORT OS_WARN_RESULT OS_NOTHROW OS_NONNULL1
-int
-voucher_get_current_persona_originator_info(
-	struct proc_persona_info *persona_info);
-
-/*!
- * @function voucher_get_current_persona_proximate_info
- *
- * @abstract
- * Retrieve the ’proximate’ process persona info for the currently adopted
- * voucher.
- *
- * @discussion
- * If there is no currently adopted voucher, or no PERSONA_TOKEN attribute
- * in that voucher, this function fails.
- *
- * @param persona_info
- * The proc_persona_info structure to fill in case of success
- *
- * @result
- * 0 on success: currently adopted voucher has a PERSONA_TOKEN
- * -1 on failure: persona_info is untouched/uninitialized
- */
-API_AVAILABLE(macos(10.14), ios(9.2))
-OS_VOUCHER_EXPORT OS_WARN_RESULT OS_NOTHROW OS_NONNULL1
-int
-voucher_get_current_persona_proximate_info(
-	struct proc_persona_info *persona_info);
-
-/*!
- * @function voucher_copy_with_persona_mach_voucher
- *
- * @abstract
- * Creates a copy of the currently adopted voucher and replaces its
- * persona information with the one passed in the specified mach voucher
- *
- * @discussion
- * If the specified mach voucher is not one returned from
- * mach_voucher_persona_for_originator() (called on behalf
- * of the current process), this function will fail
- *
- * @param persona_mach_voucher
- * mach voucher containing the new persona information
- *
- * @result
- * On success, a copy of the current voucher with the new
- * persona information
- * On failure, VOUCHER_INVALID
- */
-API_AVAILABLE(macos(10.14), ios(12))
-OS_VOUCHER_EXPORT OS_OBJECT_RETURNS_RETAINED OS_WARN_RESULT OS_NOTHROW
-voucher_t _Nullable
-voucher_copy_with_persona_mach_voucher(
-	mach_voucher_t persona_mach_voucher);
-
-/*!
- * @function mach_voucher_persona_self
- *
- * @abstract
- * Creates a mach voucher containing the persona information of the
- * current process that can be sent as a mach port descriptor in a message
- *
- * @discussion
- * The returned mach voucher has been pre-processed so that it can be sent
- * in a message
- *
- * @param persona_mach_voucher
- * If successful, a reference to the newly created mach voucher
- *
- * @result
- * KERN_SUCCESS: a mach voucher ready to be sent in a message is
- * successfully created
- * KERN_RESOURCE_SHORTAGE: mach voucher creation failed due to
- * lack of free space
- */
-API_AVAILABLE(macos(10.14), ios(12))
-OS_VOUCHER_EXPORT OS_WARN_RESULT OS_NOTHROW OS_NONNULL1
-kern_return_t
-mach_voucher_persona_self(mach_voucher_t *persona_mach_voucher);
-
-/*!
- * @function mach_voucher_persona_for_originator
- *
- * @abstract
- * Creates a mach voucher on behalf of the originator process by copying
- * the persona information from the specified mach voucher and then
- * updating the persona identifier to the specified value
- *
- * @discussion
- * Should be called by a privileged process on behalf of the originator process.
- * The newly created mach voucher should be returned to the originator in a
- * message. The originator's thread can adopt the new persona by passing
- * this mach voucher to voucher_copy_with_persona_mach_voucher().
- *
- * @param persona_id
- * The new persona identifier to be set in the mach voucher
- *
- * @param originator_persona_mach_voucher
- * A mach voucher received from the originator, where it was created using
- * mach_voucher_persona_self()
- *
- * @param originator_unique_pid
- * Unique pid of the originator process
- *
- * @param persona_mach_voucher
- * If successful, a reference to the newly created mach voucher
- *
- * @result
- * KERN_SUCCESS: a mach voucher ready to be returned to the
- * originator was successfully created
- * KERN_NO_ACCESS: process does not have privilege to carry
- * out this operation
- * KERN_INVALID_ARGUMENT: specified persona identifier is invalid
- * KERN_INVALID_CAPABILITY: originator_unique_pid does not
- * match the specified voucher originator's unique pid
- * KERN_RESOURCE_SHORTAGE: mach voucher creation failed due to
- * lack of free space
- */
-API_AVAILABLE(macos(10.14), ios(12))
-OS_VOUCHER_EXPORT OS_WARN_RESULT OS_NOTHROW OS_NONNULL4
-kern_return_t
-mach_voucher_persona_for_originator(uid_t persona_id,
-	mach_voucher_t originator_persona_mach_voucher,
-	uint64_t originator_unique_pid, mach_voucher_t *persona_mach_voucher);
-
-#endif // __has_include(<mach/mach.h>)
-
-__END_DECLS
-
-DISPATCH_ASSUME_NONNULL_END
-
-#endif // __OS_VOUCHER_PRIVATE__
-
-#if OS_VOUCHER_ACTIVITY_SPI
-#include "voucher_activity_private.h"
-#endif
--- a/Telegram/ThirdParty/dispatch/PATCHES	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/PATCHES	1970-01-01 00:00:00.000000000 -0000
@@ -1,436 +0,0 @@
-The libdispatch project exists in a parallel open source repository at:
-  http://github.com/apple/swift-corelibs-libdispatch
-
-Externally contributed changes are synchronized back to the internal repository
-via pull request of the result of `git am` of the contributed patch series.
-
-Internal changes are synchronized from the internal darwin/trunk branch to the
-external repository via `gi am` on the github darwin/trunk branch and merge to
-github master.
-
-Key:
-  APPLIED: change set was applied to internal repository.
-  INTERNAL: change set originated internally (i.e. already applied).
-  SKIPPED: change set was skipped.
-
-svn revisions until r218 from legacy open source repository at
-  http://svn.macosforge.org/repository/libdispatch/trunk
-
-[   1] SKIPPED
-[   2] SKIPPED
-[   3] INTERNAL rdar://problem/7148356
-[   4] APPLIED rdar://problem/7323245
-[   5] APPLIED rdar://problem/7323245
-[   6] APPLIED rdar://problem/7323245
-[   7] APPLIED rdar://problem/7323245
-[   8] APPLIED rdar://problem/7323245
-[   9] APPLIED rdar://problem/7323245
-[  10] APPLIED rdar://problem/7323245
-[  11] APPLIED rdar://problem/7323245
-[  12] APPLIED rdar://problem/7323245
-[  13] SKIPPED
-[  14] APPLIED rdar://problem/7323245
-[  15] APPLIED rdar://problem/7323245
-[  16] APPLIED rdar://problem/7323245
-[  17] APPLIED rdar://problem/7323245
-[  18] APPLIED rdar://problem/7323245
-[  19] APPLIED rdar://problem/7323245
-[  20] APPLIED rdar://problem/7323245
-[  21] APPLIED rdar://problem/7323245
-[  22] APPLIED rdar://problem/7323245
-[  23] APPLIED rdar://problem/7323245
-[  24] APPLIED rdar://problem/7323245
-[  25] APPLIED rdar://problem/7323245
-[  26] APPLIED rdar://problem/7323245
-[  27] APPLIED rdar://problem/7323245
-[  28] APPLIED rdar://problem/7323245
-[  29] APPLIED rdar://problem/7323245
-[  30] SKIPPED
-[  31] APPLIED rdar://problem/7323245
-[  32] APPLIED rdar://problem/7323245
-[  33] APPLIED rdar://problem/7323245
-[  34] APPLIED rdar://problem/7323245
-[  35] SKIPPED
-[  36] APPLIED rdar://problem/7323245
-[  37] APPLIED rdar://problem/7323245
-[  38] APPLIED rdar://problem/7323245
-[  39] APPLIED rdar://problem/7323245
-[  40] APPLIED rdar://problem/7323245
-[  41] APPLIED rdar://problem/7323245
-[  42] APPLIED rdar://problem/7323245
-[  43] APPLIED rdar://problem/7323245
-[  44] APPLIED rdar://problem/7323245
-[  45] APPLIED rdar://problem/7323245
-[  46] APPLIED rdar://problem/7323245
-[  47] APPLIED rdar://problem/7323245
-[  48] APPLIED rdar://problem/7323245
-[  49] APPLIED rdar://problem/7323245
-[  50] APPLIED rdar://problem/7323245
-[  51] APPLIED rdar://problem/7323245
-[  52] APPLIED rdar://problem/7323245
-[  53] APPLIED rdar://problem/7323245
-[  54] APPLIED rdar://problem/7323245
-[  55] APPLIED rdar://problem/7323245
-[  56] APPLIED rdar://problem/7323245
-[  57] APPLIED rdar://problem/7323245
-[  58] APPLIED rdar://problem/7323245
-[  59] APPLIED rdar://problem/7323245
-[  60] APPLIED rdar://problem/7323245
-[  61] APPLIED rdar://problem/7323245
-[  62] APPLIED rdar://problem/7323245
-[  63] APPLIED rdar://problem/7323245
-[  64] APPLIED rdar://problem/7323245
-[  65] APPLIED rdar://problem/7323245
-[  66] APPLIED rdar://problem/7323245
-[  67] APPLIED rdar://problem/7323245
-[  68] APPLIED rdar://problem/7323245
-[  69] APPLIED rdar://problem/7323245
-[  70] APPLIED rdar://problem/7323245
-[  71] INTERNAL
-[  72] INTERNAL
-[  73] APPLIED rdar://problem/7531526
-[  74] APPLIED rdar://problem/7531526
-[  75]
-[  76]
-[  77]
-[  78]
-[  79] APPLIED rdar://problem/7531526
-[  80] APPLIED rdar://problem/7531526
-[  81] APPLIED rdar://problem/7531526
-[  82] APPLIED rdar://problem/7531526
-[  83] APPLIED rdar://problem/7531526
-[  84] APPLIED rdar://problem/7531526
-[  85]
-[  86]
-[  87] APPLIED rdar://problem/7531526
-[  88] APPLIED rdar://problem/7531526
-[  89] APPLIED rdar://problem/7531526
-[  90]
-[  91]
-[  92]
-[  93]
-[  94]
-[  95]
-[  96] APPLIED rdar://problem/7531526
-[  97] APPLIED rdar://problem/7531526
-[  98]
-[  99]
-[ 100]
-[ 101]
-[ 102]
-[ 103] APPLIED rdar://problem/7531526
-[ 104] APPLIED rdar://problem/7531526
-[ 105]
-[ 106] APPLIED rdar://problem/7531526
-[ 107] SKIPPED
-[ 108] SKIPPED
-[ 109] SKIPPED
-[ 110] SKIPPED
-[ 111] SKIPPED
-[ 112] APPLIED rdar://problem/7531526
-[ 113] SKIPPED
-[ 114] APPLIED rdar://problem/7531526
-[ 115] APPLIED rdar://problem/7531526
-[ 116] APPLIED rdar://problem/7531526
-[ 117] SKIPPED
-[ 118] APPLIED rdar://problem/7531526
-[ 119] SKIPPED
-[ 120] APPLIED rdar://problem/7531526
-[ 121] SKIPPED
-[ 122] SKIPPED
-[ 123] SKIPPED
-[ 124] SKIPPED
-[ 125] APPLIED rdar://problem/7531526
-[ 126] SKIPPED
-[ 127] APPLIED rdar://problem/7531526
-[ 128]
-[ 129]
-[ 130]
-[ 131]
-[ 132]
-[ 133]
-[ 134]
-[ 135]
-[ 136]
-[ 137] APPLIED rdar://problem/7647055
-[ 138] SKIPPED
-[ 139] APPLIED rdar://problem/7531526
-[ 140] APPLIED rdar://problem/7531526
-[ 141] APPLIED rdar://problem/7531526
-[ 142] APPLIED rdar://problem/7531526
-[ 143]
-[ 144] APPLIED rdar://problem/7531526
-[ 145] APPLIED rdar://problem/7531526
-[ 146] APPLIED rdar://problem/7531526
-[ 147]
-[ 148]
-[ 149]
-[ 150]
-[ 151] APPLIED rdar://problem/7531526
-[ 152] APPLIED rdar://problem/7531526
-[ 153]
-[ 154] APPLIED rdar://problem/7531526
-[ 155]
-[ 156]
-[ 157] APPLIED rdar://problem/7531526
-[ 158]
-[ 159]
-[ 160]
-[ 161]
-[ 162] APPLIED rdar://problem/7531526
-[ 163] APPLIED rdar://problem/7531526
-[ 164]
-[ 165]
-[ 166] APPLIED rdar://problem/7531526
-[ 167] APPLIED rdar://problem/7531526
-[ 168]
-[ 169] APPLIED rdar://problem/7531526
-[ 170] APPLIED rdar://problem/7531526
-[ 171] APPLIED rdar://problem/7531526
-[ 172] APPLIED rdar://problem/7531526
-[ 173] APPLIED rdar://problem/7531526
-[ 174] APPLIED rdar://problem/7531526
-[ 175] APPLIED rdar://problem/7531526
-[ 176] APPLIED rdar://problem/7531526
-[ 177] APPLIED rdar://problem/7531526
-[ 178]
-[ 179] APPLIED rdar://problem/7531526
-[ 180] APPLIED rdar://problem/7531526
-[ 181]
-[ 182]
-[ 183] INTERNAL rdar://problem/7581831
-[ 202] INTERNAL libdispatch-187.5
-[ 212] INTERNAL libdispatch-228.18
-[ 213] INTERNAL rdar://problem/11754320
-[ 216] INTERNAL libdispatch-339.1.9
-[ 217] INTERNAL libdispatch-442.1.4
-[ 218] INTERNAL libdispatch-500.1.5
-
-github commits starting with 29bdc2f from
-
-  http://github.com/apple/swift-corelibs-libdispatch
-
-[29bdc2f] INTERNAL libdispatch-500.1.5
-[a60acd6] APPLIED rdar://23661056
-[39ac720] APPLIED rdar://23705483
-[acd56f6] APPLIED rdar://23754944
-[394d9a1] APPLIED rdar://23772602
-[3691f26] APPLIED rdar://23868354
-[8904f45] APPLIED rdar://23868354
-[6dbebd6] APPLIED rdar://23868354
-[b2ccfeb] APPLIED rdar://23868354
-[e7ca00f] APPLIED rdar://23868354
-[35eb408] APPLIED rdar://25159995
-[32411c2] APPLIED rdar://25159995
-[31586d5] APPLIED rdar://25159995
-[50faff5] APPLIED rdar://25159995
-[3ce4e3d] APPLIED rdar://25159995
-[b647aee] APPLIED rdar://25159995
-[ab7e16c] APPLIED rdar://25159995
-[cef2960] APPLIED rdar://25159995
-[dfa43cd] APPLIED rdar://25159995
-[8b9c3a9] APPLIED rdar://25159995
-[fefb6cf] APPLIED rdar://25159995
-[1a9c57f] APPLIED rdar://25159995
-[c04488a] APPLIED rdar://25159995
-[f1d58d1] APPLIED rdar://25159995
-[be83e85] APPLIED rdar://25159995
-[79fbb13] APPLIED rdar://25159995
-[6ead519] APPLIED rdar://25159995
-[1fa1513] APPLIED rdar://25159995
-[4a6ec51] APPLIED rdar://25159995
-[bc16cc9] APPLIED rdar://25159995
-[954ace4] APPLIED rdar://25159995
-[5ea30b5] APPLIED rdar://26822213
-[9f1e778] APPLIED rdar://26822213
-[3339b81] APPLIED rdar://26822213
-[4fa8d8d] APPLIED rdar://26822213
-[e922531] APPLIED rdar://26822213
-[195cbcf] APPLIED rdar://27303844
-[5b893c8] APPLIED rdar://27303844
-[92689ed] APPLIED rdar://27303844
-[ecc14fa] APPLIED rdar://27303844
-[2dbf83c] APPLIED rdar://27303844
-[78b9e82] APPLIED rdar://27303844
-[2c0e5ee] APPLIED rdar://27303844
-[5ee237f] APPLIED rdar://27600964
-[77299ec] APPLIED rdar://27600964
-[57c5c28] APPLIED rdar://27600964
-[f8423ec] APPLIED rdar://27600964
-[325f73d] APPLIED rdar://27600964
-[b84e87e] APPLIED rdar://27600964
-[ae71a91] APPLIED rdar://27600964
-[8669dea] APPLIED rdar://27600964
-[a8d0327] APPLIED rdar://27600964
-[2e4e6af] APPLIED rdar://27600964
-[2457fb2] APPLIED rdar://27600964
-[4d58038] APPLIED rdar://27600964
-[98d0a05] APPLIED rdar://27600964
-[8976101] APPLIED rdar://27600964
-[0d9ea5f] APPLIED rdar://28486911
-[e7e9a32] APPLIED rdar://28486911
-[44174d9] APPLIED rdar://28486911
-[6402cb7] APPLIED rdar://28486911
-[e2d5eb5] APPLIED rdar://28486911
-[758bb7f] APPLIED rdar://28486911
-[4c588e9] APPLIED rdar://28486911
-[1300d06] APPLIED rdar://28486911
-[ae1f7e8] APPLIED rdar://28486911
-[40a9bfb] APPLIED rdar://28486911
-[6366081] APPLIED rdar://28486911
-[81d1d0c] APPLIED rdar://28486911
-[5526122] APPLIED rdar://28486911
-[1a7ff3f] APPLIED rdar://28486911
-[e905735] APPLIED rdar://28486911
-[7fe8323] APPLIED rdar://28486911
-[6249878] APPLIED rdar://28486911
-[20792fe] APPLIED rdar://28486911
-[3639fbe] APPLIED rdar://28486911
-[bda3baf] APPLIED rdar://28486911
-[8803d07] APPLIED rdar://28486911
-[d04a0df] APPLIED rdar://28486911
-[69d2a6a] APPLIED rdar://28486911
-[367bd95] APPLIED rdar://28486911
-[152985f] APPLIED rdar://28486911
-[ba7802e] APPLIED rdar://28486911
-[92773e0] APPLIED rdar://30568673
-[548a1b9] APPLIED rdar://30568673
-[b628e5c] APPLIED rdar://30568673
-[a055ddb] APPLIED rdar://30568673
-[012f48b] APPLIED rdar://30568673
-[353adba] APPLIED rdar://30568673
-[eb730eb] APPLIED rdar://30568673
-[ac16fbb] APPLIED rdar://30568673
-[967876e] APPLIED rdar://30568673
-[44c2291] APPLIED rdar://30568673
-[ceb1fac] APPLIED rdar://30568673
-[c95febb] APPLIED rdar://30568673
-[b6e9cf4] APPLIED rdar://30568673
-[e199473] APPLIED rdar://30568673
-[3767ac7] APPLIED rdar://30568673
-[10eb0e4] APPLIED rdar://30568673
-[787dd92] APPLIED rdar://30568673
-[ba4cac5] APPLIED rdar://30568673
-[7974138] APPLIED rdar://30568673
-[cd12dcb] APPLIED rdar://32283666
-[ff05109] APPLIED rdar://32283666
-[73315ee] APPLIED rdar://32283666
-[fcc1924] APPLIED rdar://32283666
-[272e818] APPLIED rdar://32283666
-[b6f8908] APPLIED rdar://32283666
-[a6c16d0] APPLIED rdar://32283666
-[1cc64e1] APPLIED rdar://32283666
-[d137aa4] APPLIED rdar://32283666
-[a69853f] APPLIED rdar://32283666
-[eea0667] APPLIED rdar://32283666
-[f84d21d] APPLIED rdar://32283666
-[3da8398] APPLIED rdar://32283666
-[2df80a3] APPLIED rdar://32283666
-[97a2f06] APPLIED rdar://32283666
-[f76b8f5] APPLIED rdar://32283666
-[3828fbb] APPLIED rdar://32283666
-[5e8789e] APPLIED rdar://32283666
-[3fba60a] APPLIED rdar://32283666
-[d6eb245] APPLIED rdar://32283666
-[0b6c22e] APPLIED rdar://33531111
-[5a3c02a] APPLIED rdar://33531111
-[22df1e7] APPLIED rdar://33531111
-[21273de] APPLIED rdar://33531111
-[dc1857c] APPLIED rdar://33531111
-[56f36b6] APPLIED rdar://33531111
-[c87c6bb] APPLIED rdar://33531111
-[b791d23] APPLIED rdar://33531111
-[c2d0c49] APPLIED rdar://33531111
-[1d25040] APPLIED rdar://33531111
-[ab89c6c] APPLIED rdar://33531111
-[e591e7e] APPLIED rdar://33531111
-[ded5bab] APPLIED rdar://33531111
-[ce90d0c] APPLIED rdar://33531111
-[69c8f3e] APPLIED rdar://33531111
-[23a3a84] APPLIED rdar://33531111
-[79b7529] APPLIED rdar://33531111
-[f8e71eb] APPLIED rdar://33531111
-[8947dcf] APPLIED rdar://33531111
-[5ad9208] APPLIED rdar://33531111
-[698d085] APPLIED rdar://33531111
-[ce1ce45] APPLIED rdar://35017478
-[291f34d] APPLIED rdar://35017478
-[666df60] APPLIED rdar://35017478
-[80dd736] APPLIED rdar://35017478
-[0fd5a69] APPLIED rdar://35017478
-[0e35ed9] APPLIED rdar://35017478
-[70ce56b] APPLIED rdar://35017478
-[40fc1f3] APPLIED rdar://35017478
-[9ec74ed] APPLIED rdar://35017478
-[7f330ed] APPLIED rdar://35017478
-[947b51c] APPLIED rdar://35017478
-[295f676] APPLIED rdar://35017478
-[48196a2] APPLIED rdar://35017478
-[a28fc2b] APPLIED rdar://35017478
-[791ce5d] APPLIED rdar://35017478
-[0d0a998] APPLIED rdar://35017478
-[29329b5] APPLIED rdar://35017478
-[141403a] APPLIED rdar://35017478
-[b7f1beb] APPLIED rdar://35017478
-[7ef9cde] APPLIED rdar://35017478
-[12c9ca8] APPLIED rdar://35017478
-[6d6dc2e] APPLIED rdar://40252515
-[4a9833d] APPLIED rdar://40252515
-[f88e382] APPLIED rdar://40252515
-[bfa9aa7] APPLIED rdar://40252515
-[44f3640] APPLIED rdar://40252515
-[3b06f54] APPLIED rdar://40252515
-[e245cbe] APPLIED rdar://40252515
-[2a539d6] APPLIED rdar://40252515
-[e52c174] APPLIED rdar://40252515
-[723bd98] APPLIED rdar://40252515
-[7e7a579] APPLIED rdar://40252515
-[244a5fe] APPLIED rdar://40252515
-[8b72f76] APPLIED rdar://40252515
-[f3531a2] APPLIED rdar://40252515
-[5cf8acb] APPLIED rdar://40252515
-[dc01e36] APPLIED rdar://40252515
-[2d6d1fd] APPLIED rdar://40252515
-[fdd671d] APPLIED rdar://40252515
-[698220e] APPLIED rdar://40252515
-[9c792ac] APPLIED rdar://40252515
-[b5ec5d8] APPLIED rdar://40252515
-[9295346] APPLIED rdar://40252515
-[bbf03ca] APPLIED rdar://40252515
-[8d3aa22] APPLIED rdar://40252515
-[f151b33] APPLIED rdar://40252515
-[f6e6917] APPLIED rdar://40252515
-[f83b5a4] APPLIED rdar://40252515
-[c4d6402] APPLIED rdar://40252515
-[1457de8] APPLIED rdar://40252515
-[c025baa] APPLIED rdar://40252515
-[a618b46] APPLIED rdar://40252515
-[e723a8e] APPLIED rdar://44568645
-[4ac77b7] APPLIED rdar://44568645
-[03696d7] APPLIED rdar://44568645
-[44f67b2] APPLIED rdar://44568645
-[b15ee59] APPLIED rdar://44568645
-[d29ed37] APPLIED rdar://44568645
-[65ebc0c] APPLIED rdar://44568645
-[93c64d8] APPLIED rdar://44568645
-[1271df6] APPLIED rdar://44568645
-[84ac6ac] APPLIED rdar://44568645
-[30d3c8c] APPLIED rdar://44568645
-[12ff819] APPLIED rdar://44568645
-[82342ee] APPLIED rdar://44568645
-[b13a51e] APPLIED rdar://44568645
-[6bf3065] APPLIED rdar://44568645
-[631821c] APPLIED rdar://44568645
-[e764f34] APPLIED rdar://44568645
-[ff1daf8] APPLIED rdar://44568645
-[b863538] APPLIED rdar://44568645
-[ba3933d] APPLIED rdar://44568645
-[9c48a80] APPLIED rdar://44568645
-[5f49e8b] APPLIED rdar://44568645
-[653a523] APPLIED rdar://44568645
-[ac5f4c4] APPLIED rdar://44568645
-[57139c6] APPLIED rdar://44568645
-[ba74b6a] APPLIED rdar://44568645
-[3975b58] APPLIED rdar://44568645
-[81dc900] APPLIED rdar://44568645
-[6162a1d] APPLIED rdar://44568645
--- a/Telegram/ThirdParty/dispatch/private/benchmark.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/private/benchmark.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,89 +0,0 @@
-/*
- * Copyright (c) 2008-2009 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-/*
- * IMPORTANT: This header file describes INTERNAL interfaces to libdispatch
- * which are subject to change in future releases of Mac OS X. Any applications
- * relying on these interfaces WILL break.
- */
-
-#ifndef __DISPATCH_BENCHMARK__
-#define __DISPATCH_BENCHMARK__
-
-#ifndef __DISPATCH_INDIRECT__
-#error "Please #include <dispatch/private.h> instead of this file directly."
-#include <dispatch/base.h> // for HeaderDoc
-#endif
-
-DISPATCH_ASSUME_NONNULL_BEGIN
-
-__BEGIN_DECLS
-
-/*!
- * @function dispatch_benchmark
- *
- * @abstract
- * Count the average number of cycles a given block takes to execute.
- *
- * @param count
- * The number of times to serially execute the given block.
- *
- * @param block
- * The block to execute.
- *
- * @result
- * The approximate number of cycles the block takes to execute.
- *
- * @discussion
- * This function is for debugging and performance analysis work. For the best
- * results, pass a high count value to dispatch_benchmark(). When benchmarking
- * concurrent code, please compare the serial version of the code against the
- * concurrent version, and compare the concurrent version on different classes
- * of hardware. Please look for inflection points with various data sets and
- * keep the following facts in mind:
- *
- * 1) Code bound by computational bandwidth may be inferred by proportional
- *    changes in performance as concurrency is increased.
- * 2) Code bound by memory bandwidth may be inferred by negligible changes in
- *    performance as concurrency is increased.
- * 3) Code bound by critical sections may be inferred by retrograde changes in
- *    performance as concurrency is increased.
- * 3a) Intentional: locks, mutexes, and condition variables.
- * 3b) Accidental: unrelated and frequently modified data on the same
- *     cache-line.
- */
-#ifdef __BLOCKS__
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_EXPORT DISPATCH_NONNULL2 DISPATCH_NOTHROW
-uint64_t
-dispatch_benchmark(size_t count, dispatch_block_t block);
-#endif
-
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_EXPORT DISPATCH_NONNULL3 DISPATCH_NOTHROW
-uint64_t
-dispatch_benchmark_f(size_t count, void *_Nullable ctxt,
-		dispatch_function_t func);
-
-__END_DECLS
-
-DISPATCH_ASSUME_NONNULL_END
-
-#endif
--- a/Telegram/ThirdParty/dispatch/private/CMakeLists.txt	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/private/CMakeLists.txt	1970-01-01 00:00:00.000000000 -0000
@@ -1,21 +0,0 @@
-
-# TODO(compnerd) ensure that benchmark.h data_private.h introduction_private.h
-# io_private.h layout_private.h mach_private.h private.h queue_private.h
-# source_private.h are included in the source tarball
-
-if (INSTALL_PRIVATE_HEADERS)
-  install(FILES
-            benchmark.h
-            data_private.h
-            introspection_private.h
-            io_private.h
-            layout_private.h
-            mach_private.h
-            private.h
-            queue_private.h
-            source_private.h
-            time_private.h
-            workloop_private.h
-          DESTINATION
-            "${INSTALL_DISPATCH_HEADERS_DIR}")
-endif()
--- a/Telegram/ThirdParty/dispatch/private/darwin/module.modulemap	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/private/darwin/module.modulemap	1970-01-01 00:00:00.000000000 -0000
@@ -1,10 +0,0 @@
-module DispatchPrivate [system] [extern_c] {
-	umbrella header "private.h"
-	exclude header "mach_private.h"
-	export *
-}
-
-module DispatchIntrospectionPrivate [system] [extern_c] {
-	header "introspection_private.h"
-	export *
-}
--- a/Telegram/ThirdParty/dispatch/private/data_private.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/private/data_private.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,325 +0,0 @@
-/*
- * Copyright (c) 2011-2013 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-/*
- * IMPORTANT: This header file describes INTERNAL interfaces to libdispatch
- * which are subject to change in future releases of Mac OS X. Any applications
- * relying on these interfaces WILL break.
- */
-
-#ifndef __DISPATCH_DATA_PRIVATE__
-#define __DISPATCH_DATA_PRIVATE__
-
-#ifndef __DISPATCH_INDIRECT__
-#error "Please #include <dispatch/dispatch.h> instead of this file directly."
-#include <dispatch/base.h> // for HeaderDoc
-#endif
-
-DISPATCH_ASSUME_NONNULL_BEGIN
-
-__BEGIN_DECLS
-
-/*!
- * @const DISPATCH_DATA_DESTRUCTOR_NONE
- * @discussion The destructor for dispatch data objects that require no buffer
- * memory management. This can be used to allow a data object to efficiently
- * encapsulate buffers that should not be copied or freed by the system.
- */
-#define DISPATCH_DATA_DESTRUCTOR_NONE (_dispatch_data_destructor_none)
-API_AVAILABLE(macos(10.8), ios(6.0))
-DISPATCH_DATA_DESTRUCTOR_TYPE_DECL(none);
-
-/*!
- * @const DISPATCH_DATA_DESTRUCTOR_VM_DEALLOCATE
- * @discussion The destructor for dispatch data objects that have been created
- * from buffers that require deallocation using vm_deallocate.
- */
-#define DISPATCH_DATA_DESTRUCTOR_VM_DEALLOCATE \
-		(_dispatch_data_destructor_vm_deallocate)
-API_AVAILABLE(macos(10.8), ios(6.0)) DISPATCH_LINUX_UNAVAILABLE()
-DISPATCH_DATA_DESTRUCTOR_TYPE_DECL(vm_deallocate);
-
-/*!
- * @function dispatch_data_create_f
- * Creates a dispatch data object from the given contiguous buffer of memory. If
- * a non-default destructor is provided, ownership of the buffer remains with
- * the caller (i.e. the bytes will not be copied). The last release of the data
- * object will result in the invocation of the specified destructor function on
- * specified queue to free the buffer (passed as the context parameter).
- *
- * If the DISPATCH_DATA_DESTRUCTOR_FREE destructor is provided the buffer will
- * be freed via free(3) and the queue argument ignored.
- *
- * If the DISPATCH_DATA_DESTRUCTOR_DEFAULT destructor is provided, data object
- * creation will copy the buffer into internal memory managed by the system.
- *
- * @param buffer	A contiguous buffer of data.
- * @param size		The size of the contiguous buffer of data.
- * @param queue		The queue to which the destructor should be submitted.
- * @param destructor	The destructor function responsible for freeing the
- *			data buffer when it is no longer needed.
- * @result		A newly created dispatch data object.
- */
-API_AVAILABLE(macos(10.9), ios(7.0))
-DISPATCH_EXPORT DISPATCH_RETURNS_RETAINED DISPATCH_WARN_RESULT DISPATCH_NOTHROW
-dispatch_data_t
-dispatch_data_create_f(const void *buffer,
-	size_t size,
-	dispatch_queue_t _Nullable queue,
-	dispatch_function_t _Nullable destructor);
-
-/*!
- * @function dispatch_data_create_alloc
- * Creates a dispatch data object representing a newly allocated memory region
- * of the given size. If a non-NULL reference to a pointer is provided, it is
- * filled with the location of the memory region.
- *
- * It is the responsibility of the application to ensure that the data object
- * becomes immutable (i.e. the returned memory region is not further modified)
- * once the dispatch data object is passed to other API.
- *
- * @param size		The size of the required allocation.
- * @param buffer_ptr	A pointer to a pointer variable to be filled with the
- *			location of the newly allocated memory region, or NULL.
- * @result		A newly created dispatch data object.
- */
-API_AVAILABLE(macos(10.9), ios(6.0))
-DISPATCH_EXPORT DISPATCH_RETURNS_RETAINED
-DISPATCH_WARN_RESULT DISPATCH_NOTHROW
-dispatch_data_t
-dispatch_data_create_alloc(size_t size, void *_Nullable *_Nullable buffer_ptr);
-
-/*!
- * @typedef dispatch_data_applier_function_t
- * A function to be invoked for every contiguous memory region in a data object.
- *
- * @param context	Application-defined context parameter.
- * @param region	A data object representing the current region.
- * @param offset	The logical offset of the current region to the start
- *					of the data object.
- * @param buffer	The location of the memory for the current region.
- * @param size		The size of the memory for the current region.
- * @result		A Boolean indicating whether traversal should continue.
- */
-typedef bool (*dispatch_data_applier_function_t)(void *_Nullable context,
-	dispatch_data_t region, size_t offset, const void *buffer, size_t size);
-
-/*!
- * @function dispatch_data_apply_f
- * Traverse the memory regions represented by the specified dispatch data object
- * in logical order and invoke the specified function once for every contiguous
- * memory region encountered.
- *
- * Each invocation of the function is passed a data object representing the
- * current region and its logical offset, along with the memory location and
- * extent of the region. These allow direct read access to the memory region,
- * but are only valid until the passed-in region object is released. Note that
- * the region object is released by the system when the function returns, it is
- * the responsibility of the application to retain it if the region object or
- * the associated memory location are needed after the function returns.
- *
- * @param data		The data object to traverse.
- * @param context	The application-defined context to pass to the function.
- * @param applier	The function to be invoked for every contiguous memory
- *			region in the data object.
- * @result		A Boolean indicating whether traversal completed
- *			successfully.
- */
-API_AVAILABLE(macos(10.9), ios(6.0))
-DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW
-bool
-dispatch_data_apply_f(dispatch_data_t data, void *_Nullable context,
-	dispatch_data_applier_function_t applier);
-
-#if TARGET_OS_MAC
-/*!
- * @function dispatch_data_make_memory_entry
- * Return a mach memory entry for the memory regions represented by the
- * specified dispatch data object.
- *
- * For data objects created with the DISPATCH_DATA_DESTRUCTOR_VM_DEALLOCATE
- * destructor, directly makes a memory entry from the represented region;
- * otherwise, makes a memory entry from newly allocated pages containing a copy
- * of the represented memory regions.
- *
- * @param data		The data object to make a memory entry for.
- * @result		A mach port for the newly made memory entry, or
- *			MACH_PORT_NULL if an error occurred.
- */
-API_AVAILABLE(macos(10.9), ios(6.0))
-DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW
-mach_port_t
-dispatch_data_make_memory_entry(dispatch_data_t data);
-#endif
-
-/*!
- * @functiongroup Dispatch data transform SPI
- */
-
-/*!
- * @typedef dispatch_data_format_type_t
- *
- * @abstract
- * Data formats are used to specify the input and output types of data supplied
- * to dispatch_data_create_transform.
- */
-typedef const struct dispatch_data_format_type_s *dispatch_data_format_type_t;
-
-#define DISPATCH_DATA_FORMAT_TYPE_DECL(name) \
-	DISPATCH_EXPORT const struct dispatch_data_format_type_s \
-	_dispatch_data_format_type_##name
-
-/*!
- * @const DISPATCH_DATA_FORMAT_TYPE_NONE
- * @discussion A data format denoting that the given input or output format is,
- * or should be, comprised of raw data bytes with no given encoding.
- */
-#define DISPATCH_DATA_FORMAT_TYPE_NONE (&_dispatch_data_format_type_none)
-API_AVAILABLE(macos(10.8), ios(6.0))
-DISPATCH_DATA_FORMAT_TYPE_DECL(none);
-
-/*!
- * @const DISPATCH_DATA_FORMAT_TYPE_BASE32
- * @discussion A data format denoting that the given input or output format is,
- * or should be, encoded in Base32 (RFC 4648) format. On input, this format will
- * skip whitespace characters. Cannot be used in conjunction with UTF format
- * types.
- */
-#define DISPATCH_DATA_FORMAT_TYPE_BASE32 (&_dispatch_data_format_type_base32)
-API_AVAILABLE(macos(10.8), ios(6.0))
-DISPATCH_DATA_FORMAT_TYPE_DECL(base32);
-
-/*!
- * @const DISPATCH_DATA_FORMAT_TYPE_BASE32HEX
- * @discussion A data format denoting that the given input or output format is,
- * or should be, encoded in Base32Hex (RFC 4648) format. On input, this format
- * will skip whitespace characters. Cannot be used in conjunction with UTF
- * format types.
- */
-#define DISPATCH_DATA_FORMAT_TYPE_BASE32HEX \
-		(&_dispatch_data_format_type_base32hex)
-API_AVAILABLE(macos(10.9), ios(7.0))
-DISPATCH_DATA_FORMAT_TYPE_DECL(base32hex);
-
-/*!
- * @const DISPATCH_DATA_FORMAT_TYPE_BASE64
- * @discussion A data format denoting that the given input or output format is,
- * or should be, encoded in Base64 (RFC 4648) format. On input, this format will
- * skip whitespace characters. Cannot be used in conjunction with UTF format
- * types.
- */
-#define DISPATCH_DATA_FORMAT_TYPE_BASE64 (&_dispatch_data_format_type_base64)
-API_AVAILABLE(macos(10.8), ios(6.0))
-DISPATCH_DATA_FORMAT_TYPE_DECL(base64);
-
-/*!
- * @const DISPATCH_DATA_FORMAT_TYPE_UTF8
- * @discussion A data format denoting that the given input or output format is,
- * or should be, encoded in UTF-8 format. Is only valid when used in conjunction
- * with other UTF format types.
- */
-#define DISPATCH_DATA_FORMAT_TYPE_UTF8 (&_dispatch_data_format_type_utf8)
-API_AVAILABLE(macos(10.8), ios(6.0))
-DISPATCH_DATA_FORMAT_TYPE_DECL(utf8);
-
-/*!
- * @const DISPATCH_DATA_FORMAT_TYPE_UTF16LE
- * @discussion A data format denoting that the given input or output format is,
- * or should be, encoded in UTF-16LE format. Is only valid when used in
- * conjunction with other UTF format types.
- */
-#define DISPATCH_DATA_FORMAT_TYPE_UTF16LE (&_dispatch_data_format_type_utf16le)
-API_AVAILABLE(macos(10.8), ios(6.0))
-DISPATCH_DATA_FORMAT_TYPE_DECL(utf16le);
-
-/*!
- * @const DISPATCH_DATA_FORMAT_TYPE_UTF16BE
- * @discussion A data format denoting that the given input or output format is,
- * or should be, encoded in UTF-16BE format. Is only valid when used in
- * conjunction with other UTF format types.
- */
-#define DISPATCH_DATA_FORMAT_TYPE_UTF16BE (&_dispatch_data_format_type_utf16be)
-API_AVAILABLE(macos(10.8), ios(6.0))
-DISPATCH_DATA_FORMAT_TYPE_DECL(utf16be);
-
-/*!
- * @const DISPATCH_DATA_FORMAT_TYPE_UTFANY
- * @discussion A data format denoting that dispatch_data_create_transform should
- * attempt to automatically detect the input type based on the presence of a
- * byte order mark character at the beginning of the data. In the absence of a
- * BOM, the data will be assumed to be in UTF-8 format. Only valid as an input
- * format.
- */
-#define DISPATCH_DATA_FORMAT_TYPE_UTF_ANY (&_dispatch_data_format_type_utf_any)
-API_AVAILABLE(macos(10.8), ios(6.0))
-DISPATCH_DATA_FORMAT_TYPE_DECL(utf_any);
-
-/*!
- * @function dispatch_data_create_transform
- * Returns a new dispatch data object after transforming the given data object
- * from the supplied format, into the given output format.
- *
- * @param data
- * The data object representing the region(s) of memory to transform.
- * @param input_type
- * Flags specifying the input format of the source dispatch_data_t
- *
- * @param output_type
- * Flags specifying the expected output format of the resulting transformation.
- *
- * @result
- * A newly created dispatch data object, dispatch_data_empty if no has been
- * produced, or NULL if an error occurred.
- */
-API_AVAILABLE(macos(10.8), ios(6.0))
-DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_RETURNS_RETAINED
-DISPATCH_WARN_RESULT DISPATCH_NOTHROW
-dispatch_data_t
-dispatch_data_create_with_transform(dispatch_data_t data,
-	dispatch_data_format_type_t input_type,
-	dispatch_data_format_type_t output_type);
-
-/*!
- * @function dispatch_data_get_flattened_bytes_4libxpc
- *
- * Similar to dispatch_data_create_map() but attaches it to the passed in
- * dispatch data.
- *
- * The returned mapping, if not NULL, has the size returned by
- * dispatch_data_get_size() for the specified object, and its lifetime is tied
- * to the one of the dispatch data itself.
- *
- * @discussion
- * This interface is reserved for XPC usage and is not considered stable ABI.
- *
- *
- * @result
- * A newly created linear mapping for this data object, may return NULL if
- * making the dispatch data contiguous failed to allocate memory.
- */
-API_AVAILABLE(macos(10.14), ios(12.0), tvos(12.0), watchos(5.0), bridgeos(4.0))
-const void *_Nullable
-dispatch_data_get_flattened_bytes_4libxpc(dispatch_data_t data);
-
-__END_DECLS
-
-DISPATCH_ASSUME_NONNULL_END
-
-#endif // __DISPATCH_DATA_PRIVATE__
--- a/Telegram/ThirdParty/dispatch/private/generic/module.modulemap	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/private/generic/module.modulemap	1970-01-01 00:00:00.000000000 -0000
@@ -1,10 +0,0 @@
-module DispatchPrivate [system] [extern_c] {
-	umbrella header "private.h"
-	exclude header "mach_private.h"
-	export *
-}
-
-module DispatchIntrospectionPrivate [system] [extern_c] {
-	header "introspection_private.h"
-	export *
-}
--- a/Telegram/ThirdParty/dispatch/private/introspection_private.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/private/introspection_private.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,871 +0,0 @@
-/*
- * Copyright (c) 2012-2013 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-/*
- * IMPORTANT: This header file describes INTERNAL interfaces to libdispatch
- * which are subject to change in future releases of Mac OS X. Any applications
- * relying on these interfaces WILL break.
- */
-
-#ifndef __DISPATCH_INTROSPECTION_PRIVATE__
-#define __DISPATCH_INTROSPECTION_PRIVATE__
-
-/*!
- * @header
- *
- * @abstract
- * Introspection SPI for libdispatch.
- *
- * @discussion
- * This SPI is only available in the introspection version of the library,
- * loaded by running a process with the environment variable
- * DYLD_LIBRARY_PATH=/usr/lib/system/introspection
- *
- * NOTE: most of these functions are _not_ exported from the shared library,
- * the unexported functions are intended to only be called from a debugger
- * context while the rest of the process is suspended.
- */
-
-#ifndef __BEGIN_DECLS
-#if defined(__cplusplus)
-#define	__BEGIN_DECLS extern "C" {
-#define	__END_DECLS }
-#else
-#define	__BEGIN_DECLS
-#define	__END_DECLS
-#endif
-#endif
-
-__BEGIN_DECLS
-
-#ifndef __DISPATCH_INDIRECT__
-/*
- * Typedefs of opaque types, for direct inclusion of header in lldb expressions
- */
-typedef __typeof__(sizeof(int)) size_t;
-typedef struct _opaque_pthread_t *pthread_t;
-typedef void (*dispatch_function_t)(void *);
-typedef struct Block_layout *dispatch_block_t;
-typedef struct dispatch_continuation_s *dispatch_continuation_t;
-typedef struct dispatch_queue_s *dispatch_queue_t;
-typedef struct dispatch_source_s *dispatch_source_t;
-typedef struct dispatch_group_s *dispatch_group_t;
-typedef struct dispatch_object_s *dispatch_object_t;
-#ifndef API_AVAILABLE
-#define API_AVAILABLE(...)
-#endif
-#ifndef DISPATCH_EXPORT
-#define DISPATCH_EXPORT extern
-#endif
-#endif // __DISPATCH_INDIRECT__
-
-/*!
- * @typedef dispatch_introspection_versions_s
- *
- * @abstract
- * A structure of version and size information of introspection structures.
- *
- * @field introspection_version
- * Version of overall dispatch_introspection SPI.
- *
- * @field hooks_version
- * Version of dispatch_introspection_hooks_s structure.
- * Version 2 adds the queue_item_complete member.
- *
- * @field hooks_size
- * Size of dispatch_introspection_hooks_s structure.
- *
- * @field queue_item_version
- * Version of dispatch_introspection_queue_item_s structure.
- *
- * @field queue_item_size
- * Size of dispatch_introspection_queue_item_s structure.
- *
- * @field queue_block_version
- * Version of dispatch_introspection_queue_block_s structure.
- *
- * @field queue_block_size
- * Size of dispatch_introspection_queue_block_s structure.
- *
- * @field queue_function_version
- * Version of dispatch_introspection_queue_function_s structure.
- *
- * @field queue_function_size
- * Size of dispatch_introspection_queue_function_s structure.
- *
- * @field queue_thread_version
- * Version of dispatch_introspection_queue_thread_s structure.
- *
- * @field queue_thread_size
- * Size of dispatch_introspection_queue_thread_s structure.
- *
- * @field object_version
- * Version of dispatch_introspection_object_s structure.
- *
- * @field object_size
- * Size of dispatch_introspection_object_s structure.
- *
- * @field queue_version
- * Version of dispatch_introspection_queue_s structure.
- *
- * @field queue_size
- * Size of dispatch_introspection_queue_s structure.
- *
- * @field source_version
- * Version of dispatch_introspection_source_s structure.
- *
- * @field source_size
- * Size of dispatch_introspection_source_s structure.
- */
-API_AVAILABLE(macos(10.9), ios(7.0))
-DISPATCH_EXPORT const struct dispatch_introspection_versions_s {
-	unsigned long introspection_version;
-	unsigned long hooks_version;
-	size_t hooks_size;
-	unsigned long queue_item_version;
-	size_t queue_item_size;
-	unsigned long queue_block_version;
-	size_t queue_block_size;
-	unsigned long queue_function_version;
-	size_t queue_function_size;
-	unsigned long queue_thread_version;
-	size_t queue_thread_size;
-	unsigned long object_version;
-	size_t object_size;
-	unsigned long queue_version;
-	size_t queue_size;
-	unsigned long source_version;
-	size_t source_size;
-} dispatch_introspection_versions;
-
-/*!
- * @typedef dispatch_introspection_queue_block_s
- *
- * @abstract
- * A structure of introspection information for a block item enqueued on a
- * dispatch queue.
- *
- * @field continuation
- * Pointer to enqueued item.
- *
- * @field target_queue
- * Target queue of item (may be different to the queue the item is currently
- * enqueued on).
- *
- * @field block
- * Block for enqueued item.
- *
- * @field block_invoke
- * Function pointer of block for enqueued item.
- *
- * @field group
- * Group containing enqueued item (may be NULL).
- *
- * @field waiter
- * Thread waiting for completion of enqueued item (NULL if sync == 0).
- *
- * @field barrier
- * Item is a barrier on the queue (all items on serial queues are barriers).
- *
- * @field sync
- * Item was enqueued by a dispatch_sync/dispatch_barrier_sync.
- *
- * @field apply
- * Item is part of a dispatch_apply.
- */
-typedef struct dispatch_introspection_queue_block_s {
-	dispatch_continuation_t continuation;
-	dispatch_queue_t target_queue;
-	dispatch_block_t block;
-	dispatch_function_t block_invoke;
-	dispatch_group_t group;
-	pthread_t waiter;
-	unsigned long barrier:1,
-			sync:1,
-			apply:1;
-} dispatch_introspection_queue_block_s;
-typedef dispatch_introspection_queue_block_s
-		*dispatch_introspection_queue_block_t;
-
-/*!
- * @typedef dispatch_introspection_queue_function_s
- *
- * @abstract
- * A structure of introspection information for a function & context pointer
- * item enqueued on a dispatch queue.
- *
- * @field continuation
- * Pointer to enqueued item.
- *
- * @field target_queue
- * Target queue of item (may be different to the queue the item is currently
- * enqueued on).
- *
- * @field context
- * Context in enqueued item.
- *
- * @field block_invoke
- * Function pointer in enqueued item.
- *
- * @field group
- * Group containing enqueued item (may be NULL).
- *
- * @field waiter
- * Thread waiting for completion of enqueued item (NULL if sync == 0).
- *
- * @field barrier
- * Item is a barrier on the queue (all items on serial queues are barriers).
- *
- * @field sync
- * Item was enqueued by a dispatch_sync_f/dispatch_barrier_sync_f.
- *
- * @field apply
- * Item is part of a dispatch_apply_f.
- */
-typedef struct dispatch_introspection_queue_function_s {
-	dispatch_continuation_t continuation;
-	dispatch_queue_t target_queue;
-	void *context;
-	dispatch_function_t function;
-	dispatch_group_t group;
-	pthread_t waiter;
-	unsigned long barrier:1,
-			sync:1,
-			apply:1;
-} dispatch_introspection_queue_function_s;
-typedef dispatch_introspection_queue_function_s
-		*dispatch_introspection_queue_function_t;
-
-/*!
- * @typedef dispatch_introspection_object_s
- *
- * @abstract
- * A structure of introspection information for a generic dispatch object.
- *
- * @field object
- * Pointer to object.
- *
- * @field target_queue
- * Target queue of object (may be different to the queue the object is
- * currently enqueued on).
- *
- * @field type
- * Object class pointer.
- *
- * @field kind
- * String describing the object type.
- */
-typedef struct dispatch_introspection_object_s {
-	dispatch_continuation_t object;
-	dispatch_queue_t target_queue;
-	void *type;
-	const char *kind;
-} dispatch_introspection_object_s;
-typedef dispatch_introspection_object_s *dispatch_introspection_object_t;
-
-/*!
- * @typedef dispatch_introspection_queue_s
- *
- * @abstract
- * A structure of introspection information for a dispatch queue.
- *
- * @field queue
- * Pointer to queue object.
- *
- * @field target_queue
- * Target queue of queue (may be different to the queue the queue is currently
- * enqueued on). NULL indicates queue is a root queue.
- *
- * @field label
- * Pointer to queue label.
- *
- * @field serialnum
- * Queue serial number (unique per process).
- *
- * @field width
- * Queue width (1: serial queue, UINT_MAX: concurrent queue).
- *
- * @field suspend_count
- * Number of times the queue has been suspended.
- *
- * @field enqueued
- * Queue is enqueued on another queue.
- *
- * @field barrier
- * Queue is executing a barrier item.
- *
- * @field draining
- * Queue is being drained (cannot get queue items).
- *
- * @field global
- * Queue is a global queue.
- *
- * @field main
- * Queue is the main queue.
- */
-typedef struct dispatch_introspection_queue_s {
-	dispatch_queue_t queue;
-	dispatch_queue_t target_queue;
-	const char *label;
-	unsigned long serialnum;
-	unsigned int width;
-	unsigned int suspend_count;
-	unsigned long enqueued:1,
-			barrier:1,
-			draining:1,
-			global:1,
-			main:1;
-} dispatch_introspection_queue_s;
-typedef dispatch_introspection_queue_s *dispatch_introspection_queue_t;
-
-/*!
- * @typedef dispatch_introspection_source_s
- *
- * @abstract
- * A structure of introspection information for a dispatch source.
- *
- * @field source
- * Pointer to source object.
- *
- * @field target_queue
- * Target queue of source (may be different to the queue the source is currently
- * enqueued on).
- *
- * @field type
- * Source type (kevent filter)
- *
- * @field handle
- * Source handle (monitored entity).
- *
- * @field context
- * Context pointer passed to source handler. Pointer to handler block if
- * handler_is_block == 1.
- *
- * @field handler
- * Source handler function. Function pointer of handler block if
- * handler_is_block == 1.
- *
- * @field suspend_count
- * Number of times the source has been suspended.
- *
- * @field enqueued
- * Source is enqueued on a queue.
- *
- * @field handler_is_block
- * Source handler is a block.
- *
- * @field timer
- * Source is a timer.
- *
- * @field after
- * Source is a dispatch_after timer.
- */
-typedef struct dispatch_introspection_source_s {
-	dispatch_source_t source;
-	dispatch_queue_t target_queue;
-	unsigned long type;
-	unsigned long handle;
-	void *context;
-	dispatch_function_t handler;
-	unsigned int suspend_count;
-	unsigned long enqueued:1,
-			handler_is_block:1,
-			timer:1,
-			after:1,
-			is_xpc:1;
-} dispatch_introspection_source_s;
-typedef dispatch_introspection_source_s *dispatch_introspection_source_t;
-
-/*!
- * @typedef dispatch_introspection_queue_thread_s
- *
- * @abstract
- * A structure of introspection information about a thread executing items for
- * a dispatch queue.
- *
- * @field object
- * Pointer to thread object.
- *
- * @field thread
- * Thread executing items for a queue.
- *
- * @field queue
- * Queue introspection information. The queue.queue field is NULL if this thread
- * is not currently executing items for a queue.
- */
-typedef struct dispatch_introspection_queue_thread_s {
-	dispatch_continuation_t object;
-	pthread_t thread;
-	dispatch_introspection_queue_s queue;
-} dispatch_introspection_queue_thread_s;
-typedef dispatch_introspection_queue_thread_s
-		*dispatch_introspection_queue_thread_t;
-
-/*!
- * @enum dispatch_introspection_queue_item_type
- *
- * @abstract
- * Types of items enqueued on a dispatch queue.
- */
-enum dispatch_introspection_queue_item_type {
-	dispatch_introspection_queue_item_type_none = 0x0,
-	dispatch_introspection_queue_item_type_block = 0x11,
-	dispatch_introspection_queue_item_type_function = 0x12,
-	dispatch_introspection_queue_item_type_object = 0x100,
-	dispatch_introspection_queue_item_type_queue = 0x101,
-	dispatch_introspection_queue_item_type_source = 0x42,
-};
-
-/*!
- * @typedef dispatch_introspection_queue_item_s
- *
- * @abstract
- * A structure of introspection information about an item enqueued on a
- * dispatch queue.
- *
- * @field type
- * Indicates which of the union members applies to this item.
- */
-typedef struct dispatch_introspection_queue_item_s {
-	unsigned long type; // dispatch_introspection_queue_item_type
-	union {
-		dispatch_introspection_queue_block_s block;
-		dispatch_introspection_queue_function_s function;
-		dispatch_introspection_object_s object;
-		dispatch_introspection_queue_s queue;
-		dispatch_introspection_source_s source;
-	};
-} dispatch_introspection_queue_item_s;
-typedef dispatch_introspection_queue_item_s
-		*dispatch_introspection_queue_item_t;
-
-/*!
- * @typedef dispatch_introspection_hook_queue_create_t
- *
- * @abstract
- * A function pointer called when a dispatch queue is created.
- *
- * @param queue_info
- * Pointer to queue introspection structure.
- */
-typedef void (*dispatch_introspection_hook_queue_create_t)(
-		dispatch_introspection_queue_t queue_info);
-
-/*!
- * @typedef dispatch_introspection_hook_queue_dispose_t
- *
- * @abstract
- * A function pointer called when a dispatch queue is destroyed.
- *
- * @param queue_info
- * Pointer to queue introspection structure.
- */
-typedef void (*dispatch_introspection_hook_queue_dispose_t)(
-		dispatch_introspection_queue_t queue_info);
-
-/*!
- * @typedef dispatch_introspection_hook_queue_item_enqueue_t
- *
- * @abstract
- * A function pointer called when an item is enqueued onto a dispatch queue.
- *
- * @param queue
- * Pointer to queue.
- *
- * @param item
- * Pointer to item introspection structure.
- */
-typedef void (*dispatch_introspection_hook_queue_item_enqueue_t)(
-		dispatch_queue_t queue, dispatch_introspection_queue_item_t item);
-
-/*!
- * @typedef dispatch_introspection_hook_queue_item_dequeue_t
- *
- * @abstract
- * A function pointer called when an item is dequeued from a dispatch queue.
- *
- * @param queue
- * Pointer to queue.
- *
- * @param item
- * Pointer to item introspection structure.
- */
-typedef void (*dispatch_introspection_hook_queue_item_dequeue_t)(
-		dispatch_queue_t queue, dispatch_introspection_queue_item_t item);
-
-/*!
- * @typedef dispatch_introspection_hook_queue_item_complete_t
- *
- * @abstract
- * A function pointer called when an item previously dequeued from a dispatch
- * queue has completed processing.
- *
- * @discussion
- * The object pointer value passed to this function pointer must be treated as a
- * value only. It is intended solely for matching up with an earlier call to a
- * dequeue hook function pointer by comparing to the first member of the
- * dispatch_introspection_queue_item_t structure. It must NOT be dereferenced
- * or e.g. passed to dispatch_introspection_queue_item_get_info(), the memory
- * that was backing it may have been reused at the time this hook is called.
- *
- * @param object
- * Opaque dentifier for completed item. Must NOT be dereferenced.
- */
-typedef void (*dispatch_introspection_hook_queue_item_complete_t)(
-		dispatch_continuation_t object);
-
-/*!
- * @enum dispatch_introspection_runtime_event
- *
- * @abstract
- * Types for major events the dispatch runtime goes through as sent by
- * the runtime_event hook.
- *
- * @const dispatch_introspection_runtime_event_worker_event_delivery
- * A worker thread was unparked to deliver some kernel events.
- * There may be an unpark event if the thread will pick up a queue to drain.
- * There always is a worker_park event when the thread is returned to the pool.
- * `ptr` is the queue for which events are being delivered, or NULL (for generic
- * events).
- * `value` is the number of events delivered.
- *
- * @const dispatch_introspection_runtime_event_worker_unpark
- * A worker thread junst unparked (sent from the context of the thread).
- * `ptr` is the queue for which the thread unparked.
- * `value` is 0.
- *
- * @const dispatch_introspection_runtime_event_worker_request
- * `ptr` is set to the queue on behalf of which the thread request is made.
- * `value` is the number of threads requested.
- *
- * @const dispatch_introspection_runtime_event_worker_park
- * A worker thread is about to park (sent from the context of the thread).
- * `ptr` and `value` are 0.
- *
- * @const dispatch_introspection_runtime_event_sync_wait
- * A caller of dispatch_sync or dispatch_async_and_wait hit contention.
- * `ptr` is the queue that caused the initial contention.
- * `value` is 0.
- *
- * @const dispatch_introspection_runtime_event_async_sync_handoff
- * @const dispatch_introspection_runtime_event_sync_sync_handoff
- * @const dispatch_introspection_runtime_event_sync_async_handoff
- *
- * A queue is being handed off from a thread to another due to respectively:
- * - async/sync contention
- * - sync/sync contention
- * - sync/async contention
- *
- * `ptr` is set to dispatch_queue_t which is handed off to the next thread.
- * `value` is 0.
- */
-#ifndef __DISPATCH_BUILDING_DISPATCH__
-enum dispatch_introspection_runtime_event {
-	dispatch_introspection_runtime_event_worker_event_delivery = 1,
-	dispatch_introspection_runtime_event_worker_unpark = 2,
-	dispatch_introspection_runtime_event_worker_request = 3,
-	dispatch_introspection_runtime_event_worker_park = 4,
-
-	dispatch_introspection_runtime_event_sync_wait = 10,
-	dispatch_introspection_runtime_event_async_sync_handoff = 11,
-	dispatch_introspection_runtime_event_sync_sync_handoff = 12,
-	dispatch_introspection_runtime_event_sync_async_handoff = 13,
-};
-#endif
-
-/*!
- * @typedef dispatch_introspection_hook_runtime_event_t
- *
- * @abstract
- * A function pointer called for various runtime events.
- *
- * @discussion
- * The actual payloads are discussed in the documentation of the
- * dispatch_introspection_runtime_event enum.
- */
-typedef void (*dispatch_introspection_hook_runtime_event_t)(
-		enum dispatch_introspection_runtime_event event,
-		void *ptr, unsigned long long value);
-
-/*!
- * @typedef dispatch_introspection_hooks_s
- *
- * @abstract
- * A structure of function pointer hooks into libdispatch.
- */
-typedef struct dispatch_introspection_hooks_s {
-	dispatch_introspection_hook_queue_create_t queue_create;
-	dispatch_introspection_hook_queue_dispose_t queue_dispose;
-	dispatch_introspection_hook_queue_item_enqueue_t queue_item_enqueue;
-	dispatch_introspection_hook_queue_item_dequeue_t queue_item_dequeue;
-	dispatch_introspection_hook_queue_item_complete_t queue_item_complete;
-	dispatch_introspection_hook_runtime_event_t runtime_event;
-	void *_reserved[4];
-} dispatch_introspection_hooks_s;
-typedef dispatch_introspection_hooks_s *dispatch_introspection_hooks_t;
-
-/*!
- * @function dispatch_introspection_get_queues
- *
- * @abstract
- * Retrieve introspection information about all dispatch queues in the process,
- * in batches of specified size.
- *
- * @discussion
- * Retrieving queue information and iterating through the list of all queues
- * must take place from a debugger context (while the rest of the process is
- * suspended).
- *
- * @param start
- * Starting point for this batch of queue information, as returned by a previous
- * call to _dispatch_introspection_get_queues().
- * Pass NULL to retrieve the initial batch.
- *
- * @param count
- * Number of queues to introspect.
- *
- * @param queues
- * Array to fill with queue information. If less than 'count' queues are left
- * in this batch, the end of valid entries in the array will be indicated
- * by an entry with NULL queue member.
- *
- * @result
- * Queue to pass to another call to _dispatch_introspection_get_queues() to
- * retrieve information about the next batch of queues. May be NULL if there
- * are no more queues to iterate over.
- */
-extern dispatch_queue_t
-dispatch_introspection_get_queues(dispatch_queue_t start, size_t count,
-		dispatch_introspection_queue_t queues);
-
-/*!
- * @function dispatch_introspection_get_queue_threads
- *
- * @abstract
- * Retrieve introspection information about all threads in the process executing
- * items for dispatch queues, in batches of specified size.
- *
- * @discussion
- * Retrieving thread information and iterating through the list of all queue
- * threads must take place from a debugger context (while the rest of the
- * process is suspended).
- *
- * @param start
- * Starting point for this batch of thread information, as returned by a
- * previous call to _dispatch_introspection_get_queue_threads().
- * Pass NULL to retrieve the initial batch.
- *
- * @param count
- * Number of queue threads to introspect.
- *
- * @param threads
- * Array to fill with queue thread information. If less than 'count' threads are
- * left in this batch, the end of valid entries in the array will be indicated
- * by an entry with NULL object member.
- *
- * @result
- * Object to pass to another call to _dispatch_introspection_get_queues() to
- * retrieve information about the next batch of queues. May be NULL if there
- * are no more queues to iterate over.
- */
-extern dispatch_continuation_t
-dispatch_introspection_get_queue_threads(dispatch_continuation_t start,
-		size_t count, dispatch_introspection_queue_thread_t threads);
-
-/*!
- * @function dispatch_introspection_queue_get_items
- *
- * @abstract
- * Retrieve introspection information about all items enqueued on a queue, in
- * batches of specified size.
- *
- * @discussion
- * Retrieving queue item information and iterating through a queue must take
- * place from a debugger context (while the rest of the process is suspended).
- *
- * @param queue
- * Queue to introspect.
- *
- * @param start
- * Starting point for this batch of queue item information, as returned by a
- * previous call to _dispatch_introspection_queue_get_items().
- * Pass NULL to retrieve the initial batch.
- *
- * @param count
- * Number of items to introspect.
- *
- * @param items
- * Array to fill with queue item information. If less than 'count' queues are
- * left in this batch, the end of valid entries in the array will be indicated
- * by an entry with type dispatch_introspection_queue_item_type_none.
- *
- * @result
- * Item to pass to another call to _dispatch_introspection_queue_get_items() to
- * retrieve information about the next batch of queue items. May be NULL if
- * there are no more items to iterate over.
- */
-extern dispatch_continuation_t
-dispatch_introspection_queue_get_items(dispatch_queue_t queue,
-		dispatch_continuation_t start, size_t count,
-		dispatch_introspection_queue_item_t items);
-
-/*!
- * @function dispatch_introspection_queue_get_info
- *
- * @abstract
- * Retrieve introspection information about a specified dispatch queue.
- *
- * @discussion
- * Retrieving queue information must take place from a debugger context (while
- * the rest of the process is suspended).
- *
- * @param queue
- * Queue to introspect.
- *
- * @result
- * Queue information struct.
- */
-extern dispatch_introspection_queue_s
-dispatch_introspection_queue_get_info(dispatch_queue_t queue);
-
-/*!
- * @function dispatch_introspection_queue_item_get_info
- *
- * @abstract
- * Retrieve introspection information about a specified dispatch queue item.
- *
- * @discussion
- * Retrieving queue item information must take place from a debugger context
- * (while the rest of the process is suspended).
- *
- * @param queue
- * Queue to introspect.
- *
- * @param item
- * Item to introspect.
- *
- * @result
- * Queue item information struct.
- */
-extern dispatch_introspection_queue_item_s
-dispatch_introspection_queue_item_get_info(dispatch_queue_t queue,
-		dispatch_continuation_t item);
-
-/*!
- * @function dispatch_introspection_hooks_install
- *
- * @abstract
- * Install hook functions into libdispatch.
- *
- * @discussion
- * Installing hook functions must take place from a debugger context (while the
- * rest of the process is suspended) or early enough in the process lifecycle
- * that the process is still single-threaded.
- *
- * The caller is responsible for implementing chaining to the hooks that were
- * previously installed (if any).
- *
- * @param hooks
- * Pointer to structure of hook function pointers. Any of the structure members
- * may be NULL to indicate that the hook in question should not be installed.
- * The structure is copied on input and filled with the previously installed
- * hooks on output.
- */
-API_AVAILABLE(macos(10.9), ios(7.0))
-DISPATCH_EXPORT void
-dispatch_introspection_hooks_install(dispatch_introspection_hooks_t hooks);
-
-/*!
- * @function dispatch_introspection_hook_callouts_enable
- *
- * @abstract
- * Enable hook callout functions in libdispatch that a debugger can break on
- * and get introspection arguments even if there are no hook functions
- * installed via dispatch_introspection_hooks_install().
- *
- * @discussion
- * Enabling hook callout functions must take place from a debugger context
- * (while the rest of the process is suspended).
- *
- * @param enable
- * Pointer to dispatch_introspection_hooks_s structure. For every structure
- * member with (any) non-NULL value, the corresponding hook callout will be
- * enabled; for every NULL member the hook callout will be disabled (if there
- * is no hook function installed).
- * As a convenience, the 'enable' pointer may itself be NULL to indicate that
- * all hook callouts should be enabled.
- */
-extern void
-dispatch_introspection_hook_callouts_enable(
-		dispatch_introspection_hooks_t enable);
-
-/*!
- * @function dispatch_introspection_hook_callout_queue_create
- *
- * @abstract
- * Callout to queue creation hook that a debugger can break on.
- */
-extern void
-dispatch_introspection_hook_callout_queue_create(
-		dispatch_introspection_queue_t queue_info);
-
-/*!
- * @function dispatch_introspection_hook_callout_queue_dispose
- *
- * @abstract
- * Callout to queue destruction hook that a debugger can break on.
- */
-extern void
-dispatch_introspection_hook_callout_queue_dispose(
-		dispatch_introspection_queue_t queue_info);
-
-/*!
- * @function dispatch_introspection_hook_callout_queue_item_enqueue
- *
- * @abstract
- * Callout to queue enqueue hook that a debugger can break on.
- */
-extern void
-dispatch_introspection_hook_callout_queue_item_enqueue(
-		dispatch_queue_t queue, dispatch_introspection_queue_item_t item);
-
-/*!
- * @function dispatch_introspection_hook_callout_queue_item_dequeue
- *
- * @abstract
- * Callout to queue dequeue hook that a debugger can break on.
- */
-extern void
-dispatch_introspection_hook_callout_queue_item_dequeue(
-		dispatch_queue_t queue, dispatch_introspection_queue_item_t item);
-
-/*!
- * @function dispatch_introspection_hook_callout_queue_item_complete
- *
- * @abstract
- * Callout to queue item complete hook that a debugger can break on.
- */
-extern void
-dispatch_introspection_hook_callout_queue_item_complete(
-		dispatch_continuation_t object);
-
-__END_DECLS
-
-#endif
--- a/Telegram/ThirdParty/dispatch/private/io_private.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/private/io_private.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,416 +0,0 @@
-/*
- * Copyright (c) 2009-2013 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-/*
- * IMPORTANT: This header file describes INTERNAL interfaces to libdispatch
- * which are subject to change in future releases of Mac OS X. Any applications
- * relying on these interfaces WILL break.
- */
-
-#ifndef __DISPATCH_IO_PRIVATE__
-#define __DISPATCH_IO_PRIVATE__
-
-#ifndef __DISPATCH_INDIRECT__
-#error "Please #include <dispatch/dispatch.h> instead of this file directly."
-#include <dispatch/base.h> // for HeaderDoc
-#endif
-
-DISPATCH_ASSUME_NONNULL_BEGIN
-
-__BEGIN_DECLS
-
-/*!
- * @function dispatch_read_f
- * Schedule a read operation for asynchronous execution on the specified file
- * descriptor. The specified handler is enqueued with the data read from the
- * file descriptor when the operation has completed or an error occurs.
- *
- * The data object passed to the handler will be automatically released by the
- * system when the handler returns. It is the responsibility of the application
- * to retain, concatenate or copy the data object if it is needed after the
- * handler returns.
- *
- * The data object passed to the handler will only contain as much data as is
- * currently available from the file descriptor (up to the specified length).
- *
- * If an unrecoverable error occurs on the file descriptor, the handler will be
- * enqueued with the appropriate error code along with a data object of any data
- * that could be read successfully.
- *
- * An invocation of the handler with an error code of zero and an empty data
- * object indicates that EOF was reached.
- *
- * The system takes control of the file descriptor until the handler is
- * enqueued, and during this time file descriptor flags such as O_NONBLOCK will
- * be modified by the system on behalf of the application. It is an error for
- * the application to modify a file descriptor directly while it is under the
- * control of the system, but it may create additional dispatch I/O convenience
- * operations or dispatch I/O channels associated with that file descriptor.
- *
- * @param fd		The file descriptor from which to read the data.
- * @param length	The length of data to read from the file descriptor,
- *			or SIZE_MAX to indicate that all of the data currently
- *			available from the file descriptor should be read.
- * @param queue		The dispatch queue to which the handler should be
- *			submitted.
- * @param context	The application-defined context parameter to pass to
- *			the handler function.
- * @param handler	The handler to enqueue when data is ready to be
- *			delivered.
- *		param context	Application-defined context parameter.
- *		param data	The data read from the file descriptor.
- *		param error	An errno condition for the read operation or
- *				zero if the read was successful.
- */
-API_AVAILABLE(macos(10.9), ios(7.0))
-DISPATCH_EXPORT DISPATCH_NONNULL3 DISPATCH_NONNULL5 DISPATCH_NOTHROW
-void
-dispatch_read_f(dispatch_fd_t fd,
-	size_t length,
-	dispatch_queue_t queue,
-	void *_Nullable context,
-	void (*handler)(void *_Nullable context, dispatch_data_t data, int error));
-
-/*!
- * @function dispatch_write_f
- * Schedule a write operation for asynchronous execution on the specified file
- * descriptor. The specified handler is enqueued when the operation has
- * completed or an error occurs.
- *
- * If an unrecoverable error occurs on the file descriptor, the handler will be
- * enqueued with the appropriate error code along with the data that could not
- * be successfully written.
- *
- * An invocation of the handler with an error code of zero indicates that the
- * data was fully written to the channel.
- *
- * The system takes control of the file descriptor until the handler is
- * enqueued, and during this time file descriptor flags such as O_NONBLOCK will
- * be modified by the system on behalf of the application. It is an error for
- * the application to modify a file descriptor directly while it is under the
- * control of the system, but it may create additional dispatch I/O convenience
- * operations or dispatch I/O channels associated with that file descriptor.
- *
- * @param fd		The file descriptor to which to write the data.
- * @param data		The data object to write to the file descriptor.
- * @param queue		The dispatch queue to which the handler should be
- *			submitted.
- * @param context	The application-defined context parameter to pass to
- *			the handler function.
- * @param handler	The handler to enqueue when the data has been written.
- *		param context	Application-defined context parameter.
- *		param data	The data that could not be written to the I/O
- *				channel, or NULL.
- *		param error	An errno condition for the write operation or
- *				zero if the write was successful.
- */
-API_AVAILABLE(macos(10.9), ios(7.0))
-DISPATCH_EXPORT DISPATCH_NONNULL2 DISPATCH_NONNULL3 DISPATCH_NONNULL5
-DISPATCH_NOTHROW
-void
-dispatch_write_f(dispatch_fd_t fd,
-	dispatch_data_t data,
-	dispatch_queue_t queue,
-	void *_Nullable context,
-	void (*handler)(void *_Nullable context, dispatch_data_t _Nullable data,
-			int error));
-
-/*!
- * @function dispatch_io_create_f
- * Create a dispatch I/O channel associated with a file descriptor. The system
- * takes control of the file descriptor until the channel is closed, an error
- * occurs on the file descriptor or all references to the channel are released.
- * At that time the specified cleanup handler will be enqueued and control over
- * the file descriptor relinquished.
- *
- * While a file descriptor is under the control of a dispatch I/O channel, file
- * descriptor flags such as O_NONBLOCK will be modified by the system on behalf
- * of the application. It is an error for the application to modify a file
- * descriptor directly while it is under the control of a dispatch I/O channel,
- * but it may create additional channels associated with that file descriptor.
- *
- * @param type	The desired type of I/O channel (DISPATCH_IO_STREAM
- *		or DISPATCH_IO_RANDOM).
- * @param fd	The file descriptor to associate with the I/O channel.
- * @param queue	The dispatch queue to which the handler should be submitted.
- * @param context	The application-defined context parameter to pass to
- *			the cleanup handler function.
- * @param cleanup_handler	The handler to enqueue when the system
- *				relinquishes control over the file descriptor.
- *	param context		Application-defined context parameter.
- *	param error		An errno condition if control is relinquished
- *				because channel creation failed, zero otherwise.
- * @result	The newly created dispatch I/O channel or NULL if an error
- *		occurred (invalid type specified).
- */
-API_AVAILABLE(macos(10.9), ios(7.0))
-DISPATCH_EXPORT DISPATCH_MALLOC DISPATCH_RETURNS_RETAINED DISPATCH_WARN_RESULT
-DISPATCH_NOTHROW
-dispatch_io_t
-dispatch_io_create_f(dispatch_io_type_t type,
-	dispatch_fd_t fd,
-	dispatch_queue_t queue,
-	void *_Nullable context,
-	void (*cleanup_handler)(void *_Nullable context, int error));
-
-/*!
- * @function dispatch_io_create_with_path_f
- * Create a dispatch I/O channel associated with a path name. The specified
- * path, oflag and mode parameters will be passed to open(2) when the first I/O
- * operation on the channel is ready to execute and the resulting file
- * descriptor will remain open and under the control of the system until the
- * channel is closed, an error occurs on the file descriptor or all references
- * to the channel are released. At that time the file descriptor will be closed
- * and the specified cleanup handler will be enqueued.
- *
- * @param type	The desired type of I/O channel (DISPATCH_IO_STREAM
- *		or DISPATCH_IO_RANDOM).
- * @param path	The absolute path to associate with the I/O channel.
- * @param oflag	The flags to pass to open(2) when opening the file at
- *		path.
- * @param mode	The mode to pass to open(2) when creating the file at
- *		path (i.e. with flag O_CREAT), zero otherwise.
- * @param queue	The dispatch queue to which the handler should be
- *		submitted.
- * @param context	The application-defined context parameter to pass to
- *			the cleanup handler function.
- * @param cleanup_handler	The handler to enqueue when the system
- *				has closed the file at path.
- *	param context		Application-defined context parameter.
- *	param error		An errno condition if control is relinquished
- *				because channel creation or opening of the
- *				specified file failed, zero otherwise.
- * @result	The newly created dispatch I/O channel or NULL if an error
- *		occurred (invalid type or non-absolute path specified).
- */
-API_AVAILABLE(macos(10.9), ios(7.0))
-DISPATCH_EXPORT DISPATCH_NONNULL2 DISPATCH_MALLOC DISPATCH_RETURNS_RETAINED
-DISPATCH_WARN_RESULT DISPATCH_NOTHROW
-dispatch_io_t
-dispatch_io_create_with_path_f(dispatch_io_type_t type,
-	const char *path, int oflag, mode_t mode,
-	dispatch_queue_t queue,
-	void *_Nullable context,
-	void (*cleanup_handler)(void *_Nullable context, int error));
-
-/*!
- * @function dispatch_io_create_with_io_f
- * Create a new dispatch I/O channel from an existing dispatch I/O channel.
- * The new channel inherits the file descriptor or path name associated with
- * the existing channel, but not its channel type or policies.
- *
- * If the existing channel is associated with a file descriptor, control by the
- * system over that file descriptor is extended until the new channel is also
- * closed, an error occurs on the file descriptor, or all references to both
- * channels are released. At that time the specified cleanup handler will be
- * enqueued and control over the file descriptor relinquished.
- *
- * While a file descriptor is under the control of a dispatch I/O channel, file
- * descriptor flags such as O_NONBLOCK will be modified by the system on behalf
- * of the application. It is an error for the application to modify a file
- * descriptor directly while it is under the control of a dispatch I/O channel,
- * but it may create additional channels associated with that file descriptor.
- *
- * @param type	The desired type of I/O channel (DISPATCH_IO_STREAM
- *		or DISPATCH_IO_RANDOM).
- * @param io	The existing channel to create the new I/O channel from.
- * @param queue	The dispatch queue to which the handler should be submitted.
- * @param context	The application-defined context parameter to pass to
- *			the cleanup handler function.
- * @param cleanup_handler	The handler to enqueue when the system
- *				relinquishes control over the file descriptor
- *				(resp. closes the file at path) associated with
- *				the existing channel.
- *	param context		Application-defined context parameter.
- *	param error		An errno condition if control is relinquished
- *				because channel creation failed, zero otherwise.
- * @result	The newly created dispatch I/O channel or NULL if an error
- *		occurred (invalid type specified).
- */
-API_AVAILABLE(macos(10.9), ios(7.0))
-DISPATCH_EXPORT DISPATCH_NONNULL2 DISPATCH_MALLOC DISPATCH_RETURNS_RETAINED
-DISPATCH_WARN_RESULT DISPATCH_NOTHROW
-dispatch_io_t
-dispatch_io_create_with_io_f(dispatch_io_type_t type,
-	dispatch_io_t io,
-	dispatch_queue_t queue,
-	void *_Nullable context,
-	void (*cleanup_handler)(void *_Nullable context, int error));
-
-/*!
- * @typedef dispatch_io_handler_function_t
- * The prototype of I/O handler functions for dispatch I/O operations.
- *
- * @param context	Application-defined context parameter.
- * @param done		A flag indicating whether the operation is complete.
- * @param data		The data object to be handled.
- * @param error		An errno condition for the operation.
- */
-typedef void (*dispatch_io_handler_function_t)(void *_Nullable context,
-	bool done, dispatch_data_t _Nullable data, int error);
-
-/*!
- * @function dispatch_io_read_f
- * Schedule a read operation for asynchronous execution on the specified I/O
- * channel. The I/O handler is enqueued one or more times depending on the
- * general load of the system and the policy specified on the I/O channel.
- *
- * Any data read from the channel is described by the dispatch data object
- * passed to the I/O handler. This object will be automatically released by the
- * system when the I/O handler returns. It is the responsibility of the
- * application to retain, concatenate or copy the data object if it is needed
- * after the I/O handler returns.
- *
- * Dispatch I/O handlers are not reentrant. The system will ensure that no new
- * I/O handler instance is invoked until the previously enqueued handler
- * function has returned.
- *
- * An invocation of the I/O handler with the done flag set indicates that the
- * read operation is complete and that the handler will not be enqueued again.
- *
- * If an unrecoverable error occurs on the I/O channel's underlying file
- * descriptor, the I/O handler will be enqueued with the done flag set, the
- * appropriate error code and a NULL data object.
- *
- * An invocation of the I/O handler with the done flag set, an error code of
- * zero and an empty data object indicates that EOF was reached.
- *
- * @param channel	The dispatch I/O channel from which to read the data.
- * @param offset	The offset relative to the channel position from which
- *			to start reading (only for DISPATCH_IO_RANDOM).
- * @param length	The length of data to read from the I/O channel, or
- *			SIZE_MAX to indicate that data should be read until EOF
- *			is reached.
- * @param queue		The dispatch queue to which the I/O handler should be
- *			submitted.
- * @param context	The application-defined context parameter to pass to
- *			the handler function.
- * @param io_handler	The I/O handler to enqueue when data is ready to be
- *			delivered.
- *	param context	Application-defined context parameter.
- *	param done	A flag indicating whether the operation is complete.
- *	param data	An object with the data most recently read from the
- *			I/O channel as part of this read operation, or NULL.
- *	param error	An errno condition for the read operation or zero if
- *			the read was successful.
- */
-API_AVAILABLE(macos(10.9), ios(7.0))
-DISPATCH_EXPORT DISPATCH_NONNULL1 DISPATCH_NONNULL4 DISPATCH_NONNULL6
-DISPATCH_NOTHROW
-void
-dispatch_io_read_f(dispatch_io_t channel,
-	off_t offset,
-	size_t length,
-	dispatch_queue_t queue,
-	void *_Nullable context,
-	dispatch_io_handler_function_t io_handler);
-
-/*!
- * @function dispatch_io_write_f
- * Schedule a write operation for asynchronous execution on the specified I/O
- * channel. The I/O handler is enqueued one or more times depending on the
- * general load of the system and the policy specified on the I/O channel.
- *
- * Any data remaining to be written to the I/O channel is described by the
- * dispatch data object passed to the I/O handler. This object will be
- * automatically released by the system when the I/O handler returns. It is the
- * responsibility of the application to retain, concatenate or copy the data
- * object if it is needed after the I/O handler returns.
- *
- * Dispatch I/O handlers are not reentrant. The system will ensure that no new
- * I/O handler instance is invoked until the previously enqueued handler
- * function has returned.
- *
- * An invocation of the I/O handler with the done flag set indicates that the
- * write operation is complete and that the handler will not be enqueued again.
- *
- * If an unrecoverable error occurs on the I/O channel's underlying file
- * descriptor, the I/O handler will be enqueued with the done flag set, the
- * appropriate error code and an object containing the data that could not be
- * written.
- *
- * An invocation of the I/O handler with the done flag set and an error code of
- * zero indicates that the data was fully written to the channel.
- *
- * @param channel	The dispatch I/O channel on which to write the data.
- * @param offset	The offset relative to the channel position from which
- *			to start writing (only for DISPATCH_IO_RANDOM).
- * @param data		The data to write to the I/O channel. The data object
- *			will be retained by the system until the write operation
- *			is complete.
- * @param queue		The dispatch queue to which the I/O handler should be
- *			submitted.
- * @param context	The application-defined context parameter to pass to
- *			the handler function.
- * @param io_handler	The I/O handler to enqueue when data has been delivered.
- *	param context	Application-defined context parameter.
- *	param done	A flag indicating whether the operation is complete.
- *	param data	An object of the data remaining to be
- *			written to the I/O channel as part of this write
- *			operation, or NULL.
- *	param error	An errno condition for the write operation or zero
- *			if the write was successful.
- */
-API_AVAILABLE(macos(10.9), ios(7.0))
-DISPATCH_EXPORT DISPATCH_NONNULL1 DISPATCH_NONNULL3 DISPATCH_NONNULL4
-DISPATCH_NONNULL6 DISPATCH_NOTHROW
-void
-dispatch_io_write_f(dispatch_io_t channel,
-	off_t offset,
-	dispatch_data_t data,
-	dispatch_queue_t queue,
-	void *_Nullable context,
-	dispatch_io_handler_function_t io_handler);
-
-/*!
- * @function dispatch_io_barrier_f
- * Schedule a barrier operation on the specified I/O channel; all previously
- * scheduled operations on the channel will complete before the provided
- * barrier function is enqueued onto the global queue determined by the
- * channel's target queue, and no subsequently scheduled operations will start
- * until the barrier function has returned.
- *
- * If multiple channels are associated with the same file descriptor, a barrier
- * operation scheduled on any of these channels will act as a barrier across all
- * channels in question, i.e. all previously scheduled operations on any of the
- * channels will complete before the barrier function is enqueued, and no
- * operations subsequently scheduled on any of the channels will start until the
- * barrier function has returned.
- *
- * While the barrier function is running, it may safely operate on the channel's
- * underlying file descriptor with fsync(2), lseek(2) etc. (but not close(2)).
- *
- * @param channel	The dispatch I/O channel to schedule the barrier on.
- * @param context	The application-defined context parameter to pass to
- *			the barrier function.
- * @param barrier	The barrier function.
- */
-API_AVAILABLE(macos(10.9), ios(7.0))
-DISPATCH_EXPORT DISPATCH_NONNULL1 DISPATCH_NONNULL3 DISPATCH_NOTHROW
-void
-dispatch_io_barrier_f(dispatch_io_t channel,
-	void *_Nullable context,
-	dispatch_function_t barrier);
-
-__END_DECLS
-
-DISPATCH_ASSUME_NONNULL_END
-
-#endif /* __DISPATCH_IO_PRIVATE__ */
--- a/Telegram/ThirdParty/dispatch/private/layout_private.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/private/layout_private.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,101 +0,0 @@
-/*
- * Copyright (c) 2014 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#ifndef __DISPATCH_LAYOUT_PRIVATE__
-#define __DISPATCH_LAYOUT_PRIVATE__
-
-#ifndef __DISPATCH_INDIRECT__
-#error "Please #include <dispatch/private.h> instead of this file directly."
-#include <dispatch/base.h> // for HeaderDoc
-#endif
-
-__BEGIN_DECLS
-
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_EXPORT const struct dispatch_queue_offsets_s {
-	// always add new fields at the end
-	const uint16_t dqo_version;
-	const uint16_t dqo_label;
-	const uint16_t dqo_label_size;
-	const uint16_t dqo_flags;
-	const uint16_t dqo_flags_size;
-	const uint16_t dqo_serialnum;
-	const uint16_t dqo_serialnum_size;
-	const uint16_t dqo_width;
-	const uint16_t dqo_width_size;
-	const uint16_t dqo_running;
-	const uint16_t dqo_running_size;
-	// fields added in dqo_version 5:
-	const uint16_t dqo_suspend_cnt;
-	const uint16_t dqo_suspend_cnt_size;
-	const uint16_t dqo_target_queue;
-	const uint16_t dqo_target_queue_size;
-	const uint16_t dqo_priority;
-	const uint16_t dqo_priority_size;
-} dispatch_queue_offsets;
-
-#if DISPATCH_LAYOUT_SPI
-/*!
- * @group Data Structure Layout SPI
- * SPI intended for CoreSymbolication only
- */
-
-API_AVAILABLE(macos(10.10), ios(8.0))
-DISPATCH_EXPORT const struct dispatch_tsd_indexes_s {
-	// always add new fields at the end
-	const uint16_t dti_version;
-	const uint16_t dti_queue_index;
-	const uint16_t dti_voucher_index;
-	const uint16_t dti_qos_class_index;
-	/* version 3 */
-	const uint16_t dti_continuation_cache_index;
-} dispatch_tsd_indexes;
-
-#if TARGET_OS_MAC
-
-#include <malloc/malloc.h>
-
-API_AVAILABLE(macos(10.14), ios(12.0), tvos(12.0), watchos(5.0))
-DISPATCH_EXPORT const struct dispatch_allocator_layout_s {
-	const uint16_t dal_version;
-	/* version 1 */
-	/* Pointer to the allocator metadata address, points to NULL if unused */
-	void **const dal_allocator_zone;
-	/* Magical "isa" for allocations that are on freelists */
-	void *const *const dal_deferred_free_isa;
-	/* Size of allocations made in the magazine */
-	const uint16_t dal_allocation_size;
-	/* fields used by the enumerator */
-	const uint16_t dal_magazine_size;
-	const uint16_t dal_first_allocation_offset;
-	const uint16_t dal_allocation_isa_offset;
-	/* Enumerates allocated continuations */
-	kern_return_t (*dal_enumerator)(task_t remote_task,
-			const struct dispatch_allocator_layout_s *remote_allocator_layout,
-			vm_address_t zone_address, memory_reader_t reader,
-			void (^recorder)(vm_address_t dc_address, void *dc_mem,
-					size_t size, bool *stop));
-} dispatch_allocator_layout;
-#endif // TARGET_OS_MAC
-#endif // DISPATCH_LAYOUT_SPI
-
-__END_DECLS
-
-#endif // __DISPATCH_LAYOUT_PRIVATE__
--- a/Telegram/ThirdParty/dispatch/private/mach_private.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/private/mach_private.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,1155 +0,0 @@
-/*
- * Copyright (c) 2012-2013 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-/*
- * IMPORTANT: This header file describes INTERNAL interfaces to libdispatch
- * which are subject to change in future releases of Mac OS X. Any applications
- * relying on these interfaces WILL break.
- */
-
-#ifndef __DISPATCH_MACH_PRIVATE__
-#define __DISPATCH_MACH_PRIVATE__
-
-#ifndef __DISPATCH_INDIRECT__
-#error "Please #include <dispatch/dispatch.h> instead of this file directly."
-#include <dispatch/base.h> // for HeaderDoc
-#endif
-
-__BEGIN_DECLS
-
-#if DISPATCH_MACH_SPI
-
-#define DISPATCH_MACH_SPI_VERSION 20161026
-
-#include <mach/mach.h>
-
-DISPATCH_ASSUME_NONNULL_BEGIN
-
-/*!
- * @functiongroup Dispatch Mach Channel SPI
- *
- * IMPORTANT: This is Libsystem-internal SPI not intended for general use and
- * is subject to change at any time without warning.
- */
-
-/*!
- * @typedef dispatch_mach_t
- * A dispatch mach channel asynchronously recevives and sends mach messages.
- */
-DISPATCH_DECL(dispatch_mach);
-
-/*!
- * @typedef dispatch_mach_reason_t
- * Reasons for a mach channel handler to be invoked, or the result of an
- * immediate send attempt.
- *
- * @const DISPATCH_MACH_CONNECTED
- * The channel has been connected. The first handler invocation on a channel
- * after calling dispatch_mach_connect() will have this reason.
- *
- * @const DISPATCH_MACH_MESSAGE_RECEIVED
- * A message was received, it is passed in the message parameter.
- * It is the responsibility of the client of this API to handle this and consume
- * or dispose of the rights in the message (for example by calling
- * mach_msg_destroy()).
- *
- * @const DISPATCH_MACH_MESSAGE_SENT
- * A message was sent, it is passed in the message parameter (so that associated
- * resources can be disposed of).
- *
- * @const DISPATCH_MACH_MESSAGE_SEND_FAILED
- * A message failed to be sent, it is passed in the message parameter (so that
- * associated resources can be disposed of), along with the error code from
- * mach_msg().
- *
- * @const DISPATCH_MACH_MESSAGE_NOT_SENT
- * A message was not sent due to the channel being canceled or reconnected, it
- * is passed in the message parameter (so that associated resources can be
- * disposed of).
- *
- * @const DISPATCH_MACH_BARRIER_COMPLETED
- * A barrier block has finished executing.
- *
- * @const DISPATCH_MACH_DISCONNECTED
- * The channel has been disconnected by a call to dispatch_mach_reconnect() or
- * dispatch_mach_cancel(), an empty message is passed in the message parameter
- * (so that associated port rights can be disposed of).
- * The message header will contain either a remote port with a previously
- * connected send right, or a local port with a previously connected receive
- * right (if the channel was canceled), or a local port with a receive right
- * that was being monitored for a direct reply to a message previously sent to
- * the channel (if no reply was received).
- *
- * @const DISPATCH_MACH_CANCELED
- * The channel has been canceled.
- *
- * @const DISPATCH_MACH_REPLY_RECEIVED
- * A synchronous reply to a call to dispatch_mach_send_and_wait_for_reply() has
- * been received on another thread, an empty message is passed in the message
- * parameter (so that associated port rights can be disposed of).
- * The message header will contain a local port with a receive right associated
- * with the reply to the message that was synchronously sent to the channel.
- *
- * @const DISPATCH_MACH_NEEDS_DEFERRED_SEND
- * The message could not be sent synchronously. Only returned from a send with
- * result operation and never passed to a channel handler. Indicates that the
- * message passed to the send operation must not be disposed of until it is
- * returned via the channel handler.
- *
- * @const DISPATCH_MACH_SIGTERM_RECEIVED
- * A SIGTERM signal has been received. This notification is delivered at most
- * once during the lifetime of the channel. This event is sent only for XPC
- * channels (i.e. channels that were created by calling
- * dispatch_mach_create_4libxpc()) and only if the
- * dmxh_enable_sigterm_notification function in the XPC hooks structure returned
- * true when it was called at channel activation time.
- *
- * @const DISPATCH_MACH_ASYNC_WAITER_DISCONNECTED
- * The channel has been disconnected by a call to dispatch_mach_reconnect() or
- * dispatch_mach_cancel(), an empty message is passed in the message parameter
- * (so that associated port rights can be disposed of). The message header will
- * contain a local port with the receive right previously allocated to receive
- * an asynchronous reply to a message previously sent to the channel. Used
- * only if the channel is disconnected while waiting for a reply to a message
- * sent with dispatch_mach_send_with_result_and_async_reply_4libxpc().
- */
-DISPATCH_ENUM(dispatch_mach_reason, unsigned long,
-	DISPATCH_MACH_CONNECTED = 1,
-	DISPATCH_MACH_MESSAGE_RECEIVED,
-	DISPATCH_MACH_MESSAGE_SENT,
-	DISPATCH_MACH_MESSAGE_SEND_FAILED,
-	DISPATCH_MACH_MESSAGE_NOT_SENT,
-	DISPATCH_MACH_BARRIER_COMPLETED,
-	DISPATCH_MACH_DISCONNECTED,
-	DISPATCH_MACH_CANCELED,
-	DISPATCH_MACH_REPLY_RECEIVED,
-	DISPATCH_MACH_NEEDS_DEFERRED_SEND,
-	DISPATCH_MACH_SIGTERM_RECEIVED,
-	DISPATCH_MACH_ASYNC_WAITER_DISCONNECTED,
-	DISPATCH_MACH_REASON_LAST, /* unused */
-);
-
-/*!
- * @typedef dispatch_mach_send_flags_t
- * Flags that can be passed to the *with_flags send functions.
- */
-DISPATCH_ENUM(dispatch_mach_send_flags, unsigned long,
-	DISPATCH_MACH_SEND_DEFAULT = 0,
-);
-
-/*!
- * @typedef dispatch_mach_trailer_t
- * Trailer type of mach message received by dispatch mach channels
- */
-
-typedef mach_msg_context_trailer_t dispatch_mach_trailer_t;
-
-/*!
- * @constant DISPATCH_MACH_RECEIVE_MAX_INLINE_MESSAGE_SIZE
- * Maximum size of a message that can be received inline by a dispatch mach
- * channel, reception of larger messages requires an extra roundtrip through
- * the kernel.
- */
-
-#define DISPATCH_MACH_RECEIVE_MAX_INLINE_MESSAGE_SIZE \
-		(0x4000 - sizeof(dispatch_mach_trailer_t))
-
-/*!
- * @typedef dispatch_mach_msg_t
- * A dispatch mach message encapsulates messages received or sent with dispatch
- * mach channels.
- */
-DISPATCH_DECL(dispatch_mach_msg);
-
-/*!
- * @typedef dispatch_mach_msg_destructor_t
- * Dispatch mach message object destructors.
- *
- * @const DISPATCH_MACH_MSG_DESTRUCTOR_DEFAULT
- * Message buffer storage is internal to the object, if a buffer is supplied
- * during object creation, its contents are copied.
- *
- * @const DISPATCH_MACH_MSG_DESTRUCTOR_FREE
- * Message buffer will be deallocated with free(3).
- *
- * @const DISPATCH_MACH_MSG_DESTRUCTOR_FREE
- * Message buffer will be deallocated with vm_deallocate.
- */
-DISPATCH_ENUM(dispatch_mach_msg_destructor, unsigned int,
-	DISPATCH_MACH_MSG_DESTRUCTOR_DEFAULT = 0,
-	DISPATCH_MACH_MSG_DESTRUCTOR_FREE,
-	DISPATCH_MACH_MSG_DESTRUCTOR_VM_DEALLOCATE,
-);
-
-/*!
- * @function dispatch_mach_msg_create
- * Creates a dispatch mach message object, either with a newly allocated message
- * buffer of given size, or from an existing message buffer that will be
- * deallocated with the specified destructor when the object is released.
- *
- * If a non-NULL reference to a pointer is provided in 'msg_ptr', it is filled
- * with the location of the (possibly newly allocated) message buffer.
- *
- * It is the responsibility of the application to ensure that it does not modify
- * the underlying message buffer once the dispatch mach message object is passed
- * to other dispatch mach API.
- *
- * @param msg			The message buffer to create the message object from.
- *						If 'destructor' is DISPATCH_MACH_MSG_DESTRUCTOR_DEFAULT,
- *						this argument may be NULL to leave the newly allocated
- *						message buffer zero-initialized.
- * @param size			The size of the message buffer.
- *						Must be >= sizeof(mach_msg_header_t)
- * @param destructor	The destructor to use to deallocate the message buffer
- *						when the object is released.
- * @param msg_ptr		A pointer to a pointer variable to be filled with the
- *						location of the (possibly newly allocated) message
- *						buffer, or NULL.
- * @result				A newly created dispatch mach message object.
- */
-API_AVAILABLE(macos(10.9), ios(7.0))
-DISPATCH_EXPORT DISPATCH_MALLOC DISPATCH_RETURNS_RETAINED DISPATCH_WARN_RESULT
-DISPATCH_NOTHROW
-dispatch_mach_msg_t
-dispatch_mach_msg_create(mach_msg_header_t *_Nullable msg, size_t size,
-		dispatch_mach_msg_destructor_t destructor,
-		mach_msg_header_t *_Nonnull *_Nullable msg_ptr);
-
-/*!
- * @function dispatch_mach_msg_get_msg
- * Returns the message buffer underlying a dispatch mach message object.
- *
- * @param message	The dispatch mach message object to query.
- * @param size_ptr	A pointer to a size_t variable to be filled with the
- *					size of the message buffer, or NULL.
- * @result			Pointer to message buffer underlying the object.
- */
-API_AVAILABLE(macos(10.9), ios(7.0))
-DISPATCH_EXPORT DISPATCH_NONNULL1 DISPATCH_NOTHROW
-mach_msg_header_t*
-dispatch_mach_msg_get_msg(dispatch_mach_msg_t message,
-		size_t *_Nullable size_ptr);
-
-#ifdef __BLOCKS__
-/*!
- * @typedef dispatch_mach_handler_t
- * Prototype of dispatch mach channel handler blocks.
- *
- * @param reason	Reason the handler was invoked.
- * @param message	Message object that was sent or received.
- * @param error		Mach error code for the send operation.
- */
-typedef void (^dispatch_mach_handler_t)(dispatch_mach_reason_t reason,
-		dispatch_mach_msg_t _Nullable message, mach_error_t error);
-
-/*!
- * @function dispatch_mach_create
- * Create a dispatch mach channel to asynchronously receive and send mach
- * messages.
- *
- * The specified handler will be called with the corresponding reason parameter
- * for each message received and for each message that was successfully sent,
- * that failed to be sent, or was not sent; as well as when a barrier block
- * has completed, or when channel connection, reconnection or cancellation has
- * taken effect.
- *
- * Dispatch mach channels are created in a disconnected state, they must be
- * connected via dispatch_mach_connect() to begin receiving and sending
- * messages.
- *
- * @param label
- * An optional string label to attach to the channel. The string is not copied,
- * if it is non-NULL it must point to storage that remains valid for the
- * lifetime of the channel object. May be NULL.
- *
- * @param queue
- * The target queue of the channel, where the handler and barrier blocks will
- * be submitted.
- *
- * @param handler
- * The handler block to submit when a message has been sent or received.
- *
- * @result
- * The newly created dispatch mach channel.
- */
-API_AVAILABLE(macos(10.9), ios(6.0))
-DISPATCH_EXPORT DISPATCH_MALLOC DISPATCH_RETURNS_RETAINED DISPATCH_WARN_RESULT
-DISPATCH_NONNULL3 DISPATCH_NOTHROW
-dispatch_mach_t
-dispatch_mach_create(const char *_Nullable label,
-		dispatch_queue_t _Nullable queue, dispatch_mach_handler_t handler);
-#endif
-
-/*!
- * @typedef dispatch_mach_handler_function_t
- * Prototype of dispatch mach channel handler functions.
- *
- * @param context	Application-defined context parameter.
- * @param reason	Reason the handler was invoked.
- * @param message	Message object that was sent or received.
- * @param error		Mach error code for the send operation.
- */
-typedef void (*dispatch_mach_handler_function_t)(void *_Nullable context,
-		dispatch_mach_reason_t reason, dispatch_mach_msg_t _Nullable message,
-		mach_error_t error);
-
-/*!
- * @function dispatch_mach_create_f
- * Create a dispatch mach channel to asynchronously receive and send mach
- * messages.
- *
- * The specified handler will be called with the corresponding reason parameter
- * for each message received and for each message that was successfully sent,
- * that failed to be sent, or was not sent; as well as when a barrier block
- * has completed, or when channel connection, reconnection or cancellation has
- * taken effect.
- *
- * Dispatch mach channels are created in a disconnected state, they must be
- * connected via dispatch_mach_connect() to begin receiving and sending
- * messages.
- *
- * @param label
- * An optional string label to attach to the channel. The string is not copied,
- * if it is non-NULL it must point to storage that remains valid for the
- * lifetime of the channel object. May be NULL.
- *
- * @param queue
- * The target queue of the channel, where the handler and barrier blocks will
- * be submitted.
- *
- * @param context
- * The application-defined context to pass to the handler.
- *
- * @param handler
- * The handler function to submit when a message has been sent or received.
- *
- * @result
- * The newly created dispatch mach channel.
- */
-API_AVAILABLE(macos(10.9), ios(6.0))
-DISPATCH_EXPORT DISPATCH_MALLOC DISPATCH_RETURNS_RETAINED DISPATCH_WARN_RESULT
-DISPATCH_NONNULL4 DISPATCH_NOTHROW
-dispatch_mach_t
-dispatch_mach_create_f(const char *_Nullable label,
-		dispatch_queue_t _Nullable queue, void *_Nullable context,
-		dispatch_mach_handler_function_t handler);
-
-/*!
- * @function dispatch_mach_connect
- * Connect a mach channel to the specified receive and send rights.
- *
- * This function must only be called once during the lifetime of a channel, it
- * will initiate message reception and perform any already submitted message
- * sends or barrier operations.
- *
- * @param channel
- * The mach channel to connect.
- *
- * @param receive
- * The receive right to associate with the channel. May be MACH_PORT_NULL.
- *
- * @param send
- * The send right to associate with the channel. May be MACH_PORT_NULL.
- *
- * @param checkin
- * An optional message object encapsulating the initial check-in message to send
- * upon channel connection. The check-in message is sent immediately before the
- * first message submitted via dispatch_mach_send(). The message object will be
- * retained until the initial send operation is complete (or not peformed due
- * to channel cancellation or reconnection) and the channel handler has
- * returned. May be NULL.
- */
-API_AVAILABLE(macos(10.9), ios(6.0))
-DISPATCH_EXPORT DISPATCH_NONNULL1 DISPATCH_NOTHROW
-void
-dispatch_mach_connect(dispatch_mach_t channel, mach_port_t receive,
-		mach_port_t send, dispatch_mach_msg_t _Nullable checkin);
-
-/*!
- * @function dispatch_mach_reconnect
- * Reconnect a mach channel to the specified send right.
- *
- * Disconnects the channel from the current send right, interrupts any pending
- * message sends (and returns the messages as unsent), and reconnects the
- * channel to a new send right.
- *
- * The application must wait for the channel handler to be invoked with
- * DISPATCH_MACH_DISCONNECTED before releasing the previous send right.
- *
- * @param channel
- * The mach channel to reconnect.
- *
- * @param send
- * The new send right to associate with the channel. May be MACH_PORT_NULL.
- *
- * @param checkin
- * An optional message object encapsulating the initial check-in message to send
- * upon channel reconnection. The check-in message is sent immediately before
- * the first message submitted via dispatch_mach_send() after this function
- * returns. The message object will be retained until the initial send operation
- * is complete (or not peformed due to channel cancellation or reconnection)
- * and the channel handler has returned. May be NULL.
- */
-API_AVAILABLE(macos(10.9), ios(6.0))
-DISPATCH_EXPORT DISPATCH_NONNULL1 DISPATCH_NOTHROW
-void
-dispatch_mach_reconnect(dispatch_mach_t channel, mach_port_t send,
-		dispatch_mach_msg_t _Nullable checkin);
-
-/*!
- * @function dispatch_mach_cancel
- * Cancel a mach channel, preventing any further messages from being sent or
- * received.
- *
- * The application must wait for the channel handler to be invoked with
- * DISPATCH_MACH_DISCONNECTED before releasing the underlying send and receive
- * rights.
- *
- * Note: explicit cancellation of mach channels is required, no implicit
- *       cancellation takes place on release of the last application reference
- *       to the channel object. Failure to cancel will cause the channel and
- *       its associated resources to be leaked.
- *
- * @param channel
- * The mach channel to cancel.
- */
-API_AVAILABLE(macos(10.9), ios(6.0))
-DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW
-void
-dispatch_mach_cancel(dispatch_mach_t channel);
-
-/*!
- * @function dispatch_mach_mig_demux
- *
- * @abstract
- * Handles an incoming DISPATCH_MACH_MESSAGE_RECEIVED event through a series of
- * MIG subsystem demultiplexers.
- *
- * @discussion
- * This function can be used with a static array of MIG subsystems to try.
- * If it returns true, then the dispatch mach message has been consumed as per
- * usual MIG rules.
- *
- * If it returns false, then the mach message has not been touched, and
- * consuming or disposing of the rights in the message is mandatory.
- *
- * It is hence possible to write a manual demuxer this way:
- *
- * <code>
- * if (!dispatch_mach_mig_demux(context, subsystems, count, message)) {
- *     mach_msg_header_t hdr = dispatch_mach_msg_get_msg(message, NULL);
- *     switch (hdr->msgh_id) {
- *     case ...: // manual consumption of messages
- *         ...
- *         break;
- *     default:
- *         mach_msg_destroy(hdr); // no one claimed the message, destroy it
- *     }
- * }
- * </code>
- *
- * @param context
- * An optional context that the MIG routines can query with
- * dispatch_mach_mig_demux_get_context() as MIG doesn't support contexts.
- *
- * @param subsystems
- * An array of mig_subsystem structs for all the demuxers to try.
- * These are exposed by MIG in the Server header of the generated interface.
- *
- * @param count
- * The number of entries in the subsystems array.
- *
- * @param msg
- * The dispatch mach message to process.
- *
- * @returns
- * Whether or not the dispatch mach message has been consumed.
- * If false is returned, then it is the responsibility of the caller to consume
- * or dispose of the received message rights.
- */
-API_AVAILABLE(macos(10.14), ios(12.0), tvos(12.0), watchos(5.0))
-DISPATCH_EXPORT DISPATCH_NONNULL2 DISPATCH_NONNULL4 DISPATCH_NOTHROW
-bool
-dispatch_mach_mig_demux(void *_Nullable context,
-		const struct mig_subsystem *_Nonnull const subsystems[_Nonnull],
-		size_t count, dispatch_mach_msg_t msg);
-
-/*!
- * @function dispatch_mach_mig_demux_get_context
- *
- * @abstract
- * Returns the context passed to dispatch_mach_mig_demux() from the context of
- * a MIG routine implementation.
- *
- * @discussion
- * Calling this function from another context than a MIG routine called from the
- * context of dispatch_mach_mig_demux_get_context() is invalid and will cause
- * your process to be terminated.
- *
- * @returns
- * The context passed to the outer call to dispatch_mach_mig_demux().
- */
-API_AVAILABLE(macos(10.14), ios(12.0), tvos(12.0), watchos(5.0))
-DISPATCH_EXPORT DISPATCH_NOTHROW
-void *_Nullable
-dispatch_mach_mig_demux_get_context(void);
-
-/*!
- * @function dispatch_mach_send
- * Asynchronously send a message encapsulated in a dispatch mach message object
- * to the specified mach channel.
- *
- * Unless the message is being sent to a send-once right (as determined by the
- * presence of MACH_MSG_TYPE_MOVE_SEND_ONCE in the message header remote bits),
- * the message header remote port is set to the channel send right before the
- * send operation is performed.
- *
- * If the message expects a direct reply (as determined by the presence of
- * MACH_MSG_TYPE_MAKE_SEND_ONCE in the message header local bits) the receive
- * right specified in the message header local port will be monitored until a
- * reply message (or a send-once notification) is received, or the channel is
- * canceled. Hence the application must wait for the channel handler to be
- * invoked with a DISPATCH_MACH_DISCONNECTED message before releasing that
- * receive right.
- *
- * If the message send operation is attempted but the channel is canceled
- * before the send operation succesfully completes, the message returned to the
- * channel handler with DISPATCH_MACH_MESSAGE_NOT_SENT may be the result of a
- * pseudo-receive operation. If the message expected a direct reply, the
- * receive right originally specified in the message header local port will
- * returned in a DISPATCH_MACH_DISCONNECTED message.
- *
- * @param channel
- * The mach channel to which to send the message.
- *
- * @param message
- * The message object encapsulating the message to send. The object will be
- * retained until the send operation is complete and the channel handler has
- * returned. The storage underlying the message object may be modified by the
- * send operation.
- *
- * @param options
- * Additional send options to pass to mach_msg() when performing the send
- * operation.
- */
-API_AVAILABLE(macos(10.9), ios(6.0))
-DISPATCH_EXPORT DISPATCH_NONNULL1 DISPATCH_NONNULL2 DISPATCH_NOTHROW
-void
-dispatch_mach_send(dispatch_mach_t channel, dispatch_mach_msg_t message,
-		mach_msg_option_t options);
-
-/*!
- * @function dispatch_mach_send_with_result
- * Asynchronously send a message encapsulated in a dispatch mach message object
- * to the specified mach channel. If an immediate send can be performed, return
- * its result via out parameters.
- *
- * Unless the message is being sent to a send-once right (as determined by the
- * presence of MACH_MSG_TYPE_MOVE_SEND_ONCE in the message header remote bits),
- * the message header remote port is set to the channel send right before the
- * send operation is performed.
- *
- * If the message expects a direct reply (as determined by the presence of
- * MACH_MSG_TYPE_MAKE_SEND_ONCE in the message header local bits) the receive
- * right specified in the message header local port will be monitored until a
- * reply message (or a send-once notification) is received, or the channel is
- * canceled. Hence the application must wait for the channel handler to be
- * invoked with a DISPATCH_MACH_DISCONNECTED message before releasing that
- * receive right.
- *
- * If the message send operation is attempted but the channel is canceled
- * before the send operation succesfully completes, the message returned to the
- * channel handler with DISPATCH_MACH_MESSAGE_NOT_SENT may be the result of a
- * pseudo-receive operation. If the message expected a direct reply, the
- * receive right originally specified in the message header local port will
- * returned in a DISPATCH_MACH_DISCONNECTED message.
- *
- * If an immediate send could be performed, returns the resulting reason
- * (e.g. DISPATCH_MACH_MESSAGE_SENT) and possible error to the caller in the
- * send_result and send_error out parameters (instead of via the channel
- * handler), in which case the passed-in message and associated resources
- * can be disposed of synchronously.
- *
- * If a deferred send is required, returns DISPATCH_MACH_NEEDS_DEFERRED_SEND
- * in the send_result out parameter to indicate that the passed-in message has
- * been retained and associated resources must not be disposed of until the
- * message is returned asynchronusly via the channel handler.
- *
- * @param channel
- * The mach channel to which to send the message.
- *
- * @param message
- * The message object encapsulating the message to send. Unless an immediate
- * send could be performed, the object will be retained until the asynchronous
- * send operation is complete and the channel handler has returned. The storage
- * underlying the message object may be modified by the send operation.
- *
- * @param options
- * Additional send options to pass to mach_msg() when performing the send
- * operation.
- *
- * @param send_flags
- * Flags to configure the send operation. Must be 0 for now.
- *
- * @param send_result
- * Out parameter to return the result of the immediate send attempt.
- * If a deferred send is required, returns DISPATCH_MACH_NEEDS_DEFERRED_SEND.
- * Must not be NULL.
- *
- * @param send_error
- * Out parameter to return the error from the immediate send attempt.
- * If a deferred send is required, returns 0. Must not be NULL.
- */
-API_AVAILABLE(macos(10.12), ios(10.0), tvos(10.0), watchos(3.0))
-DISPATCH_EXPORT DISPATCH_NONNULL1 DISPATCH_NONNULL2 DISPATCH_NONNULL5
-DISPATCH_NONNULL6 DISPATCH_NOTHROW
-void
-dispatch_mach_send_with_result(dispatch_mach_t channel,
-		dispatch_mach_msg_t message, mach_msg_option_t options,
-		dispatch_mach_send_flags_t send_flags,
-		dispatch_mach_reason_t *send_result, mach_error_t *send_error);
-
-/*!
- * @function dispatch_mach_send_and_wait_for_reply
- * Synchronously send a message encapsulated in a dispatch mach message object
- * to the specified mach channel and wait for a reply.
- *
- * Unless the message is being sent to a send-once right (as determined by the
- * presence of MACH_MSG_TYPE_MOVE_SEND_ONCE in the message header remote bits),
- * the message header remote port is set to the channel send right before the
- * send operation is performed.
- *
- * The message is required to expect a direct reply (as determined by the
- * presence of MACH_MSG_TYPE_MAKE_SEND_ONCE in the message header local bits)
- * and this function will not complete until the receive right specified in the
- * message header local port receives a reply message (or a send-once
- * notification) which will be returned, or until that receive right is
- * destroyed in response to the channel being canceled, in which case NULL will
- * be returned.
- * In all these cases the application must wait for the channel handler to
- * be invoked with a DISPATCH_MACH_REPLY_RECEIVED or DISPATCH_MACH_DISCONNECTED
- * message before releasing that receive right.
- *
- * Alternatively, the application may specify MACH_PORT_NULL in the header local
- * port to indicate that the channel should create and manage the reply receive
- * right internally, including destroying it upon channel cancellation.
- * This is a more efficient mode of operation as no asynchronous operations are
- * required to return the receive right (i.e. the channel handler will not be
- * called as described above).
- *
- * If the message send operation is attempted but the channel is canceled
- * before the send operation succesfully completes, the message returned to the
- * channel handler with DISPATCH_MACH_MESSAGE_NOT_SENT may be the result of a
- * pseudo-receive operation. The receive right originally specified in the
- * message header local port will returned in a DISPATCH_MACH_DISCONNECTED
- * message (unless it was MACH_PORT_NULL).
- *
- * @param channel
- * The mach channel to which to send the message.
- *
- * @param message
- * The message object encapsulating the message to send. The object will be
- * retained until the send operation is complete and the channel handler has
- * returned. The storage underlying the message object may be modified by the
- * send operation.
- *
- * @param options
- * Additional send options to pass to mach_msg() when performing the send
- * operation.
- *
- * @result
- * The received reply message object, or NULL if the channel was canceled.
- */
-API_AVAILABLE(macos(10.11), ios(9.0))
-DISPATCH_EXPORT DISPATCH_MALLOC DISPATCH_RETURNS_RETAINED DISPATCH_WARN_RESULT
-DISPATCH_NONNULL1 DISPATCH_NONNULL2 DISPATCH_NOTHROW
-dispatch_mach_msg_t _Nullable
-dispatch_mach_send_and_wait_for_reply(dispatch_mach_t channel,
-		dispatch_mach_msg_t message, mach_msg_option_t options);
-
-/*!
- * @function dispatch_mach_send_with_result_and_wait_for_reply
- * Synchronously send a message encapsulated in a dispatch mach message object
- * to the specified mach channel and wait for a reply. If an immediate send can
- * be performed, return its result via out parameters.
- *
- * Unless the message is being sent to a send-once right (as determined by the
- * presence of MACH_MSG_TYPE_MOVE_SEND_ONCE in the message header remote bits),
- * the message header remote port is set to the channel send right before the
- * send operation is performed.
- *
- * The message is required to expect a direct reply (as determined by the
- * presence of MACH_MSG_TYPE_MAKE_SEND_ONCE in the message header local bits)
- * and this function will not complete until the receive right specified in the
- * message header local port receives a reply message (or a send-once
- * notification) which will be returned, or until that receive right is
- * destroyed in response to the channel being canceled, in which case NULL will
- * be returned.
- * In all these cases the application must wait for the channel handler to
- * be invoked with a DISPATCH_MACH_REPLY_RECEIVED or DISPATCH_MACH_DISCONNECTED
- * message before releasing that receive right.
- *
- * Alternatively, the application may specify MACH_PORT_NULL in the header local
- * port to indicate that the channel should create and manage the reply receive
- * right internally, including destroying it upon channel cancellation.
- * This is a more efficient mode of operation as no asynchronous operations are
- * required to return the receive right (i.e. the channel handler will not be
- * called as described above).
- *
- * If the message send operation is attempted but the channel is canceled
- * before the send operation succesfully completes, the message returned to the
- * channel handler with DISPATCH_MACH_MESSAGE_NOT_SENT may be the result of a
- * pseudo-receive operation. The receive right originally specified in the
- * message header local port will returned in a DISPATCH_MACH_DISCONNECTED
- * message (unless it was MACH_PORT_NULL).
- *
- * If an immediate send could be performed, returns the resulting reason
- * (e.g. DISPATCH_MACH_MESSAGE_SENT) and possible error to the caller in the
- * send_result and send_error out parameters (instead of via the channel
- * handler), in which case the passed-in message and associated resources
- * can be disposed of synchronously.
- *
- * If a deferred send is required, returns DISPATCH_MACH_NEEDS_DEFERRED_SEND
- * in the send_result out parameter to indicate that the passed-in message has
- * been retained and associated resources must not be disposed of until the
- * message is returned asynchronusly via the channel handler.
- *
- * @param channel
- * The mach channel to which to send the message.
- *
- * @param message
- * The message object encapsulating the message to send. Unless an immediate
- * send could be performed, the object will be retained until the asynchronous
- * send operation is complete and the channel handler has returned. The storage
- * underlying the message object may be modified by the send operation.
- *
- * @param options
- * Additional send options to pass to mach_msg() when performing the send
- * operation.
- *
- * @param send_flags
- * Flags to configure the send operation. Must be 0 for now.
- *
- * @param send_result
- * Out parameter to return the result of the immediate send attempt.
- * If a deferred send is required, returns DISPATCH_MACH_NEEDS_DEFERRED_SEND.
- * Must not be NULL.
- *
- * @param send_error
- * Out parameter to return the error from the immediate send attempt.
- * If a deferred send is required, returns 0. Must not be NULL.
- *
- * @result
- * The received reply message object, or NULL if the channel was canceled.
- */
-API_AVAILABLE(macos(10.12), ios(10.0), tvos(10.0), watchos(3.0))
-DISPATCH_EXPORT DISPATCH_MALLOC DISPATCH_RETURNS_RETAINED DISPATCH_WARN_RESULT
-DISPATCH_NONNULL1 DISPATCH_NONNULL2 DISPATCH_NONNULL5 DISPATCH_NONNULL6
-DISPATCH_NOTHROW
-dispatch_mach_msg_t _Nullable
-dispatch_mach_send_with_result_and_wait_for_reply(dispatch_mach_t channel,
-		dispatch_mach_msg_t message, mach_msg_option_t options,
-		dispatch_mach_send_flags_t send_flags,
-		dispatch_mach_reason_t *send_result, mach_error_t *send_error);
-
-#ifdef __BLOCKS__
-/*!
- * @function dispatch_mach_send_barrier
- * Submit a send barrier to the specified mach channel. Messages submitted to
- * the channel before the barrier will be sent before the barrier block is
- * executed, and messages submitted to the channel after the barrier will only
- * be sent once the barrier block has completed and the channel handler
- * invocation for the barrier has returned.
- *
- * @param channel
- * The mach channel to which to submit the barrier.
- *
- * @param barrier
- * The barrier block to submit to the channel target queue.
- */
-API_AVAILABLE(macos(10.9), ios(6.0))
-DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW
-void
-dispatch_mach_send_barrier(dispatch_mach_t channel, dispatch_block_t barrier);
-#endif
-
-/*!
- * @function dispatch_mach_send_barrier_f
- * Submit a send barrier to the specified mach channel. Messages submitted to
- * the channel before the barrier will be sent before the barrier block is
- * executed, and messages submitted to the channel after the barrier will only
- * be sent once the barrier block has completed and the channel handler
- * invocation for the barrier has returned.
- *
- * @param channel
- * The mach channel to which to submit the barrier.
- *
- * @param context
- * The application-defined context parameter to pass to the function.
- *
- * @param barrier
- * The barrier function to submit to the channel target queue.
- */
-API_AVAILABLE(macos(10.9), ios(6.0))
-DISPATCH_EXPORT DISPATCH_NONNULL1 DISPATCH_NONNULL3 DISPATCH_NOTHROW
-void
-dispatch_mach_send_barrier_f(dispatch_mach_t channel, void *_Nullable context,
-		dispatch_function_t barrier);
-
-#ifdef __BLOCKS__
-/*!
- * @function dispatch_mach_receive_barrier
- * Submit a receive barrier to the specified mach channel. Channel handlers for
- * messages received by the channel after the receive barrier has been
- * submitted will only be invoked once the barrier block has completed and the
- * channel handler invocation for the barrier has returned.
- *
- * @param channel
- * The mach channel to which to submit the receive barrier.
- *
- * @param barrier
- * The barrier block to submit to the channel target queue.
- */
-API_AVAILABLE(macos(10.9), ios(6.0))
-DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW
-void
-dispatch_mach_receive_barrier(dispatch_mach_t channel,
-		dispatch_block_t barrier);
-#endif
-
-/*!
- * @function dispatch_mach_receive_barrier_f
- * Submit a receive barrier to the specified mach channel. Channel handlers for
- * messages received by the channel after the receive barrier has been
- * submitted will only be invoked once the barrier block has completed and the
- * channel handler invocation for the barrier has returned.
- *
- * @param channel
- * The mach channel to which to submit the receive barrier.
- *
- * @param context
- * The application-defined context parameter to pass to the function.
- *
- * @param barrier
- * The barrier function to submit to the channel target queue.
- */
-API_AVAILABLE(macos(10.9), ios(6.0))
-DISPATCH_EXPORT DISPATCH_NONNULL1 DISPATCH_NONNULL3 DISPATCH_NOTHROW
-void
-dispatch_mach_receive_barrier_f(dispatch_mach_t channel, void *_Nullable context,
-		dispatch_function_t barrier);
-
-/*!
- * @function dispatch_mach_get_checkin_port
- * Returns the port specified in the message header remote port of the check-in
- * message passed to the most recent invocation of dispatch_mach_connect() or
- * dispatch_mach_reconnect() for the provided mach channel (irrespective of the
- * completion of the (re)connect or check-in operations in question).
- *
- * Returns MACH_PORT_NULL if dispatch_mach_connect() has not yet been called or
- * if the most recently specified check-in message was NULL, and MACH_PORT_DEAD
- * if the channel has been canceled.
- *
- * It is the responsibility of the application to ensure that the port
- * specified in a check-in message remains valid at the time this function is
- * called.
- *
- * @param channel
- * The mach channel to query.
- *
- * @result
- * The most recently specified check-in port for the channel.
- */
-API_AVAILABLE(macos(10.9), ios(6.0))
-DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW
-mach_port_t
-dispatch_mach_get_checkin_port(dispatch_mach_t channel);
-
-// SPI for libxpc
-/*
- * Type for the callback for receipt of asynchronous replies to
- * dispatch_mach_send_with_result_and_async_reply_4libxpc().
- */
-typedef void (*_Nonnull dispatch_mach_async_reply_callback_t)(void *context,
-		dispatch_mach_reason_t reason, dispatch_mach_msg_t message);
-
-API_AVAILABLE(macos(10.13), ios(11.0), tvos(11.0), watchos(4.0))
-typedef const struct dispatch_mach_xpc_hooks_s {
-#define DISPATCH_MACH_XPC_MIN_HOOKS_VERSION 3
-#define DISPATCH_MACH_XPC_HOOKS_VERSION     3
-	unsigned long version;
-
-	/* Fields available in version 1. */
-
-	/*
-	 * Called to handle a Mach message event inline if possible. Returns true
-	 * if the event was handled, false if the event should be delivered to the
-	 * channel event handler. The implementation should not make any assumptions
-	 * about the thread in which the function is called and cannot assume that
-	 * invocations of this function are serialized relative to each other or
-	 * relative to the channel's event handler function. In addition, the
-	 * handler must not throw an exception or call out to any code that might
-	 * throw an exception.
-	 */
-	bool (* _Nonnull dmxh_direct_message_handler)(void *_Nullable context,
-			dispatch_mach_reason_t reason, dispatch_mach_msg_t message,
-			mach_error_t error);
-
-	/* Fields available in version 2. */
-
-	/*
-	 * Gets the queue to which a reply to a message sent using
-	 * dispatch_mach_send_with_result_and_async_reply_4libxpc() should be
-	 * delivered. The msg_context argument is the value of the do_ctxt field
-	 * of the outgoing message, as returned by dispatch_get_context().
-	 *
-	 * This function should return a consistent result until an event is
-	 * received for this message. This function must return NULL if
-	 * dispatch_mach_send_with_result_and_async_reply_4libxpc() wasn't used to
-	 * send the message, and non NULL otherwise.
-	 */
-	dispatch_queue_t _Nullable (*_Nonnull dmxh_msg_context_reply_queue)(
-			void *_Nonnull msg_context);
-
-	/*
-	 * Called when a reply to a message sent by
-	 * dispatch_mach_send_with_result_and_async_reply_4libxpc() is received. The
-	 * message argument points to the reply message and the context argument is
-	 * the context value passed to dispatch_mach_create_4libxpc() when creating
-	 * the Mach channel. The handler is called on the queue that is returned by
-	 * dmxh_msg_context_reply_queue() when the reply is received or if the
-	 * channel is disconnected. The reason argument is
-	 * DISPATCH_MACH_MESSAGE_RECEIVED if a reply has been received or
-	 * DISPATCH_MACH_ASYNC_WAITER_DISCONNECTED if the channel has been
-	 * disconnected. Refer to the documentation for
-	 * dispatch_mach_send_with_result_and_async_reply_4libxpc() for more
-	 * details.
-	 */
-	dispatch_mach_async_reply_callback_t dmxh_async_reply_handler;
-
-	/* Fields available in version 3. */
-	/**
-	 * Called once when the Mach channel has been activated. If this function
-	 * returns true, a DISPATCH_MACH_SIGTERM_RECEIVED notification will be
-	 * delivered to the channel's event handler when a SIGTERM is received.
-	 */
-	bool (*_Nonnull dmxh_enable_sigterm_notification)(
-			void *_Nullable context);
-} *dispatch_mach_xpc_hooks_t;
-
-/*!
- * @function dispatch_mach_hooks_install_4libxpc
- *
- * @abstract
- * installs XPC callbacks for dispatch Mach channels.
- *
- * @discussion
- * In order to improve the performance of the XPC/dispatch interface, it is
- * sometimes useful for dispatch to be able to call directly into XPC. The
- * channel hooks structure should be initialized with pointers to XPC callback
- * functions, or NULL for callbacks that XPC does not support. The version
- * number in the structure must be set to reflect the fields that have been
- * initialized. This function may be called only once.
- *
- * @param hooks
- * A pointer to the channel hooks structure. This must remain valid once set.
- */
-API_AVAILABLE(macos(10.13), ios(11.0), tvos(11.0), watchos(4.0))
-DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW
-void
-dispatch_mach_hooks_install_4libxpc(dispatch_mach_xpc_hooks_t hooks);
-
-/*!
- * @function dispatch_mach_create_4libxpc
- * Create a dispatch mach channel to asynchronously receive and send mach
- * messages, specifically for libxpc.
- *
- * The specified handler will be called with the corresponding reason parameter
- * for each message received and for each message that was successfully sent,
- * that failed to be sent, or was not sent; as well as when a barrier block
- * has completed, or when channel connection, reconnection or cancellation has
- * taken effect. However, the handler will not be called for messages that
- * were passed to the XPC hooks dmxh_direct_message_handler function if that
- * function returned true.
- *
- * Dispatch mach channels are created in a disconnected state, they must be
- * connected via dispatch_mach_connect() to begin receiving and sending
- * messages.
- *
- * @param label
- * An optional string label to attach to the channel. The string is not copied,
- * if it is non-NULL it must point to storage that remains valid for the
- * lifetime of the channel object. May be NULL.
- *
- * @param queue
- * The target queue of the channel, where the handler and barrier blocks will
- * be submitted.
- *
- * @param context
- * The application-defined context to pass to the handler.
- *
- * @param handler
- * The handler function to submit when a message has been sent or received.
- *
- * @result
- * The newly created dispatch mach channel.
- */
-API_AVAILABLE(macos(10.13), ios(11.0), tvos(11.0), watchos(4.0))
-DISPATCH_EXPORT DISPATCH_MALLOC DISPATCH_RETURNS_RETAINED DISPATCH_WARN_RESULT
-DISPATCH_NONNULL4 DISPATCH_NOTHROW
-dispatch_mach_t
-dispatch_mach_create_4libxpc(const char *_Nullable label,
-		dispatch_queue_t _Nullable queue, void *_Nullable context,
-		dispatch_mach_handler_function_t handler);
-
-/*!
- * @function dispatch_mach_send_with_result_and_async_reply_4libxpc
- * SPI for XPC that asynchronously sends a message encapsulated in a dispatch
- * mach message object to the specified mach channel. If an immediate send can
- * be performed, returns its result via out parameters.
- *
- * The reply message is processed on the queue returned by the
- * dmxh_msg_context_reply_queue function in the dispatch_mach_xpc_hooks_s
- * structure, which is called with a single argument whose value is the
- * do_ctxt field of the message argument to this function. The reply message is
- * delivered to the dmxh_async_reply_handler hook function instead of being
- * passed to the channel event handler.
- *
- * If the dmxh_msg_context_reply_queue function is not implemented or returns
- * NULL, the reply message is delivered to the channel event handler on the
- * channel queue.
- *
- * Unless the message is being sent to a send-once right (as determined by the
- * presence of MACH_MSG_TYPE_MOVE_SEND_ONCE in the message header remote bits),
- * the message header remote port is set to the channel send right before the
- * send operation is performed.
- *
- * The message is required to expect a direct reply (as determined by the
- * presence of MACH_MSG_TYPE_MAKE_SEND_ONCE in the message header local bits).
- * The receive right specified in the message header local port will be
- * monitored until a reply message (or a send-once notification) is received, or
- * the channel is canceled. Hence the application must wait for the reply
- * to be received or for a DISPATCH_MACH_ASYNC_WAITER_DISCONNECTED message
- * before releasing that receive right.
- *
- * If the message send operation is attempted but the channel is canceled
- * before the send operation succesfully completes, the message returned to the
- * channel handler with DISPATCH_MACH_MESSAGE_NOT_SENT may be the result of a
- * pseudo-receive operation and the receive right originally specified in the
- * message header local port will be returned in a
- * DISPATCH_MACH_ASYNC_WAITER_DISCONNECTED message.
- *
- * If an immediate send could be performed, returns the resulting reason
- * (e.g. DISPATCH_MACH_MESSAGE_SENT) and possible error to the caller in the
- * send_result and send_error out parameters (instead of via the channel
- * handler), in which case the passed-in message and associated resources
- * can be disposed of synchronously.
- *
- * If a deferred send is required, returns DISPATCH_MACH_NEEDS_DEFERRED_SEND
- * in the send_result out parameter to indicate that the passed-in message has
- * been retained and associated resources must not be disposed of until the
- * message is returned asynchronusly via the channel handler.
- *
- * @param channel
- * The mach channel to which to send the message.
- *
- * @param message
- * The message object encapsulating the message to send. Unless an immediate
- * send could be performed, the object will be retained until the asynchronous
- * send operation is complete and the channel handler has returned. The storage
- * underlying the message object may be modified by the send operation.
- *
- * @param options
- * Additional send options to pass to mach_msg() when performing the send
- * operation.
- *
- * @param send_flags
- * Flags to configure the send operation. Must be 0 for now.
- *
- * @param send_result
- * Out parameter to return the result of the immediate send attempt.
- * If a deferred send is required, returns DISPATCH_MACH_NEEDS_DEFERRED_SEND.
- * Must not be NULL.
- *
- * @param send_error
- * Out parameter to return the error from the immediate send attempt.
- * If a deferred send is required, returns 0. Must not be NULL.
- */
-API_AVAILABLE(macos(10.13), ios(11.0), tvos(11.0), watchos(4.0))
-DISPATCH_EXPORT DISPATCH_NONNULL1 DISPATCH_NONNULL2 DISPATCH_NONNULL5
-DISPATCH_NONNULL6 DISPATCH_NOTHROW
-void
-dispatch_mach_send_with_result_and_async_reply_4libxpc(dispatch_mach_t channel,
-		dispatch_mach_msg_t message, mach_msg_option_t options,
-		dispatch_mach_send_flags_t send_flags,
-		dispatch_mach_reason_t *send_result, mach_error_t *send_error);
-
-/*!
- * @function dispatch_mach_handoff_reply_f
- *
- * @abstract
- * Inform the runtime that a given sync IPC is being handed off to a new queue
- * hierarchy.
- *
- * @discussion
- * This function can only be called from the context of an IPC handler, or from
- * a work item created by dispatch_mach_handoff_reply_f. Calling
- * dispatch_mach_handoff_reply_f from a different context is undefined and will
- * cause the process to be terminated.
- *
- * dispatch_mach_handoff_reply_f will only take effect when the work item that
- * issued it returns.
- *
- * @param queue
- * The queue the IPC reply will be handed off to. This queue must be an
- * immutable queue hierarchy (with all nodes created with
- * dispatch_queue_create_with_target() for example).
- *
- * @param port
- * The send once right that will be replied to.
- */
-API_AVAILABLE(macos(10.14), ios(12.0), tvos(12.0), watchos(5.0))
-DISPATCH_EXPORT DISPATCH_NONNULL1 DISPATCH_NONNULL4 DISPATCH_NOTHROW
-void
-dispatch_mach_handoff_reply_f(dispatch_queue_t queue, mach_port_t port,
-		void *_Nullable ctxt, dispatch_function_t func);
-
-/*!
- * @function dispatch_mach_handoff_reply
- *
- * @abstract
- * Inform the runtime that a given sync IPC is being handed off to a new queue
- * hierarchy.
- *
- * @see dispatch_mach_handoff_reply_f
- */
-API_AVAILABLE(macos(10.14), ios(12.0), tvos(12.0), watchos(5.0))
-DISPATCH_EXPORT DISPATCH_NONNULL1 DISPATCH_NONNULL3 DISPATCH_NOTHROW
-void
-dispatch_mach_handoff_reply(dispatch_queue_t queue, mach_port_t port,
-		dispatch_block_t block);
-
-DISPATCH_ASSUME_NONNULL_END
-
-#endif // DISPATCH_MACH_SPI
-
-__END_DECLS
-
-#endif
--- a/Telegram/ThirdParty/dispatch/private/private.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/private/private.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,269 +0,0 @@
-/*
- * Copyright (c) 2008-2013 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-/*
- * IMPORTANT: This header file describes INTERNAL interfaces to libdispatch
- * which are subject to change in future releases of Mac OS X. Any applications
- * relying on these interfaces WILL break.
- */
-
-#ifndef __DISPATCH_PRIVATE__
-#define __DISPATCH_PRIVATE__
-
-#ifdef __APPLE__
-#include <Availability.h>
-#include <os/availability.h>
-#include <TargetConditionals.h>
-#include <os/base.h>
-#elif defined(_WIN32)
-#include <os/generic_win_base.h>
-#elif defined(__unix__)
-#include <os/generic_unix_base.h>
-#endif
-
-#if TARGET_OS_MAC
-#include <mach/boolean.h>
-#include <mach/mach.h>
-#include <mach/message.h>
-#endif
-#if defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))
-#include <unistd.h>
-#endif
-#if !defined(_WIN32)
-#include <pthread.h>
-#endif
-#if TARGET_OS_MAC
-#include <pthread/qos.h>
-#endif
-
-#ifndef __DISPATCH_BUILDING_DISPATCH__
-#include <dispatch/dispatch.h>
-
-#ifndef __DISPATCH_INDIRECT__
-#define __DISPATCH_INDIRECT__
-#endif
-
-#include <dispatch/benchmark.h>
-#include <dispatch/queue_private.h>
-#include <dispatch/workloop_private.h>
-#include <dispatch/source_private.h>
-#if DISPATCH_MACH_SPI
-#include <dispatch/mach_private.h>
-#endif // DISPATCH_MACH_SPI
-#include <dispatch/data_private.h>
-#include <dispatch/io_private.h>
-#include <dispatch/layout_private.h>
-#include <dispatch/time_private.h>
-
-#undef __DISPATCH_INDIRECT__
-#endif /* !__DISPATCH_BUILDING_DISPATCH__ */
-
-// <rdar://problem/9627726> Check that public and private dispatch headers match
-#if DISPATCH_API_VERSION != 20180109 // Keep in sync with <dispatch/dispatch.h>
-#error "Dispatch header mismatch between /usr/include and /usr/local/include"
-#endif
-
-DISPATCH_ASSUME_NONNULL_BEGIN
-
-__BEGIN_DECLS
-
-/*!
- * @function _dispatch_is_multithreaded
- *
- * @abstract
- * Returns true if the current process has become multithreaded by the use
- * of libdispatch functionality.
- *
- * @discussion
- * This SPI is intended for use by low-level system components that need to
- * ensure that they do not make a single-threaded process multithreaded, to
- * avoid negatively affecting child processes of a fork (without exec).
- *
- * Such components must not use any libdispatch functionality if this function
- * returns false.
- *
- * @result
- * Boolean indicating whether the process has used libdispatch and become
- * multithreaded.
- */
-API_AVAILABLE(macos(10.8), ios(6.0))
-DISPATCH_EXPORT DISPATCH_NOTHROW
-bool _dispatch_is_multithreaded(void);
-
-/*!
- * @function _dispatch_is_fork_of_multithreaded_parent
- *
- * @abstract
- * Returns true if the current process is a child of a parent process that had
- * become multithreaded by the use of libdispatch functionality at the time of
- * fork (without exec).
- *
- * @discussion
- * This SPI is intended for use by (rare) low-level system components that need
- * to continue working on the child side of a fork (without exec) of a
- * multithreaded process.
- *
- * Such components must not use any libdispatch functionality if this function
- * returns true.
- *
- * @result
- * Boolean indicating whether the parent process had used libdispatch and
- * become multithreaded at the time of fork.
- */
-API_AVAILABLE(macos(10.9), ios(7.0))
-DISPATCH_EXPORT DISPATCH_NOTHROW
-bool _dispatch_is_fork_of_multithreaded_parent(void);
-
-/*!
- * @function _dispatch_prohibit_transition_to_multithreaded
- *
- * @abstract
- * Sets a mode that aborts if a program tries to use dispatch.
- *
- * @discussion
- * This SPI is intended for use by programs that know they will use fork() and
- * want their children to be able to use dispatch before exec(). Such programs
- * should call _dispatch_prohibit_transition_to_multithreaded(true) as early as
- * possible, which will cause any use of dispatch API that would make the
- * process multithreaded to abort immediately.
- *
- * Once the program no longer intends to call fork() it can call
- * _dispatch_prohibit_transition_to_multithreaded(false).
- *
- * This status is not inherited by the child process, so if the behavior
- * is required after fork, _dispatch_prohibit_transition_to_multithreaded(true)
- * should be called manually in the child after fork.
- *
- * If the program already used dispatch before the guard is enabled, then
- * this function will abort immediately.
- */
-API_AVAILABLE(macos(10.12), ios(10.0), tvos(10.0), watchos(3.0))
-DISPATCH_EXPORT DISPATCH_NOTHROW
-void _dispatch_prohibit_transition_to_multithreaded(bool prohibit);
-
-/*
- * dispatch_time convenience macros
- */
-
-#define _dispatch_time_after_nsec(t) \
-		dispatch_time(DISPATCH_TIME_NOW, (t))
-#define _dispatch_time_after_usec(t) \
-		dispatch_time(DISPATCH_TIME_NOW, (t) * NSEC_PER_USEC)
-#define _dispatch_time_after_msec(t) \
-		dispatch_time(DISPATCH_TIME_NOW, (t) * NSEC_PER_MSEC)
-#define _dispatch_time_after_sec(t) \
-		dispatch_time(DISPATCH_TIME_NOW, (t) * NSEC_PER_SEC)
-
-/*
- * SPI for CoreFoundation/Foundation ONLY
- */
-
-#if TARGET_OS_MAC
-#define DISPATCH_COCOA_COMPAT 1
-#elif defined(__linux__) || defined(__FreeBSD__) || defined(_WIN32)
-#define DISPATCH_COCOA_COMPAT 1
-#else
-#define DISPATCH_COCOA_COMPAT 0
-#endif
-
-#if DISPATCH_COCOA_COMPAT
-
-#define DISPATCH_CF_SPI_VERSION 20160712
-
-#if TARGET_OS_MAC
-typedef mach_port_t dispatch_runloop_handle_t;
-#elif defined(__linux__) || defined(__FreeBSD__)
-typedef int dispatch_runloop_handle_t;
-#elif defined(_WIN32)
-typedef void *dispatch_runloop_handle_t;
-#else
-#error "runloop support not implemented on this platform"
-#endif
-
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_EXPORT DISPATCH_CONST DISPATCH_WARN_RESULT DISPATCH_NOTHROW
-dispatch_runloop_handle_t
-_dispatch_get_main_queue_port_4CF(void);
-
-API_AVAILABLE(macos(10.12), ios(10.0), tvos(10.0), watchos(3.0))
-DISPATCH_EXPORT DISPATCH_NOTHROW
-dispatch_runloop_handle_t
-_dispatch_get_main_queue_handle_4CF(void);
-
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_EXPORT DISPATCH_NOTHROW
-void
-_dispatch_main_queue_callback_4CF(void *_Null_unspecified msg);
-
-API_AVAILABLE(macos(10.9), ios(7.0))
-DISPATCH_EXPORT DISPATCH_MALLOC DISPATCH_RETURNS_RETAINED DISPATCH_WARN_RESULT
-DISPATCH_NOTHROW
-dispatch_queue_serial_t
-_dispatch_runloop_root_queue_create_4CF(const char *_Nullable label,
-		unsigned long flags);
-
-API_AVAILABLE(macos(10.9), ios(7.0))
-DISPATCH_EXPORT DISPATCH_WARN_RESULT DISPATCH_NOTHROW
-dispatch_runloop_handle_t
-_dispatch_runloop_root_queue_get_port_4CF(dispatch_queue_t queue);
-
-#if TARGET_OS_MAC
-API_AVAILABLE(macos(10.13.2), ios(11.2), tvos(11.2), watchos(4.2))
-DISPATCH_EXPORT DISPATCH_WARN_RESULT DISPATCH_NOTHROW
-bool
-_dispatch_source_will_reenable_kevent_4NW(dispatch_source_t source);
-#endif
-
-API_AVAILABLE(macos(10.9), ios(7.0))
-DISPATCH_EXPORT DISPATCH_NOTHROW
-void
-_dispatch_runloop_root_queue_wakeup_4CF(dispatch_queue_t queue);
-
-API_AVAILABLE(macos(10.9), ios(7.0))
-DISPATCH_EXPORT DISPATCH_WARN_RESULT DISPATCH_NOTHROW
-bool
-_dispatch_runloop_root_queue_perform_4CF(dispatch_queue_t queue);
-
-API_AVAILABLE(macos(10.9), ios(7.0))
-DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW
-void
-_dispatch_source_set_runloop_timer_4CF(dispatch_source_t source,
-		dispatch_time_t start, uint64_t interval, uint64_t leeway);
-
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_EXPORT
-void *_Nonnull (*_Nullable _dispatch_begin_NSAutoReleasePool)(void);
-
-API_AVAILABLE(macos(10.6), ios(4.0))
-DISPATCH_EXPORT
-void (*_Nullable _dispatch_end_NSAutoReleasePool)(void *);
-
-#endif /* DISPATCH_COCOA_COMPAT */
-
-API_AVAILABLE(macos(10.13), ios(11.0), tvos(11.0), watchos(4.0))
-DISPATCH_EXPORT DISPATCH_NOTHROW
-void
-_dispatch_poll_for_events_4launchd(void);
-
-__END_DECLS
-
-DISPATCH_ASSUME_NONNULL_END
-
-#endif // __DISPATCH_PRIVATE__
--- a/Telegram/ThirdParty/dispatch/private/queue_private.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/private/queue_private.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,503 +0,0 @@
-/*
- * Copyright (c) 2008-2013 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-/*
- * IMPORTANT: This header file describes INTERNAL interfaces to libdispatch
- * which are subject to change in future releases of Mac OS X. Any applications
- * relying on these interfaces WILL break.
- */
-
-#ifndef __DISPATCH_QUEUE_PRIVATE__
-#define __DISPATCH_QUEUE_PRIVATE__
-
-#ifndef __DISPATCH_INDIRECT__
-#error "Please #include <dispatch/private.h> instead of this file directly."
-#include <dispatch/base.h> // for HeaderDoc
-#endif
-
-DISPATCH_ASSUME_NONNULL_BEGIN
-
-__BEGIN_DECLS
-
-/*!
- * @enum dispatch_queue_flags_t
- *
- * @constant DISPATCH_QUEUE_OVERCOMMIT
- * The queue will create a new thread for invoking blocks, regardless of how
- * busy the computer is.
- */
-enum {
-	DISPATCH_QUEUE_OVERCOMMIT = 0x2ull,
-};
-
-
-/*!
- * @function dispatch_set_qos_class
- *
- * @abstract
- * Sets the QOS class on a dispatch queue, source or mach channel.
- *
- * @discussion
- * This is equivalent to using dispatch_queue_make_attr_with_qos_class()
- * when creating a dispatch queue, but is availabile on additional dispatch
- * object types.
- *
- * When configured in this manner, the specified QOS class will be used over
- * the assigned QOS of workitems submitted asynchronously to this object,
- * unless the workitem has been created with ENFORCE semantics
- * (see DISPATCH_BLOCK_ENFORCE_QOS_CLASS).
- *
- * Calling this function will supersede any prior calls to
- * dispatch_set_qos_class() or dispatch_set_qos_class_floor().
- *
- * @param object
- * A dispatch queue, source or mach channel to configure.
- * The object must be inactive, and can't be a workloop.
- *
- * Passing another object type or an object that has been activated is undefined
- * and will cause the process to be terminated.
- *
- * @param qos_class
- * A QOS class value:
- *  - QOS_CLASS_USER_INTERACTIVE
- *  - QOS_CLASS_USER_INITIATED
- *  - QOS_CLASS_DEFAULT
- *  - QOS_CLASS_UTILITY
- *  - QOS_CLASS_BACKGROUND
- * Passing any other value is undefined.
- *
- * @param relative_priority
- * A relative priority within the QOS class. This value is a negative
- * offset from the maximum supported scheduler priority for the given class.
- * Passing a value greater than zero or less than QOS_MIN_RELATIVE_PRIORITY
- * is undefined.
- */
-API_AVAILABLE(macos(10.14), ios(12.0), tvos(12.0), watchos(5.0))
-DISPATCH_EXPORT DISPATCH_NOTHROW
-void
-dispatch_set_qos_class(dispatch_object_t object,
-		dispatch_qos_class_t qos_class, int relative_priority);
-
-/*!
- * @function dispatch_set_qos_class_floor
- *
- * @abstract
- * Sets the QOS class floor on a dispatch queue, source, workloop or mach
- * channel.
- *
- * @discussion
- * The QOS class of workitems submitted to this object asynchronously will be
- * elevated to at least the specified QOS class floor.
- * Unlike dispatch_set_qos_class(), the QOS of the workitem will be used if
- * higher than the floor even when the workitem has been created without
- * "ENFORCE" semantics.
- *
- * Setting the QOS class floor is equivalent to the QOS effects of configuring
- * a target queue whose QOS class has been set with dispatch_set_qos_class().
- *
- * Calling this function will supersede any prior calls to
- * dispatch_set_qos_class() or dispatch_set_qos_class_floor().
- *
- * @param object
- * A dispatch queue, workloop, source or mach channel to configure.
- * The object must be inactive.
- *
- * Passing another object type or an object that has been activated is undefined
- * and will cause the process to be terminated.
- *
- * @param qos_class
- * A QOS class value:
- *  - QOS_CLASS_USER_INTERACTIVE
- *  - QOS_CLASS_USER_INITIATED
- *  - QOS_CLASS_DEFAULT
- *  - QOS_CLASS_UTILITY
- *  - QOS_CLASS_BACKGROUND
- * Passing any other value is undefined.
- *
- * @param relative_priority
- * A relative priority within the QOS class. This value is a negative
- * offset from the maximum supported scheduler priority for the given class.
- * Passing a value greater than zero or less than QOS_MIN_RELATIVE_PRIORITY
- * is undefined.
- */
-API_AVAILABLE(macos(10.14), ios(12.0), tvos(12.0), watchos(5.0))
-DISPATCH_EXPORT DISPATCH_NOTHROW
-void
-dispatch_set_qos_class_floor(dispatch_object_t object,
-		dispatch_qos_class_t qos_class, int relative_priority);
-
-/*!
- * @function dispatch_set_qos_class_fallback
- *
- * @abstract
- * Sets the fallback QOS class on a dispatch queue, source, workloop or mach
- * channel.
- *
- * @discussion
- * Workitems submitted asynchronously to this object that don't have an assigned
- * QOS class will use the specified QOS class as a fallback. This interface
- * doesn't support relative priority.
- *
- * Workitems without an assigned QOS are:
- * - workitems submitted from the context of a thread opted-out of QOS,
- * - workitems created with the DISPATCH_BLOCK_DETACHED or
- *   DISPATCH_BLOCK_NO_QOS_CLASS flags,
- * - XPC messages sent with xpc_connection_send_notification(),
- * - XPC connection and dispatch source handlers.
- *
- * Calling both dispatch_set_qos_class_fallback() and dispatch_set_qos_class()
- * on an object will only apply the effect of dispatch_set_qos_class().
- *
- * A QOS class fallback must always be at least as high as the current QOS
- * floor for the dispatch queue hierarchy, else it is ignored.
- *
- * When no QOS fallback has been explicitly specified:
- * - queues on hierarchies without a QOS class or QOS class floor have
- *   a fallback of QOS_CLASS_DEFAULT,
- * - queues on hierarchies with a QOS class or QOS class floor configured will
- *   also use that QOS class as a fallback.
- *
- * @param object
- * A dispatch queue, workloop, source or mach channel to configure.
- * The object must be inactive.
- *
- * Passing another object type or an object that has been activated is undefined
- * and will cause the process to be terminated.
- *
- * @param qos_class
- * A QOS class value:
- *  - QOS_CLASS_USER_INTERACTIVE
- *  - QOS_CLASS_USER_INITIATED
- *  - QOS_CLASS_DEFAULT
- *  - QOS_CLASS_UTILITY
- *  - QOS_CLASS_BACKGROUND
- * Passing any other value is undefined.
- */
-API_AVAILABLE(macos(10.14), ios(12.0), tvos(12.0), watchos(5.0))
-DISPATCH_EXPORT DISPATCH_NOTHROW
-void
-dispatch_set_qos_class_fallback(dispatch_object_t object,
-		dispatch_qos_class_t qos_class);
-
-#define DISPATCH_QUEUE_FLAGS_MASK (DISPATCH_QUEUE_OVERCOMMIT)
-
-// On FreeBSD pthread_attr_t is a typedef to a pointer type
-#if defined(__FreeBSD__)
-#  define DISPATCH_QUEUE_NULLABLE_PTHREAD_ATTR_PTR _Nullable
-#else
-#  define DISPATCH_QUEUE_NULLABLE_PTHREAD_ATTR_PTR
-#endif
-
-/*!
- * @function dispatch_queue_attr_make_with_overcommit
- *
- * @discussion
- * Returns a dispatch queue attribute value with the overcommit flag set to the
- * specified value.
- *
- * This attribute only makes sense when the specified queue is targeted at
- * a root queue. Passing this attribute to dispatch_queue_create_with_target()
- * with a target queue that is not a root queue will result in an assertion and
- * the process being terminated.
- *
- * It is recommended to not specify a target queue at all when using this
- * attribute and to use dispatch_queue_attr_make_with_qos_class() to select the
- * appropriate QOS class instead.
- *
- * Queues created with this attribute cannot change target after having been
- * activated. See dispatch_set_target_queue() and dispatch_activate().
- *
- * @param attr
- * A queue attribute value to be combined with the overcommit flag, or NULL.
- *
- * @param overcommit
- * Boolean overcommit flag.
- *
- * @return
- * Returns an attribute value which may be provided to dispatch_queue_create().
- * This new value combines the attributes specified by the 'attr' parameter and
- * the overcommit flag.
- */
-API_AVAILABLE(macos(10.10), ios(8.0))
-DISPATCH_EXPORT DISPATCH_WARN_RESULT DISPATCH_PURE DISPATCH_NOTHROW
-dispatch_queue_attr_t
-dispatch_queue_attr_make_with_overcommit(dispatch_queue_attr_t _Nullable attr,
-		bool overcommit);
-
-/*!
- * @typedef dispatch_queue_priority_t
- *
- * @constant DISPATCH_QUEUE_PRIORITY_NON_INTERACTIVE
- * Items dispatched to the queue will run at non-interactive priority.
- * This priority level is intended for user-initiated application activity that
- * is long-running and CPU or IO intensive and that the user is actively waiting
- * on, but that should not interfere with interactive use of the application.
- *
- * This global queue priority level is mapped to QOS_CLASS_UTILITY.
- */
-#define DISPATCH_QUEUE_PRIORITY_NON_INTERACTIVE INT8_MIN
-
-/*!
- * @function dispatch_queue_set_label_nocopy
- *
- * @abstract
- * Set the label for a given queue, without copying the input string.
- *
- * @discussion
- * The queue must have been initially created with a NULL label, else using
- * this function to set the queue label is undefined.
- *
- * The caller of this function must make sure the label pointer remains valid
- * while it is used as the queue label and while any callers to
- * dispatch_queue_get_label() may have obtained it. Since the queue lifetime
- * may extend past the last release, it is advised to call this function with
- * a constant string or NULL before the queue is released, or to destroy the
- * label from a finalizer for that queue.
- *
- * This function should be called before any work item could call
- * dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL) or from the context of
- * the queue itself.
- *
- * @param queue
- * The queue to adjust. Attempts to set the label of the main queue or a global
- * concurrent queue will be ignored.
- *
- * @param label
- * The new label for the queue.
- */
-API_AVAILABLE(macos(10.13), ios(11.0), tvos(11.0), watchos(4.0))
-DISPATCH_EXPORT DISPATCH_NONNULL1 DISPATCH_NOTHROW
-void
-dispatch_queue_set_label_nocopy(dispatch_queue_t queue,
-		const char * _Nullable label);
-
-/*!
- * @function dispatch_queue_set_width
- *
- * @abstract
- * Set the width of concurrency for a given queue. The width of a serial queue
- * is one.
- *
- * @discussion
- * This SPI is DEPRECATED and will be removed in a future release.
- * Uses of this SPI to make a queue concurrent by setting its width to LONG_MAX
- * should be replaced by passing DISPATCH_QUEUE_CONCURRENT to
- * dispatch_queue_create().
- * Uses of this SPI to limit queue concurrency are not recommended and should
- * be replaced by alternative mechanisms such as a dispatch semaphore created
- * with the desired concurrency width.
- *
- * @param queue
- * The queue to adjust. Attempts to set the width of the main queue or a global
- * concurrent queue will be ignored.
- *
- * @param width
- * The new maximum width of concurrency depending on available resources.
- * If zero is passed, then the value is promoted to one.
- * Negative values are magic values that map to automatic width values.
- * Unknown negative values default to DISPATCH_QUEUE_WIDTH_MAX_LOGICAL_CPUS.
- */
-#define DISPATCH_QUEUE_WIDTH_ACTIVE_CPUS		-1
-#define DISPATCH_QUEUE_WIDTH_MAX_PHYSICAL_CPUS	-2
-#define DISPATCH_QUEUE_WIDTH_MAX_LOGICAL_CPUS	-3
-
-API_DEPRECATED("Use dispatch_queue_create(name, DISPATCH_QUEUE_CONCURRENT)",
-		macos(10.6,10.10), ios(4.0,8.0))
-DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW
-void
-dispatch_queue_set_width(dispatch_queue_t dq, long width);
-
-#if defined(__BLOCKS__) && defined(__APPLE__)
-/*!
- * @function dispatch_pthread_root_queue_create
- *
- * @abstract
- * Creates a new concurrent dispatch root queue with a pthread-based pool of
- * worker threads owned by the application.
- *
- * @discussion
- * Dispatch pthread root queues are similar to the global concurrent dispatch
- * queues in that they invoke blocks concurrently, however the blocks are not
- * executed on ordinary worker threads but use a dedicated pool of pthreads not
- * shared with the global queues or any other pthread root queues.
- *
- * NOTE: this is a special-purpose facility that should only be used in very
- * limited circumstances, in almost all cases the global concurrent queues
- * should be preferred. While this facility allows for more flexibility in
- * configuring worker threads for special needs it comes at the cost of
- * increased overall memory usage due to reduced thread sharing and higher
- * latency in worker thread bringup.
- *
- * Dispatch pthread root queues do not support suspension, application context
- * and change of width or of target queue. They can however be used as the
- * target queue for serial or concurrent queues obtained via
- * dispatch_queue_create() or dispatch_queue_create_with_target(), which
- * enables the blocks submitted to those queues to be processed on the root
- * queue's pthread pool.
- *
- * When a dispatch pthread root queue is no longer needed, it should be
- * released with dispatch_release(). Existing worker pthreads and pending blocks
- * submitted to the root queue will hold a reference to the queue so it will not
- * be deallocated until all blocks have finished and worker threads exited.
- *
- * @param label
- * A string label to attach to the queue.
- * This parameter is optional and may be NULL.
- *
- * @param flags
- * Pass flags value returned by dispatch_pthread_root_queue_flags_pool_size()
- * or 0 if unused.
- *
- * @param attr
- * Attributes passed to pthread_create(3) when creating worker pthreads. This
- * parameter is copied and can be destroyed after this call returns.
- * This parameter is optional and may be NULL.
- *
- * @param configure
- * Configuration block called on newly created worker pthreads before any blocks
- * for the root queue are executed. The block may configure the current thread
- * as needed.
- * This parameter is optional and may be NULL.
- *
- * @result
- * The newly created dispatch pthread root queue.
- */
-API_AVAILABLE(macos(10.9), ios(6.0)) DISPATCH_LINUX_UNAVAILABLE()
-DISPATCH_EXPORT DISPATCH_MALLOC DISPATCH_RETURNS_RETAINED DISPATCH_WARN_RESULT
-DISPATCH_NOTHROW
-dispatch_queue_global_t
-dispatch_pthread_root_queue_create(const char *_Nullable label,
-		unsigned long flags, const pthread_attr_t DISPATCH_QUEUE_NULLABLE_PTHREAD_ATTR_PTR *_Nullable attr,
-		dispatch_block_t _Nullable configure);
-
-/*!
- * @function dispatch_pthread_root_queue_flags_pool_size
- *
- * @abstract
- * Returns flags argument to pass to dispatch_pthread_root_queue_create() to
- * specify the maximum size of the pthread pool to use for a pthread root queue.
- *
- * @param pool_size
- * Maximum size of the pthread pool to use for the root queue. The number of
- * pthreads created for this root queue will never exceed this number but there
- * is no guarantee that the specified number will be reached.
- * Pass 0 to specify that a default pool size determined by the system should
- * be used.
- * NOTE: passing pool_size == 1 does NOT make the pthread root queue equivalent
- *       to a serial queue.
- *
- * @result
- * The flags argument to pass to dispatch_pthread_root_queue_create().
- */
-DISPATCH_INLINE DISPATCH_ALWAYS_INLINE
-unsigned long
-dispatch_pthread_root_queue_flags_pool_size(uint8_t pool_size)
-{
-	#define _DISPATCH_PTHREAD_ROOT_QUEUE_FLAG_POOL_SIZE (0x80000000ul)
-	return (_DISPATCH_PTHREAD_ROOT_QUEUE_FLAG_POOL_SIZE |
-			(unsigned long)pool_size);
-}
-
-/*!
- * @function dispatch_pthread_root_queue_copy_current
- *
- * @abstract
- * Returns a reference to the pthread root queue object that has created the
- * currently executing thread, or NULL if the current thread is not associated
- * to a pthread root queue.
- *
- * @result
- * A new reference to a pthread root queue object or NULL.
- */
-API_AVAILABLE(macos(10.12), ios(10.0), tvos(10.0), watchos(3.0))
-DISPATCH_LINUX_UNAVAILABLE()
-DISPATCH_EXPORT DISPATCH_RETURNS_RETAINED DISPATCH_WARN_RESULT DISPATCH_NOTHROW
-dispatch_queue_global_t _Nullable
-dispatch_pthread_root_queue_copy_current(void);
-
-/*!
- * @constant DISPATCH_APPLY_CURRENT_ROOT_QUEUE
- *
- * @discussion
- * This constant is deprecated, please use DISPATCH_APPLY_AUTO.
- *
- * DISPATCH_APPLY_AUTO also selects the current pthread root queue if
- * applicable.
- */
-#define DISPATCH_APPLY_CURRENT_ROOT_QUEUE ((dispatch_queue_t _Nonnull)0)
-
-#endif /* defined(__BLOCKS__) && defined(__APPLE__) */
-
-/*!
- * @function dispatch_async_enforce_qos_class_f
- *
- * @abstract
- * Submits a function for asynchronous execution on a dispatch queue.
- *
- * @discussion
- * See dispatch_async() for details. The QOS will be enforced as if
- * this was called:
- * <code>
- *     dispatch_async(queue, dispatch_block_create(DISPATCH_BLOCK_ENFORCE_QOS_CLASS, ^{
- *         work(context);
- *     });
- * </code>
- *
- * @param queue
- * The target dispatch queue to which the function is submitted.
- * The system will hold a reference on the target queue until the function
- * has returned.
- * The result of passing NULL in this parameter is undefined.
- *
- * @param context
- * The application-defined context parameter to pass to the function.
- *
- * @param work
- * The application-defined function to invoke on the target queue. The first
- * parameter passed to this function is the context provided to
- * dispatch_async_f().
- * The result of passing NULL in this parameter is undefined.
- */
-API_AVAILABLE(macos(10.11), ios(9.0))
-DISPATCH_EXPORT DISPATCH_NONNULL1 DISPATCH_NONNULL3 DISPATCH_NOTHROW
-void
-dispatch_async_enforce_qos_class_f(dispatch_queue_t queue,
-		void *_Nullable context, dispatch_function_t work);
-
-#ifdef __ANDROID__
-/*!
- * @function _dispatch_install_thread_detach_callback
- *
- * @param cb
- * Function to be called before each worker thread exits to detach JVM.
- *
- * Hook to be able to detach threads from the Java JVM before they exit.
- * If JNI has been used on a thread on Android it needs to have been
- * "detached" before the thread exits or the application will crash.
- */
-DISPATCH_EXPORT
-void _dispatch_install_thread_detach_callback(void (*cb)(void));
-#endif
-
-__END_DECLS
-
-DISPATCH_ASSUME_NONNULL_END
-
-#endif
--- a/Telegram/ThirdParty/dispatch/private/source_private.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/private/source_private.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,649 +0,0 @@
-/*
- * Copyright (c) 2008-2013 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-/*
- * IMPORTANT: This header file describes INTERNAL interfaces to libdispatch
- * which are subject to change in future releases of Mac OS X. Any applications
- * relying on these interfaces WILL break.
- */
-
-#ifndef __DISPATCH_SOURCE_PRIVATE__
-#define __DISPATCH_SOURCE_PRIVATE__
-
-#ifndef __DISPATCH_INDIRECT__
-#error "Please #include <dispatch/private.h> instead of this file directly."
-#include <dispatch/base.h> // for HeaderDoc
-#endif
-
-DISPATCH_ASSUME_NONNULL_BEGIN
-
-__BEGIN_DECLS
-
-/*!
- * @const DISPATCH_SOURCE_TYPE_INTERVAL
- * @discussion A dispatch source that submits the event handler block at a
- * specified time interval, phase-aligned with all other interval sources on
- * the system that have the same interval value.
- *
- * The initial submission of the event handler will occur at some point during
- * the first time interval after the source is created (assuming the source is
- * resumed at that time).
- *
- * By default, the unit for the interval value is milliseconds and the leeway
- * (maximum amount of time any individual handler submission may be deferred to
- * align with other system activity) for the source is fixed at interval/2.
- *
- * If the DISPATCH_INTERVAL_UI_ANIMATION flag is specified, the unit for the
- * interval value is animation frames (1/60th of a second) and the leeway is
- * fixed at one frame.
- *
- * The handle is the interval value in milliseconds or frames.
- * The mask specifies which flags from dispatch_source_timer_flags_t to apply.
- *
- * Starting with macOS 10.14, iOS 12, dispatch_source_set_timer()
- * can be used on such sources, and its arguments are used as follow:
- * - start:
- *   must be DISPATCH_TIME_NOW or DISPATCH_TIME_FOREVER.
- *   DISPATCH_TIME_NOW will enable the timer, and align its phase, and
- *   DISPATCH_TIME_FOREVER will disable the timer as usual.*
- * - interval:
- *   its unit is in milliseconds by default, or frames if the source
- *   was created with the DISPATCH_INTERVAL_UI_ANIMATION flag.
- * - leeway:
- *   per-thousands of the interval (valid values range from 0 to 1000).
- *   If ~0ull is passed, the default leeway for the interval is used instead.
- */
-#define DISPATCH_SOURCE_TYPE_INTERVAL (&_dispatch_source_type_interval)
-API_AVAILABLE(macos(10.9), ios(7.0))
-DISPATCH_SOURCE_TYPE_DECL(interval);
-
-/*!
- * @const DISPATCH_SOURCE_TYPE_VFS
- * @discussion Apple-internal dispatch source that monitors for vfs events
- * defined by dispatch_vfs_flags_t.
- * The handle is a process identifier (pid_t).
- */
-#define DISPATCH_SOURCE_TYPE_VFS (&_dispatch_source_type_vfs)
-API_AVAILABLE(macos(10.6), ios(4.0)) DISPATCH_LINUX_UNAVAILABLE()
-DISPATCH_SOURCE_TYPE_DECL(vfs);
-
-/*!
- * @const DISPATCH_SOURCE_TYPE_VM
- * @discussion A dispatch source that monitors virtual memory
- * The mask is a mask of desired events from dispatch_source_vm_flags_t.
- * This type is deprecated, use DISPATCH_SOURCE_TYPE_MEMORYPRESSURE instead.
- */
-#define DISPATCH_SOURCE_TYPE_VM (&_dispatch_source_type_vm)
-API_DEPRECATED_WITH_REPLACEMENT("DISPATCH_SOURCE_TYPE_MEMORYPRESSURE",
-		macos(10.7,10.10), ios(4.3,8.0)) DISPATCH_LINUX_UNAVAILABLE()
-DISPATCH_SOURCE_TYPE_DECL(vm);
-
-/*!
- * @const DISPATCH_SOURCE_TYPE_MEMORYSTATUS
- * @discussion A dispatch source that monitors memory status
- * The mask is a mask of desired events from
- * dispatch_source_memorystatus_flags_t.
- */
-#define DISPATCH_SOURCE_TYPE_MEMORYSTATUS (&_dispatch_source_type_memorystatus)
-API_DEPRECATED_WITH_REPLACEMENT("DISPATCH_SOURCE_TYPE_MEMORYPRESSURE",
-		macos(10.9, 10.12), ios(6.0, 10.0), tvos(6.0, 10.0), watchos(1.0, 3.0))
-DISPATCH_LINUX_UNAVAILABLE()
-DISPATCH_SOURCE_TYPE_DECL(memorystatus);
-
-/*!
- * @const DISPATCH_SOURCE_TYPE_SOCK
- * @discussion A dispatch source that monitors events on socket state changes.
- */
-#define DISPATCH_SOURCE_TYPE_SOCK (&_dispatch_source_type_sock)
-API_AVAILABLE(macos(10.8), ios(6.0)) DISPATCH_LINUX_UNAVAILABLE()
-DISPATCH_SOURCE_TYPE_DECL(sock);
-
-/*!
- * @const DISPATCH_SOURCE_TYPE_NW_CHANNEL
- * @discussion A dispatch source that monitors events on a network channel.
- */
-#define DISPATCH_SOURCE_TYPE_NW_CHANNEL (&_dispatch_source_type_nw_channel)
-API_AVAILABLE(macos(10.13), ios(11.0), tvos(11.0), watchos(4.0)) DISPATCH_LINUX_UNAVAILABLE()
-DISPATCH_SOURCE_TYPE_DECL(nw_channel);
-
-__END_DECLS
-
-/*!
- * @enum dispatch_source_sock_flags_t
- *
- * @constant DISPATCH_SOCK_CONNRESET
- * Received RST
- *
- * @constant DISPATCH_SOCK_READCLOSED
- * Read side is shutdown
- *
- * @constant DISPATCH_SOCK_WRITECLOSED
- * Write side is shutdown
- *
- * @constant DISPATCH_SOCK_TIMEOUT
- * Timeout: rexmt, keep-alive or persist
- *
- * @constant DISPATCH_SOCK_NOSRCADDR
- * Source address not available
- *
- * @constant DISPATCH_SOCK_IFDENIED
- * Interface denied connection
- *
- * @constant DISPATCH_SOCK_SUSPEND
- * Output queue suspended
- *
- * @constant DISPATCH_SOCK_RESUME
- * Output queue resumed
- *
- * @constant DISPATCH_SOCK_KEEPALIVE
- * TCP Keepalive received
- *
- * @constant DISPATCH_SOCK_CONNECTED
- * Socket is connected
- *
- * @constant DISPATCH_SOCK_DISCONNECTED
- * Socket is disconnected
- *
- * @constant DISPATCH_SOCK_CONNINFO_UPDATED
- * Connection info was updated
- *
- * @constant DISPATCH_SOCK_NOTIFY_ACK
- * Notify acknowledgement
- */
-enum {
-	DISPATCH_SOCK_CONNRESET = 0x00000001,
-	DISPATCH_SOCK_READCLOSED = 0x00000002,
-	DISPATCH_SOCK_WRITECLOSED = 0x00000004,
-	DISPATCH_SOCK_TIMEOUT = 0x00000008,
-	DISPATCH_SOCK_NOSRCADDR = 0x00000010,
-	DISPATCH_SOCK_IFDENIED = 0x00000020,
-	DISPATCH_SOCK_SUSPEND = 0x00000040,
-	DISPATCH_SOCK_RESUME = 0x00000080,
-	DISPATCH_SOCK_KEEPALIVE = 0x00000100,
-	DISPATCH_SOCK_ADAPTIVE_WTIMO = 0x00000200,
-	DISPATCH_SOCK_ADAPTIVE_RTIMO = 0x00000400,
-	DISPATCH_SOCK_CONNECTED = 0x00000800,
-	DISPATCH_SOCK_DISCONNECTED = 0x00001000,
-	DISPATCH_SOCK_CONNINFO_UPDATED = 0x00002000,
-	DISPATCH_SOCK_NOTIFY_ACK = 0x00004000,
-};
-
-/*!
- * @enum dispatch_source_nw_channel_flags_t
- *
- * @constant DISPATCH_NW_CHANNEL_FLOW_ADV_UPDATE
- * Received network channel flow advisory.
- */
-enum {
-	DISPATCH_NW_CHANNEL_FLOW_ADV_UPDATE = 0x00000001,
-};
-
-/*!
- * @enum dispatch_source_vfs_flags_t
- *
- * @constant DISPATCH_VFS_NOTRESP
- * Server down.
- *
- * @constant DISPATCH_VFS_NEEDAUTH
- * Server bad auth.
- *
- * @constant DISPATCH_VFS_LOWDISK
- * We're low on space.
- *
- * @constant DISPATCH_VFS_MOUNT
- * New filesystem arrived.
- *
- * @constant DISPATCH_VFS_UNMOUNT
- * Filesystem has left.
- *
- * @constant DISPATCH_VFS_DEAD
- * Filesystem is dead, needs force unmount.
- *
- * @constant DISPATCH_VFS_ASSIST
- * Filesystem needs assistance from external program.
- *
- * @constant DISPATCH_VFS_NOTRESPLOCK
- * Server lockd down.
- *
- * @constant DISPATCH_VFS_UPDATE
- * Filesystem information has changed.
- *
- * @constant DISPATCH_VFS_VERYLOWDISK
- * File system has *very* little disk space left.
- *
- * @constant DISPATCH_VFS_QUOTA
- * We hit a user quota (quotactl) for this filesystem.
- *
- * @constant DISPATCH_VFS_NEARLOWDISK
- * Filesystem is nearly full (below NEARLOWDISK level).
- *
- * @constant DISPATCH_VFS_DESIREDDISK
- * Filesystem has exceeded the DESIREDDISK level
- *
- * @constant DISPATCH_VFS_FREE_SPACE_CHANGE
- * Filesystem free space changed.
- */
-enum {
-	DISPATCH_VFS_NOTRESP = 0x0001,
-	DISPATCH_VFS_NEEDAUTH = 0x0002,
-	DISPATCH_VFS_LOWDISK = 0x0004,
-	DISPATCH_VFS_MOUNT = 0x0008,
-	DISPATCH_VFS_UNMOUNT = 0x0010,
-	DISPATCH_VFS_DEAD = 0x0020,
-	DISPATCH_VFS_ASSIST = 0x0040,
-	DISPATCH_VFS_NOTRESPLOCK = 0x0080,
-	DISPATCH_VFS_UPDATE = 0x0100,
-	DISPATCH_VFS_VERYLOWDISK = 0x0200,
-	DISPATCH_VFS_QUOTA = 0x1000,
-	DISPATCH_VFS_NEARLOWDISK = 0x2000,
-	DISPATCH_VFS_DESIREDDISK = 0x4000,
-	DISPATCH_VFS_FREE_SPACE_CHANGE = 0x8000,
-};
-
-/*!
- * @enum dispatch_clockid_t
- *
- * @discussion
- * These values can be used with DISPATCH_SOURCE_TYPE_TIMER as a "handle"
- * to anchor the timer to a given clock which allows for various optimizations.
- *
- * Note that using an explicit clock will make the dispatch source "strict"
- * like dispatch_source_set_mandatory_cancel_handler() does.
- *
- * @constant DISPATCH_CLOCKID_UPTIME
- * A monotonic clock that doesn't tick while the machine is asleep.
- * Equivalent to the CLOCK_UPTIME clock ID on BSD systems.
- *
- * @constant DISPATCH_CLOCKID_MONOTONIC
- * A monotonic clock that ticks while the machine sleeps.
- * Equivalent to POSIX CLOCK_MONOTONIC.
- * (Note that on Linux, CLOCK_MONOTONIC isn't conformant and doesn't tick while
- * sleeping, hence on Linux this is the same clock as CLOCK_BOOTTIME).
- *
- * @constant DISPATCH_CLOCKID_WALLTIME
- * A clock equivalent to the wall clock time, as returned by gettimeofday().
- * Equivalent to POSIX CLOCK_REALTIME.
- *
- * @constant DISPATCH_CLOCKID_REALTIME
- * An alias for DISPATCH_CLOCKID_WALLTIME to match the POSIX clock of the
- * same name.
- */
-DISPATCH_ENUM(dispatch_clockid, uintptr_t,
-	DISPATCH_CLOCKID_UPTIME DISPATCH_ENUM_API_AVAILABLE(macos(10.14), ios(12.0), tvos(12.0), watchos(5.0)) = 1,
-	DISPATCH_CLOCKID_MONOTONIC DISPATCH_ENUM_API_AVAILABLE(macos(10.14), ios(12.0), tvos(12.0), watchos(5.0)) = 2,
-	DISPATCH_CLOCKID_WALLTIME DISPATCH_ENUM_API_AVAILABLE(macos(10.14), ios(12.0), tvos(12.0), watchos(5.0)) = 3,
-	DISPATCH_CLOCKID_REALTIME DISPATCH_ENUM_API_AVAILABLE(macos(10.14), ios(12.0), tvos(12.0), watchos(5.0)) = 3,
-);
-
-/*!
- * @enum dispatch_source_timer_flags_t
- *
- * @constant DISPATCH_TIMER_BACKGROUND
- * Specifies that the timer is used to trigger low priority maintenance-level
- * activity and that the system may apply larger minimum leeway values to the
- * timer in order to align it with other system activity.
- *
- * @constant DISPATCH_INTERVAL_UI_ANIMATION
- * Specifies that the interval source is used for UI animation. The unit for
- * the interval value of such sources is frames (1/60th of a second) and the
- * leeway is fixed at one frame.
- */
-enum {
-	DISPATCH_TIMER_BACKGROUND = 0x2,
-	DISPATCH_INTERVAL_UI_ANIMATION = 0x20,
-};
-
-/*!
- * @enum dispatch_source_mach_send_flags_t
- *
- * @constant DISPATCH_MACH_SEND_POSSIBLE
- * The mach port corresponding to the given send right has space available
- * for messages. Delivered only once a mach_msg() to that send right with
- * options MACH_SEND_MSG|MACH_SEND_TIMEOUT|MACH_SEND_NOTIFY has returned
- * MACH_SEND_TIMED_OUT (and not again until the next such mach_msg() timeout).
- * NOTE: The source must have registered the send right for monitoring with the
- *       system for such a mach_msg() to arm the send-possible notifcation, so
- *       the initial send attempt must occur from a source registration handler.
- */
-enum {
-	DISPATCH_MACH_SEND_POSSIBLE = 0x8,
-};
-
-/*!
- * @enum dispatch_source_proc_flags_t
- *
- * @constant DISPATCH_PROC_REAP
- * The process has been reaped by the parent process via wait*().
- * This flag is deprecated and will be removed in a future release.
- *
- * @constant DISPATCH_PROC_EXIT_STATUS
- * The process has exited. Specifying this flag allows the process exit status
- * to be retrieved from the source's status value, as returned by the
- * dispatch_source_get_extended_data() function. The macros
- * DISPATCH_PROC_EXIT_STATUS_EXITED(), DISPATCH_PROC_EXIT_STATUS_CODE(),
- * DISPATCH_PROC_EXIT_STATUS_SIGNALED(), DISPATCH_PROC_EXIT_STATUS_TERMSIG() and
- * DISPATCH_PROC_EXIT_STATUS_CORE_DUMPED() can be used to examine the status
- * value.
- */
-enum {
-	DISPATCH_PROC_REAP DISPATCH_ENUM_API_DEPRECATED("unsupported flag",
-			macos(10.6,10.9), ios(4.0,7.0)) = 0x10000000,
-	DISPATCH_PROC_EXIT_STATUS DISPATCH_ENUM_API_AVAILABLE(macos(10.13), ios(11.0), tvos(11.0), watchos(2.0)) = 0x04000000,
-};
-
-/*!
- * @enum dispatch_source_vm_flags_t
- *
- * @constant DISPATCH_VM_PRESSURE
- * The VM has experienced memory pressure.
- */
-
-enum {
-	DISPATCH_VM_PRESSURE DISPATCH_ENUM_API_DEPRECATED_WITH_REPLACEMENT("DISPATCH_MEMORYPRESSURE_WARN", macos(10.7, 10.10), ios(4.3, 8.0))
-			= 0x80000000,
-};
-
-/*!
- * @typedef dispatch_source_memorypressure_flags_t
- * Type of dispatch_source_memorypressure flags
- *
- * @constant DISPATCH_MEMORYPRESSURE_LOW_SWAP
- * The system's memory pressure state has entered the "low swap" condition.
- * Restricted to the root user.
- */
-enum {
-	DISPATCH_MEMORYPRESSURE_LOW_SWAP DISPATCH_ENUM_API_AVAILABLE(macos(10.10), ios(8.0)) = 0x08,
-};
-
-/*!
- * @enum dispatch_source_memorystatus_flags_t
- * @warning Deprecated, see DISPATCH_MEMORYPRESSURE_*
- */
-enum {
-	DISPATCH_MEMORYSTATUS_PRESSURE_NORMAL
-			DISPATCH_ENUM_API_DEPRECATED_WITH_REPLACEMENT("DISPATCH_MEMORYPRESSURE_NORMAL", macos(10.9, 10.12),
-			ios(6.0, 10.0), tvos(6.0, 10.0), watchos(1.0, 3.0)) = 0x01,
-	DISPATCH_MEMORYSTATUS_PRESSURE_WARN
-			DISPATCH_ENUM_API_DEPRECATED_WITH_REPLACEMENT("DISPATCH_MEMORYPRESSURE_WARN", macos(10.9, 10.12),
-			ios(6.0, 10.0), tvos(6.0, 10.0), watchos(1.0, 3.0)) = 0x02,
-	DISPATCH_MEMORYSTATUS_PRESSURE_CRITICAL
-			DISPATCH_ENUM_API_DEPRECATED_WITH_REPLACEMENT("DISPATCH_MEMORYPRESSURE_CRITICAL", macos(10.9, 10.12),
-			ios(6.0, 10.0), tvos(6.0, 10.0), watchos(1.0, 3.0)) = 0x04,
-	DISPATCH_MEMORYSTATUS_LOW_SWAP
-			DISPATCH_ENUM_API_DEPRECATED_WITH_REPLACEMENT("DISPATCH_MEMORYPRESSURE_LOW_SWAP", macos(10.9, 10.12),
-			ios(6.0, 10.0), tvos(6.0, 10.0), watchos(1.0, 3.0)) = 0x08,
-};
-
-/*!
- * @typedef dispatch_source_memorypressure_flags_t
- * Type of dispatch_source_memorypressure flags
- *
- * @constant DISPATCH_MEMORYPRESSURE_PROC_LIMIT_WARN
- * The memory of the process has crossed 80% of its high watermark limit.
- *
- * @constant DISPATCH_MEMORYPRESSURE_PROC_LIMIT_CRITICAL
- * The memory of the process has reached 100% of its high watermark limit.
- *
- * @constant DISPATCH_MEMORYPRESSURE_MSL_STATUS
- * Mask for enabling/disabling malloc stack logging.
- */
-enum {
-	DISPATCH_MEMORYPRESSURE_PROC_LIMIT_WARN DISPATCH_ENUM_API_AVAILABLE(macos(10.12), ios(10.0), tvos(10.0), watchos(3.0)) = 0x10,
-
-	DISPATCH_MEMORYPRESSURE_PROC_LIMIT_CRITICAL DISPATCH_ENUM_API_AVAILABLE(macos(10.12), ios(10.0), tvos(10.0), watchos(3.0)) = 0x20,
-
-	DISPATCH_MEMORYPRESSURE_MSL_STATUS DISPATCH_ENUM_API_AVAILABLE(macos(10.13), ios(11.0), tvos(11.0), watchos(4.0)) = 0xf0000000,
-};
-
-/*!
- * Macros to check the exit status obtained from the status field of the
- * structure returned by the dispatch_source_get_extended_data() function for a
- * source of type DISPATCH_SOURCE_TYPE_PROC when DISPATCH_PROC_EXIT_STATUS has
- * been requested.
- *
- * DISPATCH_PROC_EXIT_STATUS_EXITED returns whether the process exited. If this
- * is true, the exit status can be obtained from DISPATCH_PROC_EXIT_STATUS_CODE.
- *
- * DISPATCH_PROC_EXIT_STATUS_SIGNALED returns whether the process was terminated
- * by a signal.
- *
- * DISPATCH_PROC_EXIT_STATUS_TERMSIG returns the signal that caused the process
- * to terminate, or 0 if the process was not terminated by a signal.
- *
- * DISPATCH_PROC_EXIT_STATUS_CORE_DUMPED returns whether a core dump of the
- * process was created.
- */
-#define DISPATCH_PROC_EXIT_STATUS_EXITED(status) ((bool)WIFEXITED(status))
-#define DISPATCH_PROC_EXIT_STATUS_CODE(status) ((int)WEXITSTATUS(status))
-#define DISPATCH_PROC_EXIT_STATUS_SIGNALED(status) ((bool)WIFSIGNALED(status))
-#define DISPATCH_PROC_EXIT_STATUS_TERMSIG(status) ((int)WTERMSIG(status))
-#define DISPATCH_PROC_EXIT_STATUS_CORE_DUMPED(status) ((bool)WCOREDUMP(status))
-
-__BEGIN_DECLS
-
-/*!
- * @function dispatch_source_set_mandatory_cancel_handler
- *
- * @abstract
- * Sets the event handler block for the given dispatch source, and indicates
- * that calling dispatch_source_cancel() is mandatory for this source object.
- *
- * @discussion
- * The cancellation handler (if specified) will be submitted to the source's
- * target queue in response to a call to dispatch_source_cancel() once the
- * system has released all references to the source's underlying handle and
- * the source's event handler block has returned.
- *
- * When this function has been used used to set a cancellation handler, then
- * the following result in an assertion and the process being terminated:
- * - releasing the last reference on the dispatch source without having
- *   cancelled it by calling dispatch_source_cancel();
- * - changing any handler after the source has been activated;
- * - changing the target queue of the source after it has been activated.
- *
- * IMPORTANT:
- * Source cancellation and a cancellation handler are required for file
- * descriptor and mach port based sources in order to safely close the
- * descriptor or destroy the port. Making the cancellation handler of such
- * sources mandatory is strongly recommended.
- * Closing the descriptor or port before the cancellation handler is invoked may
- * result in a race condition. If a new descriptor is allocated with the same
- * value as the recently closed descriptor while the source's event handler is
- * still running, the event handler may read/write data to the wrong descriptor.
- *
- * @param source
- * The dispatch source to modify.
- * The result of passing NULL in this parameter is undefined.
- *
- * @param handler
- * The cancellation handler block to submit to the source's target queue.
- * The result of passing NULL in this parameter is undefined.
- */
-#ifdef __BLOCKS__
-API_AVAILABLE(macos(10.13), ios(11.0), tvos(11.0), watchos(4.0))
-DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW
-void
-dispatch_source_set_mandatory_cancel_handler(dispatch_source_t source,
-		dispatch_block_t handler);
-#endif /* __BLOCKS__ */
-
-/*!
- * @function dispatch_source_set_mandatory_cancel_handler_f
- *
- * @abstract
- * Sets the event handler function for the given dispatch source, and causes an
- * assertion if this source is released before having been explicitly canceled.
- *
- * @discussion
- * See dispatch_source_set_mandatory_cancel_handler() for more details.
- *
- * @param source
- * The dispatch source to modify.
- * The result of passing NULL in this parameter is undefined.
- *
- * @param handler
- * The cancellation handler function to submit to the source's target queue.
- * The context parameter passed to the event handler function is the current
- * context of the dispatch source at the time the handler call is made.
- * The result of passing NULL in this parameter is undefined.
- */
-API_AVAILABLE(macos(10.13), ios(11.0), tvos(11.0), watchos(4.0))
-DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW
-void
-dispatch_source_set_mandatory_cancel_handler_f(dispatch_source_t source,
-		dispatch_function_t handler);
-
-/*!
- * @function dispatch_source_cancel_and_wait
- *
- * @abstract
- * Synchronously cancel the dispatch source, preventing any further invocation
- * of its event handler block.
- *
- * @discussion
- * Cancellation prevents any further invocation of handler blocks for the
- * specified dispatch source, but does not interrupt a handler block that is
- * already in progress.
- *
- * When this function returns, any handler block that may have been in progress
- * has returned, the specified source has been unregistered and it is safe to
- * reclaim any system resource (such as file descriptors or mach ports) that
- * the specified source was monitoring.
- *
- * If the specified dispatch source is inactive, it will be activated as a side
- * effect of calling this function.
- *
- * It is possible to call this function from several threads concurrently,
- * and it is the responsibility of the callers to synchronize reclaiming the
- * associated system resources.
- *
- * This function is not subject to priority inversion when it is waiting on
- * a handler block still in progress, unlike patterns based on waiting on
- * a dispatch semaphore or a dispatch group signaled (or left) from the source
- * cancel handler.
- *
- * This function must not be called if the specified source has a cancel
- * handler set, or from the context of its handler blocks.
- *
- * This function must not be called from the context of the target queue of
- * the specified source or from any queue that synchronizes with it. Note that
- * calling dispatch_source_cancel() from such a context already guarantees
- * that no handler is in progress, and that no new event will be delivered.
- *
- * This function must not be called on sources suspended with an explicit
- * call to dispatch_suspend(), or being concurrently activated on another
- * thread.
- *
- * @param source
- * The dispatch source to be canceled.
- * The result of passing NULL in this parameter is undefined.
- */
-API_AVAILABLE(macos(10.12), ios(10.0), tvos(10.0), watchos(3.0))
-DISPATCH_EXPORT DISPATCH_NOTHROW
-void
-dispatch_source_cancel_and_wait(dispatch_source_t source);
-
-#if __has_include(<mach/mach.h>)
-/*!
- * @typedef dispatch_mig_callback_t
- *
- * @abstract
- * The signature of a function that handles Mach message delivery and response.
- */
-typedef boolean_t (*dispatch_mig_callback_t)(mach_msg_header_t *message,
-		mach_msg_header_t *reply);
-
-API_AVAILABLE(macos(10.6), ios(4.0)) DISPATCH_LINUX_UNAVAILABLE()
-DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW
-mach_msg_return_t
-dispatch_mig_server(dispatch_source_t ds, size_t maxmsgsz,
-		dispatch_mig_callback_t callback);
-
-/*!
- * @function dispatch_mach_msg_get_context
- *
- * @abstract
- * Extract the context pointer from a mach message trailer.
- */
-API_AVAILABLE(macos(10.6), ios(4.0)) DISPATCH_LINUX_UNAVAILABLE()
-DISPATCH_EXPORT DISPATCH_PURE DISPATCH_WARN_RESULT DISPATCH_NONNULL_ALL
-DISPATCH_NOTHROW
-void *_Nullable
-dispatch_mach_msg_get_context(mach_msg_header_t *msg);
-#endif
-
-/*!
- * @typedef dispatch_source_extended_data_t
- *
- * @abstract
- * Type used by dispatch_source_get_extended_data() to return a consistent
- * snapshot of the data and status of a dispatch source.
- */
-typedef struct dispatch_source_extended_data_s {
-    unsigned long data;
-    unsigned long status;
-} *dispatch_source_extended_data_t;
-
-/*!
- * @function dispatch_source_get_extended_data
- *
- * @abstract
- * Returns the current data and status values for a dispatch source.
- *
- * @discussion
- * This function is intended to be called from within the event handler block.
- * The result of calling this function outside of the event handler callback is
- * undefined.
- *
- * @param source
- * The result of passing NULL in this parameter is undefined.
- *
- * @param data
- * A pointer to a dispatch_source_extended_data_s in which the data and status
- * will be returned. The data field is populated with the value that would be
- * returned by dispatch_source_get_data(). The value of the status field should
- * be interpreted according to the type of the dispatch source:
- *
- *  DISPATCH_SOURCE_TYPE_PROC:            dispatch_source_proc_exit_flags_t
- *
- * If called from the event handler of a data source type not listed above, the
- * status value is undefined.
- *
- * @param size
- * The size of the specified structure. Should be set to
- * sizeof(dispatch_source_extended_data_s).
- *
- * @result
- * The size of the structure returned in *data, which will never be greater than
- * the value of the size argument. If this is less than the value of the size
- * argument, the remaining space in data will have been populated with zeroes.
- */
-API_AVAILABLE(macos(10.13), ios(11.0), tvos(11.0), watchos(4.0))
-DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_WARN_RESULT DISPATCH_PURE
-DISPATCH_NOTHROW
-size_t
-dispatch_source_get_extended_data(dispatch_source_t source,
-		dispatch_source_extended_data_t data, size_t size);
-
-__END_DECLS
-
-DISPATCH_ASSUME_NONNULL_END
-
-#endif
--- a/Telegram/ThirdParty/dispatch/private/time_private.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/private/time_private.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,87 +0,0 @@
-/*
- * Copyright (c) 20017 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-/*
- * IMPORTANT: This header file describes INTERNAL interfaces to libdispatch
- * which are subject to change in future releases. Any applications relying on
- * these interfaces WILL break.
- */
-
-#ifndef __DISPATCH_TIME_PRIVATE__
-#define __DISPATCH_TIME_PRIVATE__
-
-#ifndef __DISPATCH_INDIRECT__
-#error "Please #include <dispatch/private.h> instead of this file directly."
-#include <dispatch/base.h> // for HeaderDoc
-#endif
-
-/*
- * @constant DISPATCH_MONOTONICTIME_NOW
- * A dispatch_time_t value that corresponds to the current value of the
- * platform's monotonic clock. On Apple platforms, this clock is based on
- * mach_continuous_time(). Use this value with the dispatch_time() function to
- * derive a time value for a timer in monotonic time (i.e. a timer that
- * continues to tick while the system is asleep). For example:
- *
- * dispatch_time_t t = dispatch_time(DISPATCH_MONOTONICTIME_NOW,5*NSEC_PER_SEC);
- * dispatch_source_t ds = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER,
- *			0, 0, q);
- * dispatch_source_set_event_handler(ds, ^{ ...  });
- * dispatch_source_set_timer(ds, t, 10 * NSEC_PER_SEC, 0);
- * dispatch_activate(ds);
- */
-enum {
-	DISPATCH_MONOTONICTIME_NOW DISPATCH_ENUM_API_AVAILABLE(macos(10.14), ios(12.0), tvos(12.0), watchos(5.0)) = (1ull << 63)
-};
-
-#ifdef __APPLE__
-
-// Helper macros for up time, montonic time and wall time.
-#define _dispatch_uptime_after_nsec(t) \
-		dispatch_time(DISPATCH_TIME_NOW, (t))
-#define _dispatch_uptime_after_usec(t) \
-		dispatch_time(DISPATCH_TIME_NOW, (t) * NSEC_PER_USEC)
-#define _dispatch_uptime_after_msec(t) \
-		dispatch_time(DISPATCH_TIME_NOW, (t) * NSEC_PER_MSEC)
-#define _dispatch_uptime_after_sec(t) \
-		dispatch_time(DISPATCH_TIME_NOW, (t) * NSEC_PER_SEC)
-
-#define _dispatch_monotonictime_after_nsec(t) \
-		dispatch_time(DISPATCH_MONOTONICTIME_NOW, (t))
-#define _dispatch_monotonictime_after_usec(t) \
-		dispatch_time(DISPATCH_MONOTONICTIME_NOW, (t) * NSEC_PER_USEC)
-#define _dispatch_monotonictime_after_msec(t) \
-		dispatch_time(DISPATCH_MONOTONICTIME_NOW, (t) * NSEC_PER_MSEC)
-#define _dispatch_monotonictime_after_sec(t) \
-		dispatch_time(DISPATCH_MONOTONICTIME_NOW, (t) * NSEC_PER_SEC)
-
-#define _dispatch_walltime_after_nsec(t) \
-		dispatch_time(DISPATCH_WALLTIME_NOW, (t))
-#define _dispatch_walltime_after_usec(t) \
-		dispatch_time(DISPATCH_WALLTIME_NOW, (t) * NSEC_PER_USEC)
-#define _dispatch_walltime_after_msec(t) \
-		dispatch_time(DISPATCH_WALLTIME_NOW, (t) * NSEC_PER_MSEC)
-#define _dispatch_walltime_after_sec(t) \
-		dispatch_time(DISPATCH_WALLTIME_NOW, (t) * NSEC_PER_SEC)
-
-#endif // __APPLE__
-
-#endif
-
--- a/Telegram/ThirdParty/dispatch/private/workloop_private.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/private/workloop_private.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,440 +0,0 @@
-/*
- * Copyright (c) 2017-2018 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-/*
- * IMPORTANT: This header file describes INTERNAL interfaces to libdispatch
- * which are subject to change in future releases of Mac OS X. Any applications
- * relying on these interfaces WILL break.
- */
-
-#ifndef __DISPATCH_WORKLOOP_PRIVATE__
-#define __DISPATCH_WORKLOOP_PRIVATE__
-
-#ifndef __DISPATCH_INDIRECT__
-#error "Please #include <dispatch/private.h> instead of this file directly."
-#include <dispatch/base.h> // for HeaderDoc
-#endif
-
-/******************************************************************************\
- *
- * THIS FILE IS AN IN-PROGRESS INTERFACE THAT IS SUBJECT TO CHANGE
- *
-\******************************************************************************/
-
-DISPATCH_ASSUME_NONNULL_BEGIN
-
-__BEGIN_DECLS
-
-/*!
- * @typedef dispatch_workloop_t
- *
- * @abstract
- * Dispatch workloops invoke workitems submitted to them in priority order.
- *
- * @discussion
- * A dispatch workloop is a flavor of dispatch_queue_t that is a priority
- * ordered queue (using the QOS class of the submitted workitems as the
- * ordering).
- *
- * Between each workitem invocation, the workloop will evaluate whether higher
- * priority workitems have since been submitted and execute these first.
- *
- * Serial queues targeting a workloop maintain FIFO execution of their
- * workitems. However, the workloop may reorder workitems submitted to
- * independent serial queues targeting it with respect to each other,
- * based on their priorities.
- *
- * A dispatch workloop is a "subclass" of dispatch_queue_t which can be passed
- * to all APIs accepting a dispatch queue, except for functions from the
- * dispatch_sync() family. dispatch_async_and_wait() must be used for workloop
- * objects. Functions from the dispatch_sync() family on queues targeting
- * a workloop are still permitted but discouraged for performance reasons.
- */
-#if defined(__DISPATCH_BUILDING_DISPATCH__) && !defined(__OBJC__)
-typedef struct dispatch_workloop_s *dispatch_workloop_t;
-#else
-DISPATCH_DECL_SUBCLASS(dispatch_workloop, dispatch_queue);
-#endif
-
-/*!
- * @function dispatch_workloop_create
- *
- * @abstract
- * Creates a new dispatch workloop to which workitems may be submitted.
- *
- * @param label
- * A string label to attach to the workloop.
- *
- * @result
- * The newly created dispatch workloop.
- */
-API_AVAILABLE(macos(10.14), ios(12.0), tvos(12.0), watchos(5.0))
-DISPATCH_EXPORT DISPATCH_MALLOC DISPATCH_RETURNS_RETAINED DISPATCH_WARN_RESULT
-DISPATCH_NOTHROW
-dispatch_workloop_t
-dispatch_workloop_create(const char *_Nullable label);
-
-/*!
- * @function dispatch_workloop_create_inactive
- *
- * @abstract
- * Creates a new inactive dispatch workloop that can be setup and then
- * activated.
- *
- * @discussion
- * Creating an inactive workloop allows for it to receive further configuration
- * before it is activated, and workitems can be submitted to it.
- *
- * Submitting workitems to an inactive workloop is undefined and will cause the
- * process to be terminated.
- *
- * @param label
- * A string label to attach to the workloop.
- *
- * @result
- * The newly created dispatch workloop.
- */
-API_AVAILABLE(macos(10.14), ios(12.0), tvos(12.0), watchos(5.0))
-DISPATCH_EXPORT DISPATCH_MALLOC DISPATCH_RETURNS_RETAINED DISPATCH_WARN_RESULT
-DISPATCH_NOTHROW
-dispatch_workloop_t
-dispatch_workloop_create_inactive(const char *_Nullable label);
-
-/*!
- * @function dispatch_workloop_set_autorelease_frequency
- *
- * @abstract
- * Sets the autorelease frequency of the workloop.
- *
- * @discussion
- * See dispatch_queue_attr_make_with_autorelease_frequency().
- * The default policy for a workloop is
- * DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM.
- *
- * @param workloop
- * The dispatch workloop to modify.
- *
- * This workloop must be inactive, passing an activated object is undefined
- * and will cause the process to be terminated.
- *
- * @param frequency
- * The requested autorelease frequency.
- */
-API_AVAILABLE(macos(10.14), ios(12.0), tvos(12.0), watchos(5.0))
-DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW
-void
-dispatch_workloop_set_autorelease_frequency(dispatch_workloop_t workloop,
-		dispatch_autorelease_frequency_t frequency);
-
-DISPATCH_ENUM(dispatch_workloop_param_flags, uint64_t,
-	DISPATCH_WORKLOOP_NONE DISPATCH_ENUM_API_AVAILABLE(macos(10.14), ios(12.0), tvos(12.0), watchos(5.0)) = 0x0,
-	DISPATCH_WORKLOOP_FIXED_PRIORITY DISPATCH_ENUM_API_AVAILABLE(macos(10.14), ios(12.0), tvos(12.0), watchos(5.0)) = 0x1,
-);
-
-/*!
- * @function dispatch_workloop_set_qos_class_floor
- *
- * @abstract
- * Sets the QOS class floor of a workloop.
- *
- * @discussion
- * See dispatch_set_qos_class_floor().
- *
- * This function is strictly equivalent to dispatch_set_qos_class_floor() but
- * allows to pass extra flags.
- *
- * Using both dispatch_workloop_set_scheduler_priority() and
- * dispatch_set_qos_class_floor() or dispatch_workloop_set_qos_class_floor()
- * is undefined and will cause the process to be terminated.
- *
- * @param workloop
- * The dispatch workloop to modify.
- *
- * This workloop must be inactive, passing an activated object is undefined
- * and will cause the process to be terminated.
- */
-API_AVAILABLE(macos(10.14), ios(12.0), tvos(12.0), watchos(5.0))
-DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW
-void
-dispatch_workloop_set_qos_class_floor(dispatch_workloop_t workloop,
-		dispatch_qos_class_t qos, int relpri, dispatch_workloop_param_flags_t flags);
-
-/*!
- * @function dispatch_workloop_set_scheduler_priority
- *
- * @abstract
- * Sets the scheduler priority for a dispatch workloop.
- *
- * @discussion
- * This sets the scheduler priority of the threads that the runtime will bring
- * up to service this workloop.
- *
- * QOS propagation still functions on these workloops, but its effect on the
- * priority of the thread brought up to service this workloop is ignored.
- *
- * Using both dispatch_workloop_set_scheduler_priority() and
- * dispatch_set_qos_class_floor() or dispatch_workloop_set_qos_class_floor()
- * is undefined and will cause the process to be terminated.
- *
- * @param workloop
- * The dispatch workloop to modify.
- *
- * This workloop must be inactive, passing an activated object is undefined
- * and will cause the process to be terminated.
- */
-API_AVAILABLE(macos(10.14), ios(12.0), tvos(12.0), watchos(5.0))
-DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW
-void
-dispatch_workloop_set_scheduler_priority(dispatch_workloop_t workloop,
-		int priority, dispatch_workloop_param_flags_t flags);
-
-/*!
- * @function dispatch_workloop_set_cpupercent
- *
- * @abstract
- * Sets the cpu percent and refill attributes for a dispatch workloop.
- *
- * @discussion
- * This should only used if the workloop was also setup with the
- * DISPATCH_WORKLOOP_FIXED_PRIORITY flag as a safe guard against
- * busy loops that could starve the rest of the system forever.
- *
- * If DISPATCH_WORKLOOP_FIXED_PRIORITY wasn't passed, using this function is
- * undefined and will cause the process to be terminated.
- *
- * @param workloop
- * The dispatch workloop to modify.
- *
- * This workloop must be inactive, passing an activated object is undefined
- * and will cause the process to be terminated.
- */
-API_AVAILABLE(macos(10.14), ios(12.0), tvos(12.0), watchos(5.0))
-DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW
-void
-dispatch_workloop_set_cpupercent(dispatch_workloop_t workloop, uint8_t percent,
-		uint32_t refillms);
-
-/*!
- * @function dispatch_workloop_is_current()
- *
- * @abstract
- * Returns whether the current thread has been made by the runtime to service
- * this workloop.
- *
- * @discussion
- * Note that when using <code>dispatch_async_and_wait(workloop, ^{ ... })</code>
- * then <code>workloop</code> will be seen as the "current" one by the submitted
- * workitem, but that is not the case when using dispatch_sync() on a queue
- * targeting the workloop.
- */
-API_AVAILABLE(macos(10.14), ios(12.0), tvos(12.0), watchos(5.0))
-DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW
-bool
-dispatch_workloop_is_current(dispatch_workloop_t workloop);
-
-/*!
- * @function dispatch_workloop_copy_current()
- *
- * @abstract
- * Returns a copy of the workoop that is being serviced on the calling thread
- * if any.
- *
- * @discussion
- * If the thread is not a workqueue thread, or is not servicing a dispatch
- * workloop, then NULL is returned.
- *
- * This returns a retained object that must be released with dispatch_release().
- */
-API_AVAILABLE(macos(10.14), ios(12.0), tvos(12.0), watchos(5.0))
-DISPATCH_EXPORT DISPATCH_RETURNS_RETAINED DISPATCH_NOTHROW
-dispatch_workloop_t _Nullable
-dispatch_workloop_copy_current(void);
-
-// Equivalent to dispatch_workloop_set_qos_class_floor(workoop, qos, 0, flags)
-API_DEPRECATED_WITH_REPLACEMENT("dispatch_workloop_set_qos_class_floor",
-		macos(10.14,10.14), ios(12.0,12.0), tvos(12.0,12.0), watchos(5.0,5.0))
-DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW
-void
-dispatch_workloop_set_qos_class(dispatch_workloop_t workloop,
-		dispatch_qos_class_t qos, dispatch_workloop_param_flags_t flags);
-
-API_AVAILABLE(macos(10.14), ios(12.0), tvos(12.0), watchos(5.0))
-DISPATCH_EXPORT DISPATCH_NOTHROW
-bool
-_dispatch_workloop_should_yield_4NW(void);
-
-/*!
- * @function dispatch_async_and_wait
- *
- * @abstract
- * Submits a block for synchronous execution on a dispatch queue.
- *
- * @discussion
- * Submits a workitem to a dispatch queue like dispatch_async(), however
- * dispatch_async_and_wait() will not return until the workitem has finished.
- *
- * Like functions of the dispatch_sync family, dispatch_async_and_wait() is
- * subject to dead-lock (See dispatch_sync() for details).
- *
- * However, dispatch_async_and_wait() differs from functions of the
- * dispatch_sync family in two fundamental ways: how it respects queue
- * attributes and how it chooses the execution context invoking the workitem.
- *
- * <b>Differences with dispatch_sync()</b>
- *
- * Work items submitted to a queue with dispatch_async_and_wait() observe all
- * queue attributes of that queue when invoked (inluding autorelease frequency
- * or QOS class).
- *
- * When the runtime has brought up a thread to invoke the asynchronous workitems
- * already submitted to the specified queue, that servicing thread will also be
- * used to execute synchronous work submitted to the queue with
- * dispatch_async_and_wait().
- *
- * However, if the runtime has not brought up a thread to service the specified
- * queue (because it has no workitems enqueued, or only synchronous workitems),
- * then dispatch_async_and_wait() will invoke the workitem on the calling thread,
- * similar to the behaviour of functions in the dispatch_sync family.
- *
- * As an exception, if the queue the work is submitted to doesn't target
- * a global concurrent queue (for example because it targets the main queue),
- * then the workitem will never be invoked by the thread calling
- * dispatch_async_and_wait().
- *
- * In other words, dispatch_async_and_wait() is similar to submitting
- * a dispatch_block_create()d workitem to a queue and then waiting on it, as
- * shown in the code example below. However, dispatch_async_and_wait() is
- * significantly more efficient when a new thread is not required to execute
- * the workitem (as it will use the stack of the submitting thread instead of
- * requiring heap allocations).
- *
- * <code>
- *     dispatch_block_t b = dispatch_block_create(0, block);
- *     dispatch_async(queue, b);
- *     dispatch_block_wait(b, DISPATCH_TIME_FOREVER);
- *     Block_release(b);
- * </code>
- *
- * @param queue
- * The target dispatch queue to which the block is submitted.
- * The result of passing NULL in this parameter is undefined.
- *
- * @param block
- * The block to be invoked on the target dispatch queue.
- * The result of passing NULL in this parameter is undefined.
- */
-#ifdef __BLOCKS__
-API_AVAILABLE(macos(10.14), ios(12.0), tvos(12.0), watchos(5.0))
-DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW
-void
-dispatch_async_and_wait(dispatch_queue_t queue,
-		DISPATCH_NOESCAPE dispatch_block_t block);
-#endif
-
-/*!
- * @function dispatch_async_and_wait_f
- *
- * @abstract
- * Submits a function for synchronous execution on a dispatch queue.
- *
- * @discussion
- * See dispatch_async_and_wait() for details.
- *
- * @param queue
- * The target dispatch queue to which the function is submitted.
- * The result of passing NULL in this parameter is undefined.
- *
- * @param context
- * The application-defined context parameter to pass to the function.
- *
- * @param work
- * The application-defined function to invoke on the target queue. The first
- * parameter passed to this function is the context provided to
- * dispatch_async_and_wait_f().
- * The result of passing NULL in this parameter is undefined.
- */
-API_AVAILABLE(macos(10.14), ios(12.0), tvos(12.0), watchos(5.0))
-DISPATCH_EXPORT DISPATCH_NONNULL1 DISPATCH_NONNULL3 DISPATCH_NOTHROW
-void
-dispatch_async_and_wait_f(dispatch_queue_t queue,
-		void *_Nullable context, dispatch_function_t work);
-
-/*!
- * @function dispatch_barrier_async_and_wait
- *
- * @abstract
- * Submits a block for synchronous execution on a dispatch queue.
- *
- * @discussion
- * Submits a block to a dispatch queue like dispatch_async_and_wait(), but marks
- * that block as a barrier (relevant only on DISPATCH_QUEUE_CONCURRENT
- * queues).
- *
- * @param queue
- * The target dispatch queue to which the block is submitted.
- * The result of passing NULL in this parameter is undefined.
- *
- * @param work
- * The application-defined block to invoke on the target queue.
- * The result of passing NULL in this parameter is undefined.
- */
-#ifdef __BLOCKS__
-API_AVAILABLE(macos(10.14), ios(12.0), tvos(12.0), watchos(5.0))
-DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW
-void
-dispatch_barrier_async_and_wait(dispatch_queue_t queue,
-		DISPATCH_NOESCAPE dispatch_block_t block);
-#endif
-
-/*!
- * @function dispatch_barrier_async_and_wait_f
- *
- * @abstract
- * Submits a function for synchronous execution on a dispatch queue.
- *
- * @discussion
- * Submits a function to a dispatch queue like dispatch_async_and_wait_f(), but
- * marks that function as a barrier (relevant only on DISPATCH_QUEUE_CONCURRENT
- * queues).
- *
- * @param queue
- * The target dispatch queue to which the function is submitted.
- * The result of passing NULL in this parameter is undefined.
- *
- * @param context
- * The application-defined context parameter to pass to the function.
- *
- * @param work
- * The application-defined function to invoke on the target queue. The first
- * parameter passed to this function is the context provided to
- * dispatch_barrier_async_and_wait_f().
- * The result of passing NULL in this parameter is undefined.
- */
-API_AVAILABLE(macos(10.14), ios(12.0), tvos(12.0), watchos(5.0))
-DISPATCH_EXPORT DISPATCH_NONNULL1 DISPATCH_NONNULL3 DISPATCH_NOTHROW
-void
-dispatch_barrier_async_and_wait_f(dispatch_queue_t queue,
-		void *_Nullable context, dispatch_function_t work);
-
-__END_DECLS
-
-DISPATCH_ASSUME_NONNULL_END
-
-#endif
--- a/Telegram/ThirdParty/dispatch/README.md	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/README.md	1970-01-01 00:00:00.000000000 -0000
@@ -1,24 +0,0 @@
-# Grand Central Dispatch
-
-Grand Central Dispatch (GCD or libdispatch) provides comprehensive support for concurrent code execution on multicore hardware.
-
-libdispatch is currently available on all Darwin platforms. This project aims to make a modern version of libdispatch available on all other Swift platforms. To do this, we will implement as much of the portable subset of the API as possible, using the existing open source C implementation.
-
-libdispatch on Darwin is a combination of logic in the `xnu` kernel alongside the user-space Library. The kernel has the most information available to balance workload across the entire system. As a first step, however, we believe it is useful to bring up the basic functionality of the library using user-space pthread primitives on Linux.  Eventually, a Linux kernel module could be developed to support more informed thread scheduling.
-
-## Project Status
-
-A port of libdispatch to Linux has been completed. On Linux, since Swift 3, swift-corelibs-libdispatch has been included in all Swift releases and is used by other swift-corelibs projects.
-
-Opportunities to contribute and on-going work include:
-
-1. Develop a test suite for the Swift APIs of libdispatch.
-2. Enhance libdispatch as needed to support Swift language evolution and the needs of the other Core Libraries projects.
-
-## Build and Install
-
-For detailed instructions on building and installing libdispatch, see [INSTALL.md](INSTALL.md)
-
-## Testing
-
-For detailed instructions on testing libdispatch, see [TESTING.md](TESTING.md)
--- a/Telegram/ThirdParty/dispatch/resolver/resolved.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/resolver/resolved.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,26 +0,0 @@
-/*
- * Copyright (c) 2010-2013 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-/*
- * IMPORTANT: This header file describes INTERNAL interfaces to libdispatch
- * which are subject to change in future releases of Mac OS X. Any applications
- * relying on these interfaces WILL break.
- */
-
--- a/Telegram/ThirdParty/dispatch/resolver/resolver.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/resolver/resolver.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,20 +0,0 @@
-/*
- * Copyright (c) 2010-2013 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
--- a/Telegram/ThirdParty/dispatch/resolver/resolver.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/resolver/resolver.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,31 +0,0 @@
-/*
- * Copyright (c) 2010 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-/*
- * IMPORTANT: This header file describes INTERNAL interfaces to libdispatch
- * which are subject to change in future releases of Mac OS X. Any applications
- * relying on these interfaces WILL break.
- */
-
-#ifndef __DISPATCH_RESOLVERS__
-#define __DISPATCH_RESOLVERS__
-
-
-#endif
--- a/Telegram/ThirdParty/dispatch/src/allocator.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/allocator.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,797 +0,0 @@
-/*
- * Copyright (c) 2012-2013 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include "internal.h"
-#include "allocator_internal.h"
-
-#if DISPATCH_ALLOCATOR
-
-#ifndef VM_MEMORY_LIBDISPATCH
-#define VM_MEMORY_LIBDISPATCH 74
-#endif
-
-// _dispatch_main_heap is is the first heap in the linked list, where searches
-// always begin.
-//
-// _dispatch_main_heap, and dh_next, are read normally but only written (in
-// try_create_heap) by cmpxchg. They start life at 0, and are only written
-// once to non-zero. They are not marked volatile. There is a small risk that
-// some thread may see a stale 0 value and enter try_create_heap. It will
-// waste some time in an allocate syscall, but eventually it will try to
-// cmpxchg, expecting to overwrite 0 with an address. This will fail
-// (because another thread already did this), the thread will deallocate the
-// unused allocated memory, and continue with the new value.
-//
-// If something goes wrong here, the symptom would be a NULL dereference
-// in alloc_continuation_from_heap or _magazine when derefing the magazine ptr.
-DISPATCH_GLOBAL(dispatch_heap_t _dispatch_main_heap);
-
-DISPATCH_ALWAYS_INLINE
-static void
-set_last_found_page(bitmap_t *val)
-{
-	dispatch_assert(_dispatch_main_heap);
-	unsigned int cpu = _dispatch_cpu_number();
-	_dispatch_main_heap[cpu].header.last_found_page = val;
-}
-
-DISPATCH_ALWAYS_INLINE
-static bitmap_t *
-last_found_page(void)
-{
-	dispatch_assert(_dispatch_main_heap);
-	unsigned int cpu = _dispatch_cpu_number();
-	return _dispatch_main_heap[cpu].header.last_found_page;
-}
-
-#pragma mark -
-#pragma mark dispatch_alloc_bitmaps
-
-DISPATCH_ALWAYS_INLINE_NDEBUG DISPATCH_CONST
-static bitmap_t *
-supermap_address(struct dispatch_magazine_s *magazine, unsigned int supermap)
-{
-	return &magazine->supermaps[supermap];
-}
-
-DISPATCH_ALWAYS_INLINE_NDEBUG DISPATCH_CONST
-static bitmap_t *
-bitmap_address(struct dispatch_magazine_s *magazine, unsigned int supermap,
-		unsigned int map)
-{
-	return &magazine->maps[supermap][map];
-}
-
-DISPATCH_ALWAYS_INLINE_NDEBUG DISPATCH_CONST
-static dispatch_continuation_t
-continuation_address(struct dispatch_magazine_s *magazine,
-		unsigned int supermap, unsigned int map, unsigned int index)
-{
-#if DISPATCH_DEBUG
-	dispatch_assert(supermap < SUPERMAPS_PER_MAGAZINE);
-	dispatch_assert(map < BITMAPS_PER_SUPERMAP);
-	dispatch_assert(index < CONTINUATIONS_PER_BITMAP);
-#endif
-	return (dispatch_continuation_t)&magazine->conts[supermap][map][index];
-}
-
-DISPATCH_ALWAYS_INLINE_NDEBUG DISPATCH_CONST
-static struct dispatch_magazine_s *
-magazine_for_continuation(dispatch_continuation_t c)
-{
-	return (struct dispatch_magazine_s *)((uintptr_t)c & MAGAZINE_MASK);
-}
-
-DISPATCH_ALWAYS_INLINE_NDEBUG
-static void
-get_cont_and_indices_for_bitmap_and_index(bitmap_t *bitmap,
-		unsigned int index, dispatch_continuation_t *continuation_out,
-		bitmap_t **supermap_out, unsigned int *bitmap_index_out)
-{
-	// m_for_c wants a continuation not a bitmap, but it works because it
-	// just masks off the bottom bits of the address.
-	struct dispatch_magazine_s *m = magazine_for_continuation((void *)bitmap);
-	unsigned int mindex = (unsigned int)(bitmap - m->maps[0]);
-	unsigned int bindex = mindex % BITMAPS_PER_SUPERMAP;
-	unsigned int sindex = mindex / BITMAPS_PER_SUPERMAP;
-	dispatch_assert(&m->maps[sindex][bindex] == bitmap);
-	if (likely(continuation_out)) {
-		*continuation_out = continuation_address(m, sindex, bindex, index);
-	}
-	if (likely(supermap_out)) *supermap_out = supermap_address(m, sindex);
-	if (likely(bitmap_index_out)) *bitmap_index_out = bindex;
-}
-
-DISPATCH_ALWAYS_INLINE_NDEBUG DISPATCH_CONST
-static bool
-continuation_is_in_first_page(dispatch_continuation_t c)
-{
-#if PACK_FIRST_PAGE_WITH_CONTINUATIONS
-	// (the base of c's magazine == the base of c's page)
-	// => c is in first page of magazine
-	return (((uintptr_t)c & MAGAZINE_MASK) ==
-			((uintptr_t)c & ~(uintptr_t)DISPATCH_ALLOCATOR_PAGE_MASK));
-#else
-	(void)c;
-	return false;
-#endif
-}
-
-DISPATCH_ALWAYS_INLINE_NDEBUG
-static void
-get_maps_and_indices_for_continuation(dispatch_continuation_t c,
-		bitmap_t **supermap_out, unsigned int *bitmap_index_out,
-		bitmap_t **bitmap_out, unsigned int *index_out)
-{
-	unsigned int cindex, sindex, index, mindex;
-	padded_continuation *p = (padded_continuation *)c;
-	struct dispatch_magazine_s *m = magazine_for_continuation(c);
-#if PACK_FIRST_PAGE_WITH_CONTINUATIONS
-	if (likely(continuation_is_in_first_page(c))) {
-		cindex = (unsigned int)(p - m->fp_conts);
-		index = cindex % CONTINUATIONS_PER_BITMAP;
-		mindex = cindex / CONTINUATIONS_PER_BITMAP;
-		if (likely(supermap_out)) *supermap_out = NULL;
-		if (likely(bitmap_index_out)) *bitmap_index_out = mindex;
-		if (likely(bitmap_out)) *bitmap_out = &m->fp_maps[mindex];
-		if (likely(index_out)) *index_out = index;
-		return;
-	}
-#endif // PACK_FIRST_PAGE_WITH_CONTINUATIONS
-	cindex = (unsigned int)(p - (padded_continuation *)m->conts);
-	sindex = cindex / (BITMAPS_PER_SUPERMAP * CONTINUATIONS_PER_BITMAP);
-	mindex = (cindex / CONTINUATIONS_PER_BITMAP) % BITMAPS_PER_SUPERMAP;
-	index = cindex % CONTINUATIONS_PER_BITMAP;
-	if (likely(supermap_out)) *supermap_out = &m->supermaps[sindex];
-	if (likely(bitmap_index_out)) *bitmap_index_out = mindex;
-	if (likely(bitmap_out)) *bitmap_out = &m->maps[sindex][mindex];
-	if (likely(index_out)) *index_out = index;
-}
-
-// Base address of page, or NULL if this page shouldn't be madvise()d
-DISPATCH_ALWAYS_INLINE_NDEBUG DISPATCH_CONST
-static void *
-madvisable_page_base_for_continuation(dispatch_continuation_t c)
-{
-	if (likely(continuation_is_in_first_page(c))) {
-		return NULL;
-	}
-	void *page_base = (void *)((uintptr_t)c &
-			~(uintptr_t)DISPATCH_ALLOCATOR_PAGE_MASK);
-#if DISPATCH_DEBUG
-	struct dispatch_magazine_s *m = magazine_for_continuation(c);
-	if (unlikely(page_base < (void *)&m->conts)) {
-		DISPATCH_INTERNAL_CRASH(page_base, "madvisable continuation too low");
-	}
-	if (unlikely(page_base > (void *)&m->conts[SUPERMAPS_PER_MAGAZINE-1]
-			[BITMAPS_PER_SUPERMAP-1][CONTINUATIONS_PER_BITMAP-1])) {
-		DISPATCH_INTERNAL_CRASH(page_base, "madvisable continuation too high");
-	}
-#endif
-	return page_base;
-}
-
-// Bitmap that controls the first few continuations in the same page as
-// the continuations controlled by the passed bitmap. Undefined results if the
-// passed bitmap controls continuations in the first page.
-DISPATCH_ALWAYS_INLINE_NDEBUG DISPATCH_CONST
-static bitmap_t *
-first_bitmap_in_same_page(bitmap_t *b)
-{
-#if DISPATCH_DEBUG
-	struct dispatch_magazine_s *m;
-	m = magazine_for_continuation((void*)b);
-	dispatch_assert(b >= &m->maps[0][0]);
-	dispatch_assert(b <  &m->maps[SUPERMAPS_PER_MAGAZINE]
-			[BITMAPS_PER_SUPERMAP]);
-#endif
-	const uintptr_t PAGE_BITMAP_MASK = (BITMAPS_PER_PAGE *
-			BYTES_PER_BITMAP) - 1;
-	return (bitmap_t *)((uintptr_t)b & ~PAGE_BITMAP_MASK);
-}
-
-DISPATCH_ALWAYS_INLINE_NDEBUG DISPATCH_CONST
-static bool
-bitmap_is_full(bitmap_t bits)
-{
-	return (bits == BITMAP_ALL_ONES);
-}
-
-#define NO_BITS_WERE_UNSET (UINT_MAX)
-
-// max_index is the 0-based position of the most significant bit that is
-// allowed to be set.
-DISPATCH_ALWAYS_INLINE_NDEBUG
-static unsigned int
-bitmap_set_first_unset_bit_upto_index(volatile bitmap_t *bitmap,
-		unsigned int max_index)
-{
-	// No barriers needed in acquire path: the just-allocated
-	// continuation is "uninitialized", so the caller shouldn't
-	// load from it before storing, so we don't need to guard
-	// against reordering those loads.
-	dispatch_assert(sizeof(*bitmap) == sizeof(unsigned long));
-	return os_atomic_set_first_bit(bitmap, max_index);
-}
-
-DISPATCH_ALWAYS_INLINE
-static unsigned int
-bitmap_set_first_unset_bit(volatile bitmap_t *bitmap)
-{
-	return bitmap_set_first_unset_bit_upto_index(bitmap, UINT_MAX);
-}
-
-#define CLEAR_EXCLUSIVELY true
-#define CLEAR_NONEXCLUSIVELY false
-
-// Return true if this bit was the last in the bitmap, and it is now all zeroes
-DISPATCH_ALWAYS_INLINE_NDEBUG
-static bool
-bitmap_clear_bit(volatile bitmap_t *bitmap, unsigned int index,
-		bool exclusively)
-{
-#if DISPATCH_DEBUG
-	dispatch_assert(index < CONTINUATIONS_PER_BITMAP);
-#endif
-	const bitmap_t mask = BITMAP_C(1) << index;
-	bitmap_t b;
-
-	if (exclusively == CLEAR_EXCLUSIVELY) {
-		if (unlikely((*bitmap & mask) == 0)) {
-			DISPATCH_CLIENT_CRASH(*bitmap,
-					"Corruption: failed to clear bit exclusively");
-		}
-	}
-
-	// and-and-fetch
-	b = os_atomic_and(bitmap, ~mask, release);
-	return b == 0;
-}
-
-DISPATCH_ALWAYS_INLINE_NDEBUG
-static void
-mark_bitmap_as_full_if_still_full(volatile bitmap_t *supermap,
-		unsigned int bitmap_index, volatile bitmap_t *bitmap)
-{
-#if DISPATCH_DEBUG
-	dispatch_assert(bitmap_index < BITMAPS_PER_SUPERMAP);
-#endif
-	const bitmap_t mask = BITMAP_C(1) << bitmap_index;
-	bitmap_t s, s_new;
-
-	// No barriers because supermaps are only advisory, they
-	// don't protect access to other memory.
-	os_atomic_rmw_loop(supermap, s, s_new, relaxed, {
-		if (!bitmap_is_full(*bitmap)) {
-			os_atomic_rmw_loop_give_up(return);
-		}
-		s_new = s | mask;
-	});
-}
-
-#pragma mark -
-#pragma mark dispatch_alloc_continuation_alloc
-
-#if PACK_FIRST_PAGE_WITH_CONTINUATIONS
-DISPATCH_ALWAYS_INLINE_NDEBUG
-static dispatch_continuation_t
-alloc_continuation_from_first_page(struct dispatch_magazine_s *magazine)
-{
-	unsigned int i, index, continuation_index;
-
-	// TODO: unroll if this is hot?
-	for (i = 0; i < FULL_BITMAPS_IN_FIRST_PAGE; i++) {
-		index = bitmap_set_first_unset_bit(&magazine->fp_maps[i]);
-		if (likely(index != NO_BITS_WERE_UNSET)) goto found;
-	}
-	if (REMAINDERED_CONTINUATIONS_IN_FIRST_PAGE) {
-		index = bitmap_set_first_unset_bit_upto_index(&magazine->fp_maps[i],
-				REMAINDERED_CONTINUATIONS_IN_FIRST_PAGE - 1);
-		if (likely(index != NO_BITS_WERE_UNSET)) goto found;
-	}
-	return NULL;
-
-found:
-	continuation_index = (i * CONTINUATIONS_PER_BITMAP) + index;
-	return (dispatch_continuation_t)&magazine->fp_conts[continuation_index];
-}
-#endif // PACK_FIRST_PAGE_WITH_CONTINUATIONS
-
-DISPATCH_ALWAYS_INLINE_NDEBUG
-static dispatch_continuation_t
-alloc_continuation_from_magazine(struct dispatch_magazine_s *magazine)
-{
-	unsigned int s, b, index;
-
-	for (s = 0; s < SUPERMAPS_PER_MAGAZINE; s++) {
-		volatile bitmap_t *supermap = supermap_address(magazine, s);
-		if (bitmap_is_full(*supermap)) {
-			continue;
-		}
-		for (b = 0; b < BITMAPS_PER_SUPERMAP; b++) {
-			volatile bitmap_t *bitmap = bitmap_address(magazine, s, b);
-			index = bitmap_set_first_unset_bit(bitmap);
-			if (index != NO_BITS_WERE_UNSET) {
-				set_last_found_page(
-						first_bitmap_in_same_page((bitmap_t *)bitmap));
-				mark_bitmap_as_full_if_still_full(supermap, b, bitmap);
-				return continuation_address(magazine, s, b, index);
-			}
-		}
-	}
-	return NULL;
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_alloc_try_create_heap(dispatch_heap_t *heap_ptr)
-{
-#if HAVE_MACH
-	kern_return_t kr;
-	mach_vm_size_t vm_size = MAGAZINES_PER_HEAP * BYTES_PER_MAGAZINE;
-	mach_vm_offset_t vm_mask = ~MAGAZINE_MASK;
-	mach_vm_address_t vm_addr = vm_page_size;
-	while (unlikely(kr = mach_vm_map(mach_task_self(), &vm_addr, vm_size,
-			vm_mask, VM_FLAGS_ANYWHERE | VM_MAKE_TAG(VM_MEMORY_LIBDISPATCH),
-			MEMORY_OBJECT_NULL, 0, FALSE, VM_PROT_DEFAULT, VM_PROT_ALL,
-			VM_INHERIT_DEFAULT))) {
-		if (kr != KERN_NO_SPACE) {
-			DISPATCH_CLIENT_CRASH(kr, "Could not allocate heap");
-		}
-		_dispatch_temporary_resource_shortage();
-		vm_addr = vm_page_size;
-	}
-	uintptr_t aligned_region = (uintptr_t)vm_addr;
-#else // HAVE_MACH
-	const size_t region_sz = (1 + MAGAZINES_PER_HEAP) * BYTES_PER_MAGAZINE;
-	void *region_p;
-	while (!dispatch_assume((region_p = mmap(NULL, region_sz,
-			PROT_READ|PROT_WRITE, MAP_ANON | MAP_PRIVATE,
-			VM_MAKE_TAG(VM_MEMORY_LIBDISPATCH), 0)) != MAP_FAILED)) {
-		_dispatch_temporary_resource_shortage();
-	}
-	uintptr_t region = (uintptr_t)region_p;
-	uintptr_t region_end = region + region_sz;
-	uintptr_t aligned_region, aligned_region_end;
-	uintptr_t bottom_slop_len, top_slop_len;
-	// Realign if needed; find the slop at top/bottom to unmap
-	if ((region & ~(MAGAZINE_MASK)) == 0) {
-		bottom_slop_len = 0;
-		aligned_region = region;
-		aligned_region_end = region_end - BYTES_PER_MAGAZINE;
-		top_slop_len = BYTES_PER_MAGAZINE;
-	} else {
-		aligned_region = (region & MAGAZINE_MASK) + BYTES_PER_MAGAZINE;
-		aligned_region_end = aligned_region +
-				(MAGAZINES_PER_HEAP * BYTES_PER_MAGAZINE);
-		bottom_slop_len = aligned_region - region;
-		top_slop_len = BYTES_PER_MAGAZINE - bottom_slop_len;
-	}
-#if DISPATCH_DEBUG
-	// Double-check our math.
-	dispatch_assert(aligned_region % DISPATCH_ALLOCATOR_PAGE_SIZE == 0);
-	dispatch_assert(aligned_region % vm_kernel_page_size == 0);
-	dispatch_assert(aligned_region_end % DISPATCH_ALLOCATOR_PAGE_SIZE == 0);
-	dispatch_assert(aligned_region_end % vm_kernel_page_size == 0);
-	dispatch_assert(aligned_region_end > aligned_region);
-	dispatch_assert(top_slop_len % DISPATCH_ALLOCATOR_PAGE_SIZE == 0);
-	dispatch_assert(bottom_slop_len % DISPATCH_ALLOCATOR_PAGE_SIZE == 0);
-	dispatch_assert(aligned_region_end + top_slop_len == region_end);
-	dispatch_assert(region + bottom_slop_len == aligned_region);
-	dispatch_assert(region_sz == bottom_slop_len + top_slop_len +
-			MAGAZINES_PER_HEAP * BYTES_PER_MAGAZINE);
-	if (bottom_slop_len) {
-		(void)dispatch_assume_zero(mprotect((void *)region, bottom_slop_len,
-				PROT_NONE));
-	}
-	if (top_slop_len) {
-		(void)dispatch_assume_zero(mprotect((void *)aligned_region_end,
-				top_slop_len, PROT_NONE));
-	}
-#else
-	if (bottom_slop_len) {
-		(void)dispatch_assume_zero(munmap((void *)region, bottom_slop_len));
-	}
-	if (top_slop_len) {
-		(void)dispatch_assume_zero(munmap((void *)aligned_region_end,
-				top_slop_len));
-	}
-#endif // DISPATCH_DEBUG
-#endif // HAVE_MACH
-
-	if (!os_atomic_cmpxchg(heap_ptr, NULL, (void *)aligned_region,
-			relaxed)) {
-		// If we lost the race to link in the new region, unmap the whole thing.
-#if DISPATCH_DEBUG
-		(void)dispatch_assume_zero(mprotect((void *)aligned_region,
-				MAGAZINES_PER_HEAP * BYTES_PER_MAGAZINE, PROT_NONE));
-#else
-		(void)dispatch_assume_zero(munmap((void *)aligned_region,
-				MAGAZINES_PER_HEAP * BYTES_PER_MAGAZINE));
-#endif
-	}
-}
-
-DISPATCH_NOINLINE
-static dispatch_continuation_t
-_dispatch_alloc_continuation_from_heap(dispatch_heap_t heap)
-{
-	dispatch_continuation_t cont;
-
-	unsigned int cpu_number = _dispatch_cpu_number();
-#ifdef DISPATCH_DEBUG
-	dispatch_assert(cpu_number < NUM_CPU);
-#endif
-
-#if PACK_FIRST_PAGE_WITH_CONTINUATIONS
-	// First try the continuations in the first page for this CPU
-	cont = alloc_continuation_from_first_page(&(heap[cpu_number]));
-	if (likely(cont)) {
-		return cont;
-	}
-#endif
-	// Next, try the rest of the magazine for this CPU
-	cont = alloc_continuation_from_magazine(&(heap[cpu_number]));
-	return cont;
-}
-
-DISPATCH_NOINLINE
-static dispatch_continuation_t
-_dispatch_alloc_continuation_from_heap_slow(void)
-{
-	dispatch_heap_t *heap = &_dispatch_main_heap;
-	dispatch_continuation_t cont;
-
-	for (;;) {
-		if (unlikely(!*heap)) {
-			_dispatch_alloc_try_create_heap(heap);
-		}
-		cont = _dispatch_alloc_continuation_from_heap(*heap);
-		if (likely(cont)) {
-			return cont;
-		}
-		// If we have tuned our parameters right, 99.999% of apps should
-		// never reach this point! The ones that do have gone off the rails...
-		//
-		// Magazine is full? Onto the next heap!
-		// We tried 'stealing' from other CPUs' magazines. The net effect
-		// was worse performance from more wasted search time and more
-		// cache contention.
-
-		// rdar://11378331
-		// Future optimization: start at the page we last used, start
-		// in the *zone* we last used. But this would only improve deeply
-		// pathological cases like dispatch_starfish
-		heap = &(*heap)->header.dh_next;
-	}
-}
-
-DISPATCH_ALLOC_NOINLINE
-static dispatch_continuation_t
-_dispatch_alloc_continuation_alloc(void)
-{
-	dispatch_continuation_t cont;
-
-	if (likely(_dispatch_main_heap)) {
-		// Start looking in the same page where we found a continuation
-		// last time.
-		bitmap_t *last = last_found_page();
-		if (likely(last)) {
-			unsigned int i;
-			for (i = 0; i < BITMAPS_PER_PAGE; i++) {
-				bitmap_t *cur = last + i;
-				unsigned int index = bitmap_set_first_unset_bit(cur);
-				if (likely(index != NO_BITS_WERE_UNSET)) {
-					bitmap_t *supermap;
-					unsigned int bindex;
-					get_cont_and_indices_for_bitmap_and_index(cur,
-							index, &cont, &supermap, &bindex);
-					mark_bitmap_as_full_if_still_full(supermap, bindex,
-							cur);
-					return cont;
-				}
-			}
-		}
-
-		cont = _dispatch_alloc_continuation_from_heap(_dispatch_main_heap);
-		if (likely(cont)) {
-			return cont;
-		}
-	}
-	return _dispatch_alloc_continuation_from_heap_slow();
-}
-
-#pragma mark -
-#pragma mark dispatch_alloc_continuation_free
-
-DISPATCH_NOINLINE
-static void
-_dispatch_alloc_maybe_madvise_page(dispatch_continuation_t c)
-{
-	void *page = madvisable_page_base_for_continuation(c);
-	if (!page) {
-		// page can't be madvised; maybe it contains non-continuations
-		return;
-	}
-	// Are all the continuations in this page unallocated?
-	volatile bitmap_t *page_bitmaps;
-	get_maps_and_indices_for_continuation((dispatch_continuation_t)page, NULL,
-			NULL, (bitmap_t **)&page_bitmaps, NULL);
-	unsigned int i;
-	for (i = 0; i < BITMAPS_PER_PAGE; i++) {
-		if (page_bitmaps[i] != 0) {
-			return;
-		}
-	}
-	// They are all unallocated, so we could madvise the page. Try to
-	// take ownership of them all.
-	int last_locked = 0;
-	do {
-		if (!os_atomic_cmpxchg(&page_bitmaps[last_locked], BITMAP_C(0),
-				BITMAP_ALL_ONES, relaxed)) {
-			// We didn't get one; since there is a cont allocated in
-			// the page, we can't madvise. Give up and unlock all.
-			goto unlock;
-		}
-	} while (++last_locked < (signed)BITMAPS_PER_PAGE);
-#if DISPATCH_DEBUG
-	//fprintf(stderr, "%s: madvised page %p for cont %p (next = %p), "
-	//		"[%u+1]=%u bitmaps at %p\n", __func__, page, c, c->do_next,
-	//		last_locked-1, BITMAPS_PER_PAGE, &page_bitmaps[0]);
-	// Scribble to expose use-after-free bugs
-	// madvise (syscall) flushes these stores
-	memset(page, DISPATCH_ALLOCATOR_SCRIBBLE, DISPATCH_ALLOCATOR_PAGE_SIZE);
-#endif
-	(void)dispatch_assume_zero(madvise(page, DISPATCH_ALLOCATOR_PAGE_SIZE,
-			MADV_FREE));
-
-unlock:
-	while (last_locked > 1) {
-		page_bitmaps[--last_locked] = BITMAP_C(0);
-	}
-	if (last_locked) {
-		os_atomic_store(&page_bitmaps[0], BITMAP_C(0), relaxed);
-	}
-	return;
-}
-
-DISPATCH_ALLOC_NOINLINE
-static void
-_dispatch_alloc_continuation_free(dispatch_continuation_t c)
-{
-	bitmap_t *b, *s;
-	unsigned int b_idx, idx;
-
-	c->dc_flags = 0;
-	get_maps_and_indices_for_continuation(c, &s, &b_idx, &b, &idx);
-	bool bitmap_now_empty = bitmap_clear_bit(b, idx, CLEAR_EXCLUSIVELY);
-	if (unlikely(s)) {
-		(void)bitmap_clear_bit(s, b_idx, CLEAR_NONEXCLUSIVELY);
-	}
-	// We only try to madvise(2) pages outside of the first page.
-	// (Allocations in the first page do not have a supermap entry.)
-	if (unlikely(bitmap_now_empty && s)) {
-		return _dispatch_alloc_maybe_madvise_page(c);
-	}
-}
-
-#pragma mark -
-#pragma mark dispatch_alloc_init
-
-#if DISPATCH_CONTINUATION_MALLOC || DISPATCH_DEBUG
-static void
-_dispatch_alloc_init(void)
-{
-	// Double-check our math. These are all compile time checks and don't
-	// generate code.
-
-	dispatch_static_assert(sizeof(bitmap_t) == BYTES_PER_BITMAP);
-	dispatch_static_assert(sizeof(bitmap_t) == BYTES_PER_SUPERMAP);
-	dispatch_static_assert(sizeof(struct dispatch_magazine_header_s) ==
-			SIZEOF_HEADER);
-
-	dispatch_static_assert(sizeof(struct dispatch_continuation_s) <=
-			DISPATCH_CONTINUATION_SIZE);
-
-	// Magazines should be the right size, so they pack neatly into an array of
-	// heaps.
-	dispatch_static_assert(sizeof(struct dispatch_magazine_s) ==
-			BYTES_PER_MAGAZINE);
-
-	// The header and maps sizes should match what we computed.
-	dispatch_static_assert(SIZEOF_HEADER ==
-			sizeof(((struct dispatch_magazine_s *)0x0)->header));
-	dispatch_static_assert(SIZEOF_MAPS ==
-			sizeof(((struct dispatch_magazine_s *)0x0)->maps));
-
-	// The main array of continuations should start at the second page,
-	// self-aligned.
-	dispatch_static_assert(offsetof(struct dispatch_magazine_s, conts) %
-			(CONTINUATIONS_PER_BITMAP * DISPATCH_CONTINUATION_SIZE) == 0);
-	dispatch_static_assert(offsetof(struct dispatch_magazine_s, conts) ==
-			DISPATCH_ALLOCATOR_PAGE_SIZE);
-
-#if PACK_FIRST_PAGE_WITH_CONTINUATIONS
-	// The continuations in the first page should actually fit within the first
-	// page.
-	dispatch_static_assert(offsetof(struct dispatch_magazine_s, fp_conts) <
-			DISPATCH_ALLOCATOR_PAGE_SIZE);
-	dispatch_static_assert(offsetof(struct dispatch_magazine_s, fp_conts) %
-			DISPATCH_CONTINUATION_SIZE == 0);
-	dispatch_static_assert(offsetof(struct dispatch_magazine_s, fp_conts) +
-			sizeof(((struct dispatch_magazine_s *)0x0)->fp_conts) ==
-			DISPATCH_ALLOCATOR_PAGE_SIZE);
-#endif // PACK_FIRST_PAGE_WITH_CONTINUATIONS
-	// Make sure our alignment will be correct: that is, that we are correctly
-	// aligning to both.
-	dispatch_static_assert(ROUND_UP_TO_BITMAP_ALIGNMENT(ROUND_UP_TO_BITMAP_ALIGNMENT_AND_CONTINUATION_SIZE(1)) ==
-			ROUND_UP_TO_BITMAP_ALIGNMENT_AND_CONTINUATION_SIZE(1));
-	dispatch_static_assert(ROUND_UP_TO_CONTINUATION_SIZE(ROUND_UP_TO_BITMAP_ALIGNMENT_AND_CONTINUATION_SIZE(1)) ==
-			ROUND_UP_TO_BITMAP_ALIGNMENT_AND_CONTINUATION_SIZE(1));
-}
-#endif // DISPATCH_CONTINUATION_MALLOC || DISPATCH_DEBUG
-
-kern_return_t
-_dispatch_allocator_enumerate(task_t remote_task,
-		const struct dispatch_allocator_layout_s *remote_dal,
-		vm_address_t zone_address, memory_reader_t reader,
-		void (^recorder)(vm_address_t, void *, size_t, bool *stop))
-{
-	const size_t heap_size = remote_dal->dal_magazine_size;
-	const size_t dc_size = remote_dal->dal_allocation_size;
-	const size_t dc_flags_offset = remote_dal->dal_allocation_isa_offset;
-	bool stop = false;
-	void *heap;
-
-	while (zone_address) {
-		// FIXME: improve this by not faulting everything and driving it through
-		//        the bitmap.
-		kern_return_t kr = reader(remote_task, zone_address, heap_size, &heap);
-		size_t offs = remote_dal->dal_first_allocation_offset;
-		if (kr) return kr;
-		while (offs < heap_size) {
-			void *isa = *(void **)(heap + offs + dc_flags_offset);
-			if (isa && isa != remote_dal->dal_deferred_free_isa) {
-				recorder(zone_address + offs, heap + offs, dc_size, &stop);
-				if (stop) return KERN_SUCCESS;
-			}
-			offs += dc_size;
-		}
-		zone_address = (vm_address_t)((dispatch_heap_t)heap)->header.dh_next;
-	}
-
-	return KERN_SUCCESS;
-}
-
-#endif // DISPATCH_ALLOCATOR
-
-#pragma mark -
-#pragma mark dispatch_malloc
-
-#if DISPATCH_CONTINUATION_MALLOC
-
-#if DISPATCH_USE_MALLOCZONE
-static malloc_zone_t *_dispatch_ccache_zone;
-
-#define calloc(n, s) malloc_zone_calloc(_dispatch_ccache_zone, (n), (s))
-#define free(c) malloc_zone_free(_dispatch_ccache_zone, (c))
-
-static void
-_dispatch_malloc_init(void)
-{
-	_dispatch_ccache_zone = malloc_create_zone(0, 0);
-	dispatch_assert(_dispatch_ccache_zone);
-	malloc_set_zone_name(_dispatch_ccache_zone, "DispatchContinuations");
-}
-#else
-#define _dispatch_malloc_init() ((void)0)
-#endif // DISPATCH_USE_MALLOCZONE
-
-static dispatch_continuation_t
-_dispatch_malloc_continuation_alloc(void)
-{
-	dispatch_continuation_t dc;
-	size_t alloc_size = ROUND_UP_TO_CACHELINE_SIZE(sizeof(*dc));
-	while (unlikely(!(dc = calloc(1, alloc_size)))) {
-		_dispatch_temporary_resource_shortage();
-	}
-	return dc;
-}
-
-static inline void
-_dispatch_malloc_continuation_free(dispatch_continuation_t c)
-{
-	free(c);
-}
-#endif // DISPATCH_CONTINUATION_MALLOC
-
-#pragma mark -
-#pragma mark dispatch_continuation_alloc
-
-#if DISPATCH_ALLOCATOR
-#if DISPATCH_CONTINUATION_MALLOC
-#if !DISPATCH_USE_NANOZONE
-#define malloc_engaged_nano() false
-#endif // !DISPATCH_USE_NANOZONE
-DISPATCH_STATIC_GLOBAL(bool _dispatch_use_dispatch_alloc);
-#else
-#define _dispatch_use_dispatch_alloc 1
-#endif // DISPATCH_CONTINUATION_MALLOC
-#endif // DISPATCH_ALLOCATOR
-
-#if (DISPATCH_ALLOCATOR && (DISPATCH_CONTINUATION_MALLOC || DISPATCH_DEBUG)) \
-		|| (DISPATCH_CONTINUATION_MALLOC && DISPATCH_USE_MALLOCZONE)
-
-DISPATCH_STATIC_GLOBAL(dispatch_once_t _dispatch_continuation_alloc_init_pred);
-
-static void
-_dispatch_continuation_alloc_init(void *ctxt DISPATCH_UNUSED)
-{
-#if DISPATCH_ALLOCATOR
-#if DISPATCH_CONTINUATION_MALLOC
-	bool use_dispatch_alloc = !malloc_engaged_nano();
-	char *e = getenv("LIBDISPATCH_CONTINUATION_ALLOCATOR");
-	if (e) {
-		use_dispatch_alloc = atoi(e);
-	}
-	_dispatch_use_dispatch_alloc = use_dispatch_alloc;
-#endif // DISPATCH_CONTINUATION_MALLOC
-	if (_dispatch_use_dispatch_alloc)
-		return _dispatch_alloc_init();
-#endif // DISPATCH_ALLOCATOR
-#if DISPATCH_CONTINUATION_MALLOC
-	return _dispatch_malloc_init();
-#endif // DISPATCH_ALLOCATOR
-}
-
-static inline void
-_dispatch_continuation_alloc_once(void)
-{
-	dispatch_once_f(&_dispatch_continuation_alloc_init_pred,
-			NULL, _dispatch_continuation_alloc_init);
-}
-#else
-static inline void _dispatch_continuation_alloc_once(void) {}
-#endif // DISPATCH_ALLOCATOR ... || DISPATCH_CONTINUATION_MALLOC ...
-
-dispatch_continuation_t
-_dispatch_continuation_alloc_from_heap(void)
-{
-	_dispatch_continuation_alloc_once();
-#if DISPATCH_ALLOCATOR
-	if (_dispatch_use_dispatch_alloc)
-		return _dispatch_alloc_continuation_alloc();
-#endif
-#if DISPATCH_CONTINUATION_MALLOC
-	return _dispatch_malloc_continuation_alloc();
-#endif
-}
-
-void
-_dispatch_continuation_free_to_heap(dispatch_continuation_t c)
-{
-#if DISPATCH_ALLOCATOR
-	if (_dispatch_use_dispatch_alloc)
-		return _dispatch_alloc_continuation_free(c);
-#endif
-#if DISPATCH_CONTINUATION_MALLOC
-	return _dispatch_malloc_continuation_free(c);
-#endif
-}
--- a/Telegram/ThirdParty/dispatch/src/allocator_internal.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/allocator_internal.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,296 +0,0 @@
-/*
- * Copyright (c) 2012-2013 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-/*
- * IMPORTANT: This header file describes INTERNAL interfaces to libdispatch
- * which are subject to change in future releases of Mac OS X. Any applications
- * relying on these interfaces WILL break.
- */
-
-#ifndef __DISPATCH_ALLOCATOR_INTERNAL__
-#define __DISPATCH_ALLOCATOR_INTERNAL__
-
-#ifndef DISPATCH_ALLOCATOR
-#if TARGET_OS_MAC && (defined(__LP64__) || TARGET_OS_IPHONE)
-#define DISPATCH_ALLOCATOR 1
-#endif
-#endif
-
-#ifndef DISPATCH_USE_NANOZONE
-#if TARGET_OS_MAC && defined(__LP64__)
-#define DISPATCH_USE_NANOZONE 1
-#endif
-#endif
-
-#ifndef DISPATCH_USE_MALLOCZONE
-#if (TARGET_OS_MAC && !DISPATCH_USE_NANOZONE) || \
-		(!TARGET_OS_MAC && HAVE_MALLOC_CREATE_ZONE)
-#define DISPATCH_USE_MALLOCZONE 1
-#endif
-#endif
-
-#ifndef DISPATCH_CONTINUATION_MALLOC
-#if DISPATCH_USE_NANOZONE || !DISPATCH_ALLOCATOR
-#define DISPATCH_CONTINUATION_MALLOC 1
-#endif
-#endif
-
-#if !DISPATCH_ALLOCATOR && !DISPATCH_CONTINUATION_MALLOC
-#error Invalid allocator configuration
-#endif
-
-#if DISPATCH_ALLOCATOR && DISPATCH_CONTINUATION_MALLOC
-#define DISPATCH_ALLOC_NOINLINE DISPATCH_NOINLINE
-#else
-#define DISPATCH_ALLOC_NOINLINE
-#endif
-
-#pragma mark -
-#pragma mark DISPATCH_ALLOCATOR
-
-#if DISPATCH_ALLOCATOR
-
-// Configuration here!
-#define NUM_CPU dispatch_hw_config(logical_cpus)
-#define MAGAZINES_PER_HEAP (NUM_CPU)
-
-// Do you care about compaction or performance?
-#if TARGET_OS_IPHONE
-#define PACK_FIRST_PAGE_WITH_CONTINUATIONS 1
-#else
-#define PACK_FIRST_PAGE_WITH_CONTINUATIONS 0
-#endif
-
-#ifndef PAGE_MAX_SIZE
-#define PAGE_MAX_SIZE PAGE_SIZE
-#endif
-#ifndef PAGE_MAX_MASK
-#define PAGE_MAX_MASK PAGE_MASK
-#endif
-#define DISPATCH_ALLOCATOR_PAGE_SIZE PAGE_MAX_SIZE
-#define DISPATCH_ALLOCATOR_PAGE_MASK PAGE_MAX_MASK
-
-
-#if TARGET_OS_IPHONE
-#define PAGES_PER_MAGAZINE 64
-#else
-#define PAGES_PER_MAGAZINE 512
-#endif
-
-// Use the largest type your platform is comfortable doing atomic ops with.
-// TODO: rdar://11477843
-typedef unsigned long bitmap_t;
-#if DISPATCH_SIZEOF_PTR == 8
-#define BYTES_PER_BITMAP 8
-#else
-#define BYTES_PER_BITMAP 4
-#endif
-
-#define BITMAP_C(v) ((bitmap_t)(v))
-#define BITMAP_ALL_ONES (~BITMAP_C(0))
-
-// Stop configuring.
-
-#define CONTINUATIONS_PER_BITMAP (BYTES_PER_BITMAP * 8)
-#define BITMAPS_PER_SUPERMAP (BYTES_PER_SUPERMAP * 8)
-
-#define BYTES_PER_MAGAZINE (PAGES_PER_MAGAZINE * DISPATCH_ALLOCATOR_PAGE_SIZE)
-#define CONSUMED_BYTES_PER_BITMAP (BYTES_PER_BITMAP + \
-		(DISPATCH_CONTINUATION_SIZE * CONTINUATIONS_PER_BITMAP))
-
-#define BYTES_PER_SUPERMAP BYTES_PER_BITMAP
-#define CONSUMED_BYTES_PER_SUPERMAP (BYTES_PER_SUPERMAP + \
-		(BITMAPS_PER_SUPERMAP * CONSUMED_BYTES_PER_BITMAP))
-
-#define BYTES_PER_HEAP (BYTES_PER_MAGAZINE * MAGAZINES_PER_HEAP)
-
-#define BYTES_PER_PAGE DISPATCH_ALLOCATOR_PAGE_SIZE
-#define CONTINUATIONS_PER_PAGE (BYTES_PER_PAGE / DISPATCH_CONTINUATION_SIZE)
-#define BITMAPS_PER_PAGE (CONTINUATIONS_PER_PAGE / CONTINUATIONS_PER_BITMAP)
-
-// Assumption: metadata will be only in the first page.
-#define SUPERMAPS_PER_MAGAZINE ((BYTES_PER_MAGAZINE - BYTES_PER_PAGE) / \
-		CONSUMED_BYTES_PER_SUPERMAP)
-#define BITMAPS_PER_MAGAZINE (SUPERMAPS_PER_MAGAZINE * BITMAPS_PER_SUPERMAP)
-#define CONTINUATIONS_PER_MAGAZINE \
-		(BITMAPS_PER_MAGAZINE * CONTINUATIONS_PER_BITMAP)
-
-#define HEAP_MASK (~(uintptr_t)(BYTES_PER_HEAP - 1))
-#define MAGAZINE_MASK (~(uintptr_t)(BYTES_PER_MAGAZINE - 1))
-
-// this will round up such that first_bitmap_in_same_page() can mask the address
-// of a bitmap_t in the maps to obtain the first bitmap for that same page
-#define ROUND_UP_TO_BITMAP_ALIGNMENT(x) \
-		(((x) + ((BITMAPS_PER_PAGE * BYTES_PER_BITMAP) - 1u)) & \
-		~((BITMAPS_PER_PAGE * BYTES_PER_BITMAP) - 1u))
-// Since these are both powers of two, we end up with not only the max alignment,
-// but happily the least common multiple, which will be the greater of the two.
-#define ROUND_UP_TO_BITMAP_ALIGNMENT_AND_CONTINUATION_SIZE(x) (ROUND_UP_TO_CONTINUATION_SIZE(ROUND_UP_TO_BITMAP_ALIGNMENT(x)))
-#define PADDING_TO_BITMAP_ALIGNMENT_AND_CONTINUATION_SIZE(x) (ROUND_UP_TO_BITMAP_ALIGNMENT_AND_CONTINUATION_SIZE(x) - (x))
-
-#define PADDING_TO_CONTINUATION_SIZE(x) (ROUND_UP_TO_CONTINUATION_SIZE(x) - (x))
-
-#if DISPATCH_SIZEOF_PTR == 8
-#define SIZEOF_HEADER 16
-#else
-#define SIZEOF_HEADER 8
-#endif
-
-#define SIZEOF_SUPERMAPS (BYTES_PER_SUPERMAP * SUPERMAPS_PER_MAGAZINE)
-#define SIZEOF_MAPS (BYTES_PER_BITMAP * BITMAPS_PER_SUPERMAP * \
-		SUPERMAPS_PER_MAGAZINE)
-
-// header is expected to end on supermap's required alignment
-#define HEADER_TO_SUPERMAPS_PADDING 0
-// we want to align the maps to a continuation size, but we must also have proper padding
-// so that we can perform first_bitmap_in_same_page()
-#define SUPERMAPS_TO_MAPS_PADDING (PADDING_TO_BITMAP_ALIGNMENT_AND_CONTINUATION_SIZE( \
-		SIZEOF_SUPERMAPS + HEADER_TO_SUPERMAPS_PADDING + SIZEOF_HEADER))
-
-#define MAPS_TO_FPMAPS_PADDING (PADDING_TO_CONTINUATION_SIZE(SIZEOF_MAPS))
-
-#define BYTES_LEFT_IN_FIRST_PAGE (BYTES_PER_PAGE - \
-		(SIZEOF_HEADER + HEADER_TO_SUPERMAPS_PADDING + SIZEOF_SUPERMAPS + \
-		SUPERMAPS_TO_MAPS_PADDING + SIZEOF_MAPS + MAPS_TO_FPMAPS_PADDING))
-
-#if PACK_FIRST_PAGE_WITH_CONTINUATIONS
-
-#define FULL_BITMAPS_IN_FIRST_PAGE \
-		(BYTES_LEFT_IN_FIRST_PAGE / CONSUMED_BYTES_PER_BITMAP)
-#define REMAINDER_IN_FIRST_PAGE (BYTES_LEFT_IN_FIRST_PAGE - \
-		(FULL_BITMAPS_IN_FIRST_PAGE * CONSUMED_BYTES_PER_BITMAP) - \
-		(FULL_BITMAPS_IN_FIRST_PAGE ? 0 : \
-		ROUND_UP_TO_CONTINUATION_SIZE(BYTES_PER_BITMAP)))
-
-#define REMAINDERED_CONTINUATIONS_IN_FIRST_PAGE \
-		(REMAINDER_IN_FIRST_PAGE / DISPATCH_CONTINUATION_SIZE)
-#define CONTINUATIONS_IN_FIRST_PAGE (FULL_BITMAPS_IN_FIRST_PAGE * \
-		CONTINUATIONS_PER_BITMAP) + REMAINDERED_CONTINUATIONS_IN_FIRST_PAGE
-#define BITMAPS_IN_FIRST_PAGE (FULL_BITMAPS_IN_FIRST_PAGE + \
-		(REMAINDERED_CONTINUATIONS_IN_FIRST_PAGE == 0 ? 0 : 1))
-
-#define FPMAPS_TO_FPCONTS_PADDING (PADDING_TO_CONTINUATION_SIZE(\
-		BYTES_PER_BITMAP * BITMAPS_IN_FIRST_PAGE))
-
-#else // PACK_FIRST_PAGE_WITH_CONTINUATIONS
-
-#define MAPS_TO_CONTS_PADDING BYTES_LEFT_IN_FIRST_PAGE
-
-#endif // PACK_FIRST_PAGE_WITH_CONTINUATIONS
-
-#define AFTER_CONTS_PADDING (BYTES_PER_MAGAZINE - (BYTES_PER_PAGE + \
-		(DISPATCH_CONTINUATION_SIZE * CONTINUATIONS_PER_MAGAZINE)))
-
-// This is the object our allocator allocates: a chunk of memory rounded up
-// from sizeof(struct dispatch_continuation_s) to the cacheline size, so
-// unrelated continuations don't share cachelines. It'd be nice if
-// dispatch_continuation_s included this rounding/padding, but it doesn't.
-typedef char padded_continuation[DISPATCH_CONTINUATION_SIZE];
-
-// A dispatch_heap_t is the base address of an array of dispatch_magazine_s,
-// one magazine per CPU.
-typedef struct dispatch_magazine_s * dispatch_heap_t;
-
-struct dispatch_magazine_header_s {
-	// Link to the next heap in the chain. Only used in magazine 0's header
-	dispatch_heap_t dh_next;
-
-	// Points to the first bitmap in the page where this CPU successfully
-	// allocated a continuation last time. Only used in the first heap.
-	bitmap_t *last_found_page;
-};
-
-// A magazine is a complex data structure. It must be exactly
-// PAGES_PER_MAGAZINE * PAGE_SIZE bytes long, and that value must be a
-// power of 2. (See magazine_for_continuation()).
-struct dispatch_magazine_s {
-	// See above.
-	struct dispatch_magazine_header_s header;
-
-	// Align supermaps as needed.
-#if HEADER_TO_SUPERMAPS_PADDING > 0
-	char _pad0[HEADER_TO_SUPERMAPS_PADDING];
-#endif
-
-	// Second-level bitmap; each set bit means a bitmap_t in maps[][]
-	// is completely full (and can be skipped while searching).
-	bitmap_t supermaps[SUPERMAPS_PER_MAGAZINE];
-
-	// Align maps to a cacheline.
-#if SUPERMAPS_TO_MAPS_PADDING > 0
-	char _pad1[SUPERMAPS_TO_MAPS_PADDING];
-#endif
-
-	// Each bit in maps[][] is the free/used state of a member of conts[][][].
-	bitmap_t maps[SUPERMAPS_PER_MAGAZINE][BITMAPS_PER_SUPERMAP];
-
-	// Align fp_maps to a cacheline.
-#if MAPS_TO_FPMAPS_PADDING > 0
-	char _pad2[MAPS_TO_FPMAPS_PADDING];
-#endif
-
-#if PACK_FIRST_PAGE_WITH_CONTINUATIONS
-	// Bitmaps for the continuations that live in the first page, which
-	// are treated specially (they have faster search code).
-	bitmap_t fp_maps[BITMAPS_IN_FIRST_PAGE];
-
-	// Align fp_conts to cacheline.
-#if FPMAPS_TO_FPCONTS_PADDING > 0
-	char _pad3[FPMAPS_TO_FPCONTS_PADDING];
-#endif
-
-	// Continuations that live in the first page.
-	padded_continuation fp_conts[CONTINUATIONS_IN_FIRST_PAGE];
-
-#else // PACK_FIRST_PAGE_WITH_CONTINUATIONS
-
-#if MAPS_TO_CONTS_PADDING > 0
-	char _pad4[MAPS_TO_CONTS_PADDING];
-#endif
-#endif // PACK_FIRST_PAGE_WITH_CONTINUATIONS
-
-	// This is the big array of continuations.
-	// This must start on a page boundary.
-	padded_continuation conts[SUPERMAPS_PER_MAGAZINE][BITMAPS_PER_SUPERMAP]
-			[CONTINUATIONS_PER_BITMAP];
-
-	// Fill the unused space to exactly BYTES_PER_MAGAZINE
-#if AFTER_CONTS_PADDING > 0
-	char _pad5[AFTER_CONTS_PADDING];
-#endif
-};
-
-#if DISPATCH_DEBUG
-#define DISPATCH_ALLOCATOR_SCRIBBLE ((uintptr_t)0xAFAFAFAFAFAFAFAF)
-#endif
-
-
-kern_return_t _dispatch_allocator_enumerate(task_t remote_task,
-			const struct dispatch_allocator_layout_s *remote_allocator_layout,
-			vm_address_t zone_address, memory_reader_t reader,
-			void (^recorder)(vm_address_t, void *, size_t , bool *stop));
-
-#endif // DISPATCH_ALLOCATOR
-
-#if DISPATCH_ALLOCATOR
-extern dispatch_heap_t _dispatch_main_heap;
-#endif
-
-#endif // __DISPATCH_ALLOCATOR_INTERNAL__
--- a/Telegram/ThirdParty/dispatch/src/apply.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/apply.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,368 +0,0 @@
-/*
- * Copyright (c) 2008-2013 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include "internal.h"
-
-typedef void (*dispatch_apply_function_t)(void *, size_t);
-static char const * const _dispatch_apply_key = "apply";
-
-#define DISPATCH_APPLY_INVOKE_REDIRECT 0x1
-#define DISPATCH_APPLY_INVOKE_WAIT     0x2
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_apply_invoke2(dispatch_apply_t da, long invoke_flags)
-{
-	size_t const iter = da->da_iterations;
-	size_t idx, done = 0;
-
-	idx = os_atomic_inc_orig2o(da, da_index, acquire);
-	if (unlikely(idx >= iter)) goto out;
-
-	// da_dc is only safe to access once the 'index lock' has been acquired
-	dispatch_apply_function_t const func = (void *)da->da_dc->dc_func;
-	void *const da_ctxt = da->da_dc->dc_ctxt;
-
-	_dispatch_perfmon_workitem_dec(); // this unit executes many items
-
-	// Handle nested dispatch_apply rdar://problem/9294578
-	dispatch_thread_context_s apply_ctxt = {
-		.dtc_key = _dispatch_apply_key,
-		.dtc_apply_nesting = da->da_nested,
-	};
-	_dispatch_thread_context_push(&apply_ctxt);
-
-	dispatch_thread_frame_s dtf;
-	dispatch_priority_t old_dbp = 0;
-	if (invoke_flags & DISPATCH_APPLY_INVOKE_REDIRECT) {
-		dispatch_queue_t dq = da->da_dc->dc_data;
-		_dispatch_thread_frame_push(&dtf, dq);
-		old_dbp = _dispatch_set_basepri(dq->dq_priority);
-	}
-	dispatch_invoke_flags_t flags = da->da_flags;
-
-	// Striding is the responsibility of the caller.
-	do {
-		dispatch_invoke_with_autoreleasepool(flags, {
-			_dispatch_client_callout2(da_ctxt, idx, func);
-			_dispatch_perfmon_workitem_inc();
-			done++;
-			idx = os_atomic_inc_orig2o(da, da_index, relaxed);
-		});
-	} while (likely(idx < iter));
-
-	if (invoke_flags & DISPATCH_APPLY_INVOKE_REDIRECT) {
-		_dispatch_reset_basepri(old_dbp);
-		_dispatch_thread_frame_pop(&dtf);
-	}
-
-	_dispatch_thread_context_pop(&apply_ctxt);
-
-	// The thread that finished the last workitem wakes up the possibly waiting
-	// thread that called dispatch_apply. They could be one and the same.
-	if (!os_atomic_sub2o(da, da_todo, done, release)) {
-		_dispatch_thread_event_signal(&da->da_event);
-	}
-out:
-	if (invoke_flags & DISPATCH_APPLY_INVOKE_WAIT) {
-		_dispatch_thread_event_wait(&da->da_event);
-		_dispatch_thread_event_destroy(&da->da_event);
-	}
-	if (os_atomic_dec2o(da, da_thr_cnt, release) == 0) {
-#if DISPATCH_INTROSPECTION
-		_dispatch_continuation_free(da->da_dc);
-#endif
-		_dispatch_continuation_free((dispatch_continuation_t)da);
-	}
-}
-
-DISPATCH_NOINLINE
-void
-_dispatch_apply_invoke(void *ctxt)
-{
-	_dispatch_apply_invoke2(ctxt, 0);
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_apply_invoke_and_wait(void *ctxt)
-{
-	_dispatch_apply_invoke2(ctxt, DISPATCH_APPLY_INVOKE_WAIT);
-	_dispatch_perfmon_workitem_inc();
-}
-
-DISPATCH_NOINLINE
-void
-_dispatch_apply_redirect_invoke(void *ctxt)
-{
-	_dispatch_apply_invoke2(ctxt, DISPATCH_APPLY_INVOKE_REDIRECT);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_invoke_flags_t
-_dispatch_apply_autorelease_frequency(dispatch_queue_t dq)
-{
-	dispatch_invoke_flags_t qaf = 0;
-
-	while (dq && !qaf) {
-		qaf = _dispatch_queue_autorelease_frequency(dq);
-		dq = dq->do_targetq;
-	}
-	return qaf;
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_apply_serial(void *ctxt)
-{
-	dispatch_apply_t da = (dispatch_apply_t)ctxt;
-	dispatch_continuation_t dc = da->da_dc;
-	size_t const iter = da->da_iterations;
-	dispatch_invoke_flags_t flags;
-	size_t idx = 0;
-
-	_dispatch_perfmon_workitem_dec(); // this unit executes many items
-	flags = _dispatch_apply_autorelease_frequency(dc->dc_data);
-	do {
-		dispatch_invoke_with_autoreleasepool(flags, {
-			_dispatch_client_callout2(dc->dc_ctxt, idx, (void*)dc->dc_func);
-			_dispatch_perfmon_workitem_inc();
-		});
-	} while (++idx < iter);
-
-#if DISPATCH_INTROSPECTION
-	_dispatch_continuation_free(da->da_dc);
-#endif
-	_dispatch_continuation_free((dispatch_continuation_t)da);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_apply_f(dispatch_queue_global_t dq, dispatch_apply_t da,
-		dispatch_function_t func)
-{
-	int32_t i = 0;
-	dispatch_continuation_t head = NULL, tail = NULL;
-	pthread_priority_t pp = _dispatch_get_priority();
-
-	// The current thread does not need a continuation
-	int32_t continuation_cnt = da->da_thr_cnt - 1;
-
-	dispatch_assert(continuation_cnt);
-
-	for (i = 0; i < continuation_cnt; i++) {
-		dispatch_continuation_t next = _dispatch_continuation_alloc();
-		uintptr_t dc_flags = DC_FLAG_CONSUME;
-
-		_dispatch_continuation_init_f(next, dq, da, func,
-				DISPATCH_BLOCK_HAS_PRIORITY, dc_flags);
-		next->dc_priority = pp | _PTHREAD_PRIORITY_ENFORCE_FLAG;
-		next->do_next = head;
-		head = next;
-
-		if (!tail) {
-			tail = next;
-		}
-	}
-
-	_dispatch_thread_event_init(&da->da_event);
-	// FIXME: dq may not be the right queue for the priority of `head`
-	_dispatch_trace_item_push_list(dq, head, tail);
-	_dispatch_root_queue_push_inline(dq, head, tail, continuation_cnt);
-	// Call the first element directly
-	_dispatch_apply_invoke_and_wait(da);
-}
-
-DISPATCH_ALWAYS_INLINE DISPATCH_WARN_RESULT
-static inline int32_t
-_dispatch_queue_try_reserve_apply_width(dispatch_queue_t dq, int32_t da_width)
-{
-	uint64_t old_state, new_state;
-	int32_t width;
-
-	if (unlikely(dq->dq_width == 1)) {
-		return 0;
-	}
-
-	os_atomic_rmw_loop2o(dq, dq_state, old_state, new_state, relaxed, {
-		width = (int32_t)_dq_state_available_width(old_state);
-		if (unlikely(!width)) {
-			os_atomic_rmw_loop_give_up(return 0);
-		}
-		if (width > da_width) {
-			width = da_width;
-		}
-		new_state = old_state + (uint64_t)width * DISPATCH_QUEUE_WIDTH_INTERVAL;
-	});
-	return width;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_queue_relinquish_width(dispatch_queue_t top_dq,
-		dispatch_queue_t stop_dq, int32_t da_width)
-{
-	uint64_t delta = (uint64_t)da_width * DISPATCH_QUEUE_WIDTH_INTERVAL;
-	dispatch_queue_t dq = top_dq;
-
-	while (dq != stop_dq) {
-		os_atomic_sub2o(dq, dq_state, delta, relaxed);
-		dq = dq->do_targetq;
-	}
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_apply_redirect(void *ctxt)
-{
-	dispatch_apply_t da = (dispatch_apply_t)ctxt;
-	int32_t da_width = da->da_thr_cnt - 1;
-	dispatch_queue_t top_dq = da->da_dc->dc_data, dq = top_dq;
-
-	do {
-		int32_t width = _dispatch_queue_try_reserve_apply_width(dq, da_width);
-
-		if (unlikely(da_width > width)) {
-			int32_t excess = da_width - width;
-			_dispatch_queue_relinquish_width(top_dq, dq, excess);
-			da_width = width;
-			if (unlikely(!da_width)) {
-				return _dispatch_apply_serial(da);
-			}
-			da->da_thr_cnt -= excess;
-		}
-		if (!da->da_flags) {
-			// find first queue in descending target queue order that has
-			// an autorelease frequency set, and use that as the frequency for
-			// this continuation.
-			da->da_flags = _dispatch_queue_autorelease_frequency(dq);
-		}
-		dq = dq->do_targetq;
-	} while (unlikely(dq->do_targetq));
-
-	_dispatch_apply_f(upcast(dq)._dgq, da, _dispatch_apply_redirect_invoke);
-	_dispatch_queue_relinquish_width(top_dq, dq, da_width);
-}
-
-#define DISPATCH_APPLY_MAX UINT16_MAX // must be < sqrt(SIZE_MAX)
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_queue_global_t
-_dispatch_apply_root_queue(dispatch_queue_t dq)
-{
-	if (dq) {
-		while (unlikely(dq->do_targetq)) {
-			dq = dq->do_targetq;
-		}
-		// if the current root queue is a pthread root queue, select it
-		if (!_dispatch_is_in_root_queues_array(dq)) {
-			return upcast(dq)._dgq;
-		}
-	}
-
-	pthread_priority_t pp = _dispatch_get_priority();
-	dispatch_qos_t qos = _dispatch_qos_from_pp(pp);
-	return _dispatch_get_root_queue(qos ? qos : DISPATCH_QOS_DEFAULT, false);
-}
-
-DISPATCH_NOINLINE
-void
-dispatch_apply_f(size_t iterations, dispatch_queue_t _dq, void *ctxt,
-		void (*func)(void *, size_t))
-{
-	if (unlikely(iterations == 0)) {
-		return;
-	}
-	dispatch_thread_context_t dtctxt =
-			_dispatch_thread_context_find(_dispatch_apply_key);
-	size_t nested = dtctxt ? dtctxt->dtc_apply_nesting : 0;
-	dispatch_queue_t old_dq = _dispatch_queue_get_current();
-	dispatch_queue_t dq;
-
-	if (likely(_dq == DISPATCH_APPLY_AUTO)) {
-		dq = _dispatch_apply_root_queue(old_dq)->_as_dq;
-	} else {
-		dq = _dq; // silence clang Nullability complaints
-	}
-	dispatch_qos_t qos = _dispatch_priority_qos(dq->dq_priority) ?:
-			_dispatch_priority_fallback_qos(dq->dq_priority);
-	if (unlikely(dq->do_targetq)) {
-		// if the queue passed-in is not a root queue, use the current QoS
-		// since the caller participates in the work anyway
-		qos = _dispatch_qos_from_pp(_dispatch_get_priority());
-	}
-	int32_t thr_cnt = (int32_t)_dispatch_qos_max_parallelism(qos,
-			DISPATCH_MAX_PARALLELISM_ACTIVE);
-
-	if (likely(!nested)) {
-		nested = iterations;
-	} else {
-		thr_cnt = nested < (size_t)thr_cnt ? thr_cnt / (int32_t)nested : 1;
-		nested = nested < DISPATCH_APPLY_MAX && iterations < DISPATCH_APPLY_MAX
-				? nested * iterations : DISPATCH_APPLY_MAX;
-	}
-	if (iterations < (size_t)thr_cnt) {
-		thr_cnt = (int32_t)iterations;
-	}
-	struct dispatch_continuation_s dc = {
-		.dc_func = (void*)func,
-		.dc_ctxt = ctxt,
-		.dc_data = dq,
-	};
-	dispatch_apply_t da = (__typeof__(da))_dispatch_continuation_alloc();
-	da->da_index = 0;
-	da->da_todo = iterations;
-	da->da_iterations = iterations;
-	da->da_nested = nested;
-	da->da_thr_cnt = thr_cnt;
-#if DISPATCH_INTROSPECTION
-	da->da_dc = _dispatch_continuation_alloc();
-	*da->da_dc = dc;
-	da->da_dc->dc_flags = DC_FLAG_ALLOCATED;
-#else
-	da->da_dc = &dc;
-#endif
-	da->da_flags = 0;
-
-	if (unlikely(dq->dq_width == 1 || thr_cnt <= 1)) {
-		return dispatch_sync_f(dq, da, _dispatch_apply_serial);
-	}
-	if (unlikely(dq->do_targetq)) {
-		if (unlikely(dq == old_dq)) {
-			return dispatch_sync_f(dq, da, _dispatch_apply_serial);
-		} else {
-			return dispatch_sync_f(dq, da, _dispatch_apply_redirect);
-		}
-	}
-
-	dispatch_thread_frame_s dtf;
-	_dispatch_thread_frame_push(&dtf, dq);
-	_dispatch_apply_f(upcast(dq)._dgq, da, _dispatch_apply_invoke);
-	_dispatch_thread_frame_pop(&dtf);
-}
-
-#ifdef __BLOCKS__
-void
-dispatch_apply(size_t iterations, dispatch_queue_t dq, void (^work)(size_t))
-{
-	dispatch_apply_f(iterations, dq, work,
-			(dispatch_apply_function_t)_dispatch_Block_invoke(work));
-}
-#endif
--- a/Telegram/ThirdParty/dispatch/src/benchmark.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/benchmark.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,128 +0,0 @@
-/*
- * Copyright (c) 2008-2013 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include "internal.h"
-
-struct __dispatch_benchmark_data_s {
-#if HAVE_MACH_ABSOLUTE_TIME
-	mach_timebase_info_data_t tbi;
-#endif
-	uint64_t loop_cost;
-	void (*func)(void *);
-	void *ctxt;
-	size_t count;
-};
-
-static void
-_dispatch_benchmark_init(void *context)
-{
-	struct __dispatch_benchmark_data_s *bdata = context;
-	// try and simulate performance of real benchmark as much as possible
-	// keep 'f', 'c' and 'cnt' in registers
-	register void (*f)(void *) = bdata->func;
-	register void *c = bdata->ctxt;
-	register size_t cnt = bdata->count;
-	size_t i = 0;
-	uint64_t start, delta;
-#if DISPATCH_SIZEOF_PTR == 8 && !defined(_WIN32)
-	__uint128_t lcost;
-#else
-	long double lcost;
-#endif
-#if HAVE_MACH_ABSOLUTE_TIME
-	kern_return_t kr;
-
-	kr = mach_timebase_info(&bdata->tbi);
-	dispatch_assert_zero(kr);
-#endif
-
-	start = _dispatch_uptime();
-	do {
-		i++;
-		f(c);
-	} while (i < cnt);
-	delta = _dispatch_uptime() - start;
-
-	lcost = delta;
-#if HAVE_MACH_ABSOLUTE_TIME
-	lcost *= bdata->tbi.numer;
-	lcost /= bdata->tbi.denom;
-#endif
-	lcost /= cnt;
-
-	bdata->loop_cost = lcost > UINT64_MAX ? UINT64_MAX : (uint64_t)lcost;
-}
-
-#ifdef __BLOCKS__
-uint64_t
-dispatch_benchmark(size_t count, void (^block)(void))
-{
-	return dispatch_benchmark_f(count, block, _dispatch_Block_invoke(block));
-}
-#endif
-
-static void
-_dispatch_benchmark_dummy_function(void *ctxt DISPATCH_UNUSED)
-{
-}
-
-uint64_t
-dispatch_benchmark_f(size_t count, register void *ctxt,
-		register void (*func)(void *))
-{
-	static struct __dispatch_benchmark_data_s bdata = {
-		.func = _dispatch_benchmark_dummy_function,
-		.count = 10000000ul, // ten million
-	};
-	static dispatch_once_t pred;
-	uint64_t ns, start, delta;
-#if DISPATCH_SIZEOF_PTR == 8 && !defined(_WIN32)
-	__uint128_t conversion, big_denom;
-#else
-	long double conversion, big_denom;
-#endif
-	size_t i = 0;
-
-	dispatch_once_f(&pred, &bdata, _dispatch_benchmark_init);
-
-	if (unlikely(count == 0)) {
-		return 0;
-	}
-
-	start = _dispatch_uptime();
-	do {
-		i++;
-		func(ctxt);
-	} while (i < count);
-	delta = _dispatch_uptime() - start;
-
-	conversion = delta;
-#if HAVE_MACH_ABSOLUTE_TIME
-	conversion *= bdata.tbi.numer;
-	big_denom = bdata.tbi.denom;
-#else
-	big_denom = delta;
-#endif
-	big_denom *= count;
-	conversion /= big_denom;
-	ns = conversion > UINT64_MAX ? UINT64_MAX : (uint64_t)conversion;
-
-	return ns - bdata.loop_cost;
-}
--- a/Telegram/ThirdParty/dispatch/src/block.cpp	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/block.cpp	1970-01-01 00:00:00.000000000 -0000
@@ -1,126 +0,0 @@
-/*
- * Copyright (c) 2015 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#ifdef __BLOCKS__
-
-#if __cplusplus < 201103L
-#error Must build with C++11 or later
-#endif
-
-#if __has_feature(cxx_exceptions)
-#error Must build without C++ exceptions
-#endif
-
-#include "internal.h"
-
-// NOTE: this file must not contain any atomic operations
-
-#if DISPATCH_DEBUG && DISPATCH_BLOCK_PRIVATE_DATA_DEBUG
-#define _dispatch_block_private_data_debug(msg, ...) \
-		_dispatch_debug("block_private[%p]: " msg, (this), ##__VA_ARGS__)
-#else
-#define _dispatch_block_private_data_debug(msg, ...)
-#endif
-
-#pragma mark -
-#pragma mark _dispatch_block_create
-
-// rdar://20766742 C++ helpers to enable block capture of vouchers and groups
-
-struct dispatch_block_private_data_s {
-	DISPATCH_BLOCK_PRIVATE_DATA_HEADER();
-	static void* operator new(size_t) = delete;
-	static void* operator new [] (size_t) = delete;
-	explicit inline DISPATCH_ALWAYS_INLINE dispatch_block_private_data_s(
-			dispatch_block_flags_t flags, voucher_t voucher,
-			pthread_priority_t priority, dispatch_block_t block) noexcept :
-			dbpd_magic(), dbpd_flags(flags), dbpd_atomic_flags(),
-			dbpd_performed(), dbpd_priority(priority), dbpd_voucher(voucher),
-			dbpd_block(block), dbpd_group(), dbpd_queue(), dbpd_thread()
-	{
-		// stack structure constructor, no releases on destruction
-		_dispatch_block_private_data_debug("create, block: %p", dbpd_block);
-	}
-	inline DISPATCH_ALWAYS_INLINE dispatch_block_private_data_s(
-			dispatch_block_private_data_s const &o) noexcept :
-			dbpd_magic(DISPATCH_BLOCK_PRIVATE_DATA_MAGIC),
-			dbpd_flags(o.dbpd_flags), dbpd_atomic_flags(), dbpd_performed(),
-			dbpd_priority(o.dbpd_priority), dbpd_voucher(o.dbpd_voucher),
-			dbpd_block(), dbpd_group(), dbpd_queue(), dbpd_thread()
-	{
-		// copy constructor, create copy with retained references
-		if (dbpd_voucher && dbpd_voucher != DISPATCH_NO_VOUCHER) {
-			voucher_retain(dbpd_voucher);
-		}
-		if (o.dbpd_block) {
-			dbpd_block = reinterpret_cast<dispatch_block_t>(
-					_dispatch_Block_copy(o.dbpd_block));
-		}
-		_dispatch_block_private_data_debug("copy from %p, block: %p from %p",
-				&o, dbpd_block, o.dbpd_block);
-		if (!o.dbpd_magic) return; // No group in initial copy of stack object
-		dbpd_group = _dispatch_group_create_and_enter();
-	}
-	inline DISPATCH_ALWAYS_INLINE ~dispatch_block_private_data_s() noexcept
-	{
-		_dispatch_block_private_data_debug("destroy%s, block: %p",
-				dbpd_magic ? "" : " (stack)", dbpd_block);
-
-#if DISPATCH_INTROSPECTION
-		void *db = (char *) this - sizeof(struct Block_layout);
-		_dispatch_ktrace1(DISPATCH_QOS_TRACE_private_block_dispose, db);
-#endif /* DISPATCH_INTROSPECTION */
-
-		if (dbpd_magic != DISPATCH_BLOCK_PRIVATE_DATA_MAGIC) return;
-		if (dbpd_group) {
-			if (!dbpd_performed) dispatch_group_leave(dbpd_group);
-			_os_object_release(dbpd_group->_as_os_obj);
-		}
-		if (dbpd_queue) {
-			_os_object_release_internal_n(dbpd_queue->_as_os_obj, 2);
-		}
-		if (dbpd_block) Block_release(dbpd_block);
-		if (dbpd_voucher && dbpd_voucher != DISPATCH_NO_VOUCHER) {
-			voucher_release(dbpd_voucher);
-		}
-	}
-};
-
-dispatch_block_t
-_dispatch_block_create(dispatch_block_flags_t flags, voucher_t voucher,
-		pthread_priority_t pri, dispatch_block_t block)
-{
-	struct dispatch_block_private_data_s dbpds(flags, voucher, pri, block);
-	return reinterpret_cast<dispatch_block_t>(_dispatch_Block_copy(^{
-		// Capture stack object: invokes copy constructor (17094902)
-		(void)dbpds;
-		_dispatch_block_invoke_direct(&dbpds);
-	}));
-}
-
-extern "C" {
-// The compiler hides the name of the function it generates, and changes it if
-// we try to reference it directly, but the linker still sees it.
-extern void DISPATCH_BLOCK_SPECIAL_INVOKE(void *)
-		__asm__(OS_STRINGIFY(__USER_LABEL_PREFIX__) "___dispatch_block_create_block_invoke");
-void (*const _dispatch_block_special_invoke)(void*) = DISPATCH_BLOCK_SPECIAL_INVOKE;
-}
-
-#endif // __BLOCKS__
--- a/Telegram/ThirdParty/dispatch/src/BlocksRuntime/Block.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/BlocksRuntime/Block.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,73 +0,0 @@
-// This source file is part of the Swift.org open source project
-//
-// Copyright (c) 2014 - 2015 Apple Inc. and the Swift project authors
-// Licensed under Apache License v2.0 with Runtime Library Exception
-//
-// See https://swift.org/LICENSE.txt for license information
-// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
-//
-
-
-#ifndef _Block_H_
-#define _Block_H_
-
-#if defined(_WIN32)
-#    if defined(BlocksRuntime_STATIC)
-#        define BLOCK_ABI
-#    else
-#        if defined(BlocksRuntime_EXPORTS)
-#            define BLOCK_ABI __declspec(dllexport)
-#        else
-#            define BLOCK_ABI __declspec(dllimport)
-#        endif
-#    endif
-#else
-#    define BLOCK_ABI __attribute__((__visibility__("default")))
-#endif
-
-#if !defined(BLOCK_EXPORT)
-#   if defined(__cplusplus)
-#       define BLOCK_EXPORT extern "C" BLOCK_ABI
-#   else
-#       define BLOCK_EXPORT extern BLOCK_ABI
-#   endif
-#endif
-
-#if __cplusplus
-extern "C" {
-#endif
-
-// Create a heap based copy of a Block or simply add a reference to an existing one.
-// This must be paired with Block_release to recover memory, even when running
-// under Objective-C Garbage Collection.
-BLOCK_EXPORT void *_Block_copy(const void *aBlock);
-
-// Lose the reference, and if heap based and last reference, recover the memory
-BLOCK_EXPORT void _Block_release(const void *aBlock);
-
-// Used by the compiler. Do not call this function yourself.
-BLOCK_EXPORT void _Block_object_assign(void *, const void *, const int);
-
-// Used by the compiler. Do not call this function yourself.
-BLOCK_EXPORT void _Block_object_dispose(const void *, const int);
-
-// Used by the compiler. Do not use these variables yourself.
-#if defined(_WIN32)
-extern void * _NSConcreteGlobalBlock[32];
-extern void * _NSConcreteStackBlock[32];
-#else
-BLOCK_EXPORT void * _NSConcreteGlobalBlock[32];
-BLOCK_EXPORT void * _NSConcreteStackBlock[32];
-#endif
-
-#if __cplusplus
-}
-#endif
-
-// Type correct macros
-
-#define Block_copy(...) ((__typeof(__VA_ARGS__))_Block_copy((const void *)(__VA_ARGS__)))
-#define Block_release(...) _Block_release((const void *)(__VA_ARGS__))
-
-
-#endif
--- a/Telegram/ThirdParty/dispatch/src/BlocksRuntime/Block_private.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/BlocksRuntime/Block_private.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,264 +0,0 @@
-// This source file is part of the Swift.org open source project
-//
-// Copyright (c) 2014 - 2015 Apple Inc. and the Swift project authors
-// Licensed under Apache License v2.0 with Runtime Library Exception
-//
-// See https://swift.org/LICENSE.txt for license information
-// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
-//
-
-
-#ifndef _BLOCK_PRIVATE_H_
-#define _BLOCK_PRIVATE_H_
-
-#include <stdbool.h>
-#include <stdint.h>
-#include <stdio.h>
-
-#include "Block.h"
-
-#if __cplusplus
-extern "C" {
-#endif
-
-
-// Values for Block_layout->flags to describe block objects
-enum {
-    BLOCK_DEALLOCATING =      (0x0001),  // runtime
-    BLOCK_REFCOUNT_MASK =     (0xfffe),  // runtime
-    BLOCK_NEEDS_FREE =        (1 << 24), // runtime
-    BLOCK_HAS_COPY_DISPOSE =  (1 << 25), // compiler
-    BLOCK_HAS_CTOR =          (1 << 26), // compiler: helpers have C++ code
-    BLOCK_IS_GC =             (1 << 27), // runtime
-    BLOCK_IS_GLOBAL =         (1 << 28), // compiler
-    BLOCK_USE_STRET =         (1 << 29), // compiler: undefined if !BLOCK_HAS_SIGNATURE
-    BLOCK_HAS_SIGNATURE  =    (1 << 30), // compiler
-    BLOCK_HAS_EXTENDED_LAYOUT=(1 << 31)  // compiler
-};
-
-#define BLOCK_DESCRIPTOR_1 1
-struct Block_descriptor_1 {
-    unsigned long int reserved;
-    unsigned long int size;
-};
-
-#define BLOCK_DESCRIPTOR_2 1
-struct Block_descriptor_2 {
-    // requires BLOCK_HAS_COPY_DISPOSE
-    void (*copy)(void *dst, const void *src);
-    void (*dispose)(const void *);
-};
-
-#define BLOCK_DESCRIPTOR_3 1
-struct Block_descriptor_3 {
-    // requires BLOCK_HAS_SIGNATURE
-    const char *signature;
-    const char *layout;     // contents depend on BLOCK_HAS_EXTENDED_LAYOUT
-};
-
-struct Block_layout {
-    void *isa;
-    volatile int32_t flags; // contains ref count
-    int32_t reserved; 
-    void (*invoke)(void *, ...);
-    struct Block_descriptor_1 *descriptor;
-    // imported variables
-};
-
-
-// Values for Block_byref->flags to describe __block variables
-enum {
-    // Byref refcount must use the same bits as Block_layout's refcount.
-    // BLOCK_DEALLOCATING =      (0x0001),  // runtime
-    // BLOCK_REFCOUNT_MASK =     (0xfffe),  // runtime
-
-    BLOCK_BYREF_LAYOUT_MASK =       (0xf << 28), // compiler
-    BLOCK_BYREF_LAYOUT_EXTENDED =   (  1 << 28), // compiler
-    BLOCK_BYREF_LAYOUT_NON_OBJECT = (  2 << 28), // compiler
-    BLOCK_BYREF_LAYOUT_STRONG =     (  3 << 28), // compiler
-    BLOCK_BYREF_LAYOUT_WEAK =       (  4 << 28), // compiler
-    BLOCK_BYREF_LAYOUT_UNRETAINED = (  5 << 28), // compiler
-
-    BLOCK_BYREF_IS_GC =             (  1 << 27), // runtime
-
-    BLOCK_BYREF_HAS_COPY_DISPOSE =  (  1 << 25), // compiler
-    BLOCK_BYREF_NEEDS_FREE =        (  1 << 24), // runtime
-};
-
-struct Block_byref {
-    void *isa;
-    struct Block_byref *forwarding;
-    volatile int32_t flags; // contains ref count
-    uint32_t size;
-};
-
-struct Block_byref_2 {
-    // requires BLOCK_BYREF_HAS_COPY_DISPOSE
-    void (*byref_keep)(struct Block_byref *dst, struct Block_byref *src);
-    void (*byref_destroy)(struct Block_byref *);
-};
-
-struct Block_byref_3 {
-    // requires BLOCK_BYREF_LAYOUT_EXTENDED
-    const char *layout;
-};
-
-
-// Extended layout encoding.
-
-// Values for Block_descriptor_3->layout with BLOCK_HAS_EXTENDED_LAYOUT
-// and for Block_byref_3->layout with BLOCK_BYREF_LAYOUT_EXTENDED
-
-// If the layout field is less than 0x1000, then it is a compact encoding 
-// of the form 0xXYZ: X strong pointers, then Y byref pointers, 
-// then Z weak pointers.
-
-// If the layout field is 0x1000 or greater, it points to a 
-// string of layout bytes. Each byte is of the form 0xPN.
-// Operator P is from the list below. Value N is a parameter for the operator.
-// Byte 0x00 terminates the layout; remaining block data is non-pointer bytes.
-
-enum {
-    BLOCK_LAYOUT_ESCAPE = 0, // N=0 halt, rest is non-pointer. N!=0 reserved.
-    BLOCK_LAYOUT_NON_OBJECT_BYTES = 1,    // N bytes non-objects
-    BLOCK_LAYOUT_NON_OBJECT_WORDS = 2,    // N words non-objects
-    BLOCK_LAYOUT_STRONG           = 3,    // N words strong pointers
-    BLOCK_LAYOUT_BYREF            = 4,    // N words byref pointers
-    BLOCK_LAYOUT_WEAK             = 5,    // N words weak pointers
-    BLOCK_LAYOUT_UNRETAINED       = 6,    // N words unretained pointers
-    BLOCK_LAYOUT_UNKNOWN_WORDS_7  = 7,    // N words, reserved
-    BLOCK_LAYOUT_UNKNOWN_WORDS_8  = 8,    // N words, reserved
-    BLOCK_LAYOUT_UNKNOWN_WORDS_9  = 9,    // N words, reserved
-    BLOCK_LAYOUT_UNKNOWN_WORDS_A  = 0xA,  // N words, reserved
-    BLOCK_LAYOUT_UNUSED_B         = 0xB,  // unspecified, reserved
-    BLOCK_LAYOUT_UNUSED_C         = 0xC,  // unspecified, reserved
-    BLOCK_LAYOUT_UNUSED_D         = 0xD,  // unspecified, reserved
-    BLOCK_LAYOUT_UNUSED_E         = 0xE,  // unspecified, reserved
-    BLOCK_LAYOUT_UNUSED_F         = 0xF,  // unspecified, reserved
-};
-
-
-// Runtime support functions used by compiler when generating copy/dispose helpers
-
-// Values for _Block_object_assign() and _Block_object_dispose() parameters
-enum {
-    // see function implementation for a more complete description of these fields and combinations
-    BLOCK_FIELD_IS_OBJECT   =  3,  // id, NSObject, __attribute__((NSObject)), block, ...
-    BLOCK_FIELD_IS_BLOCK    =  7,  // a block variable
-    BLOCK_FIELD_IS_BYREF    =  8,  // the on stack structure holding the __block variable
-    BLOCK_FIELD_IS_WEAK     = 16,  // declared __weak, only used in byref copy helpers
-    BLOCK_BYREF_CALLER      = 128, // called from __block (byref) copy/dispose support routines.
-};
-
-enum {
-    BLOCK_ALL_COPY_DISPOSE_FLAGS = 
-        BLOCK_FIELD_IS_OBJECT | BLOCK_FIELD_IS_BLOCK | BLOCK_FIELD_IS_BYREF |
-        BLOCK_FIELD_IS_WEAK | BLOCK_BYREF_CALLER
-};
-
-// Runtime entry point called by compiler when assigning objects inside copy helper routines
-BLOCK_EXPORT void _Block_object_assign(void *destAddr, const void *object, const int flags);
-    // BLOCK_FIELD_IS_BYREF is only used from within block copy helpers
-
-
-// runtime entry point called by the compiler when disposing of objects inside dispose helper routine
-BLOCK_EXPORT void _Block_object_dispose(const void *object, const int flags);
-
-
-// Other support functions
-
-// runtime entry to get total size of a closure
-BLOCK_EXPORT size_t Block_size(void *aBlock);
-
-// indicates whether block was compiled with compiler that sets the ABI related metadata bits
-BLOCK_EXPORT bool _Block_has_signature(void *aBlock);
-
-// returns TRUE if return value of block is on the stack, FALSE otherwise
-BLOCK_EXPORT bool _Block_use_stret(void *aBlock);
-
-// Returns a string describing the block's parameter and return types.
-// The encoding scheme is the same as Objective-C @encode.
-// Returns NULL for blocks compiled with some compilers.
-BLOCK_EXPORT const char * _Block_signature(void *aBlock);
-
-// Returns a string describing the block's GC layout.
-// This uses the GC skip/scan encoding.
-// May return NULL.
-BLOCK_EXPORT const char * _Block_layout(void *aBlock);
-
-// Returns a string describing the block's layout.
-// This uses the "extended layout" form described above.
-// May return NULL.
-BLOCK_EXPORT const char * _Block_extended_layout(void *aBlock);
-
-// Callable only from the ARR weak subsystem while in exclusion zone
-BLOCK_EXPORT bool _Block_tryRetain(const void *aBlock);
-
-// Callable only from the ARR weak subsystem while in exclusion zone
-BLOCK_EXPORT bool _Block_isDeallocating(const void *aBlock);
-
-
-// the raw data space for runtime classes for blocks
-// class+meta used for stack, malloc, and collectable based blocks
-BLOCK_EXPORT void * _NSConcreteMallocBlock[32];
-BLOCK_EXPORT void * _NSConcreteAutoBlock[32];
-BLOCK_EXPORT void * _NSConcreteFinalizingBlock[32];
-BLOCK_EXPORT void * _NSConcreteWeakBlockVariable[32];
-// declared in Block.h
-// BLOCK_EXPORT void * _NSConcreteGlobalBlock[32];
-// BLOCK_EXPORT void * _NSConcreteStackBlock[32];
-
-
-// the intercept routines that must be used under GC
-BLOCK_EXPORT void _Block_use_GC( void *(*alloc)(const unsigned long, const bool isOne, const bool isObject),
-                                  void (*setHasRefcount)(const void *, const bool),
-                                  void (*gc_assign_strong)(void *, void **),
-                                  void (*gc_assign_weak)(const void *, void *),
-                                  void (*gc_memmove)(void *, void *, unsigned long));
-
-// earlier version, now simply transitional
-BLOCK_EXPORT void _Block_use_GC5( void *(*alloc)(const unsigned long, const bool isOne, const bool isObject),
-                                  void (*setHasRefcount)(const void *, const bool),
-                                  void (*gc_assign_strong)(void *, void **),
-                                  void (*gc_assign_weak)(const void *, void *));
-
-BLOCK_EXPORT void _Block_use_RR( void (*retain)(const void *),
-                                 void (*release)(const void *));
-
-struct Block_callbacks_RR {
-    size_t  size;                   // size == sizeof(struct Block_callbacks_RR)
-    void  (*retain)(const void *);
-    void  (*release)(const void *);
-    void  (*destructInstance)(const void *);
-};
-typedef struct Block_callbacks_RR Block_callbacks_RR;
-
-BLOCK_EXPORT void _Block_use_RR2(const Block_callbacks_RR *callbacks);
-
-// make a collectable GC heap based Block.  Not useful under non-GC.
-BLOCK_EXPORT void *_Block_copy_collectable(const void *aBlock);
-
-// thread-unsafe diagnostic
-BLOCK_EXPORT const char *_Block_dump(const void *block);
-
-
-// Obsolete
-
-// first layout
-struct Block_basic {
-    void *isa;
-    int Block_flags;  // int32_t
-    int Block_size; // XXX should be packed into Block_flags
-    void (*Block_invoke)(void *);
-    void (*Block_copy)(void *dst, void *src);  // iff BLOCK_HAS_COPY_DISPOSE
-    void (*Block_dispose)(void *);             // iff BLOCK_HAS_COPY_DISPOSE
-    //long params[0];  // where const imports, __block storage references, etc. get laid down
-} __attribute__((deprecated));
-
-
-#if __cplusplus
-}
-#endif
-
-
-#endif
--- a/Telegram/ThirdParty/dispatch/src/BlocksRuntime/BlocksRuntime.def	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/BlocksRuntime/BlocksRuntime.def	1970-01-01 00:00:00.000000000 -0000
@@ -1,4 +0,0 @@
-LIBRARY BlocksRuntime
-EXPORTS
-  _NSConcreteGlobalBlock CONSTANT
-  _NSConcreteStackBlock CONSTANT
--- a/Telegram/ThirdParty/dispatch/src/BlocksRuntime/CMakeLists.txt	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/BlocksRuntime/CMakeLists.txt	1970-01-01 00:00:00.000000000 -0000
@@ -1,38 +0,0 @@
-
-add_library(BlocksRuntime
-  data.c
-  runtime.c)
-if(CMAKE_SYSTEM_NAME STREQUAL Windows)
-  target_sources(BlocksRuntime PRIVATE
-    BlocksRuntime.def)
-
-  if(NOT BUILD_SHARED_LIBS)
-    target_compile_definitions(BlocksRuntime PRIVATE
-      BlocksRuntime_STATIC)
-  endif()
-endif()
-
-target_include_directories(BlocksRuntime PUBLIC
-  ${CMAKE_CURRENT_SOURCE_DIR})
-if(HAVE_OBJC AND CMAKE_DL_LIBS)
-  target_link_libraries(BlocksRuntime PUBLIC
-    ${CMAKE_DL_LIBS})
-endif()
-
-set_target_properties(BlocksRuntime PROPERTIES
-  POSITION_INDEPENDENT_CODE TRUE)
-
-add_library(BlocksRuntime::BlocksRuntime ALIAS BlocksRuntime)
-
-install(FILES Block.h
-        DESTINATION ${INSTALL_BLOCK_HEADERS_DIR})
-if(INSTALL_PRIVATE_HEADERS)
-  install(FILES Block_private.h
-          DESTINATION ${INSTALL_BLOCK_HEADERS_DIR})
-endif()
-set_property(GLOBAL APPEND PROPERTY DISPATCH_EXPORTS BlocksRuntime)
-install(TARGETS BlocksRuntime
-        EXPORT dispatchExports
-        ARCHIVE DESTINATION ${INSTALL_TARGET_DIR}
-        LIBRARY DESTINATION ${INSTALL_TARGET_DIR}
-        RUNTIME DESTINATION bin)
--- a/Telegram/ThirdParty/dispatch/src/BlocksRuntime/data.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/BlocksRuntime/data.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,30 +0,0 @@
-// This source file is part of the Swift.org open source project
-//
-// Copyright (c) 2014 - 2015 Apple Inc. and the Swift project authors
-// Licensed under Apache License v2.0 with Runtime Library Exception
-//
-// See https://swift.org/LICENSE.txt for license information
-// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
-//
-
-/********************
-NSBlock support
-
-We allocate space and export a symbol to be used as the Class for the on-stack and malloc'ed copies until ObjC arrives on the scene.  These data areas are set up by Foundation to link in as real classes post facto.
-
-We keep these in a separate file so that we can include the runtime code in test subprojects but not include the data so that compiled code that sees the data in libSystem doesn't get confused by a second copy.  Somehow these don't get unified in a common block.
-**********************/
-#include "Block.h"
-
-#if defined(_WIN32)
-void * _NSConcreteStackBlock[32] = { 0 };
-void * _NSConcreteGlobalBlock[32] = { 0 };
-#else
-BLOCK_ABI void * _NSConcreteStackBlock[32] = { 0 };
-BLOCK_ABI void * _NSConcreteGlobalBlock[32] = { 0 };
-#endif
-
-BLOCK_ABI void * _NSConcreteMallocBlock[32] = { 0 };
-BLOCK_ABI void * _NSConcreteAutoBlock[32] = { 0 };
-BLOCK_ABI void * _NSConcreteFinalizingBlock[32] = { 0 };
-BLOCK_ABI void * _NSConcreteWeakBlockVariable[32] = { 0 };
--- a/Telegram/ThirdParty/dispatch/src/BlocksRuntime/runtime.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/BlocksRuntime/runtime.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,760 +0,0 @@
-// This source file is part of the Swift.org open source project
-//
-// Copyright (c) 2014 - 2015 Apple Inc. and the Swift project authors
-// Licensed under Apache License v2.0 with Runtime Library Exception
-//
-// See https://swift.org/LICENSE.txt for license information
-// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
-//
-
-#include "Block_private.h"
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <stdint.h>
-#if HAVE_OBJC
-#define __USE_GNU
-#include <dlfcn.h>
-#endif
-#if __has_include(<os/assumes.h>)
-#include <os/assumes.h>
-#else
-#include <assert.h> 
-#endif
-#ifndef os_assumes
-#define os_assumes(_x) _x
-#endif
-#ifndef os_assert
-#define os_assert(_x) assert(_x)
-#endif
-
-#if !defined(__has_builtin)
-#define __has_builtin(builtin) 0
-#endif
-
-#if __has_builtin(__sync_bool_compare_and_swap)
-#define OSAtomicCompareAndSwapInt(_Old, _New, _Ptr)                            \
-  __sync_bool_compare_and_swap(_Ptr, _Old, _New)
-#else
-#define _CRT_SECURE_NO_WARNINGS 1
-#include <Windows.h>
-static __inline bool OSAtomicCompareAndSwapInt(int oldi, int newi,
-                                               int volatile *dst) {
-  // fixme barrier is overkill -- see objc-os.h
-  int original = InterlockedCompareExchange((LONG volatile *)dst, newi, oldi);
-  return (original == oldi);
-}
-#endif
-
-/***********************
-Globals
-************************/
-
-#if HAVE_OBJC
-static void *_Block_copy_class = _NSConcreteMallocBlock;
-static void *_Block_copy_finalizing_class = _NSConcreteMallocBlock;
-static int _Block_copy_flag = BLOCK_NEEDS_FREE;
-#endif
-static int _Byref_flag_initial_value = BLOCK_BYREF_NEEDS_FREE | 4;  // logical 2
-
-static bool isGC = false;
-
-/*******************************************************************************
-Internal Utilities
-********************************************************************************/
-
-
-static int32_t latching_incr_int(volatile int32_t *where) {
-    while (1) {
-        int32_t old_value = *where;
-        if ((old_value & BLOCK_REFCOUNT_MASK) == BLOCK_REFCOUNT_MASK) {
-            return BLOCK_REFCOUNT_MASK;
-        }
-        if (OSAtomicCompareAndSwapInt(old_value, old_value+2, where)) {
-            return old_value+2;
-        }
-    }
-}
-
-static bool latching_incr_int_not_deallocating(volatile int32_t *where) {
-    while (1) {
-        int32_t old_value = *where;
-        if (old_value & BLOCK_DEALLOCATING) {
-            // if deallocating we can't do this
-            return false;
-        }
-        if ((old_value & BLOCK_REFCOUNT_MASK) == BLOCK_REFCOUNT_MASK) {
-            // if latched, we're leaking this block, and we succeed
-            return true;
-        }
-        if (OSAtomicCompareAndSwapInt(old_value, old_value+2, where)) {
-            // otherwise, we must store a new retained value without the deallocating bit set
-            return true;
-        }
-    }
-}
-
-
-// return should_deallocate?
-static bool latching_decr_int_should_deallocate(volatile int32_t *where) {
-    while (1) {
-        int32_t old_value = *where;
-        if ((old_value & BLOCK_REFCOUNT_MASK) == BLOCK_REFCOUNT_MASK) {
-            return false; // latched high
-        }
-        if ((old_value & BLOCK_REFCOUNT_MASK) == 0) {
-            return false;   // underflow, latch low
-        }
-        int32_t new_value = old_value - 2;
-        bool result = false;
-        if ((old_value & (BLOCK_REFCOUNT_MASK|BLOCK_DEALLOCATING)) == 2) {
-            new_value = old_value - 1;
-            result = true;
-        }
-        if (OSAtomicCompareAndSwapInt(old_value, new_value, where)) {
-            return result;
-        }
-    }
-}
-
-// hit zero?
-static bool latching_decr_int_now_zero(volatile int32_t *where) {
-    while (1) {
-        int32_t old_value = *where;
-        if ((old_value & BLOCK_REFCOUNT_MASK) == BLOCK_REFCOUNT_MASK) {
-            return false; // latched high
-        }
-        if ((old_value & BLOCK_REFCOUNT_MASK) == 0) {
-            return false;   // underflow, latch low
-        }
-        int32_t new_value = old_value - 2;
-        if (OSAtomicCompareAndSwapInt(old_value, new_value, where)) {
-            return (new_value & BLOCK_REFCOUNT_MASK) == 0;
-        }
-    }
-}
-
-
-/***********************
-GC support stub routines
-************************/
-#if !defined(_MSC_VER) || defined(__clang__)
-#pragma mark GC Support Routines
-#endif
-
-
-
-static void *_Block_alloc_default(size_t size, const bool initialCountIsOne, const bool isObject) {
-	(void)initialCountIsOne;
-	(void)isObject;
-    return malloc(size);
-}
-
-static void _Block_assign_default(void *value, void **destptr) {
-    *destptr = value;
-}
-
-static void _Block_setHasRefcount_default(const void *ptr, const bool hasRefcount) {
-	(void)ptr;
-	(void)hasRefcount;
-}
-
-#if HAVE_OBJC
-static void _Block_do_nothing(const void *aBlock) { }
-#endif
-
-static void _Block_retain_object_default(const void *ptr) {
-	(void)ptr;
-}
-
-static void _Block_release_object_default(const void *ptr) {
-	(void)ptr;
-}
-
-static void _Block_assign_weak_default(const void *ptr, void *dest) {
-#if !defined(_WIN32)
-    *(long *)dest = (long)ptr;
-#else
-    *(void **)dest = (void *)ptr;
-#endif
-}
-
-static void _Block_memmove_default(void *dst, void *src, unsigned long size) {
-    memmove(dst, src, (size_t)size);
-}
-
-#if HAVE_OBJC
-static void _Block_memmove_gc_broken(void *dest, void *src, unsigned long size) {
-    void **destp = (void **)dest;
-    void **srcp = (void **)src;
-    while (size) {
-        _Block_assign_default(*srcp, destp);
-        destp++;
-        srcp++;
-        size -= sizeof(void *);
-    }
-}
-#endif
-
-static void _Block_destructInstance_default(const void *aBlock) {
-	(void)aBlock;
-}
-
-/**************************************************************************
-GC support callout functions - initially set to stub routines
-***************************************************************************/
-
-static void *(*_Block_allocator)(size_t, const bool isOne, const bool isObject) = _Block_alloc_default;
-static void (*_Block_deallocator)(const void *) = (void (*)(const void *))free;
-static void (*_Block_assign)(void *value, void **destptr) = _Block_assign_default;
-static void (*_Block_setHasRefcount)(const void *ptr, const bool hasRefcount) = _Block_setHasRefcount_default;
-static void (*_Block_retain_object)(const void *ptr) = _Block_retain_object_default;
-static void (*_Block_release_object)(const void *ptr) = _Block_release_object_default;
-static void (*_Block_assign_weak)(const void *dest, void *ptr) = _Block_assign_weak_default;
-static void (*_Block_memmove)(void *dest, void *src, unsigned long size) = _Block_memmove_default;
-static void (*_Block_destructInstance) (const void *aBlock) = _Block_destructInstance_default;
-
-
-#if HAVE_OBJC
-/**************************************************************************
-GC support SPI functions - called from ObjC runtime and CoreFoundation
-***************************************************************************/
-
-// Public SPI
-// Called from objc-auto to turn on GC.
-// version 3, 4 arg, but changed 1st arg
-void _Block_use_GC( void *(*alloc)(size_t, const bool isOne, const bool isObject),
-                    void (*setHasRefcount)(const void *, const bool),
-                    void (*gc_assign)(void *, void **),
-                    void (*gc_assign_weak)(const void *, void *),
-                    void (*gc_memmove)(void *, void *, unsigned long)) {
-
-    isGC = true;
-    _Block_allocator = alloc;
-    _Block_deallocator = _Block_do_nothing;
-    _Block_assign = gc_assign;
-    _Block_copy_flag = BLOCK_IS_GC;
-    _Block_copy_class = _NSConcreteAutoBlock;
-    // blocks with ctors & dtors need to have the dtor run from a class with a finalizer
-    _Block_copy_finalizing_class = _NSConcreteFinalizingBlock;
-    _Block_setHasRefcount = setHasRefcount;
-    _Byref_flag_initial_value = BLOCK_BYREF_IS_GC;   // no refcount
-    _Block_retain_object = _Block_do_nothing;
-    _Block_release_object = _Block_do_nothing;
-    _Block_assign_weak = gc_assign_weak;
-    _Block_memmove = gc_memmove;
-}
-
-// transitional
-void _Block_use_GC5( void *(*alloc)(size_t, const bool isOne, const bool isObject),
-                    void (*setHasRefcount)(const void *, const bool),
-                    void (*gc_assign)(void *, void **),
-                    void (*gc_assign_weak)(const void *, void *)) {
-    // until objc calls _Block_use_GC it will call us; supply a broken internal memmove implementation until then
-    _Block_use_GC(alloc, setHasRefcount, gc_assign, gc_assign_weak, _Block_memmove_gc_broken);
-}
-
- 
-// Called from objc-auto to alternatively turn on retain/release.
-// Prior to this the only "object" support we can provide is for those
-// super special objects that live in libSystem, namely dispatch queues.
-// Blocks and Block_byrefs have their own special entry points.
-BLOCK_EXPORT
-void _Block_use_RR( void (*retain)(const void *),
-                    void (*release)(const void *)) {
-    _Block_retain_object = retain;
-    _Block_release_object = release;
-    _Block_destructInstance = dlsym(RTLD_DEFAULT, "objc_destructInstance");
-}
-#endif // HAVE_OBJC
-
-// Called from CF to indicate MRR. Newer version uses a versioned structure, so we can add more functions
-// without defining a new entry point.
-BLOCK_EXPORT
-void _Block_use_RR2(const Block_callbacks_RR *callbacks) {
-    _Block_retain_object = callbacks->retain;
-    _Block_release_object = callbacks->release;
-    _Block_destructInstance = callbacks->destructInstance;
-}
-
-/****************************************************************************
-Accessors for block descriptor fields
-*****************************************************************************/
-#if 0
-static struct Block_descriptor_1 * _Block_descriptor_1(struct Block_layout *aBlock)
-{
-    return aBlock->descriptor;
-}
-#endif
-
-static struct Block_descriptor_2 * _Block_descriptor_2(struct Block_layout *aBlock)
-{
-    if (! (aBlock->flags & BLOCK_HAS_COPY_DISPOSE)) return NULL;
-    uint8_t *desc = (uint8_t *)aBlock->descriptor;
-    desc += sizeof(struct Block_descriptor_1);
-    return (struct Block_descriptor_2 *)desc;
-}
-
-static struct Block_descriptor_3 * _Block_descriptor_3(struct Block_layout *aBlock)
-{
-    if (! (aBlock->flags & BLOCK_HAS_SIGNATURE)) return NULL;
-    uint8_t *desc = (uint8_t *)aBlock->descriptor;
-    desc += sizeof(struct Block_descriptor_1);
-    if (aBlock->flags & BLOCK_HAS_COPY_DISPOSE) {
-        desc += sizeof(struct Block_descriptor_2);
-    }
-    return (struct Block_descriptor_3 *)desc;
-}
-
-static __inline bool _Block_has_layout(struct Block_layout *aBlock) {
-    if (! (aBlock->flags & BLOCK_HAS_SIGNATURE)) return false;
-    uint8_t *desc = (uint8_t *)aBlock->descriptor;
-    desc += sizeof(struct Block_descriptor_1);
-    if (aBlock->flags & BLOCK_HAS_COPY_DISPOSE) {
-        desc += sizeof(struct Block_descriptor_2);
-    }
-    return ((struct Block_descriptor_3 *)desc)->layout != NULL;
-}    
-
-static void _Block_call_copy_helper(void *result, struct Block_layout *aBlock)
-{
-    struct Block_descriptor_2 *desc = _Block_descriptor_2(aBlock);
-    if (!desc) return;
-
-    (*desc->copy)(result, aBlock); // do fixup
-}
-
-static void _Block_call_dispose_helper(struct Block_layout *aBlock)
-{
-    struct Block_descriptor_2 *desc = _Block_descriptor_2(aBlock);
-    if (!desc) return;
-
-    (*desc->dispose)(aBlock);
-}
-
-/*******************************************************************************
-Internal Support routines for copying
-********************************************************************************/
-
-#if !defined(_MSC_VER) || defined(__clang__)
-#pragma mark Copy/Release support
-#endif
-
-// Copy, or bump refcount, of a block.  If really copying, call the copy helper if present.
-static void *_Block_copy_internal(const void *arg, const bool wantsOne) {
-    struct Block_layout *aBlock;
-
-    if (!arg) return NULL;
-    
-    
-    // The following would be better done as a switch statement
-    aBlock = (struct Block_layout *)arg;
-    if (aBlock->flags & BLOCK_NEEDS_FREE) {
-        // latches on high
-        latching_incr_int(&aBlock->flags);
-        return aBlock;
-    }
-    else if (aBlock->flags & BLOCK_IS_GC) {
-        // GC refcounting is expensive so do most refcounting here.
-        if (wantsOne && ((latching_incr_int(&aBlock->flags) & BLOCK_REFCOUNT_MASK) == 2)) {
-            // Tell collector to hang on this - it will bump the GC refcount version
-            _Block_setHasRefcount(aBlock, true);
-        }
-        return aBlock;
-    }
-    else if (aBlock->flags & BLOCK_IS_GLOBAL) {
-        return aBlock;
-    }
-
-    // Its a stack block.  Make a copy.
-    if (!isGC) {
-        struct Block_layout *result = malloc(aBlock->descriptor->size);
-        if (!result) return NULL;
-        memmove(result, aBlock, aBlock->descriptor->size); // bitcopy first
-        // reset refcount
-        result->flags &= ~(BLOCK_REFCOUNT_MASK|BLOCK_DEALLOCATING);    // XXX not needed
-        result->flags |= BLOCK_NEEDS_FREE | 2;  // logical refcount 1
-        result->isa = _NSConcreteMallocBlock;
-        _Block_call_copy_helper(result, aBlock);
-        return result;
-    }
-    else {
-        // Under GC want allocation with refcount 1 so we ask for "true" if wantsOne
-        // This allows the copy helper routines to make non-refcounted block copies under GC
-        int32_t flags = aBlock->flags;
-        bool hasCTOR = (flags & BLOCK_HAS_CTOR) != 0;
-        struct Block_layout *result = _Block_allocator(aBlock->descriptor->size, wantsOne, hasCTOR || _Block_has_layout(aBlock));
-        if (!result) return NULL;
-        memmove(result, aBlock, aBlock->descriptor->size); // bitcopy first
-        // reset refcount
-        // if we copy a malloc block to a GC block then we need to clear NEEDS_FREE.
-        flags &= ~(BLOCK_NEEDS_FREE|BLOCK_REFCOUNT_MASK|BLOCK_DEALLOCATING);   // XXX not needed
-        if (wantsOne)
-            flags |= BLOCK_IS_GC | 2;
-        else
-            flags |= BLOCK_IS_GC;
-        result->flags = flags;
-        _Block_call_copy_helper(result, aBlock);
-        if (hasCTOR) {
-            result->isa = _NSConcreteFinalizingBlock;
-        }
-        else {
-            result->isa = _NSConcreteAutoBlock;
-        }
-        return result;
-    }
-}
-
-
-
-
-
-// Runtime entry points for maintaining the sharing knowledge of byref data blocks.
-
-// A closure has been copied and its fixup routine is asking us to fix up the reference to the shared byref data
-// Closures that aren't copied must still work, so everyone always accesses variables after dereferencing the forwarding ptr.
-// We ask if the byref pointer that we know about has already been copied to the heap, and if so, increment it.
-// Otherwise we need to copy it and update the stack forwarding pointer
-static void _Block_byref_assign_copy(void *dest, const void *arg, const int flags) {
-    struct Block_byref **destp = (struct Block_byref **)dest;
-    struct Block_byref *src = (struct Block_byref *)arg;
-        
-    if (src->forwarding->flags & BLOCK_BYREF_IS_GC) {
-        ;   // don't need to do any more work
-    }
-    else if ((src->forwarding->flags & BLOCK_REFCOUNT_MASK) == 0) {
-        // src points to stack
-        bool isWeak = ((flags & (BLOCK_FIELD_IS_BYREF|BLOCK_FIELD_IS_WEAK)) == (BLOCK_FIELD_IS_BYREF|BLOCK_FIELD_IS_WEAK));
-        // if its weak ask for an object (only matters under GC)
-        struct Block_byref *copy = (struct Block_byref *)_Block_allocator(src->size, false, isWeak);
-        copy->flags = src->flags | _Byref_flag_initial_value; // non-GC one for caller, one for stack
-        copy->forwarding = copy; // patch heap copy to point to itself (skip write-barrier)
-        src->forwarding = copy;  // patch stack to point to heap copy
-        copy->size = src->size;
-        if (isWeak) {
-            copy->isa = &_NSConcreteWeakBlockVariable;  // mark isa field so it gets weak scanning
-        }
-        if (src->flags & BLOCK_BYREF_HAS_COPY_DISPOSE) {
-            // Trust copy helper to copy everything of interest
-            // If more than one field shows up in a byref block this is wrong XXX
-            struct Block_byref_2 *src2 = (struct Block_byref_2 *)(src+1);
-            struct Block_byref_2 *copy2 = (struct Block_byref_2 *)(copy+1);
-            copy2->byref_keep = src2->byref_keep;
-            copy2->byref_destroy = src2->byref_destroy;
-
-            if (src->flags & BLOCK_BYREF_LAYOUT_EXTENDED) {
-                struct Block_byref_3 *src3 = (struct Block_byref_3 *)(src2+1);
-                struct Block_byref_3 *copy3 = (struct Block_byref_3*)(copy2+1);
-                copy3->layout = src3->layout;
-            }
-
-            (*src2->byref_keep)(copy, src);
-        }
-        else {
-            // just bits.  Blast 'em using _Block_memmove in case they're __strong
-            // This copy includes Block_byref_3, if any.
-            _Block_memmove(copy+1, src+1,
-                           src->size - sizeof(struct Block_byref));
-        }
-    }
-    // already copied to heap
-    else if ((src->forwarding->flags & BLOCK_BYREF_NEEDS_FREE) == BLOCK_BYREF_NEEDS_FREE) {
-        latching_incr_int(&src->forwarding->flags);
-    }
-    // assign byref data block pointer into new Block
-    _Block_assign(src->forwarding, (void **)destp);
-}
-
-// Old compiler SPI
-static void _Block_byref_release(const void *arg) {
-    struct Block_byref *byref = (struct Block_byref *)arg;
-
-    // dereference the forwarding pointer since the compiler isn't doing this anymore (ever?)
-    byref = byref->forwarding;
-
-    // To support C++ destructors under GC we arrange for there to be a finalizer for this
-    // by using an isa that directs the code to a finalizer that calls the byref_destroy method.
-    if ((byref->flags & BLOCK_BYREF_NEEDS_FREE) == 0) {
-        return; // stack or GC or global
-    }
-    os_assert(byref->flags & BLOCK_REFCOUNT_MASK);
-    if (latching_decr_int_should_deallocate(&byref->flags)) {
-        if (byref->flags & BLOCK_BYREF_HAS_COPY_DISPOSE) {
-            struct Block_byref_2 *byref2 = (struct Block_byref_2 *)(byref+1);
-            (*byref2->byref_destroy)(byref);
-        }
-        _Block_deallocator((struct Block_layout *)byref);
-    }
-}
-
-
-/************************************************************
- *
- * API supporting SPI
- * _Block_copy, _Block_release, and (old) _Block_destroy
- *
- ***********************************************************/
-
-#if !defined(_MSC_VER) || defined(__clang__)
-#pragma mark SPI/API
-#endif
-
-BLOCK_EXPORT
-void *_Block_copy(const void *arg) {
-    return _Block_copy_internal(arg, true);
-}
-
-
-// API entry point to release a copied Block
-BLOCK_EXPORT
-void _Block_release(const void *arg) {
-    struct Block_layout *aBlock = (struct Block_layout *)arg;
-    if (!aBlock 
-        || (aBlock->flags & BLOCK_IS_GLOBAL)
-        || ((aBlock->flags & (BLOCK_IS_GC|BLOCK_NEEDS_FREE)) == 0)
-        ) return;
-    if (aBlock->flags & BLOCK_IS_GC) {
-        if (latching_decr_int_now_zero(&aBlock->flags)) {
-            // Tell GC we no longer have our own refcounts.  GC will decr its refcount
-            // and unless someone has done a CFRetain or marked it uncollectable it will
-            // now be subject to GC reclamation.
-            _Block_setHasRefcount(aBlock, false);
-        }
-    }
-    else if (aBlock->flags & BLOCK_NEEDS_FREE) {
-        if (latching_decr_int_should_deallocate(&aBlock->flags)) {
-            _Block_call_dispose_helper(aBlock);
-            _Block_destructInstance(aBlock);
-            _Block_deallocator(aBlock);
-        }
-    }
-}
-
-BLOCK_EXPORT
-bool _Block_tryRetain(const void *arg) {
-    struct Block_layout *aBlock = (struct Block_layout *)arg;
-    return latching_incr_int_not_deallocating(&aBlock->flags);
-}
-
-BLOCK_EXPORT
-bool _Block_isDeallocating(const void *arg) {
-    struct Block_layout *aBlock = (struct Block_layout *)arg;
-    return (aBlock->flags & BLOCK_DEALLOCATING) != 0;
-}
-
-// Old Compiler SPI point to release a copied Block used by the compiler in dispose helpers
-static void _Block_destroy(const void *arg) {
-    struct Block_layout *aBlock;
-    if (!arg) return;
-    aBlock = (struct Block_layout *)arg;
-    if (aBlock->flags & BLOCK_IS_GC) {
-        // assert(aBlock->Block_flags & BLOCK_HAS_CTOR);
-        return; // ignore, we are being called because of a DTOR
-    }
-    _Block_release(aBlock);
-}
-
-
-
-/************************************************************
- *
- * SPI used by other layers
- *
- ***********************************************************/
-
-// SPI, also internal.  Called from NSAutoBlock only under GC
-BLOCK_EXPORT
-void *_Block_copy_collectable(const void *aBlock) {
-    return _Block_copy_internal(aBlock, false);
-}
-
-
-// SPI
-BLOCK_EXPORT
-size_t Block_size(void *aBlock) {
-    return ((struct Block_layout *)aBlock)->descriptor->size;
-}
-
-BLOCK_EXPORT
-bool _Block_use_stret(void *aBlock) {
-    struct Block_layout *layout = (struct Block_layout *)aBlock;
-
-    int requiredFlags = BLOCK_HAS_SIGNATURE | BLOCK_USE_STRET;
-    return (layout->flags & requiredFlags) == requiredFlags;
-}
-
-// Checks for a valid signature, not merely the BLOCK_HAS_SIGNATURE bit.
-BLOCK_EXPORT
-bool _Block_has_signature(void *aBlock) {
-    return _Block_signature(aBlock) ? true : false;
-}
-
-BLOCK_EXPORT
-const char * _Block_signature(void *aBlock)
-{
-    struct Block_descriptor_3 *desc3 = _Block_descriptor_3(aBlock);
-    if (!desc3) return NULL;
-
-    return desc3->signature;
-}
-
-BLOCK_EXPORT
-const char * _Block_layout(void *aBlock)
-{
-    // Don't return extended layout to callers expecting GC layout
-    struct Block_layout *layout = (struct Block_layout *)aBlock;
-    if (layout->flags & BLOCK_HAS_EXTENDED_LAYOUT) return NULL;
-
-    struct Block_descriptor_3 *desc3 = _Block_descriptor_3(aBlock);
-    if (!desc3) return NULL;
-
-    return desc3->layout;
-}
-
-BLOCK_EXPORT
-const char * _Block_extended_layout(void *aBlock)
-{
-    // Don't return GC layout to callers expecting extended layout
-    struct Block_layout *layout = (struct Block_layout *)aBlock;
-    if (! (layout->flags & BLOCK_HAS_EXTENDED_LAYOUT)) return NULL;
-
-    struct Block_descriptor_3 *desc3 = _Block_descriptor_3(aBlock);
-    if (!desc3) return NULL;
-
-    // Return empty string (all non-object bytes) instead of NULL 
-    // so callers can distinguish "empty layout" from "no layout".
-    if (!desc3->layout) return "";
-    else return desc3->layout;
-}
-
-#if !defined(_MSC_VER) || defined(__clang__)
-#pragma mark Compiler SPI entry points
-#endif
-
-    
-/*******************************************************
-
-Entry points used by the compiler - the real API!
-
-
-A Block can reference four different kinds of things that require help when the Block is copied to the heap.
-1) C++ stack based objects
-2) References to Objective-C objects
-3) Other Blocks
-4) __block variables
-
-In these cases helper functions are synthesized by the compiler for use in Block_copy and Block_release, called the copy and dispose helpers.  The copy helper emits a call to the C++ const copy constructor for C++ stack based objects and for the rest calls into the runtime support function _Block_object_assign.  The dispose helper has a call to the C++ destructor for case 1 and a call into _Block_object_dispose for the rest.
-
-The flags parameter of _Block_object_assign and _Block_object_dispose is set to
-	* BLOCK_FIELD_IS_OBJECT (3), for the case of an Objective-C Object,
-	* BLOCK_FIELD_IS_BLOCK (7), for the case of another Block, and
-	* BLOCK_FIELD_IS_BYREF (8), for the case of a __block variable.
-If the __block variable is marked weak the compiler also or's in BLOCK_FIELD_IS_WEAK (16)
-
-So the Block copy/dispose helpers should only ever generate the four flag values of 3, 7, 8, and 24.
-
-When  a __block variable is either a C++ object, an Objective-C object, or another Block then the compiler also generates copy/dispose helper functions.  Similarly to the Block copy helper, the "__block" copy helper (formerly and still a.k.a. "byref" copy helper) will do a C++ copy constructor (not a const one though!) and the dispose helper will do the destructor.  And similarly the helpers will call into the same two support functions with the same values for objects and Blocks with the additional BLOCK_BYREF_CALLER (128) bit of information supplied.
-
-So the __block copy/dispose helpers will generate flag values of 3 or 7 for objects and Blocks respectively, with BLOCK_FIELD_IS_WEAK (16) or'ed as appropriate and always 128 or'd in, for the following set of possibilities:
-	__block id                   128+3       (0x83)
-	__block (^Block)             128+7       (0x87)
-    __weak __block id            128+3+16    (0x93)
-	__weak __block (^Block)      128+7+16    (0x97)
-        
-
-********************************************************/
-
-//
-// When Blocks or Block_byrefs hold objects then their copy routine helpers use this entry point
-// to do the assignment.
-//
-BLOCK_EXPORT
-void _Block_object_assign(void *destAddr, const void *object, const int flags) {
-    switch (os_assumes(flags & BLOCK_ALL_COPY_DISPOSE_FLAGS)) {
-      case BLOCK_FIELD_IS_OBJECT:
-        /*******
-        id object = ...;
-        [^{ object; } copy];
-        ********/
-            
-        _Block_retain_object(object);
-        _Block_assign((void *)object, destAddr);
-        break;
-
-      case BLOCK_FIELD_IS_BLOCK:
-        /*******
-        void (^object)(void) = ...;
-        [^{ object; } copy];
-        ********/
-
-        _Block_assign(_Block_copy_internal(object, false), destAddr);
-        break;
-    
-      case BLOCK_FIELD_IS_BYREF | BLOCK_FIELD_IS_WEAK:
-      case BLOCK_FIELD_IS_BYREF:
-        /*******
-         // copy the onstack __block container to the heap
-         __block ... x;
-         __weak __block ... x;
-         [^{ x; } copy];
-         ********/
-        
-        _Block_byref_assign_copy(destAddr, object, flags);
-        break;
-        
-      case BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_OBJECT:
-      case BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_BLOCK:
-        /*******
-         // copy the actual field held in the __block container
-         __block id object;
-         __block void (^object)(void);
-         [^{ object; } copy];
-         ********/
-
-        // under manual retain release __block object/block variables are dangling
-        _Block_assign((void *)object, destAddr);
-        break;
-
-      case BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_OBJECT | BLOCK_FIELD_IS_WEAK:
-      case BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_BLOCK  | BLOCK_FIELD_IS_WEAK:
-        /*******
-         // copy the actual field held in the __block container
-         __weak __block id object;
-         __weak __block void (^object)(void);
-         [^{ object; } copy];
-         ********/
-
-        _Block_assign_weak(object, destAddr);
-        break;
-
-      default:
-        break;
-    }
-}
-
-// When Blocks or Block_byrefs hold objects their destroy helper routines call this entry point
-// to help dispose of the contents
-// Used initially only for __attribute__((NSObject)) marked pointers.
-BLOCK_EXPORT
-void _Block_object_dispose(const void *object, const int flags) {
-    switch (os_assumes(flags & BLOCK_ALL_COPY_DISPOSE_FLAGS)) {
-      case BLOCK_FIELD_IS_BYREF | BLOCK_FIELD_IS_WEAK:
-      case BLOCK_FIELD_IS_BYREF:
-        // get rid of the __block data structure held in a Block
-        _Block_byref_release(object);
-        break;
-      case BLOCK_FIELD_IS_BLOCK:
-        _Block_destroy(object);
-        break;
-      case BLOCK_FIELD_IS_OBJECT:
-        _Block_release_object(object);
-        break;
-      case BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_OBJECT:
-      case BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_BLOCK:
-      case BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_OBJECT | BLOCK_FIELD_IS_WEAK:
-      case BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_BLOCK  | BLOCK_FIELD_IS_WEAK:
-        break;
-      default:
-        break;
-    }
-}
--- a/Telegram/ThirdParty/dispatch/src/CMakeLists.txt	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/CMakeLists.txt	1970-01-01 00:00:00.000000000 -0000
@@ -1,171 +0,0 @@
-
-if(NOT CMAKE_SYSTEM_NAME STREQUAL Darwin)
-  add_subdirectory(BlocksRuntime)
-endif()
-
-add_library(dispatch
-  allocator.c
-  apply.c
-  benchmark.c
-  data.c
-  init.c
-  introspection.c
-  io.c
-  mach.c
-  object.c
-  once.c
-  queue.c
-  semaphore.c
-  source.c
-  time.c
-  transform.c
-  voucher.c
-  shims.c
-  protocol.defs
-  provider.d
-  allocator_internal.h
-  data_internal.h
-  inline_internal.h
-  internal.h
-  introspection_internal.h
-  io_internal.h
-  mach_internal.h
-  object_internal.h
-  queue_internal.h
-  semaphore_internal.h
-  shims.h
-  source_internal.h
-  trace.h
-  voucher_internal.h
-  event/event.c
-  event/event_config.h
-  event/event_epoll.c
-  event/event_internal.h
-  event/event_kevent.c
-  event/event_windows.c
-  firehose/firehose_internal.h
-  shims/android_stubs.h
-  shims/atomic.h
-  shims/atomic_sfb.h
-  shims/getprogname.h
-  shims/hw_config.h
-  shims/lock.c
-  shims/lock.h
-  shims/perfmon.h
-  shims/time.h
-  shims/tsd.h
-  shims/yield.c
-  shims/yield.h)
-
-if(CMAKE_SYSTEM_NAME STREQUAL Windows)
-  target_sources(dispatch PRIVATE
-    shims/generic_sys_queue.h
-    shims/generic_win_stubs.c
-    shims/generic_win_stubs.h
-    shims/getprogname.c)
-endif()
-
-if(DISPATCH_USE_INTERNAL_WORKQUEUE)
-  target_sources(dispatch PRIVATE
-    event/workqueue.c
-    event/workqueue_internal.h)
-endif()
-
-target_sources(dispatch PRIVATE
-  block.cpp)
-
-if(ENABLE_DTRACE)
-  dtrace_usdt_probe(${CMAKE_CURRENT_SOURCE_DIR}/provider.d OUTPUT_SOURCES
-    dispatch_dtrace_provider_headers)
-  target_sources(dispatch PRIVATE
-    ${dispatch_dtrace_provider_headers})
-endif()
-
-if(HAVE_OBJC)
-  # TODO(compnerd) split DispatchStubs.cc into a separate component for the ObjC
-  # registration and a separate component for the swift compiler's emission of a
-  # call to the ObjC autorelease elision entry point.
-  target_sources(dispatch PRIVATE
-    data.m
-    object.m
-    swift/DispatchStubs.cc)
-endif()
-
-
-set_target_properties(dispatch PROPERTIES
-  POSITION_INDEPENDENT_CODE YES)
-
-target_include_directories(dispatch PUBLIC
-  ${PROJECT_BINARY_DIR}
-  ${PROJECT_SOURCE_DIR}
-  ${CMAKE_CURRENT_SOURCE_DIR}
-  ${CMAKE_CURRENT_BINARY_DIR})
-target_include_directories(dispatch PRIVATE
-  ${PROJECT_SOURCE_DIR}/private)
-
-if(CMAKE_SYSTEM_NAME STREQUAL Windows)
-  target_compile_definitions(dispatch PRIVATE
-    _CRT_NONSTDC_NO_WARNINGS
-    _CRT_SECURE_NO_WARNINGS)
-elseif(CMAKE_SYSTEM_NAME STREQUAL Android)
-  target_compile_options(dispatch PRIVATE
-    -U_GNU_SOURCE)
-endif()
-if(DISPATCH_ENABLE_ASSERTS)
-  target_compile_definitions(dispatch PRIVATE
-    DISPATCH_DEBUG=1)
-endif()
-
-if("${CMAKE_C_SIMULATE_ID}" STREQUAL "MSVC")
-  target_compile_options(dispatch PRIVATE /EHs-c-)
-  target_compile_options(dispatch PRIVATE /W3)
-else()
-  target_compile_options(dispatch PRIVATE -fno-exceptions)
-  target_compile_options(dispatch PRIVATE -Wall)
-endif()
-
-# FIXME(compnerd) add check for -fblocks?
-target_compile_options(dispatch PRIVATE -fblocks)
-
-check_c_compiler_flag("-momit-leaf-frame-pointer -Werror -Wall -O3" C_SUPPORTS_OMIT_LEAF_FRAME_POINTER)
-if (C_SUPPORTS_OMIT_LEAF_FRAME_POINTER)
-  target_compile_options(dispatch PRIVATE -momit-leaf-frame-pointer)
-endif()
-
-if(LibRT_FOUND)
-  target_link_libraries(dispatch PRIVATE RT::rt)
-endif()
-target_link_libraries(dispatch PRIVATE
-  Threads::Threads)
-target_link_libraries(dispatch PUBLIC
-  BlocksRuntime::BlocksRuntime)
-if(CMAKE_SYSTEM_NAME STREQUAL Windows)
-  target_link_libraries(dispatch PRIVATE
-    ShLwApi
-    WS2_32
-    WinMM
-    synchronization)
-endif()
-
-if(CMAKE_SYSTEM_NAME STREQUAL Darwin)
-  set_property(TARGET dispatch APPEND_STRING PROPERTY LINK_FLAGS
-    "-Xlinker -compatibility_version -Xlinker 1"
-    "-Xlinker -current_version -Xlinker ${VERSION}"
-    "-Xlinker -dead_strip"
-    "-Xlinker -alias_list -Xlinker ${PROJECT_SOURCE_DIR}/xcodeconfig/libdispatch.aliases")
-endif()
-
-if(NOT CMAKE_SYSTEM_NAME MATCHES "Darwin|Windows")
-  set_target_properties(dispatch PROPERTIES INSTALL_RPATH "$ORIGIN")
-endif()
-
-if(ENABLE_SWIFT)
-  add_subdirectory(swift)
-endif()
-
-set_property(GLOBAL APPEND PROPERTY DISPATCH_EXPORTS dispatch)
-install(TARGETS dispatch
-        EXPORT dispatchExports
-        ARCHIVE DESTINATION ${INSTALL_TARGET_DIR}
-        LIBRARY DESTINATION ${INSTALL_TARGET_DIR}
-        RUNTIME DESTINATION bin)
--- a/Telegram/ThirdParty/dispatch/src/data.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/data.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,740 +0,0 @@
-/*
- * Copyright (c) 2009-2013 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include "internal.h"
-
-/*
- * Dispatch data objects are dispatch objects with standard retain/release
- * memory management. A dispatch data object either points to a number of other
- * dispatch data objects or is a leaf data object.
- * A composite data object specifies the total size of data it represents
- * and list of constituent records.
- *
- *******************************************************************************
- *
- * CURRENT IMPLEMENTATION DETAILS
- *
- *   There are actually 3 kinds of composite objects
- *   - trivial subranges
- *   - unflattened composite data objects
- *   - flattened composite data objects
- *
- * LEAVES (num_records == 0, destructor != nil)
- *
- *   Those objects have a pointer to represented memory in `buf`.
- *
- * UNFLATTENED (num_records > 1, buf == nil, destructor == nil)
- *
- *   This is the generic case of a composite object.
- *
- * FLATTENED (num_records > 1, buf != nil, destructor == nil)
- *
- *   Those objects are non trivial composite objects whose `buf` pointer
- *   is a contiguous representation (copied) of the memory it represents.
- *
- *   Such objects are created when used as an NSData and -bytes is called and
- *   where the dispatch data object is an unflattened composite object.
- *   The underlying implementation is dispatch_data_get_flattened_bytes_4libxpc.
- *
- * TRIVIAL SUBRANGES (num_records == 1, buf == nil, destructor == nil)
- *
- *   Those objects point to a single leaf, never to flattened objects.
- *
- *******************************************************************************
- *
- * Non trivial invariants:
- *
- *   It is forbidden to point into a composite data object and ignore entire
- *   records from it.  (for example by having `from` longer than the first
- *   record length).
- *
- *   dispatch_data_t's are either leaves, or composite objects pointing to
- *   leaves. Depth is never greater than 1.
- *
- *******************************************************************************
- *
- * There are 4 dispatch_data_t constructors who may create non leaf objects,
- * and ensure proper invariants.
- *
- * dispatch_data_copy_region()
- *    This function first sees through trivial subranges, and may in turn
- *    generate new trivial subranges.
- *
- * dispatch_data_create_map()
- *    This function either returns existing data objects, or a leaf.
- *
- * dispatch_data_create_subrange()
- *    This function treats flattened objects like unflattened ones,
- *    and recurses into trivial subranges, it can create trivial subranges.
- *
- * dispatch_data_create_concat()
- *    This function unwraps the top-level composite objects, trivial or not,
- *    and else concatenates the two arguments range lists, hence always creating
- *    unflattened objects, unless one of the arguments was empty.
- *
- *******************************************************************************
- */
-
-#if DISPATCH_DATA_IS_BRIDGED_TO_NSDATA
-#define _dispatch_data_retain(x) _dispatch_objc_retain(x)
-#define _dispatch_data_release(x) _dispatch_objc_release(x)
-#else
-#define _dispatch_data_retain(x) dispatch_retain(x)
-#define _dispatch_data_release(x) dispatch_release(x)
-#endif
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_data_t
-_dispatch_data_alloc(size_t n, size_t extra)
-{
-	dispatch_data_t data;
-	size_t size;
-	size_t base_size;
-
-	if (os_add_overflow(sizeof(struct dispatch_data_s), extra, &base_size)) {
-		return DISPATCH_OUT_OF_MEMORY;
-	}
-	if (os_mul_and_add_overflow(n, sizeof(range_record), base_size, &size)) {
-		return DISPATCH_OUT_OF_MEMORY;
-	}
-
-	data = _dispatch_object_alloc(DISPATCH_DATA_CLASS, size);
-	data->num_records = n;
-#if !DISPATCH_DATA_IS_BRIDGED_TO_NSDATA
-	data->do_targetq = _dispatch_get_default_queue(false);
-	data->do_next = DISPATCH_OBJECT_LISTLESS;
-#endif
-	return data;
-}
-
-static void
-_dispatch_data_destroy_buffer(const void* buffer, size_t size,
-		dispatch_queue_t queue, dispatch_block_t destructor)
-{
-	if (destructor == DISPATCH_DATA_DESTRUCTOR_FREE) {
-		free((void*)buffer);
-	} else if (destructor == DISPATCH_DATA_DESTRUCTOR_NONE) {
-		// do nothing
-#if HAVE_MACH
-	} else if (destructor == DISPATCH_DATA_DESTRUCTOR_VM_DEALLOCATE) {
-		mach_vm_size_t vm_size = size;
-		mach_vm_address_t vm_addr = (uintptr_t)buffer;
-		mach_vm_deallocate(mach_task_self(), vm_addr, vm_size);
-#else
-		(void)size;
-#endif
-	} else {
-		if (!queue) {
-			queue = _dispatch_get_default_queue(false);
-		}
-		dispatch_async_f(queue, destructor, _dispatch_call_block_and_release);
-	}
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_data_init(dispatch_data_t data, const void *buffer, size_t size,
-		dispatch_queue_t queue, dispatch_block_t destructor)
-{
-	data->buf = buffer;
-	data->size = size;
-	data->destructor = destructor;
-	if (queue) {
-		_dispatch_retain(queue);
-		data->do_targetq = queue;
-	}
-}
-
-void
-_dispatch_data_init_with_bytes(dispatch_data_t data, const void *buffer,
-		size_t size, dispatch_block_t destructor)
-{
-	if (!buffer || !size) {
-		if (destructor) {
-			_dispatch_data_destroy_buffer(buffer, size, NULL,
-					_dispatch_Block_copy(destructor));
-		}
-		buffer = NULL;
-		size = 0;
-		destructor = DISPATCH_DATA_DESTRUCTOR_NONE;
-	}
-	_dispatch_data_init(data, buffer, size, NULL, destructor);
-}
-
-dispatch_data_t
-dispatch_data_create(const void* buffer, size_t size, dispatch_queue_t queue,
-		dispatch_block_t destructor)
-{
-	dispatch_data_t data;
-	void *data_buf = NULL;
-	if (!buffer || !size) {
-		// Empty data requested so return the singleton empty object. Call
-		// destructor immediately in this case to ensure any unused associated
-		// storage is released.
-		if (destructor) {
-			_dispatch_data_destroy_buffer(buffer, size, queue,
-					_dispatch_Block_copy(destructor));
-		}
-		return dispatch_data_empty;
-	}
-	if (destructor == DISPATCH_DATA_DESTRUCTOR_DEFAULT) {
-		// The default destructor was provided, indicating the data should be
-		// copied.
-		data_buf = malloc(size);
-		if (unlikely(!data_buf)) {
-			return DISPATCH_OUT_OF_MEMORY;
-		}
-		buffer = memcpy(data_buf, buffer, size);
-		data = _dispatch_data_alloc(0, 0);
-		destructor = DISPATCH_DATA_DESTRUCTOR_FREE;
-	} else if (destructor == DISPATCH_DATA_DESTRUCTOR_INLINE) {
-		data = _dispatch_data_alloc(0, size);
-		buffer = memcpy((void*)data + sizeof(struct dispatch_data_s), buffer,
-				size);
-		destructor = DISPATCH_DATA_DESTRUCTOR_NONE;
-	} else {
-		data = _dispatch_data_alloc(0, 0);
-		destructor = _dispatch_Block_copy(destructor);
-	}
-	_dispatch_data_init(data, buffer, size, queue, destructor);
-	return data;
-}
-
-dispatch_data_t
-dispatch_data_create_f(const void *buffer, size_t size, dispatch_queue_t queue,
-		dispatch_function_t destructor_function)
-{
-	dispatch_block_t destructor = (dispatch_block_t)destructor_function;
-	if (destructor != DISPATCH_DATA_DESTRUCTOR_DEFAULT &&
-			destructor != DISPATCH_DATA_DESTRUCTOR_FREE &&
-			destructor != DISPATCH_DATA_DESTRUCTOR_NONE &&
-#if HAVE_MACH
-			destructor != DISPATCH_DATA_DESTRUCTOR_VM_DEALLOCATE &&
-#endif
-			destructor != DISPATCH_DATA_DESTRUCTOR_INLINE) {
-		destructor = ^{ destructor_function((void*)buffer); };
-	}
-	return dispatch_data_create(buffer, size, queue, destructor);
-}
-
-dispatch_data_t
-dispatch_data_create_alloc(size_t size, void** buffer_ptr)
-{
-	dispatch_data_t data = dispatch_data_empty;
-	void *buffer = NULL;
-
-	if (unlikely(!size)) {
-		goto out;
-	}
-	data = _dispatch_data_alloc(0, size);
-	buffer = (void*)data + sizeof(struct dispatch_data_s);
-	_dispatch_data_init(data, buffer, size, NULL,
-			DISPATCH_DATA_DESTRUCTOR_NONE);
-out:
-	if (buffer_ptr) {
-		*buffer_ptr = buffer;
-	}
-	return data;
-}
-
-void
-_dispatch_data_dispose(dispatch_data_t dd, DISPATCH_UNUSED bool *allow_free)
-{
-	if (_dispatch_data_leaf(dd)) {
-		_dispatch_data_destroy_buffer(dd->buf, dd->size, dd->do_targetq,
-				dd->destructor);
-	} else {
-		size_t i;
-		for (i = 0; i < _dispatch_data_num_records(dd); ++i) {
-			_dispatch_data_release(dd->records[i].data_object);
-		}
-		free((void *)dd->buf);
-	}
-}
-
-#if DISPATCH_DATA_IS_BRIDGED_TO_NSDATA
-void
-_dispatch_data_set_target_queue(dispatch_data_t dd, dispatch_queue_t tq)
-{
-	if (tq == DISPATCH_TARGET_QUEUE_DEFAULT) {
-		tq = _dispatch_get_default_queue(false);
-	}
-	_dispatch_object_set_target_queue_inline(dd, tq);
-}
-#endif // DISPATCH_DATA_IS_BRIDGED_TO_NSDATA
-
-size_t
-_dispatch_data_debug(dispatch_data_t dd, char* buf, size_t bufsiz)
-{
-	size_t offset = 0;
-	offset += dsnprintf(&buf[offset], bufsiz - offset, "data[%p] = { ", dd);
-	if (_dispatch_data_leaf(dd)) {
-		offset += dsnprintf(&buf[offset], bufsiz - offset,
-				"leaf, size = %zd, buf = %p ", dd->size, dd->buf);
-	} else {
-		offset += dsnprintf(&buf[offset], bufsiz - offset,
-				"composite, size = %zd, num_records = %zd ", dd->size,
-				_dispatch_data_num_records(dd));
-		if (dd->buf) {
-			offset += dsnprintf(&buf[offset], bufsiz - offset,
-					", flatbuf = %p ", dd->buf);
-		}
-		size_t i;
-		for (i = 0; i < _dispatch_data_num_records(dd); ++i) {
-			range_record r = dd->records[i];
-			offset += dsnprintf(&buf[offset], bufsiz - offset, "record[%zd] = "
-					"{ from = %zd, length = %zd, data_object = %p }, ", i,
-					r.from, r.length, r.data_object);
-		}
-	}
-	offset += dsnprintf(&buf[offset], bufsiz - offset, "}");
-	return offset;
-}
-
-size_t
-dispatch_data_get_size(dispatch_data_t dd)
-{
-	return dd->size;
-}
-
-dispatch_data_t
-dispatch_data_create_concat(dispatch_data_t dd1, dispatch_data_t dd2)
-{
-	dispatch_data_t data;
-	size_t n;
-
-	if (!dd1->size) {
-		_dispatch_data_retain(dd2);
-		return dd2;
-	}
-	if (!dd2->size) {
-		_dispatch_data_retain(dd1);
-		return dd1;
-	}
-
-	if (os_add_overflow(_dispatch_data_num_records(dd1),
-			_dispatch_data_num_records(dd2), &n)) {
-		return DISPATCH_OUT_OF_MEMORY;
-	}
-	data = _dispatch_data_alloc(n, 0);
-	data->size = dd1->size + dd2->size;
-	// Copy the constituent records into the newly created data object
-	// Reference leaf objects as sub-objects
-	if (_dispatch_data_leaf(dd1)) {
-		data->records[0].from = 0;
-		data->records[0].length = dd1->size;
-		data->records[0].data_object = dd1;
-	} else {
-		memcpy(data->records, dd1->records, _dispatch_data_num_records(dd1) *
-				sizeof(range_record));
-	}
-	if (_dispatch_data_leaf(dd2)) {
-		data->records[_dispatch_data_num_records(dd1)].from = 0;
-		data->records[_dispatch_data_num_records(dd1)].length = dd2->size;
-		data->records[_dispatch_data_num_records(dd1)].data_object = dd2;
-	} else {
-		memcpy(data->records + _dispatch_data_num_records(dd1), dd2->records,
-				_dispatch_data_num_records(dd2) * sizeof(range_record));
-	}
-	size_t i;
-	for (i = 0; i < _dispatch_data_num_records(data); ++i) {
-		_dispatch_data_retain(data->records[i].data_object);
-	}
-	return data;
-}
-
-dispatch_data_t
-dispatch_data_create_subrange(dispatch_data_t dd, size_t offset,
-		size_t length)
-{
-	dispatch_data_t data;
-
-	if (offset >= dd->size || !length) {
-		return dispatch_data_empty;
-	} else if (length > dd->size - offset) {
-		length = dd->size - offset;
-	} else if (length == dd->size) {
-		_dispatch_data_retain(dd);
-		return dd;
-	}
-	/*
-	 * we must only optimize leaves and not flattened objects
-	 * because lots of users want to keep the end of a buffer and release
-	 * as much memory as they can from the beginning of it
-	 *
-	 * Using the flatbuf here would be very wrong with respect to that goal
-	 */
-	if (_dispatch_data_leaf(dd)) {
-		data = _dispatch_data_alloc(1, 0);
-		data->size = length;
-		data->records[0].from = offset;
-		data->records[0].length = length;
-		data->records[0].data_object = dd;
-		_dispatch_data_retain(dd);
-		return data;
-	}
-
-	// Subrange of a composite dispatch data object
-	const size_t dd_num_records = _dispatch_data_num_records(dd);
-	bool to_the_end = (offset + length == dd->size);
-	size_t i = 0;
-
-	// find the record containing the specified offset
-	while (i < dd_num_records && offset >= dd->records[i].length) {
-		offset -= dd->records[i++].length;
-	}
-
-	// Crashing here indicates memory corruption of passed in data object
-	if (unlikely(i >= dd_num_records)) {
-		DISPATCH_INTERNAL_CRASH(i,
-				"dispatch_data_create_subrange out of bounds");
-	}
-
-	// if everything is from a single dispatch data object, avoid boxing it
-	if (offset + length <= dd->records[i].length) {
-		return dispatch_data_create_subrange(dd->records[i].data_object,
-				dd->records[i].from + offset, length);
-	}
-
-	// find the record containing the end of the current range
-	// and optimize the case when you just remove bytes at the origin
-	size_t count, last_length = 0;
-
-	if (to_the_end) {
-		count = dd_num_records - i;
-	} else {
-		last_length = length - (dd->records[i].length - offset);
-		count = 1;
-
-		while (i + count < dd_num_records) {
-			size_t record_length = dd->records[i + count++].length;
-
-			if (last_length <= record_length) {
-				break;
-			}
-			last_length -= record_length;
-
-			// Crashing here indicates memory corruption of passed in data object
-			if (unlikely(i + count >= dd_num_records)) {
-				DISPATCH_INTERNAL_CRASH(i + count,
-						"dispatch_data_create_subrange out of bounds");
-			}
-		}
-	}
-
-	data = _dispatch_data_alloc(count, 0);
-	data->size = length;
-	memcpy(data->records, dd->records + i, count * sizeof(range_record));
-
-	if (offset) {
-		data->records[0].from += offset;
-		data->records[0].length -= offset;
-	}
-	if (!to_the_end) {
-		data->records[count - 1].length = last_length;
-	}
-
-	for (i = 0; i < count; i++) {
-		_dispatch_data_retain(data->records[i].data_object);
-	}
-	return data;
-}
-
-static void*
-_dispatch_data_flatten(dispatch_data_t dd)
-{
-	void *buffer = malloc(dd->size);
-
-	// Composite data object, copy the represented buffers
-	if (buffer) {
-		dispatch_data_apply(dd, ^(dispatch_data_t region DISPATCH_UNUSED,
-				size_t off, const void* buf, size_t len) {
-			memcpy(buffer + off, buf, len);
-			return (bool)true;
-		});
-	}
-
-	return buffer;
-}
-
-// When mapping a leaf object or a subrange of a leaf object, return a direct
-// pointer to the represented buffer. For all other data objects, copy the
-// represented buffers into a contiguous area. In the future it might
-// be possible to relocate the buffers instead (if not marked as locked).
-dispatch_data_t
-dispatch_data_create_map(dispatch_data_t dd, const void **buffer_ptr,
-		size_t *size_ptr)
-{
-	dispatch_data_t data = NULL;
-	const void *buffer = NULL;
-	size_t size = dd->size;
-
-	if (!size) {
-		data = dispatch_data_empty;
-		goto out;
-	}
-
-	buffer = _dispatch_data_map_direct(dd, 0, NULL, NULL);
-	if (buffer) {
-		_dispatch_data_retain(dd);
-		data = dd;
-		goto out;
-	}
-
-	buffer = _dispatch_data_flatten(dd);
-	if (likely(buffer)) {
-		data = dispatch_data_create(buffer, size, NULL,
-				DISPATCH_DATA_DESTRUCTOR_FREE);
-	} else {
-		size = 0;
-	}
-
-out:
-	if (buffer_ptr) {
-		*buffer_ptr = buffer;
-	}
-	if (size_ptr) {
-		*size_ptr = size;
-	}
-	return data;
-}
-
-const void *
-dispatch_data_get_flattened_bytes_4libxpc(dispatch_data_t dd)
-{
-	const void *buffer;
-	size_t offset = 0;
-
-	if (unlikely(!dd->size)) {
-		return NULL;
-	}
-
-	buffer = _dispatch_data_map_direct(dd, 0, &dd, &offset);
-	if (buffer) {
-		return buffer;
-	}
-
-	void *flatbuf = _dispatch_data_flatten(dd);
-	if (likely(flatbuf)) {
-		// we need a release so that readers see the content of the buffer
-		if (unlikely(!os_atomic_cmpxchgv2o(dd, buf, NULL, flatbuf,
-				&buffer, release))) {
-			free(flatbuf);
-		} else {
-			buffer = flatbuf;
-		}
-	} else {
-		return NULL;
-	}
-
-	return buffer + offset;
-}
-
-#if DISPATCH_USE_CLIENT_CALLOUT
-DISPATCH_NOINLINE
-#else
-DISPATCH_ALWAYS_INLINE
-#endif
-static bool
-_dispatch_data_apply_client_callout(void *ctxt, dispatch_data_t region, size_t offset,
-		const void *buffer, size_t size, dispatch_data_applier_function_t f)
-{
-	return f(ctxt, region, offset, buffer, size);
-}
-
-
-static bool
-_dispatch_data_apply(dispatch_data_t dd, size_t offset, size_t from,
-		size_t size, void *ctxt, dispatch_data_applier_function_t applier)
-{
-	bool result = true;
-	const void *buffer;
-
-	buffer = _dispatch_data_map_direct(dd, 0, NULL, NULL);
-	if (buffer) {
-		return _dispatch_data_apply_client_callout(ctxt, dd,
-				offset, buffer + from, size, applier);
-	}
-
-	size_t i;
-	for (i = 0; i < _dispatch_data_num_records(dd) && result; ++i) {
-		result = _dispatch_data_apply(dd->records[i].data_object,
-				offset, dd->records[i].from, dd->records[i].length, ctxt,
-				applier);
-		offset += dd->records[i].length;
-	}
-	return result;
-}
-
-bool
-dispatch_data_apply_f(dispatch_data_t dd, void *ctxt,
-		dispatch_data_applier_function_t applier)
-{
-	if (!dd->size) {
-		return true;
-	}
-	return _dispatch_data_apply(dd, 0, 0, dd->size, ctxt, applier);
-}
-
-bool
-dispatch_data_apply(dispatch_data_t dd, dispatch_data_applier_t applier)
-{
-	if (!dd->size) {
-		return true;
-	}
-	return _dispatch_data_apply(dd, 0, 0, dd->size, applier,
-			(dispatch_data_applier_function_t)_dispatch_Block_invoke(applier));
-}
-
-static dispatch_data_t
-_dispatch_data_copy_region(dispatch_data_t dd, size_t from, size_t size,
-		size_t location, size_t *offset_ptr)
-{
-	dispatch_data_t reusable_dd = NULL;
-	size_t offset = 0;
-
-	if (from == 0 && size == dd->size) {
-		reusable_dd = dd;
-	}
-
-	if (_dispatch_data_map_direct(dd, from, &dd, &from)) {
-		if (reusable_dd) {
-			_dispatch_data_retain(reusable_dd);
-			return reusable_dd;
-		}
-
-		_dispatch_data_retain(dd);
-		if (from == 0 && size == dd->size) {
-			return dd;
-		}
-
-		dispatch_data_t data = _dispatch_data_alloc(1, 0);
-		data->size = size;
-		data->records[0].from = from;
-		data->records[0].length = size;
-		data->records[0].data_object = dd;
-		return data;
-	}
-
-	size_t i;
-	for (i = 0; i < _dispatch_data_num_records(dd); ++i) {
-		size_t length = dd->records[i].length;
-
-		if (from >= length) {
-			from -= length;
-			continue;
-		}
-
-		length -= from;
-		if (location >= offset + length) {
-			offset += length;
-			from = 0;
-			continue;
-		}
-
-		from += dd->records[i].from;
-		dd = dd->records[i].data_object;
-		*offset_ptr += offset;
-		location -= offset;
-		return _dispatch_data_copy_region(dd, from, length, location, offset_ptr);
-	}
-
-	DISPATCH_INTERNAL_CRASH(*offset_ptr+offset,
-			"dispatch_data_copy_region out of bounds");
-}
-
-// Returs either a leaf object or an object composed of a single leaf object
-dispatch_data_t
-dispatch_data_copy_region(dispatch_data_t dd, size_t location,
-		size_t *offset_ptr)
-{
-	if (location >= dd->size) {
-		*offset_ptr = dd->size;
-		return dispatch_data_empty;
-	}
-	*offset_ptr = 0;
-	return _dispatch_data_copy_region(dd, 0, dd->size, location, offset_ptr);
-}
-
-#if HAVE_MACH
-
-#ifndef MAP_MEM_VM_COPY
-#define MAP_MEM_VM_COPY 0x200000 // <rdar://problem/13336613>
-#endif
-
-mach_port_t
-dispatch_data_make_memory_entry(dispatch_data_t dd)
-{
-	mach_port_t mep = MACH_PORT_NULL;
-	memory_object_size_t mos;
-	mach_vm_size_t vm_size = dd->size;
-	mach_vm_address_t vm_addr;
-	vm_prot_t flags;
-	kern_return_t kr;
-	bool copy = (dd->destructor != DISPATCH_DATA_DESTRUCTOR_VM_DEALLOCATE);
-
-retry:
-	if (copy) {
-		vm_addr = vm_page_size;
-		kr = mach_vm_allocate(mach_task_self(), &vm_addr, vm_size,
-				VM_FLAGS_ANYWHERE);
-		if (kr) {
-			if (kr != KERN_NO_SPACE) {
-				(void)dispatch_assume_zero(kr);
-			}
-			return mep;
-		}
-		dispatch_data_apply(dd, ^(dispatch_data_t region DISPATCH_UNUSED,
-				size_t off, const void* buf, size_t len) {
-			memcpy((void*)(vm_addr + off), buf, len);
-			return (bool)true;
-		});
-	} else {
-		vm_addr = (uintptr_t)dd->buf;
-	}
-	flags = VM_PROT_DEFAULT|VM_PROT_IS_MASK|MAP_MEM_VM_COPY;
-	mos = vm_size;
-	kr = mach_make_memory_entry_64(mach_task_self(), &mos, vm_addr, flags,
-			&mep, MACH_PORT_NULL);
-	if (kr == KERN_INVALID_VALUE) {
-		// Fallback in case MAP_MEM_VM_COPY is not supported
-		flags &= ~MAP_MEM_VM_COPY;
-		kr = mach_make_memory_entry_64(mach_task_self(), &mos, vm_addr, flags,
-				&mep, MACH_PORT_NULL);
-	}
-	if (dispatch_assume_zero(kr)) {
-		mep = MACH_PORT_NULL;
-	} else if (mos < vm_size) {
-		// Memory object was truncated, e.g. due to lack of MAP_MEM_VM_COPY
-		kr = mach_port_deallocate(mach_task_self(), mep);
-		(void)dispatch_assume_zero(kr);
-		if (!copy) {
-			copy = true;
-			goto retry;
-		}
-		mep = MACH_PORT_NULL;
-	}
-	if (copy) {
-		kr = mach_vm_deallocate(mach_task_self(), vm_addr, vm_size);
-		(void)dispatch_assume_zero(kr);
-	}
-	return mep;
-}
-#endif // HAVE_MACH
--- a/Telegram/ThirdParty/dispatch/src/data_internal.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/data_internal.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,153 +0,0 @@
-/*
- * Copyright (c) 2009-2012 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-/*
- * IMPORTANT: This header file describes INTERNAL interfaces to libdispatch
- * which are subject to change in future releases of Mac OS X. Any applications
- * relying on these interfaces WILL break.
- */
-
-#ifndef __DISPATCH_DATA_INTERNAL__
-#define __DISPATCH_DATA_INTERNAL__
-
-#ifndef __DISPATCH_INDIRECT__
-#error "Please #include <dispatch/dispatch.h> instead of this file directly."
-#include <dispatch/base.h> // for HeaderDoc
-#endif
-
-typedef struct range_record_s {
-	dispatch_data_t data_object;
-	size_t from;
-	size_t length;
-} range_record;
-
-#if OS_OBJECT_HAVE_OBJC2
-#define DISPATCH_DATA_IS_BRIDGED_TO_NSDATA 1
-#else
-#define DISPATCH_DATA_IS_BRIDGED_TO_NSDATA 0
-#endif
-
-#if DISPATCH_DATA_IS_BRIDGED_TO_NSDATA
-DISPATCH_OBJC_CLASS_DECL(data);
-DISPATCH_OBJC_CLASS_DECL(data_empty);
-_OS_OBJECT_DECL_PROTOCOL(dispatch_data, dispatch_object);
-#define DISPATCH_DATA_CLASS DISPATCH_VTABLE(data)
-#define DISPATCH_DATA_EMPTY_CLASS DISPATCH_VTABLE(data_empty)
-#else
-DISPATCH_CLASS_DECL(data, OBJECT);
-#define DISPATCH_DATA_CLASS DISPATCH_VTABLE(data)
-#endif // DISPATCH_DATA_IS_BRIDGED_TO_NSDATA
-
-struct dispatch_data_s {
-#if DISPATCH_DATA_IS_BRIDGED_TO_NSDATA
-	const void *do_vtable;
-	dispatch_queue_t do_targetq;
-	void *ctxt;
-	void *finalizer;
-#else
-	DISPATCH_OBJECT_HEADER(data);
-#endif // DISPATCH_DATA_IS_BRIDGED_TO_NSDATA
-	const void *buf;
-	dispatch_block_t destructor;
-	size_t size, num_records;
-	range_record records[0];
-};
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dispatch_data_leaf(struct dispatch_data_s *dd)
-{
-	return dd->num_records == 0;
-}
-
-/*
- * This is about the number of records required to hold that dispatch data
- * if it's not a leaf. Callers either want that value, or have to special
- * case the case when the dispatch data *is* a leaf before (and that the actual
- * embedded record count of that dispatch data is 0)
- */
-DISPATCH_ALWAYS_INLINE
-static inline size_t
-_dispatch_data_num_records(struct dispatch_data_s *dd)
-{
-	return dd->num_records ?: 1;
-}
-
-typedef dispatch_data_t (*dispatch_transform_t)(dispatch_data_t data);
-
-struct dispatch_data_format_type_s {
-	uint64_t type;
-	uint64_t input_mask;
-	uint64_t output_mask;
-	dispatch_transform_t decode;
-	dispatch_transform_t encode;
-};
-
-void _dispatch_data_init_with_bytes(dispatch_data_t data, const void *buffer,
-		size_t size, dispatch_block_t destructor);
-void _dispatch_data_dispose(dispatch_data_t data, bool *allow_free);
-#if DISPATCH_DATA_IS_BRIDGED_TO_NSDATA
-void _dispatch_data_set_target_queue(struct dispatch_data_s *dd,
-		dispatch_queue_t tq);
-#endif
-DISPATCH_COLD
-size_t _dispatch_data_debug(dispatch_data_t data, char* buf, size_t bufsiz);
-
-#if !defined(__cplusplus)
-extern const dispatch_block_t _dispatch_data_destructor_inline;
-#define DISPATCH_DATA_DESTRUCTOR_INLINE (_dispatch_data_destructor_inline)
-
-/*
- * the out parameters are about seeing "through" trivial subranges
- * so for something like this: dd = { subrange [ dd1, offset1 ] },
- * this will return { dd1, offset + offset1 }
- *
- * If the dispatch object isn't a trivial subrange, it returns { dd, offset }
- */
-DISPATCH_ALWAYS_INLINE
-static inline const void*
-_dispatch_data_map_direct(struct dispatch_data_s *dd, size_t offset,
-		struct dispatch_data_s **dd_out, size_t *from_out)
-{
-	const void *buffer = NULL;
-
-	dispatch_assert(dd->size);
-	if (unlikely(!_dispatch_data_leaf(dd)) &&
-			_dispatch_data_num_records(dd) == 1) {
-		offset += dd->records[0].from;
-		dd = (struct dispatch_data_s *)dd->records[0].data_object;
-	}
-
-	if (likely(_dispatch_data_leaf(dd))) {
-		buffer = dd->buf + offset;
-	} else {
-		buffer = os_atomic_load((void **)&dd->buf, relaxed);
-		if (buffer) {
-			buffer += offset;
-		}
-	}
-	if (dd_out) *dd_out = dd;
-	if (from_out) *from_out = offset;
-	return buffer;
-}
-
-#endif // !defined(__cplusplus)
-
-#endif // __DISPATCH_DATA_INTERNAL__
--- a/Telegram/ThirdParty/dispatch/src/data.m	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/data.m	1970-01-01 00:00:00.000000000 -0000
@@ -1,202 +0,0 @@
-/*
- * Copyright (c) 2012-2013 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include "internal.h"
-
-#if DISPATCH_DATA_IS_BRIDGED_TO_NSDATA
-
-#if _OS_OBJECT_OBJC_ARC
-#error "Cannot build with ARC"
-#endif
-
-#include <Foundation/NSString.h>
-
-// NOTE: this file must not contain any atomic operations
-
-@interface DISPATCH_CLASS(data) () <DISPATCH_CLASS(data)>
-@property (readonly,nonatomic) NSUInteger length;
-@property (readonly,nonatomic) const void *bytes NS_RETURNS_INNER_POINTER;
-
-- (id)initWithBytes:(void *)bytes length:(NSUInteger)length copy:(BOOL)copy
-		freeWhenDone:(BOOL)freeBytes bytesAreVM:(BOOL)vm;
-- (BOOL)_bytesAreVM;
-- (BOOL)_isCompact;
-@end
-
-@interface DISPATCH_CLASS(data_empty) : DISPATCH_CLASS(data)
-@end
-
-@implementation DISPATCH_CLASS(data)
-
-+ (id)allocWithZone:(NSZone *) DISPATCH_UNUSED zone {
-	return _dispatch_objc_alloc(self, sizeof(struct dispatch_data_s));
-}
-
-- (id)init {
-    return [self initWithBytes:NULL length:0 copy:NO freeWhenDone:NO
-			bytesAreVM:NO];
-}
-
-- (id)initWithBytes:(void *)bytes length:(NSUInteger)length copy:(BOOL)copy
-		freeWhenDone:(BOOL)freeBytes bytesAreVM:(BOOL)vm {
-	dispatch_block_t destructor;
-	if (copy) {
-		destructor = DISPATCH_DATA_DESTRUCTOR_DEFAULT;
-	} else if (freeBytes) {
-		if (vm) {
-			destructor = DISPATCH_DATA_DESTRUCTOR_VM_DEALLOCATE;
-		} else {
-			destructor = DISPATCH_DATA_DESTRUCTOR_FREE;
-		}
-	} else {
-		destructor = DISPATCH_DATA_DESTRUCTOR_NONE;
-	}
-	_dispatch_data_init_with_bytes(self, bytes, length, destructor);
-	return self;
-}
-
-- (void)dealloc {
-	struct dispatch_data_s *dd = (void*)self;
-	_dispatch_data_dispose(self, NULL);
-	dispatch_queue_t tq = dd->do_targetq;
-	dispatch_function_t func = dd->finalizer;
-	void *ctxt = dd->ctxt;
-	[super dealloc];
-	if (func && ctxt) {
-		if (!tq) {
-			 tq = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);
-		}
-		dispatch_async_f(tq, ctxt, func);
-	}
-	if (tq) {
-		_os_object_release_internal((_os_object_t)tq);
-	}
-}
-
-- (BOOL)_bytesAreVM {
-	struct dispatch_data_s *dd = (void*)self;
-	return dd->destructor == DISPATCH_DATA_DESTRUCTOR_VM_DEALLOCATE;
-}
-
-- (void)_setContext:(void*)context {
-	struct dispatch_data_s *dd = (void*)self;
-	dd->ctxt = context;
-}
-
-- (void*)_getContext {
-	struct dispatch_data_s *dd = (void*)self;
-	return dd->ctxt;
-}
-
-- (void)_setFinalizer:(dispatch_function_t)finalizer {
-	struct dispatch_data_s *dd = (void*)self;
-	dd->finalizer = finalizer;
-}
-
-- (void)_setTargetQueue:(dispatch_queue_t)queue {
-	struct dispatch_data_s *dd = (void*)self;
-	return _dispatch_data_set_target_queue(dd, queue);
-}
-
-- (NSString *)debugDescription {
-	Class nsstring = objc_lookUpClass("NSString");
-	if (!nsstring) return nil;
-	char buf[2048];
-	_dispatch_data_debug(self, buf, sizeof(buf));
-	NSString *format = [nsstring stringWithUTF8String:"<%s: %s>"];
-	if (!format) return nil;
-	return [nsstring stringWithFormat:format, object_getClassName(self), buf];
-}
-
-- (NSUInteger)length {
-	struct dispatch_data_s *dd = (void*)self;
-	return dd->size;
-}
-
-- (const void *)bytes {
-	return dispatch_data_get_flattened_bytes_4libxpc(self);
-}
-
-- (BOOL)_isCompact {
-	struct dispatch_data_s *dd = (void*)self;
-	return !dd->size || _dispatch_data_map_direct(dd, 0, NULL, NULL) != NULL;
-}
-
-- (void)_suspend {
-}
-
-- (void)_resume {
-}
-
-- (void)_activate {
-}
-
-@end
-
-@implementation DISPATCH_CLASS(data_empty)
-
-// Force non-lazy class realization rdar://10640168
-+ (void)load {
-}
-
-- (id)retain {
-	return (id)self;
-}
-
-- (oneway void)release {
-}
-
-- (id)autorelease {
-	return (id)self;
-}
-
-- (NSUInteger)retainCount {
-	return ULONG_MAX;
-}
-
-+ (id)allocWithZone:(NSZone *) DISPATCH_UNUSED zone {
-	return (id)&_dispatch_data_empty;
-}
-
-- (void)_setContext:(void*) DISPATCH_UNUSED context {
-}
-
-- (void*)_getContext {
-	return NULL;
-}
-
-- (void)_setFinalizer:(dispatch_function_t) DISPATCH_UNUSED finalizer {
-}
-
-- (void)_setTargetQueue:(dispatch_queue_t) DISPATCH_UNUSED queue {
-}
-
-- (void)_suspend {
-}
-
-- (void)_resume {
-}
-
-- (void)_activate {
-}
-
-@end
-
-#endif // USE_OBJC
--- a/Telegram/ThirdParty/dispatch/src/event/event.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/event/event.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,1246 +0,0 @@
-/*
- * Copyright (c) 2008-2016 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include "internal.h"
-
-#pragma mark unote generic functions
-
-static void _dispatch_timer_unote_register(dispatch_timer_source_refs_t dt,
-		dispatch_wlh_t wlh, dispatch_priority_t pri);
-static void _dispatch_timer_unote_resume(dispatch_timer_source_refs_t dt);
-static void _dispatch_timer_unote_unregister(dispatch_timer_source_refs_t dt);
-
-DISPATCH_NOINLINE
-static dispatch_unote_t
-_dispatch_unote_create(dispatch_source_type_t dst,
-		uintptr_t handle, uintptr_t mask)
-{
-	dispatch_unote_linkage_t dul;
-	dispatch_unote_class_t du;
-
-	if (mask & ~dst->dst_mask) {
-		return DISPATCH_UNOTE_NULL;
-	}
-
-	if (dst->dst_mask && !mask) {
-		return DISPATCH_UNOTE_NULL;
-	}
-
-	if (dst->dst_flags & EV_UDATA_SPECIFIC) {
-		du = _dispatch_calloc(1u, dst->dst_size);
-	} else {
-		dul = _dispatch_calloc(1u, sizeof(*dul) + dst->dst_size);
-		du = _dispatch_unote_linkage_get_unote(dul)._du;
-	}
-	du->du_type = dst;
-	du->du_can_be_wlh = dst->dst_per_trigger_qos;
-	du->du_ident = (dispatch_unote_ident_t)handle;
-	du->du_filter = dst->dst_filter;
-	du->du_fflags = (__typeof__(du->du_fflags))mask;
-	if (dst->dst_flags & EV_UDATA_SPECIFIC) {
-		du->du_is_direct = true;
-	}
-	return (dispatch_unote_t){ ._du = du };
-}
-
-DISPATCH_NOINLINE
-dispatch_unote_t
-_dispatch_unote_create_with_handle(dispatch_source_type_t dst,
-		uintptr_t handle, uintptr_t mask)
-{
-	if (!handle) {
-		return DISPATCH_UNOTE_NULL;
-	}
-	return _dispatch_unote_create(dst, handle, mask);
-}
-
-DISPATCH_NOINLINE
-dispatch_unote_t
-_dispatch_unote_create_with_fd(dispatch_source_type_t dst,
-		uintptr_t handle, uintptr_t mask)
-{
-#if !TARGET_OS_MAC // <rdar://problem/27756657>
-	if (handle > INT_MAX) {
-		return DISPATCH_UNOTE_NULL;
-	}
-#endif
-	return _dispatch_unote_create(dst, handle, mask);
-}
-
-DISPATCH_NOINLINE
-dispatch_unote_t
-_dispatch_unote_create_without_handle(dispatch_source_type_t dst,
-		uintptr_t handle, uintptr_t mask)
-{
-	if (handle) {
-		return DISPATCH_UNOTE_NULL;
-	}
-	return _dispatch_unote_create(dst, handle, mask);
-}
-
-DISPATCH_NOINLINE
-void
-_dispatch_unote_dispose(dispatch_unote_t du)
-{
-	void *ptr = du._du;
-#if HAVE_MACH
-	if (du._du->dmrr_handler_is_block) {
-		Block_release(du._dmrr->dmrr_handler_ctxt);
-	}
-#endif
-	if (du._du->du_is_timer) {
-		if (unlikely(du._dt->dt_heap_entry[DTH_TARGET_ID] != DTH_INVALID_ID ||
-				du._dt->dt_heap_entry[DTH_DEADLINE_ID] != DTH_INVALID_ID)) {
-			DISPATCH_INTERNAL_CRASH(0, "Disposing of timer still in its heap");
-		}
-		if (unlikely(du._dt->dt_pending_config)) {
-			free(du._dt->dt_pending_config);
-			du._dt->dt_pending_config = NULL;
-		}
-	} else if (!du._du->du_is_direct) {
-		ptr = _dispatch_unote_get_linkage(du);
-	}
-	free(ptr);
-}
-
-bool
-_dispatch_unote_register(dispatch_unote_t du, dispatch_wlh_t wlh,
-		dispatch_priority_t pri)
-{
-	dispatch_assert(du._du->du_is_timer || !_dispatch_unote_registered(du));
-	dispatch_priority_t masked_pri;
-
-	masked_pri = pri & (DISPATCH_PRIORITY_FLAG_MANAGER |
-			DISPATCH_PRIORITY_FLAG_FALLBACK |
-			DISPATCH_PRIORITY_FLAG_FLOOR |
-			DISPATCH_PRIORITY_FALLBACK_QOS_MASK |
-			DISPATCH_PRIORITY_REQUESTED_MASK);
-
-	dispatch_assert(wlh == DISPATCH_WLH_ANON || masked_pri);
-	if (masked_pri == _dispatch_priority_make_fallback(DISPATCH_QOS_DEFAULT)) {
-		_dispatch_ktrace1(DISPATCH_PERF_source_registration_without_qos,
-				_dispatch_wref2ptr(du._du->du_owner_wref));
-	}
-
-	du._du->du_priority = pri;
-
-	switch (du._du->du_filter) {
-	case DISPATCH_EVFILT_CUSTOM_ADD:
-	case DISPATCH_EVFILT_CUSTOM_OR:
-	case DISPATCH_EVFILT_CUSTOM_REPLACE:
-		_dispatch_unote_state_set(du, DISPATCH_WLH_ANON, DU_STATE_ARMED);
-		return true;
-	}
-	if (du._du->du_is_timer) {
-		_dispatch_timer_unote_register(du._dt, wlh, pri);
-		return true;
-	}
-#if DISPATCH_HAVE_DIRECT_KNOTES
-	if (du._du->du_is_direct) {
-		return _dispatch_unote_register_direct(du, wlh);
-	}
-#endif
-	return _dispatch_unote_register_muxed(du);
-}
-
-void
-_dispatch_unote_resume(dispatch_unote_t du)
-{
-	dispatch_assert(du._du->du_is_timer || _dispatch_unote_needs_rearm(du));
-	if (du._du->du_is_timer) {
-		_dispatch_timer_unote_resume(du._dt);
-#if DISPATCH_HAVE_DIRECT_KNOTES
-	} else if (du._du->du_is_direct) {
-		_dispatch_unote_resume_direct(du);
-#endif
-	} else {
-		_dispatch_unote_resume_muxed(du);
-	}
-}
-
-bool
-_dispatch_unote_unregister(dispatch_unote_t du, uint32_t flags)
-{
-	if (!_dispatch_unote_registered(du)) {
-		return true;
-	}
-	switch (du._du->du_filter) {
-	case DISPATCH_EVFILT_CUSTOM_ADD:
-	case DISPATCH_EVFILT_CUSTOM_OR:
-	case DISPATCH_EVFILT_CUSTOM_REPLACE:
-		_dispatch_unote_state_set(du, DU_STATE_UNREGISTERED);
-		return true;
-	}
-	if (du._du->du_is_timer) {
-		_dispatch_timer_unote_unregister(du._dt);
-		return true;
-	}
-#if DISPATCH_HAVE_DIRECT_KNOTES
-	if (du._du->du_is_direct) {
-		return _dispatch_unote_unregister_direct(du, flags);
-	}
-#endif
-
-	dispatch_assert(flags & DUU_DELETE_ACK);
-	return _dispatch_unote_unregister_muxed(du);
-}
-
-#pragma mark data or / add
-
-static dispatch_unote_t
-_dispatch_source_data_create(dispatch_source_type_t dst, uintptr_t handle,
-		uintptr_t mask)
-{
-	if (handle || mask) {
-		return DISPATCH_UNOTE_NULL;
-	}
-
-	// bypass _dispatch_unote_create() because this is always "direct"
-	// even when EV_UDATA_SPECIFIC is 0
-	dispatch_unote_class_t du = _dispatch_calloc(1u, dst->dst_size);
-	du->du_type = dst;
-	du->du_filter = dst->dst_filter;
-	du->du_is_direct = true;
-	return (dispatch_unote_t){ ._du = du };
-}
-
-const dispatch_source_type_s _dispatch_source_type_data_add = {
-	.dst_kind       = "data-add",
-	.dst_filter     = DISPATCH_EVFILT_CUSTOM_ADD,
-	.dst_flags      = EV_UDATA_SPECIFIC|EV_CLEAR,
-	.dst_action     = DISPATCH_UNOTE_ACTION_PASS_DATA,
-	.dst_size       = sizeof(struct dispatch_source_refs_s),
-	.dst_strict     = false,
-
-	.dst_create     = _dispatch_source_data_create,
-	.dst_merge_evt  = NULL,
-};
-
-const dispatch_source_type_s _dispatch_source_type_data_or = {
-	.dst_kind       = "data-or",
-	.dst_filter     = DISPATCH_EVFILT_CUSTOM_OR,
-	.dst_flags      = EV_UDATA_SPECIFIC|EV_CLEAR,
-	.dst_action     = DISPATCH_UNOTE_ACTION_PASS_DATA,
-	.dst_size       = sizeof(struct dispatch_source_refs_s),
-	.dst_strict     = false,
-
-	.dst_create     = _dispatch_source_data_create,
-	.dst_merge_evt  = NULL,
-};
-
-const dispatch_source_type_s _dispatch_source_type_data_replace = {
-	.dst_kind       = "data-replace",
-	.dst_filter     = DISPATCH_EVFILT_CUSTOM_REPLACE,
-	.dst_flags      = EV_UDATA_SPECIFIC|EV_CLEAR,
-	.dst_action     = DISPATCH_UNOTE_ACTION_PASS_DATA,
-	.dst_size       = sizeof(struct dispatch_source_refs_s),
-	.dst_strict     = false,
-
-	.dst_create     = _dispatch_source_data_create,
-	.dst_merge_evt  = NULL,
-};
-
-#pragma mark file descriptors
-
-const dispatch_source_type_s _dispatch_source_type_read = {
-	.dst_kind       = "read",
-	.dst_filter     = EVFILT_READ,
-	.dst_flags      = EV_UDATA_SPECIFIC|EV_DISPATCH|EV_VANISHED,
-#if DISPATCH_EVENT_BACKEND_KEVENT
-#if HAVE_DECL_NOTE_LOWAT
-	.dst_fflags     = NOTE_LOWAT,
-#endif
-	.dst_data       = 1,
-#endif // DISPATCH_EVENT_BACKEND_KEVENT
-	.dst_action     = DISPATCH_UNOTE_ACTION_SOURCE_SET_DATA,
-	.dst_size       = sizeof(struct dispatch_source_refs_s),
-	.dst_strict     = false,
-
-	.dst_create     = _dispatch_unote_create_with_fd,
-	.dst_merge_evt  = _dispatch_source_merge_evt,
-};
-
-const dispatch_source_type_s _dispatch_source_type_write = {
-	.dst_kind       = "write",
-	.dst_filter     = EVFILT_WRITE,
-	.dst_flags      = EV_UDATA_SPECIFIC|EV_DISPATCH|EV_VANISHED,
-#if DISPATCH_EVENT_BACKEND_KEVENT
-#if HAVE_DECL_NOTE_LOWAT
-	.dst_fflags     = NOTE_LOWAT,
-#endif
-	.dst_data       = 1,
-#endif // DISPATCH_EVENT_BACKEND_KEVENT
-	.dst_action     = DISPATCH_UNOTE_ACTION_SOURCE_SET_DATA,
-	.dst_size       = sizeof(struct dispatch_source_refs_s),
-	.dst_strict     = false,
-
-	.dst_create     = _dispatch_unote_create_with_fd,
-	.dst_merge_evt  = _dispatch_source_merge_evt,
-};
-
-#pragma mark signals
-
-static dispatch_unote_t
-_dispatch_source_signal_create(dispatch_source_type_t dst, uintptr_t handle,
-		uintptr_t mask)
-{
-	if (handle >= NSIG) {
-		return DISPATCH_UNOTE_NULL;
-	}
-	return _dispatch_unote_create_with_handle(dst, handle, mask);
-}
-
-const dispatch_source_type_s _dispatch_source_type_signal = {
-	.dst_kind       = "signal",
-	.dst_filter     = EVFILT_SIGNAL,
-	.dst_flags      = DISPATCH_EV_DIRECT|EV_CLEAR,
-	.dst_action     = DISPATCH_UNOTE_ACTION_SOURCE_ADD_DATA,
-	.dst_size       = sizeof(struct dispatch_source_refs_s),
-	.dst_strict     = false,
-
-	.dst_create     = _dispatch_source_signal_create,
-	.dst_merge_evt  = _dispatch_source_merge_evt,
-};
-
-#pragma mark -
-#pragma mark timer globals
-
-DISPATCH_GLOBAL(struct dispatch_timer_heap_s
-_dispatch_timers_heap[DISPATCH_TIMER_COUNT]);
-
-#if DISPATCH_USE_DTRACE
-DISPATCH_STATIC_GLOBAL(dispatch_timer_source_refs_t
-_dispatch_trace_next_timer[DISPATCH_TIMER_QOS_COUNT]);
-#define _dispatch_trace_next_timer_set(x, q) \
-		_dispatch_trace_next_timer[(q)] = (x)
-#define _dispatch_trace_next_timer_program(d, q) \
-		_dispatch_trace_timer_program(_dispatch_trace_next_timer[(q)], (d))
-#else
-#define _dispatch_trace_next_timer_set(x, q)
-#define _dispatch_trace_next_timer_program(d, q)
-#endif
-
-#pragma mark timer heap
-/*
- * The dispatch_timer_heap_t structure is a double min-heap of timers,
- * interleaving the by-target min-heap in the even slots, and the by-deadline
- * in the odd ones.
- *
- * The min element of these is held inline in the dispatch_timer_heap_t
- * structure, and further entries are held in segments.
- *
- * dth_segments is the number of allocated segments.
- *
- * Segment 0 has a size of `DISPATCH_HEAP_INIT_SEGMENT_CAPACITY` pointers
- * Segment k has a size of (DISPATCH_HEAP_INIT_SEGMENT_CAPACITY << (k - 1))
- *
- * Segment n (dth_segments - 1) is the last segment and points its final n
- * entries to previous segments. Its address is held in the `dth_heap` field.
- *
- * segment n   [ regular timer pointers | n-1 | k | 0 ]
- *                                         |    |   |
- * segment n-1 <---------------------------'    |   |
- * segment k   <--------------------------------'   |
- * segment 0   <------------------------------------'
- */
-#define DISPATCH_HEAP_INIT_SEGMENT_CAPACITY 8u
-
-/*
- * There are two min-heaps stored interleaved in a single array,
- * even indices are for the by-target min-heap, and odd indices for
- * the by-deadline one.
- */
-#define DTH_HEAP_ID_MASK (DTH_ID_COUNT - 1)
-#define DTH_HEAP_ID(idx) ((idx) & DTH_HEAP_ID_MASK)
-#define DTH_IDX_FOR_HEAP_ID(idx, heap_id) \
-		(((idx) & ~DTH_HEAP_ID_MASK) | (heap_id))
-
-DISPATCH_ALWAYS_INLINE
-static inline uint32_t
-_dispatch_timer_heap_capacity(uint32_t segments)
-{
-	if (segments == 0) return 2;
-	uint32_t seg_no = segments - 1;
-	// for C = DISPATCH_HEAP_INIT_SEGMENT_CAPACITY,
-	// 2 + C + SUM(C << (i-1), i = 1..seg_no) - seg_no
-	return 2 + (DISPATCH_HEAP_INIT_SEGMENT_CAPACITY << seg_no) - seg_no;
-}
-
-static void
-_dispatch_timer_heap_grow(dispatch_timer_heap_t dth)
-{
-	uint32_t seg_capacity = DISPATCH_HEAP_INIT_SEGMENT_CAPACITY;
-	uint32_t seg_no = dth->dth_segments++;
-	void **heap, **heap_prev = dth->dth_heap;
-
-	if (seg_no > 0) {
-		seg_capacity <<= (seg_no - 1);
-	}
-	heap = _dispatch_calloc(seg_capacity, sizeof(void *));
-	if (seg_no > 1) {
-		uint32_t prev_seg_no = seg_no - 1;
-		uint32_t prev_seg_capacity = seg_capacity >> 1;
-		memcpy(&heap[seg_capacity - prev_seg_no],
-				&heap_prev[prev_seg_capacity - prev_seg_no],
-				prev_seg_no * sizeof(void *));
-	}
-	if (seg_no > 0) {
-		heap[seg_capacity - seg_no] = heap_prev;
-	}
-	dth->dth_heap = heap;
-}
-
-static void
-_dispatch_timer_heap_shrink(dispatch_timer_heap_t dth)
-{
-	uint32_t seg_capacity = DISPATCH_HEAP_INIT_SEGMENT_CAPACITY;
-	uint32_t seg_no = --dth->dth_segments;
-	void **heap = dth->dth_heap, **heap_prev = NULL;
-
-	if (seg_no > 0) {
-		seg_capacity <<= (seg_no - 1);
-		heap_prev = heap[seg_capacity - seg_no];
-	}
-	if (seg_no > 1) {
-		uint32_t prev_seg_no = seg_no - 1;
-		uint32_t prev_seg_capacity = seg_capacity >> 1;
-		memcpy(&heap_prev[prev_seg_capacity - prev_seg_no],
-				&heap[seg_capacity - prev_seg_no],
-				prev_seg_no * sizeof(void *));
-	}
-	dth->dth_heap = heap_prev;
-	free(heap);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_timer_source_refs_t *
-_dispatch_timer_heap_get_slot(dispatch_timer_heap_t dth, uint32_t idx)
-{
-	uint32_t seg_no, segments = dth->dth_segments;
-	void **segment;
-
-	if (idx < DTH_ID_COUNT) {
-		return &dth->dth_min[idx];
-	}
-	idx -= DTH_ID_COUNT;
-
-	// Derive the segment number from the index. Naming
-	// DISPATCH_HEAP_INIT_SEGMENT_CAPACITY `C`, the segments index ranges are:
-	// 0: 0 .. (C - 1)
-	// 1: C .. 2 * C - 1
-	// k: 2^(k-1) * C .. 2^k * C - 1
-	// so `k` can be derived from the first bit set in `idx`
-	seg_no = (uint32_t)(__builtin_clz(DISPATCH_HEAP_INIT_SEGMENT_CAPACITY - 1) -
-			__builtin_clz(idx | (DISPATCH_HEAP_INIT_SEGMENT_CAPACITY - 1)));
-	if (seg_no + 1 == segments) {
-		segment = dth->dth_heap;
-	} else {
-		uint32_t seg_capacity = DISPATCH_HEAP_INIT_SEGMENT_CAPACITY;
-		seg_capacity <<= (segments - 2);
-		segment = dth->dth_heap[seg_capacity - seg_no - 1];
-	}
-	if (seg_no) {
-		idx -= DISPATCH_HEAP_INIT_SEGMENT_CAPACITY << (seg_no - 1);
-	}
-	return (dispatch_timer_source_refs_t *)(segment + idx);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_timer_heap_set(dispatch_timer_heap_t dth,
-		dispatch_timer_source_refs_t *slot,
-		dispatch_timer_source_refs_t dt, uint32_t idx)
-{
-	if (idx < DTH_ID_COUNT) {
-		dth->dth_needs_program = true;
-	}
-	*slot = dt;
-	dt->dt_heap_entry[DTH_HEAP_ID(idx)] = idx;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline uint32_t
-_dispatch_timer_heap_parent(uint32_t idx)
-{
-	uint32_t heap_id = DTH_HEAP_ID(idx);
-	idx = (idx - DTH_ID_COUNT) / 2; // go to the parent
-	return DTH_IDX_FOR_HEAP_ID(idx, heap_id);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline uint32_t
-_dispatch_timer_heap_left_child(uint32_t idx)
-{
-	uint32_t heap_id = DTH_HEAP_ID(idx);
-	// 2 * (idx - heap_id) + DTH_ID_COUNT + heap_id
-	return 2 * idx + DTH_ID_COUNT - heap_id;
-}
-
-#if DISPATCH_HAVE_TIMER_COALESCING
-DISPATCH_ALWAYS_INLINE
-static inline uint32_t
-_dispatch_timer_heap_walk_skip(uint32_t idx, uint32_t count)
-{
-	uint32_t heap_id = DTH_HEAP_ID(idx);
-
-	idx -= heap_id;
-	if (unlikely(idx + DTH_ID_COUNT == count)) {
-		// reaching `count` doesn't mean we're done, but there is a weird
-		// corner case if the last item of the heap is a left child:
-		//
-		//     /\
-		//    /  \
-		//   /  __\
-		//  /__/
-		//     ^
-		//
-		// The formula below would return the sibling of `idx` which is
-		// out of bounds. Fortunately, the correct answer is the same
-		// as for idx's parent
-		idx = _dispatch_timer_heap_parent(idx);
-	}
-
-	//
-	// When considering the index in a non interleaved, 1-based array
-	// representation of a heap, hence looking at (idx / DTH_ID_COUNT + 1)
-	// for a given idx in our dual-heaps, that index is in one of two forms:
-	//
-	//     (a) 1xxxx011111    or    (b) 111111111
-	//         d    i    0              d       0
-	//
-	// The first bit set is the row of the binary tree node (0-based).
-	// The following digits from most to least significant represent the path
-	// to that node, where `0` is a left turn and `1` a right turn.
-	//
-	// For example 0b0101 (5) is a node on row 2 accessed going left then right:
-	//
-	// row 0          1
-	//              /   .
-	// row 1      2       3
-	//           . \     . .
-	// row 2    4   5   6   7
-	//         : : : : : : : :
-	//
-	// Skipping a sub-tree in walk order means going to the sibling of the last
-	// node reached after we turned left. If the node was of the form (a),
-	// this node is 1xxxx1, which for the above example is 0b0011 (3).
-	// If the node was of the form (b) then we never took a left, meaning
-	// we reached the last element in traversal order.
-	//
-
-	//
-	// we want to find
-	// - the least significant bit set to 0 in (idx / DTH_ID_COUNT + 1)
-	// - which is offset by log_2(DTH_ID_COUNT) from the position of the least
-	//   significant 0 in (idx + DTH_ID_COUNT + DTH_ID_COUNT - 1)
-	//   since idx is a multiple of DTH_ID_COUNT and DTH_ID_COUNT a power of 2.
-	// - which in turn is the same as the position of the least significant 1 in
-	//   ~(idx + DTH_ID_COUNT + DTH_ID_COUNT - 1)
-	//
-	dispatch_static_assert(powerof2(DTH_ID_COUNT));
-	idx += DTH_ID_COUNT + DTH_ID_COUNT - 1;
-	idx >>= __builtin_ctz(~idx);
-
-	//
-	// `idx` is now either:
-	// - 0 if it was the (b) case above, in which case the walk is done
-	// - 1xxxx0 as the position in a 0 based array representation of a non
-	//   interleaved heap, so we just have to compute the interleaved index.
-	//
-	return likely(idx) ? DTH_ID_COUNT * idx + heap_id : UINT32_MAX;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline uint32_t
-_dispatch_timer_heap_walk_next(uint32_t idx, uint32_t count)
-{
-	//
-	// Goes to the next element in heap walk order, which is the prefix ordered
-	// walk of the tree.
-	//
-	// From a given node, the next item to return is the left child if it
-	// exists, else the first right sibling we find by walking our parent chain,
-	// which is exactly what _dispatch_timer_heap_walk_skip() returns.
-	//
-	uint32_t lchild = _dispatch_timer_heap_left_child(idx);
-	if (lchild < count) {
-		return lchild;
-	}
-	return _dispatch_timer_heap_walk_skip(idx, count);
-}
-
-static uint64_t
-_dispatch_timer_heap_max_target_before(dispatch_timer_heap_t dth, uint64_t limit)
-{
-	dispatch_timer_source_refs_t dri;
-	uint32_t idx = _dispatch_timer_heap_left_child(DTH_TARGET_ID);
-	uint32_t count = dth->dth_count;
-	uint64_t tmp, target = dth->dth_min[DTH_TARGET_ID]->dt_timer.target;
-
-	while (idx < count) {
-		dri = *_dispatch_timer_heap_get_slot(dth, idx);
-		tmp = dri->dt_timer.target;
-		if (tmp > limit) {
-			// skip subtree since none of the targets below can be before limit
-			idx = _dispatch_timer_heap_walk_skip(idx, count);
-		} else {
-			target = tmp;
-			idx = _dispatch_timer_heap_walk_next(idx, count);
-		}
-	}
-	return target;
-}
-#endif // DISPATCH_HAVE_TIMER_COALESCING
-
-static void
-_dispatch_timer_heap_resift(dispatch_timer_heap_t dth,
-		dispatch_timer_source_refs_t dt, uint32_t idx)
-{
-	dispatch_static_assert(offsetof(struct dispatch_timer_source_s, target) ==
-			offsetof(struct dispatch_timer_source_s, heap_key[DTH_TARGET_ID]));
-	dispatch_static_assert(offsetof(struct dispatch_timer_source_s, deadline) ==
-			offsetof(struct dispatch_timer_source_s, heap_key[DTH_DEADLINE_ID]));
-#define dth_cmp(hid, dt1, op, dt2) \
-		(((dt1)->dt_timer.heap_key)[hid] op ((dt2)->dt_timer.heap_key)[hid])
-
-	dispatch_timer_source_refs_t *pslot, pdt;
-	dispatch_timer_source_refs_t *cslot, cdt;
-	dispatch_timer_source_refs_t *rslot, rdt;
-	uint32_t cidx, dth_count = dth->dth_count;
-	dispatch_timer_source_refs_t *slot;
-	int heap_id = DTH_HEAP_ID(idx);
-	bool sifted_up = false;
-
-	// try to sift up
-
-	slot = _dispatch_timer_heap_get_slot(dth, idx);
-	while (idx >= DTH_ID_COUNT) {
-		uint32_t pidx = _dispatch_timer_heap_parent(idx);
-		pslot = _dispatch_timer_heap_get_slot(dth, pidx);
-		pdt = *pslot;
-		if (dth_cmp(heap_id, pdt, <=, dt)) {
-			break;
-		}
-		_dispatch_timer_heap_set(dth, slot, pdt, idx);
-		slot = pslot;
-		idx = pidx;
-		sifted_up = true;
-	}
-	if (sifted_up) {
-		goto done;
-	}
-
-	// try to sift down
-
-	while ((cidx = _dispatch_timer_heap_left_child(idx)) < dth_count) {
-		uint32_t ridx = cidx + DTH_ID_COUNT;
-		cslot = _dispatch_timer_heap_get_slot(dth, cidx);
-		cdt = *cslot;
-		if (ridx < dth_count) {
-			rslot = _dispatch_timer_heap_get_slot(dth, ridx);
-			rdt = *rslot;
-			if (dth_cmp(heap_id, cdt, >, rdt)) {
-				cidx = ridx;
-				cdt = rdt;
-				cslot = rslot;
-			}
-		}
-		if (dth_cmp(heap_id, dt, <=, cdt)) {
-			break;
-		}
-		_dispatch_timer_heap_set(dth, slot, cdt, idx);
-		slot = cslot;
-		idx = cidx;
-	}
-
-done:
-	_dispatch_timer_heap_set(dth, slot, dt, idx);
-#undef dth_cmp
-}
-
-DISPATCH_ALWAYS_INLINE
-static void
-_dispatch_timer_heap_insert(dispatch_timer_heap_t dth,
-		dispatch_timer_source_refs_t dt)
-{
-	uint32_t idx = (dth->dth_count += DTH_ID_COUNT) - DTH_ID_COUNT;
-
-	DISPATCH_TIMER_ASSERT(dt->dt_heap_entry[DTH_TARGET_ID], ==,
-			DTH_INVALID_ID, "target idx");
-	DISPATCH_TIMER_ASSERT(dt->dt_heap_entry[DTH_DEADLINE_ID], ==,
-			DTH_INVALID_ID, "deadline idx");
-
-	dispatch_qos_t qos = MAX(_dispatch_priority_qos(dt->du_priority),
-			_dispatch_priority_fallback_qos(dt->du_priority));
-	if (dth->dth_max_qos < qos) {
-		dth->dth_max_qos = (uint8_t)qos;
-		dth->dth_needs_program = true;
-	}
-
-	if (idx == 0) {
-		dth->dth_needs_program = true;
-		dt->dt_heap_entry[DTH_TARGET_ID] = DTH_TARGET_ID;
-		dt->dt_heap_entry[DTH_DEADLINE_ID] = DTH_DEADLINE_ID;
-		dth->dth_min[DTH_TARGET_ID] = dth->dth_min[DTH_DEADLINE_ID] = dt;
-		return;
-	}
-
-	if (unlikely(idx + DTH_ID_COUNT >
-			_dispatch_timer_heap_capacity(dth->dth_segments))) {
-		_dispatch_timer_heap_grow(dth);
-	}
-	_dispatch_timer_heap_resift(dth, dt, idx + DTH_TARGET_ID);
-	_dispatch_timer_heap_resift(dth, dt, idx + DTH_DEADLINE_ID);
-}
-
-static void
-_dispatch_timer_heap_remove(dispatch_timer_heap_t dth,
-		dispatch_timer_source_refs_t dt)
-{
-	uint32_t idx = (dth->dth_count -= DTH_ID_COUNT);
-
-	DISPATCH_TIMER_ASSERT(dt->dt_heap_entry[DTH_TARGET_ID], !=,
-			DTH_INVALID_ID, "target idx");
-	DISPATCH_TIMER_ASSERT(dt->dt_heap_entry[DTH_DEADLINE_ID], !=,
-			DTH_INVALID_ID, "deadline idx");
-
-	if (idx == 0) {
-		DISPATCH_TIMER_ASSERT(dth->dth_min[DTH_TARGET_ID], ==, dt,
-				"target slot");
-		DISPATCH_TIMER_ASSERT(dth->dth_min[DTH_DEADLINE_ID], ==, dt,
-				"deadline slot");
-		dth->dth_needs_program = true;
-		dth->dth_min[DTH_TARGET_ID] = dth->dth_min[DTH_DEADLINE_ID] = NULL;
-		goto clear_heap_entry;
-	}
-
-	for (uint32_t heap_id = 0; heap_id < DTH_ID_COUNT; heap_id++) {
-		dispatch_timer_source_refs_t *slot, last_dt;
-		slot = _dispatch_timer_heap_get_slot(dth, idx + heap_id);
-		last_dt = *slot; *slot = NULL;
-		if (last_dt != dt) {
-			uint32_t removed_idx = dt->dt_heap_entry[heap_id];
-			_dispatch_timer_heap_resift(dth, last_dt, removed_idx);
-		}
-	}
-	if (unlikely(idx <= _dispatch_timer_heap_capacity(dth->dth_segments - 1))) {
-		_dispatch_timer_heap_shrink(dth);
-	}
-
-clear_heap_entry:
-	dt->dt_heap_entry[DTH_TARGET_ID] = DTH_INVALID_ID;
-	dt->dt_heap_entry[DTH_DEADLINE_ID] = DTH_INVALID_ID;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_timer_heap_update(dispatch_timer_heap_t dth,
-		dispatch_timer_source_refs_t dt)
-{
-	DISPATCH_TIMER_ASSERT(dt->dt_heap_entry[DTH_TARGET_ID], !=,
-			DTH_INVALID_ID, "target idx");
-	DISPATCH_TIMER_ASSERT(dt->dt_heap_entry[DTH_DEADLINE_ID], !=,
-			DTH_INVALID_ID, "deadline idx");
-
-	_dispatch_timer_heap_resift(dth, dt, dt->dt_heap_entry[DTH_TARGET_ID]);
-	_dispatch_timer_heap_resift(dth, dt, dt->dt_heap_entry[DTH_DEADLINE_ID]);
-}
-
-#pragma mark timer unote
-
-#define _dispatch_timer_du_debug(what, du) \
-		_dispatch_debug("kevent-source[%p]: %s kevent[%p] { ident = 0x%x }", \
-				_dispatch_wref2ptr((du)->du_owner_wref), what, \
-				(du), (du)->du_ident)
-
-DISPATCH_ALWAYS_INLINE
-static inline unsigned int
-_dispatch_timer_unote_idx(dispatch_timer_source_refs_t dt)
-{
-	dispatch_clock_t clock = _dispatch_timer_flags_to_clock(dt->du_timer_flags);
-	uint32_t qos = 0;
-
-#if DISPATCH_HAVE_TIMER_QOS
-	dispatch_assert(DISPATCH_TIMER_STRICT == DISPATCH_TIMER_QOS_CRITICAL);
-	dispatch_assert(DISPATCH_TIMER_BACKGROUND == DISPATCH_TIMER_QOS_BACKGROUND);
-	qos = dt->du_timer_flags & (DISPATCH_TIMER_STRICT|DISPATCH_TIMER_BACKGROUND);
-	// flags are normalized so this should never happen
-	dispatch_assert(qos < DISPATCH_TIMER_QOS_COUNT);
-#endif
-
-	return DISPATCH_TIMER_INDEX(clock, qos);
-}
-
-static void
-_dispatch_timer_unote_disarm(dispatch_timer_source_refs_t dt,
-		dispatch_timer_heap_t dth)
-{
-	uint32_t tidx = dt->du_ident;
-
-	dispatch_assert(_dispatch_unote_armed(dt));
-	_dispatch_timer_heap_remove(&dth[tidx], dt);
-	_dispatch_timers_heap_dirty(dth, tidx);
-	_dispatch_unote_state_clear_bit(dt, DU_STATE_ARMED);
-	_dispatch_timer_du_debug("disarmed", dt);
-}
-
-static void
-_dispatch_timer_unote_arm(dispatch_timer_source_refs_t dt,
-		dispatch_timer_heap_t dth, uint32_t tidx)
-{
-	if (_dispatch_unote_armed(dt)) {
-		DISPATCH_TIMER_ASSERT(dt->du_ident, ==, tidx, "tidx");
-		_dispatch_timer_heap_update(&dth[tidx], dt);
-		_dispatch_timer_du_debug("updated", dt);
-	} else {
-		dt->du_ident = tidx;
-		_dispatch_timer_heap_insert(&dth[tidx], dt);
-		_dispatch_unote_state_set_bit(dt, DU_STATE_ARMED);
-		_dispatch_timer_du_debug("armed", dt);
-	}
-	_dispatch_timers_heap_dirty(dth, tidx);
-}
-
-#define DISPATCH_TIMER_UNOTE_TRACE_SUSPENSION 0x1
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dispatch_timer_unote_needs_rearm(dispatch_timer_source_refs_t dr, int flags)
-{
-	dispatch_source_t ds = _dispatch_source_from_refs(dr);
-	if (unlikely(DISPATCH_QUEUE_IS_SUSPENDED(ds))) {
-		if (flags & DISPATCH_TIMER_UNOTE_TRACE_SUSPENSION) {
-			_dispatch_ktrace1(DISPATCH_PERF_suspended_timer_fire, ds);
-		}
-		return false;
-	}
-	return dr->du_ident != DISPATCH_TIMER_IDENT_CANCELED &&
-			dr->dt_timer.target < INT64_MAX;
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_timer_unote_register(dispatch_timer_source_refs_t dt,
-		dispatch_wlh_t wlh, dispatch_priority_t pri)
-{
-	// aggressively coalesce background/maintenance QoS timers
-	// <rdar://problem/12200216&27342536>
-	if (_dispatch_qos_is_background(_dispatch_priority_qos(pri))) {
-		if (dt->du_timer_flags & DISPATCH_TIMER_STRICT) {
-			_dispatch_ktrace1(DISPATCH_PERF_strict_bg_timer,
-					_dispatch_source_from_refs(dt));
-		} else {
-			dt->du_timer_flags |= DISPATCH_TIMER_BACKGROUND;
-			dt->du_ident = _dispatch_timer_unote_idx(dt);
-		}
-	}
-	// _dispatch_source_activate() can pre-set a wlh for timers directly
-	// attached to their workloops.
-	if (_dispatch_unote_wlh(dt) != wlh) {
-		dispatch_assert(_dispatch_unote_wlh(dt) == NULL);
-		_dispatch_unote_state_set(dt, DISPATCH_WLH_ANON, 0);
-	}
-	if (os_atomic_load2o(dt, dt_pending_config, relaxed)) {
-		_dispatch_timer_unote_configure(dt);
-	}
-}
-
-void
-_dispatch_timer_unote_configure(dispatch_timer_source_refs_t dt)
-{
-	dispatch_timer_config_t dtc;
-
-	dtc = os_atomic_xchg2o(dt, dt_pending_config, NULL, dependency);
-	if (dtc->dtc_clock != _dispatch_timer_flags_to_clock(dt->du_timer_flags)) {
-		dt->du_timer_flags &= ~_DISPATCH_TIMER_CLOCK_MASK;
-		dt->du_timer_flags |= _dispatch_timer_flags_from_clock(dtc->dtc_clock);
-	}
-	dt->dt_timer = dtc->dtc_timer;
-	free(dtc);
-	// Clear any pending data that might have accumulated on
-	// older timer params <rdar://problem/8574886>
-	os_atomic_store2o(dt, ds_pending_data, 0, relaxed);
-
-	if (_dispatch_unote_armed(dt)) {
-		return _dispatch_timer_unote_resume(dt);
-	}
-}
-
-static inline dispatch_timer_heap_t
-_dispatch_timer_unote_heap(dispatch_timer_source_refs_t dt)
-{
-	dispatch_wlh_t wlh = _dispatch_unote_wlh(dt);
-	if (wlh == DISPATCH_WLH_ANON) {
-		return _dispatch_timers_heap;
-	}
-	return ((dispatch_workloop_t)wlh)->dwl_timer_heap;
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_timer_unote_resume(dispatch_timer_source_refs_t dt)
-{
-	// ... and now reflect any impact the reconfiguration has to the heap.
-	// The heap also owns a +2 on dispatch sources it references, so maintain
-	// this invariant as we tweak the registration.
-
-	bool will_arm = _dispatch_timer_unote_needs_rearm(dt, 0);
-	bool was_armed = _dispatch_unote_armed(dt);
-	uint32_t tidx = _dispatch_timer_unote_idx(dt);
-	dispatch_timer_heap_t dth = _dispatch_timer_unote_heap(dt);
-
-	if (unlikely(was_armed && (!will_arm || dt->du_ident != tidx))) {
-		_dispatch_timer_unote_disarm(dt, dth);
-	}
-	if (will_arm) {
-		if (!was_armed) _dispatch_retain_unote_owner(dt);
-		_dispatch_timer_unote_arm(dt, dth, tidx);
-	} else if (was_armed) {
-		_dispatch_release_unote_owner_tailcall(dt);
-	}
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_timer_unote_unregister(dispatch_timer_source_refs_t dt)
-{
-	dispatch_timer_heap_t dth = _dispatch_timer_unote_heap(dt);
-	if (_dispatch_unote_armed(dt)) {
-		_dispatch_timer_unote_disarm(dt, dth);
-		_dispatch_release_2_no_dispose(_dispatch_source_from_refs(dt));
-	}
-	_dispatch_wlh_release(_dispatch_unote_wlh(dt));
-	_dispatch_unote_state_set(dt, DU_STATE_UNREGISTERED);
-	dt->du_ident = DISPATCH_TIMER_IDENT_CANCELED;
-}
-
-static dispatch_unote_t
-_dispatch_source_timer_create(dispatch_source_type_t dst,
-		uintptr_t handle, uintptr_t mask)
-{
-	dispatch_timer_source_refs_t dt;
-
-	// normalize flags
-	if (mask & DISPATCH_TIMER_STRICT) {
-		mask &= ~(uintptr_t)DISPATCH_TIMER_BACKGROUND;
-	}
-	if (mask & ~dst->dst_mask) {
-		return DISPATCH_UNOTE_NULL;
-	}
-
-	if (dst->dst_timer_flags & DISPATCH_TIMER_INTERVAL) {
-		if (!handle) return DISPATCH_UNOTE_NULL;
-	} else if (dst->dst_filter == DISPATCH_EVFILT_TIMER_WITH_CLOCK) {
-		if (handle) return DISPATCH_UNOTE_NULL;
-	} else switch (handle) {
-	case 0:
-		break;
-	case DISPATCH_CLOCKID_UPTIME:
-		dst = &_dispatch_source_type_timer_with_clock;
-		mask |= DISPATCH_TIMER_CLOCK_UPTIME;
-		break;
-	case DISPATCH_CLOCKID_MONOTONIC:
-		dst = &_dispatch_source_type_timer_with_clock;
-		mask |= DISPATCH_TIMER_CLOCK_MONOTONIC;
-		break;
-	case DISPATCH_CLOCKID_WALLTIME:
-		dst = &_dispatch_source_type_timer_with_clock;
-		mask |= DISPATCH_TIMER_CLOCK_WALL;
-		break;
-	default:
-		return DISPATCH_UNOTE_NULL;
-	}
-
-	dt = _dispatch_calloc(1u, dst->dst_size);
-	dt->du_type = dst;
-	dt->du_filter = dst->dst_filter;
-	dt->du_is_timer = true;
-	dt->du_timer_flags |= (uint8_t)(mask | dst->dst_timer_flags);
-	dt->du_ident = _dispatch_timer_unote_idx(dt);
-	dt->dt_timer.target = UINT64_MAX;
-	dt->dt_timer.deadline = UINT64_MAX;
-	dt->dt_timer.interval = UINT64_MAX;
-	dt->dt_heap_entry[DTH_TARGET_ID] = DTH_INVALID_ID;
-	dt->dt_heap_entry[DTH_DEADLINE_ID] = DTH_INVALID_ID;
-	return (dispatch_unote_t){ ._dt = dt };
-}
-
-const dispatch_source_type_s _dispatch_source_type_timer = {
-	.dst_kind           = "timer",
-	.dst_filter         = DISPATCH_EVFILT_TIMER,
-	.dst_flags          = EV_DISPATCH,
-	.dst_mask           = DISPATCH_TIMER_STRICT|DISPATCH_TIMER_BACKGROUND,
-	.dst_timer_flags    = 0,
-	.dst_action         = DISPATCH_UNOTE_ACTION_SOURCE_TIMER,
-	.dst_size           = sizeof(struct dispatch_timer_source_refs_s),
-	.dst_strict         = false,
-
-	.dst_create         = _dispatch_source_timer_create,
-	.dst_merge_evt      = _dispatch_source_merge_evt,
-};
-
-const dispatch_source_type_s _dispatch_source_type_timer_with_clock = {
-	.dst_kind           = "timer (fixed-clock)",
-	.dst_filter         = DISPATCH_EVFILT_TIMER_WITH_CLOCK,
-	.dst_flags          = EV_DISPATCH,
-	.dst_mask           = DISPATCH_TIMER_STRICT|DISPATCH_TIMER_BACKGROUND,
-	.dst_timer_flags    = 0,
-	.dst_action         = DISPATCH_UNOTE_ACTION_SOURCE_TIMER,
-	.dst_size           = sizeof(struct dispatch_timer_source_refs_s),
-
-	.dst_create         = _dispatch_source_timer_create,
-	.dst_merge_evt      = _dispatch_source_merge_evt,
-};
-
-const dispatch_source_type_s _dispatch_source_type_after = {
-	.dst_kind           = "timer (after)",
-	.dst_filter         = DISPATCH_EVFILT_TIMER_WITH_CLOCK,
-	.dst_flags          = EV_DISPATCH,
-	.dst_mask           = 0,
-	.dst_timer_flags    = DISPATCH_TIMER_AFTER,
-	.dst_action         = DISPATCH_UNOTE_ACTION_SOURCE_TIMER,
-	.dst_size           = sizeof(struct dispatch_timer_source_refs_s),
-
-	.dst_create         = _dispatch_source_timer_create,
-	.dst_merge_evt      = _dispatch_source_merge_evt,
-};
-
-const dispatch_source_type_s _dispatch_source_type_interval = {
-	.dst_kind           = "timer (interval)",
-	.dst_filter         = DISPATCH_EVFILT_TIMER_WITH_CLOCK,
-	.dst_flags          = EV_DISPATCH,
-	.dst_mask           = DISPATCH_TIMER_STRICT|DISPATCH_TIMER_BACKGROUND|
-			DISPATCH_INTERVAL_UI_ANIMATION,
-	.dst_timer_flags    = DISPATCH_TIMER_INTERVAL|DISPATCH_TIMER_CLOCK_UPTIME,
-	.dst_action         = DISPATCH_UNOTE_ACTION_SOURCE_TIMER,
-	.dst_size           = sizeof(struct dispatch_timer_source_refs_s),
-
-	.dst_create         = _dispatch_source_timer_create,
-	.dst_merge_evt      = _dispatch_source_merge_evt,
-};
-
-#pragma mark timer draining
-
-static void
-_dispatch_timers_run(dispatch_timer_heap_t dth, uint32_t tidx,
-		dispatch_clock_now_cache_t nows)
-{
-	dispatch_timer_source_refs_t dr;
-	uint64_t pending, now;
-
-	while ((dr = dth[tidx].dth_min[DTH_TARGET_ID])) {
-		DISPATCH_TIMER_ASSERT(dr->du_ident, ==, tidx, "tidx");
-		DISPATCH_TIMER_ASSERT(dr->dt_timer.target, !=, 0, "missing target");
-
-		now = _dispatch_time_now_cached(DISPATCH_TIMER_CLOCK(tidx), nows);
-		if (dr->dt_timer.target > now) {
-			// Done running timers for now.
-			break;
-		}
-
-		if (dr->du_timer_flags & DISPATCH_TIMER_AFTER) {
-			_dispatch_timer_unote_disarm(dr, dth); // +2 is consumed by _merge_evt()
-			_dispatch_wlh_release(_dispatch_unote_wlh(dr));
-			_dispatch_unote_state_set(dr, DU_STATE_UNREGISTERED);
-			os_atomic_store2o(dr, ds_pending_data, 2, relaxed);
-			_dispatch_trace_timer_fire(dr, 1, 1);
-			dux_merge_evt(dr, EV_ONESHOT, 0, 0);
-			continue;
-		}
-
-		if (os_atomic_load2o(dr, dt_pending_config, relaxed)) {
-			_dispatch_timer_unote_configure(dr);
-			continue;
-		}
-
-		// We want to try to keep repeating timers in the heap if their handler
-		// is keeping up to avoid useless hops through the manager thread.
-		//
-		// However, if we can observe a non consumed ds_pending_data, we have to
-		// remove the timer from the heap until the handler keeps up (disarm).
-		// Such an operation is a one-way street, as _dispatch_source_invoke2()
-		// can decide to dispose of a timer without going back to the manager if
-		// it can observe that it is disarmed.
-		//
-		// To solve this race, we use a the MISSED marker in ds_pending_data
-		// with a release barrier to make the changes accumulated on `ds_timer`
-		// visible to _dispatch_source_timer_data(). Doing this also transfers
-		// the responsibility to call _dispatch_timer_unote_compute_missed()
-		// to _dispatch_source_invoke2() without the manager involvement.
-		//
-		// Suspension also causes the timer to be removed from the heap. We need
-		// to make sure _dispatch_source_timer_data() will recompute the proper
-		// number of fired events when the source is resumed, and also use the
-		// MISSED marker for this similar purpose.
-		if (unlikely(os_atomic_load2o(dr, ds_pending_data, relaxed))) {
-			_dispatch_timer_unote_disarm(dr, dth);
-			pending = os_atomic_or_orig2o(dr, ds_pending_data,
-					DISPATCH_TIMER_DISARMED_MARKER, relaxed);
-		} else {
-			pending = _dispatch_timer_unote_compute_missed(dr, now, 0) << 1;
-			if (_dispatch_timer_unote_needs_rearm(dr,
-					DISPATCH_TIMER_UNOTE_TRACE_SUSPENSION)) {
-				// _dispatch_source_merge_evt() consumes a +2 which we transfer
-				// from the heap ownership when we disarm the timer. If it stays
-				// armed, we need to take new retain counts
-				_dispatch_retain_unote_owner(dr);
-				_dispatch_timer_unote_arm(dr, dth, tidx);
-				os_atomic_store2o(dr, ds_pending_data, pending, relaxed);
-			} else {
-				_dispatch_timer_unote_disarm(dr, dth);
-				pending |= DISPATCH_TIMER_DISARMED_MARKER;
-				os_atomic_store2o(dr, ds_pending_data, pending, release);
-			}
-		}
-		_dispatch_trace_timer_fire(dr, pending >> 1, pending >> 1);
-		dux_merge_evt(dr, EV_ONESHOT, 0, 0);
-	}
-}
-
-#if DISPATCH_HAVE_TIMER_COALESCING
-#define DISPATCH_KEVENT_COALESCING_WINDOW_INIT(qos, ms) \
-		[DISPATCH_TIMER_QOS_##qos] = 2ull * (ms) * NSEC_PER_MSEC
-
-static const uint64_t _dispatch_kevent_coalescing_window[] = {
-	DISPATCH_KEVENT_COALESCING_WINDOW_INIT(NORMAL, 75),
-#if DISPATCH_HAVE_TIMER_QOS
-	DISPATCH_KEVENT_COALESCING_WINDOW_INIT(CRITICAL, 1),
-	DISPATCH_KEVENT_COALESCING_WINDOW_INIT(BACKGROUND, 100),
-#endif
-};
-#endif // DISPATCH_HAVE_TIMER_COALESCING
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_timer_delay_s
-_dispatch_timers_get_delay(dispatch_timer_heap_t dth, uint32_t tidx,
-		uint32_t qos, dispatch_clock_now_cache_t nows)
-{
-	uint64_t target, deadline;
-	dispatch_timer_delay_s rc;
-
-	if (!dth[tidx].dth_min[DTH_TARGET_ID]) {
-		rc.delay = rc.leeway = INT64_MAX;
-		return rc;
-	}
-
-	target = dth[tidx].dth_min[DTH_TARGET_ID]->dt_timer.target;
-	deadline = dth[tidx].dth_min[DTH_DEADLINE_ID]->dt_timer.deadline;
-	dispatch_assert(target <= deadline && target < INT64_MAX);
-
-	uint64_t now = _dispatch_time_now_cached(DISPATCH_TIMER_CLOCK(tidx), nows);
-	if (target <= now) {
-		rc.delay = rc.leeway = 0;
-		return rc;
-	}
-
-	if (qos < DISPATCH_TIMER_QOS_COUNT && dth[tidx].dth_count > 2) {
-#if DISPATCH_HAVE_TIMER_COALESCING
-		// Timer pre-coalescing <rdar://problem/13222034>
-		// When we have several timers with this target/deadline bracket:
-		//
-		//      Target        window  Deadline
-		//        V           <-------V
-		// t1:    [...........|.................]
-		// t2:         [......|.......]
-		// t3:             [..|..........]
-		// t4:                | [.............]
-		//                 ^
-		//          Optimal Target
-		//
-		// Coalescing works better if the Target is delayed to "Optimal", by
-		// picking the latest target that isn't too close to the deadline.
-		uint64_t window = _dispatch_kevent_coalescing_window[qos];
-		if (target + window < deadline) {
-			uint64_t latest = deadline - window;
-			target = _dispatch_timer_heap_max_target_before(&dth[tidx], latest);
-		}
-#endif
-	}
-
-	rc.delay = MIN(target - now, INT64_MAX);
-	rc.leeway = MIN(deadline - target, INT64_MAX);
-	return rc;
-}
-
-static void
-_dispatch_timers_program(dispatch_timer_heap_t dth, uint32_t tidx,
-		dispatch_clock_now_cache_t nows)
-{
-	uint32_t qos = DISPATCH_TIMER_QOS(tidx);
-	dispatch_timer_delay_s range;
-
-	range = _dispatch_timers_get_delay(dth, tidx, qos, nows);
-	if (range.delay == 0) {
-		_dispatch_timers_heap_dirty(dth, tidx);
-	}
-	if (range.delay == 0 || range.delay >= INT64_MAX) {
-		_dispatch_trace_next_timer_set(NULL, qos);
-		if (dth[tidx].dth_armed) {
-			_dispatch_event_loop_timer_delete(dth, tidx);
-		}
-		dth[tidx].dth_armed = false;
-		dth[tidx].dth_needs_program = false;
-	} else {
-		_dispatch_trace_next_timer_set(dth[tidx].dth_min[DTH_TARGET_ID], qos);
-		_dispatch_trace_next_timer_program(range.delay, qos);
-		_dispatch_event_loop_timer_arm(dth, tidx, range, nows);
-		dth[tidx].dth_armed = true;
-		dth[tidx].dth_needs_program = false;
-	}
-}
-
-void
-_dispatch_event_loop_drain_timers(dispatch_timer_heap_t dth, uint32_t count)
-{
-	dispatch_clock_now_cache_s nows = { };
-	uint32_t tidx;
-
-	do {
-		for (tidx = 0; tidx < count; tidx++) {
-			_dispatch_timers_run(dth, tidx, &nows);
-		}
-
-#if DISPATCH_USE_DTRACE
-		uint32_t mask = dth[0].dth_dirty_bits & DTH_DIRTY_QOS_MASK;
-		while (mask && DISPATCH_TIMER_WAKE_ENABLED()) {
-			int qos = __builtin_ctz(mask);
-			mask -= 1 << qos;
-			_dispatch_trace_timer_wake(_dispatch_trace_next_timer[qos]);
-		}
-#endif // DISPATCH_USE_DTRACE
-
-		dth[0].dth_dirty_bits = 0;
-
-		for (tidx = 0; tidx < count; tidx++) {
-			if (dth[tidx].dth_needs_program) {
-				_dispatch_timers_program(dth, tidx, &nows);
-			}
-		}
-
-		/*
-		 * Note: dth_dirty_bits being set again can happen if we notice
-		 * a new configuration during _dispatch_timers_run() that causes
-		 * the timer to change clocks for a bucket we already drained.
-		 *
-		 * This is however extremely unlikely, and because we drain relatively
-		 * to a constant cached "now", this will converge quickly.
-		 */
-	} while (unlikely(dth[0].dth_dirty_bits));
-}
--- a/Telegram/ThirdParty/dispatch/src/event/event_config.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/event/event_config.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,248 +0,0 @@
-/*
- * Copyright (c) 2016 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#ifndef __DISPATCH_EVENT_EVENT_CONFIG__
-#define __DISPATCH_EVENT_EVENT_CONFIG__
-
-#if defined(__linux__)
-#	include <sys/eventfd.h>
-#	define DISPATCH_EVENT_BACKEND_EPOLL 1
-#	define DISPATCH_EVENT_BACKEND_KEVENT 0
-#	define DISPATCH_EVENT_BACKEND_WINDOWS 0
-#elif __has_include(<sys/event.h>)
-#	include <sys/event.h>
-#	define DISPATCH_EVENT_BACKEND_EPOLL 0
-#	define DISPATCH_EVENT_BACKEND_KEVENT 1
-#	define DISPATCH_EVENT_BACKEND_WINDOWS 0
-#elif defined(_WIN32)
-#	define DISPATCH_EVENT_BACKEND_EPOLL 0
-#	define DISPATCH_EVENT_BACKEND_KEVENT 0
-#	define DISPATCH_EVENT_BACKEND_WINDOWS 1
-#else
-#	error unsupported event loop
-#endif
-
-#if DISPATCH_DEBUG
-#define DISPATCH_MGR_QUEUE_DEBUG 1
-#define DISPATCH_WLH_DEBUG 1
-#endif
-
-#ifndef DISPATCH_MGR_QUEUE_DEBUG
-#define DISPATCH_MGR_QUEUE_DEBUG 0
-#endif
-
-#ifndef DISPATCH_WLH_DEBUG
-#define DISPATCH_WLH_DEBUG 0
-#endif
-
-#ifndef DISPATCH_MACHPORT_DEBUG
-#define DISPATCH_MACHPORT_DEBUG 0
-#endif
-
-#ifndef DISPATCH_TIMER_ASSERTIONS
-#if DISPATCH_DEBUG
-#define DISPATCH_TIMER_ASSERTIONS 1
-#else
-#define DISPATCH_TIMER_ASSERTIONS 0
-#endif
-#endif
-
-#if DISPATCH_TIMER_ASSERTIONS
-#define DISPATCH_TIMER_ASSERT(a, op, b, text) ({ \
-		__typeof__(a) _a = (a); \
-		if (unlikely(!(_a op (b)))) { \
-			DISPATCH_CLIENT_CRASH(_a, "Timer: " text); \
-		} \
-	})
-#else
-#define DISPATCH_TIMER_ASSERT(a, op, b, text) ((void)0)
-#endif
-
-#ifndef EV_VANISHED
-#define EV_VANISHED 0x0200
-#endif
-
-#if DISPATCH_EVENT_BACKEND_KEVENT
-#	if defined(EV_UDATA_SPECIFIC) && EV_UDATA_SPECIFIC
-#		define DISPATCH_HAVE_DIRECT_KNOTES 1
-#	else
-#		define DISPATCH_HAVE_DIRECT_KNOTES 0
-#	endif
-
-#	if defined(EV_SET_QOS)
-#		define DISPATCH_USE_KEVENT_QOS 1
-#	else
-#		define DISPATCH_USE_KEVENT_QOS 0
-#	endif
-
-#	ifndef KEVENT_FLAG_ERROR_EVENTS
-#		define KEVENT_FLAG_ERROR_EVENTS 0x002
-#	endif
-
-#	ifdef NOTE_LEEWAY
-#		define DISPATCH_HAVE_TIMER_COALESCING 1
-#   else
-#		define NOTE_LEEWAY 0
-#		define DISPATCH_HAVE_TIMER_COALESCING 0
-#	endif // !NOTE_LEEWAY
-#	if defined(NOTE_CRITICAL) && defined(NOTE_BACKGROUND)
-#		define DISPATCH_HAVE_TIMER_QOS 1
-#	else
-#		undef  NOTE_CRITICAL
-#		define NOTE_CRITICAL 0
-#		undef  NOTE_BACKGROUND
-#		define NOTE_BACKGROUND 0
-#		define DISPATCH_HAVE_TIMER_QOS 0
-#	endif // !defined(NOTE_CRITICAL) || !defined(NOTE_BACKGROUND)
-
-#	ifndef NOTE_FUNLOCK
-#	define NOTE_FUNLOCK 0x00000100
-#	endif
-
-// FreeBSD's kevent does not support those
-#	ifndef NOTE_ABSOLUTE
-#	define NOTE_ABSOLUTE 0
-#	endif
-#	ifndef NOTE_EXITSTATUS
-#	define NOTE_EXITSTATUS 0
-#	endif
-
-#	if HAVE_DECL_NOTE_REAP
-#	if defined(NOTE_REAP) && defined(__APPLE__)
-#	undef NOTE_REAP
-#	define NOTE_REAP 0x10000000 // <rdar://problem/13338526>
-#	endif
-#	endif // HAVE_DECL_NOTE_REAP
-
-#	ifndef VQ_QUOTA
-#	undef HAVE_DECL_VQ_QUOTA // rdar://problem/24160982
-#	endif // VQ_QUOTA
-
-#	ifndef VQ_NEARLOWDISK
-#	undef HAVE_DECL_VQ_NEARLOWDISK
-#	endif // VQ_NEARLOWDISK
-
-#	ifndef VQ_DESIRED_DISK
-#	undef HAVE_DECL_VQ_DESIRED_DISK
-#	endif // VQ_DESIRED_DISK
-
-#	ifndef VQ_FREE_SPACE_CHANGE
-#	undef HAVE_DECL_VQ_FREE_SPACE_CHANGE
-#	endif // VQ_FREE_SPACE_CHANGE
-
-#	if !defined(EVFILT_NW_CHANNEL) && defined(__APPLE__)
-#	define EVFILT_NW_CHANNEL       (-16)
-#	define NOTE_FLOW_ADV_UPDATE    	0x1
-#	endif
-#else // DISPATCH_EVENT_BACKEND_KEVENT
-#	define EV_ADD					0x0001
-#	define EV_DELETE				0x0002
-#	define EV_ENABLE				0x0004
-
-#	define EV_ONESHOT				0x0010
-#	define EV_CLEAR					0x0020
-#	define EV_DISPATCH				0x0080
-
-#	define EVFILT_READ				(-1)
-#	define EVFILT_WRITE				(-2)
-#	define EVFILT_SIGNAL			(-3)
-#	define EVFILT_TIMER				(-4)
-#	define EVFILT_SYSCOUNT			4
-
-#	define DISPATCH_HAVE_TIMER_QOS 0
-#	define DISPATCH_HAVE_TIMER_COALESCING 0
-#	define DISPATCH_HAVE_DIRECT_KNOTES 0
-#endif // !DISPATCH_EVENT_BACKEND_KEVENT
-
-// These flags are used by dispatch generic code and
-// translated back by the various backends to similar semantics
-// hence must be defined even on non Darwin platforms
-#ifndef KEVENT_FLAG_IMMEDIATE
-#	define KEVENT_FLAG_IMMEDIATE 0x001
-#endif
-
-#ifdef EV_UDATA_SPECIFIC
-#	define DISPATCH_EV_DIRECT		(EV_UDATA_SPECIFIC|EV_DISPATCH)
-#else
-#	define DISPATCH_EV_DIRECT		0x0000
-#	define EV_UDATA_SPECIFIC		0x0000
-#	undef  EV_VANISHED
-#	define EV_VANISHED				0x0000
-#endif
-
-#define DISPATCH_EV_MSG_NEEDS_FREE	0x10000 // mach message needs to be freed()
-
-#define DISPATCH_EVFILT_TIMER				(-EVFILT_SYSCOUNT - 1)
-#define DISPATCH_EVFILT_TIMER_WITH_CLOCK	(-EVFILT_SYSCOUNT - 2)
-#define DISPATCH_EVFILT_CUSTOM_ADD			(-EVFILT_SYSCOUNT - 3)
-#define DISPATCH_EVFILT_CUSTOM_OR			(-EVFILT_SYSCOUNT - 4)
-#define DISPATCH_EVFILT_CUSTOM_REPLACE		(-EVFILT_SYSCOUNT - 5)
-#define DISPATCH_EVFILT_MACH_NOTIFICATION	(-EVFILT_SYSCOUNT - 6)
-
-#if HAVE_MACH
-#	if !EV_UDATA_SPECIFIC
-#	error mach support requires EV_UDATA_SPECIFIC
-#	endif
-
-#	ifndef MACH_RCV_VOUCHER
-#	define MACH_RCV_VOUCHER 0x00000800
-#	endif
-
-#	ifndef MACH_NOTIFY_SEND_POSSIBLE
-#	undef  MACH_NOTIFY_SEND_POSSIBLE
-#	define MACH_NOTIFY_SEND_POSSIBLE MACH_NOTIFY_DEAD_NAME
-#	endif
-
-#	ifndef NOTE_MACH_CONTINUOUS_TIME
-#	define NOTE_MACH_CONTINUOUS_TIME 0
-#	endif // NOTE_MACH_CONTINUOUS_TIME
-
-#	ifndef HOST_NOTIFY_CALENDAR_SET
-#	define HOST_NOTIFY_CALENDAR_SET HOST_NOTIFY_CALENDAR_CHANGE
-#	endif // HOST_NOTIFY_CALENDAR_SET
-
-#	ifndef HOST_CALENDAR_SET_REPLYID
-#	define HOST_CALENDAR_SET_REPLYID 951
-#	endif // HOST_CALENDAR_SET_REPLYID
-
-#	ifndef MACH_SEND_OVERRIDE
-#	define MACH_SEND_OVERRIDE 0x00000020
-typedef unsigned int mach_msg_priority_t;
-#	define MACH_MSG_PRIORITY_UNSPECIFIED ((mach_msg_priority_t)0)
-#	endif // MACH_SEND_OVERRIDE
-
-#	ifndef MACH_SEND_SYNC_OVERRIDE
-#	define MACH_SEND_SYNC_OVERRIDE 0x00100000
-#	endif // MACH_SEND_SYNC_OVERRIDE
-
-#	ifndef MACH_RCV_SYNC_WAIT
-#	define MACH_RCV_SYNC_WAIT 0x00004000
-#	endif // MACH_RCV_SYNC_WAIT
-
-#	define DISPATCH_MACH_TRAILER_SIZE sizeof(dispatch_mach_trailer_t)
-#	define DISPATCH_MACH_RCV_TRAILER MACH_RCV_TRAILER_CTX
-#	define DISPATCH_MACH_RCV_OPTIONS ( \
-		MACH_RCV_MSG | MACH_RCV_LARGE | MACH_RCV_LARGE_IDENTITY | \
-		MACH_RCV_TRAILER_ELEMENTS(DISPATCH_MACH_RCV_TRAILER) | \
-		MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0) | \
-		MACH_RCV_VOUCHER)
-#endif // HAVE_MACH
-
-#endif // __DISPATCH_EVENT_EVENT_CONFIG__
--- a/Telegram/ThirdParty/dispatch/src/event/event_epoll.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/event/event_epoll.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,726 +0,0 @@
-/*
- * Copyright (c) 2016 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-
-#include "internal.h"
-#if DISPATCH_EVENT_BACKEND_EPOLL
-#include <linux/sockios.h>
-#include <sys/epoll.h>
-#include <sys/eventfd.h>
-#include <sys/signalfd.h>
-#include <sys/timerfd.h>
-
-#ifndef EPOLLFREE
-#define EPOLLFREE 0x4000
-#endif
-
-#if !DISPATCH_USE_MGR_THREAD
-#error unsupported configuration
-#endif
-
-#define DISPATCH_EPOLL_MAX_EVENT_COUNT 16
-
-enum {
-	DISPATCH_EPOLL_EVENTFD         = 0x0001,
-	DISPATCH_EPOLL_CLOCK_WALL      = 0x0002,
-	DISPATCH_EPOLL_CLOCK_UPTIME    = 0x0003,
-	DISPATCH_EPOLL_CLOCK_MONOTONIC = 0x0004,
-};
-
-typedef struct dispatch_muxnote_s {
-	LIST_ENTRY(dispatch_muxnote_s) dmn_list;
-	LIST_HEAD(, dispatch_unote_linkage_s) dmn_readers_head;
-	LIST_HEAD(, dispatch_unote_linkage_s) dmn_writers_head;
-	int       dmn_fd;
-	uint32_t  dmn_ident;
-	uint32_t  dmn_events;
-	uint16_t  dmn_disarmed_events;
-	int8_t    dmn_filter;
-	bool      dmn_skip_outq_ioctl : 1;
-	bool      dmn_skip_inq_ioctl : 1;
-} *dispatch_muxnote_t;
-
-typedef struct dispatch_epoll_timeout_s {
-	int       det_fd;
-	uint16_t  det_ident;
-	bool      det_registered;
-	bool      det_armed;
-} *dispatch_epoll_timeout_t;
-
-static int _dispatch_epfd, _dispatch_eventfd;
-
-static dispatch_once_t epoll_init_pred;
-static void _dispatch_epoll_init(void *);
-
-static LIST_HEAD(dispatch_muxnote_bucket_s, dispatch_muxnote_s)
-_dispatch_sources[DSL_HASH_SIZE];
-
-#define DISPATCH_EPOLL_TIMEOUT_INITIALIZER(clock) \
-	[DISPATCH_CLOCK_##clock] = { \
-		.det_fd = -1, \
-		.det_ident = DISPATCH_EPOLL_CLOCK_##clock, \
-	}
-static struct dispatch_epoll_timeout_s _dispatch_epoll_timeout[] = {
-	DISPATCH_EPOLL_TIMEOUT_INITIALIZER(WALL),
-	DISPATCH_EPOLL_TIMEOUT_INITIALIZER(UPTIME),
-	DISPATCH_EPOLL_TIMEOUT_INITIALIZER(MONOTONIC),
-};
-
-#pragma mark dispatch_muxnote_t
-
-DISPATCH_ALWAYS_INLINE
-static inline uint32_t
-_dispatch_muxnote_armed_events(dispatch_muxnote_t dmn)
-{
-	return dmn->dmn_events & ~dmn->dmn_disarmed_events;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline struct dispatch_muxnote_bucket_s *
-_dispatch_muxnote_bucket(uint32_t ident)
-{
-	return &_dispatch_sources[DSL_HASH(ident)];
-}
-#define _dispatch_unote_muxnote_bucket(du) \
-	_dispatch_muxnote_bucket(du._du->du_ident)
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_muxnote_t
-_dispatch_muxnote_find(struct dispatch_muxnote_bucket_s *dmb,
-		uint32_t ident, int8_t filter)
-{
-	dispatch_muxnote_t dmn;
-	if (filter == EVFILT_WRITE) filter = EVFILT_READ;
-	LIST_FOREACH(dmn, dmb, dmn_list) {
-		if (dmn->dmn_ident == ident && dmn->dmn_filter == filter) {
-			break;
-		}
-	}
-	return dmn;
-}
-#define _dispatch_unote_muxnote_find(dmb, du) \
-		_dispatch_muxnote_find(dmb, du._du->du_ident, du._du->du_filter)
-
-static void
-_dispatch_muxnote_dispose(dispatch_muxnote_t dmn)
-{
-	if (dmn->dmn_filter != EVFILT_READ || (uint32_t)dmn->dmn_fd != dmn->dmn_ident) {
-		close(dmn->dmn_fd);
-	}
-	free(dmn);
-}
-
-static pthread_t manager_thread;
-
-static void
-_dispatch_muxnote_signal_block_and_raise(int signo)
-{
-	// On linux, for signals to be delivered to the signalfd, signals
-	// must be blocked, else any thread that hasn't them blocked may
-	// receive them.  Fix that by lazily noticing, blocking said signal,
-	// and raising the signal again when it happens
-	_dispatch_sigmask();
-	pthread_kill(manager_thread, signo);
-}
-
-static dispatch_muxnote_t
-_dispatch_muxnote_create(dispatch_unote_t du, uint32_t events)
-{
-	static sigset_t signals_with_unotes;
-	static struct sigaction sa = {
-		.sa_handler = _dispatch_muxnote_signal_block_and_raise,
-		.sa_flags = SA_RESTART,
-	};
-
-	dispatch_muxnote_t dmn;
-	struct stat sb;
-	int fd = (int)du._du->du_ident;
-	int8_t filter = du._du->du_filter;
-	bool skip_outq_ioctl = false, skip_inq_ioctl = false;
-	sigset_t sigmask;
-
-	switch (filter) {
-	case EVFILT_SIGNAL: {
-		int signo = (int)du._du->du_ident;
-		if (!sigismember(&signals_with_unotes, signo)) {
-			manager_thread = pthread_self();
-			sigaddset(&signals_with_unotes, signo);
-			sigaction(signo, &sa, NULL);
-		}
-		sigemptyset(&sigmask);
-		sigaddset(&sigmask, signo);
-		fd = signalfd(-1, &sigmask, SFD_NONBLOCK | SFD_CLOEXEC);
-		if (fd < 0) {
-			return NULL;
-		}
-		break;
-	}
-	case EVFILT_WRITE:
-		filter = EVFILT_READ;
-		DISPATCH_FALLTHROUGH;
-	case EVFILT_READ:
-		if (fstat(fd, &sb) < 0) {
-			return NULL;
-		}
-		if (S_ISREG(sb.st_mode)) {
-			// make a dummy fd that is both readable & writeable
-			fd = eventfd(1, EFD_CLOEXEC | EFD_NONBLOCK);
-			if (fd < 0) {
-				return NULL;
-			}
-			// Linux doesn't support output queue size ioctls for regular files
-			skip_outq_ioctl = true;
-		} else if (S_ISSOCK(sb.st_mode)) {
-			socklen_t vlen = sizeof(int);
-			int v;
-			// Linux doesn't support saying how many clients are ready to be
-			// accept()ed for sockets
-			if (getsockopt(fd, SOL_SOCKET, SO_ACCEPTCONN, &v, &vlen) == 0) {
-				skip_inq_ioctl = (bool)v;
-			}
-		}
-		break;
-
-	default:
-		DISPATCH_INTERNAL_CRASH(0, "Unexpected filter");
-	}
-
-	dmn = _dispatch_calloc(1, sizeof(struct dispatch_muxnote_s));
-	LIST_INIT(&dmn->dmn_readers_head);
-	LIST_INIT(&dmn->dmn_writers_head);
-	dmn->dmn_fd = fd;
-	dmn->dmn_ident = du._du->du_ident;
-	dmn->dmn_filter = filter;
-	dmn->dmn_events = events;
-	dmn->dmn_skip_outq_ioctl = skip_outq_ioctl;
-	dmn->dmn_skip_inq_ioctl = skip_inq_ioctl;
-	return dmn;
-}
-
-#pragma mark dispatch_unote_t
-
-static int
-_dispatch_epoll_update(dispatch_muxnote_t dmn, uint32_t events, int op)
-{
-	dispatch_once_f(&epoll_init_pred, NULL, _dispatch_epoll_init);
-	struct epoll_event ev = {
-		.events = events,
-		.data = { .ptr = dmn },
-	};
-	return epoll_ctl(_dispatch_epfd, op, dmn->dmn_fd, &ev);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline uint32_t
-_dispatch_unote_required_events(dispatch_unote_t du)
-{
-	uint32_t events = EPOLLFREE;
-
-	switch (du._du->du_filter) {
-	case DISPATCH_EVFILT_CUSTOM_ADD:
-	case DISPATCH_EVFILT_CUSTOM_OR:
-	case DISPATCH_EVFILT_CUSTOM_REPLACE:
-		return 0;
-	case EVFILT_WRITE:
-		events |= EPOLLOUT;
-		break;
-	default:
-		events |= EPOLLIN;
-		break;
-	}
-
-	if (dux_type(du._du)->dst_flags & EV_DISPATCH) {
-		events |= EPOLLONESHOT;
-	}
-
-	return events;
-}
-
-bool
-_dispatch_unote_register_muxed(dispatch_unote_t du)
-{
-	struct dispatch_muxnote_bucket_s *dmb;
-	dispatch_muxnote_t dmn;
-	uint32_t events;
-
-	events = _dispatch_unote_required_events(du);
-
-	dmb = _dispatch_unote_muxnote_bucket(du);
-	dmn = _dispatch_unote_muxnote_find(dmb, du);
-	if (dmn) {
-		if (events & ~_dispatch_muxnote_armed_events(dmn)) {
-			events |= _dispatch_muxnote_armed_events(dmn);
-			if (_dispatch_epoll_update(dmn, events, EPOLL_CTL_MOD) < 0) {
-				dmn = NULL;
-			} else {
-				dmn->dmn_events |= events;
-				dmn->dmn_disarmed_events &= ~events;
-			}
-		}
-	} else {
-		dmn = _dispatch_muxnote_create(du, events);
-		if (dmn) {
-			if (_dispatch_epoll_update(dmn, events, EPOLL_CTL_ADD) < 0) {
-				_dispatch_muxnote_dispose(dmn);
-				dmn = NULL;
-			} else {
-				LIST_INSERT_HEAD(dmb, dmn, dmn_list);
-			}
-		}
-	}
-
-	if (dmn) {
-		dispatch_unote_linkage_t dul = _dispatch_unote_get_linkage(du);
-		if (events & EPOLLOUT) {
-			LIST_INSERT_HEAD(&dmn->dmn_writers_head, dul, du_link);
-		} else {
-			LIST_INSERT_HEAD(&dmn->dmn_readers_head, dul, du_link);
-		}
-		dul->du_muxnote = dmn;
-		_dispatch_unote_state_set(du, DISPATCH_WLH_ANON, DU_STATE_ARMED);
-	}
-	return dmn != NULL;
-}
-
-void
-_dispatch_unote_resume_muxed(dispatch_unote_t du)
-{
-	dispatch_muxnote_t dmn = _dispatch_unote_get_linkage(du)->du_muxnote;
-	dispatch_assert(_dispatch_unote_registered(du));
-	uint32_t events = _dispatch_unote_required_events(du);
-
-	if (events & dmn->dmn_disarmed_events) {
-		dmn->dmn_disarmed_events &= ~events;
-		events = _dispatch_muxnote_armed_events(dmn);
-		_dispatch_epoll_update(dmn, events, EPOLL_CTL_MOD);
-	}
-}
-
-bool
-_dispatch_unote_unregister_muxed(dispatch_unote_t du)
-{
-	dispatch_unote_linkage_t dul = _dispatch_unote_get_linkage(du);
-	dispatch_muxnote_t dmn = dul->du_muxnote;
-	uint32_t events = dmn->dmn_events;
-
-	LIST_REMOVE(dul, du_link);
-	_LIST_TRASH_ENTRY(dul, du_link);
-	dul->du_muxnote = NULL;
-
-	if (LIST_EMPTY(&dmn->dmn_readers_head)) {
-		events &= (uint32_t)~EPOLLIN;
-		if (dmn->dmn_disarmed_events & EPOLLIN) {
-			dmn->dmn_disarmed_events &= (uint16_t)~EPOLLIN;
-			dmn->dmn_events &= (uint32_t)~EPOLLIN;
-		}
-	}
-	if (LIST_EMPTY(&dmn->dmn_writers_head)) {
-		events &= (uint32_t)~EPOLLOUT;
-		if (dmn->dmn_disarmed_events & EPOLLOUT) {
-			dmn->dmn_disarmed_events &= (uint16_t)~EPOLLOUT;
-			dmn->dmn_events &= (uint32_t)~EPOLLOUT;
-		}
-	}
-
-	if (events & (EPOLLIN | EPOLLOUT)) {
-		if (events != _dispatch_muxnote_armed_events(dmn)) {
-			dmn->dmn_events = events;
-			events = _dispatch_muxnote_armed_events(dmn);
-			_dispatch_epoll_update(dmn, events, EPOLL_CTL_MOD);
-		}
-	} else {
-		epoll_ctl(_dispatch_epfd, EPOLL_CTL_DEL, dmn->dmn_fd, NULL);
-		LIST_REMOVE(dmn, dmn_list);
-		_dispatch_muxnote_dispose(dmn);
-	}
-	_dispatch_unote_state_set(du, DU_STATE_UNREGISTERED);
-	return true;
-}
-
-#pragma mark timers
-
-static void
-_dispatch_event_merge_timer(dispatch_clock_t clock)
-{
-	dispatch_timer_heap_t dth = _dispatch_timers_heap;
-	uint32_t tidx = DISPATCH_TIMER_INDEX(clock, 0);
-
-	_dispatch_epoll_timeout[clock].det_armed = false;
-
-	_dispatch_timers_heap_dirty(dth, tidx);
-	dth[tidx].dth_needs_program = true;
-	dth[tidx].dth_armed = false;
-}
-
-static void
-_dispatch_timeout_program(uint32_t tidx, uint64_t target,
-		DISPATCH_UNUSED uint64_t leeway)
-{
-	dispatch_clock_t clock = DISPATCH_TIMER_CLOCK(tidx);
-	dispatch_epoll_timeout_t timer = &_dispatch_epoll_timeout[clock];
-	struct epoll_event ev = {
-		.events = EPOLLONESHOT | EPOLLIN,
-
-	};
-	int op;
-
-	if (target >= INT64_MAX && !timer->det_registered) {
-		return;
-	}
-	ev.data.u32 = timer->det_ident;
-
-	if (unlikely(timer->det_fd < 0)) {
-		clockid_t clockid;
-		int fd;
-		switch (DISPATCH_TIMER_CLOCK(tidx)) {
-		case DISPATCH_CLOCK_UPTIME:
-			clockid = CLOCK_MONOTONIC;
-			break;
-		case DISPATCH_CLOCK_MONOTONIC:
-			clockid = CLOCK_BOOTTIME;
-			break;
-		case DISPATCH_CLOCK_WALL:
-			clockid = CLOCK_REALTIME;
-			break;
-		}
-		fd = timerfd_create(clockid, TFD_NONBLOCK | TFD_CLOEXEC);
-		if (!dispatch_assume(fd >= 0)) {
-			return;
-		}
-		timer->det_fd = fd;
-	}
-
-	if (target < INT64_MAX) {
-		struct itimerspec its = { .it_value = {
-			.tv_sec  = (time_t)(target / NSEC_PER_SEC),
-			.tv_nsec = target % NSEC_PER_SEC,
-		} };
-		dispatch_assume_zero(timerfd_settime(timer->det_fd, TFD_TIMER_ABSTIME,
-				&its, NULL));
-		if (!timer->det_registered) {
-			op = EPOLL_CTL_ADD;
-		} else if (!timer->det_armed) {
-			op = EPOLL_CTL_MOD;
-		} else {
-			return;
-		}
-	} else {
-		op = EPOLL_CTL_DEL;
-	}
-	dispatch_assume_zero(epoll_ctl(_dispatch_epfd, op, timer->det_fd, &ev));
-	timer->det_armed = timer->det_registered = (op != EPOLL_CTL_DEL);;
-}
-
-void
-_dispatch_event_loop_timer_arm(dispatch_timer_heap_t dth DISPATCH_UNUSED,
-		uint32_t tidx, dispatch_timer_delay_s range,
-		dispatch_clock_now_cache_t nows)
-{
-	dispatch_clock_t clock = DISPATCH_TIMER_CLOCK(tidx);
-	uint64_t target = range.delay + _dispatch_time_now_cached(clock, nows);
-	_dispatch_timeout_program(tidx, target, range.leeway);
-}
-
-void
-_dispatch_event_loop_timer_delete(dispatch_timer_heap_t dth DISPATCH_UNUSED,
-		uint32_t tidx)
-{
-	_dispatch_timeout_program(tidx, UINT64_MAX, UINT64_MAX);
-}
-
-#pragma mark dispatch_loop
-
-void
-_dispatch_event_loop_atfork_child(void)
-{
-}
-
-static void
-_dispatch_epoll_init(void *context DISPATCH_UNUSED)
-{
-	_dispatch_fork_becomes_unsafe();
-
-	_dispatch_epfd = epoll_create1(EPOLL_CLOEXEC);
-	if (_dispatch_epfd < 0) {
-		DISPATCH_INTERNAL_CRASH(errno, "epoll_create1() failed");
-	}
-
-	_dispatch_eventfd = eventfd(0, EFD_CLOEXEC | EFD_NONBLOCK);
-	if (_dispatch_eventfd < 0) {
-		DISPATCH_INTERNAL_CRASH(errno, "epoll_eventfd() failed");
-	}
-
-	struct epoll_event ev = {
-		.events = EPOLLIN | EPOLLFREE,
-		.data = { .u32 = DISPATCH_EPOLL_EVENTFD, },
-	};
-	int op = EPOLL_CTL_ADD;
-	if (epoll_ctl(_dispatch_epfd, op, _dispatch_eventfd, &ev) < 0) {
-		DISPATCH_INTERNAL_CRASH(errno, "epoll_ctl() failed");
-	}
-
-#if DISPATCH_USE_MGR_THREAD
-	_dispatch_trace_item_push(_dispatch_mgr_q.do_targetq, &_dispatch_mgr_q);
-	dx_push(_dispatch_mgr_q.do_targetq, &_dispatch_mgr_q, 0);
-#endif
-}
-
-void
-_dispatch_event_loop_poke(dispatch_wlh_t wlh DISPATCH_UNUSED,
-		uint64_t dq_state DISPATCH_UNUSED, uint32_t flags DISPATCH_UNUSED)
-{
-	dispatch_once_f(&epoll_init_pred, NULL, _dispatch_epoll_init);
-	dispatch_assume_zero(eventfd_write(_dispatch_eventfd, 1));
-}
-
-static void
-_dispatch_event_merge_signal(dispatch_muxnote_t dmn)
-{
-	dispatch_unote_linkage_t dul, dul_next;
-	struct signalfd_siginfo si;
-	ssize_t rc;
-
-	// Linux has the weirdest semantics around signals: if it finds a thread
-	// that has not masked a process wide-signal, it may deliver it to this
-	// thread, meaning that the signalfd may have been made readable, but the
-	// signal consumed through the legacy delivery mechanism.
-	//
-	// Because of this we can get a misfire of the signalfd yielding EAGAIN the
-	// first time around. The _dispatch_muxnote_signal_block_and_raise() hack
-	// will kick in, the thread with the wrong mask will be fixed up, and the
-	// signal delivered to us again properly.
-	if ((rc = read(dmn->dmn_fd, &si, sizeof(si))) == sizeof(si)) {
-		LIST_FOREACH_SAFE(dul, &dmn->dmn_readers_head, du_link, dul_next) {
-			dispatch_unote_t du = _dispatch_unote_linkage_get_unote(dul);
-			// consumed by dux_merge_evt()
-			_dispatch_retain_unote_owner(du);
-			dispatch_assert(!dux_needs_rearm(du._du));
-			os_atomic_store2o(du._dr, ds_pending_data, 1, relaxed);
-			dux_merge_evt(du._du, EV_ADD|EV_ENABLE|EV_CLEAR, 1, 0);
-		}
-	} else {
-		dispatch_assume(rc == -1 && errno == EAGAIN);
-	}
-}
-
-static uintptr_t
-_dispatch_get_buffer_size(dispatch_muxnote_t dmn, bool writer)
-{
-	int n;
-
-	if (writer ? dmn->dmn_skip_outq_ioctl : dmn->dmn_skip_inq_ioctl) {
-		return 1;
-	}
-
-	if (ioctl((int)dmn->dmn_ident, writer ? SIOCOUTQ : SIOCINQ, &n) != 0) {
-		switch (errno) {
-		case EINVAL:
-		case ENOTTY:
-			// this file descriptor actually doesn't support the buffer
-			// size ioctl, remember that for next time to avoid the syscall.
-			break;
-		default:
-			dispatch_assume_zero(errno);
-			break;
-		}
-		if (writer) {
-			dmn->dmn_skip_outq_ioctl = true;
-		} else {
-			dmn->dmn_skip_inq_ioctl = true;
-		}
-		return 1;
-	}
-	return (uintptr_t)n;
-}
-
-static void
-_dispatch_event_merge_hangup(dispatch_unote_t du)
-{
-	// consumed by dux_merge_evt()
-	_dispatch_retain_unote_owner(du);
-	dispatch_unote_state_t du_state = _dispatch_unote_state(du);
-	du_state |= DU_STATE_NEEDS_DELETE;
-	du_state &= ~DU_STATE_ARMED;
-	_dispatch_unote_state_set(du, du_state);
-	uintptr_t data = 0;  // EOF
-	os_atomic_store2o(du._dr, ds_pending_data, ~data, relaxed);
-	dux_merge_evt(du._du, EV_DELETE|EV_DISPATCH, data, 0);
-}
-
-static void
-_dispatch_event_merge_fd(dispatch_muxnote_t dmn, uint32_t events)
-{
-	dispatch_unote_linkage_t dul, dul_next;
-	uintptr_t data;
-
-	dmn->dmn_disarmed_events |= (events & (EPOLLIN | EPOLLOUT));
-
-	if (events & EPOLLIN) {
-		data = _dispatch_get_buffer_size(dmn, false);
-		LIST_FOREACH_SAFE(dul, &dmn->dmn_readers_head, du_link, dul_next) {
-			dispatch_unote_t du = _dispatch_unote_linkage_get_unote(dul);
-			// consumed by dux_merge_evt()
-			_dispatch_retain_unote_owner(du);
-			dispatch_assert(dux_needs_rearm(du._du));
-			_dispatch_unote_state_clear_bit(du, DU_STATE_ARMED);
-			os_atomic_store2o(du._dr, ds_pending_data, ~data, relaxed);
-			dux_merge_evt(du._du, EV_ADD|EV_ENABLE|EV_DISPATCH, data, 0);
-		}
-	}
-
-	if (events & EPOLLOUT) {
-		data = _dispatch_get_buffer_size(dmn, true);
-		LIST_FOREACH_SAFE(dul, &dmn->dmn_writers_head, du_link, dul_next) {
-			dispatch_unote_t du = _dispatch_unote_linkage_get_unote(dul);
-			// consumed by dux_merge_evt()
-			_dispatch_retain_unote_owner(du);
-			dispatch_assert(dux_needs_rearm(du._du));
-			_dispatch_unote_state_clear_bit(du, DU_STATE_ARMED);
-			os_atomic_store2o(du._dr, ds_pending_data, ~data, relaxed);
-			dux_merge_evt(du._du, EV_ADD|EV_ENABLE|EV_DISPATCH, data, 0);
-		}
-	}
-
-	// SR-9033: EPOLLHUP is an unmaskable event which we must respond to
-	if (events & EPOLLHUP) {
-		LIST_FOREACH_SAFE(dul, &dmn->dmn_readers_head, du_link, dul_next) {
-			dispatch_unote_t du = _dispatch_unote_linkage_get_unote(dul);
-			_dispatch_event_merge_hangup(du);
-		}
-		LIST_FOREACH_SAFE(dul, &dmn->dmn_writers_head, du_link, dul_next) {
-			dispatch_unote_t du = _dispatch_unote_linkage_get_unote(dul);
-			_dispatch_event_merge_hangup(du);
-		}
-		epoll_ctl(_dispatch_epfd, EPOLL_CTL_DEL, dmn->dmn_fd, NULL);
-		return;
-	}
-
-	events = _dispatch_muxnote_armed_events(dmn);
-	if (events) _dispatch_epoll_update(dmn, events, EPOLL_CTL_MOD);
-}
-
-DISPATCH_NOINLINE
-void
-_dispatch_event_loop_drain(uint32_t flags)
-{
-	struct epoll_event ev[DISPATCH_EPOLL_MAX_EVENT_COUNT];
-	int i, r;
-	int timeout = (flags & KEVENT_FLAG_IMMEDIATE) ? 0 : -1;
-
-retry:
-	r = epoll_wait(_dispatch_epfd, ev, countof(ev), timeout);
-	if (unlikely(r == -1)) {
-		int err = errno;
-		switch (err) {
-		case EINTR:
-			goto retry;
-		case EBADF:
-			DISPATCH_CLIENT_CRASH(err, "Do not close random Unix descriptors");
-			break;
-		default:
-			(void)dispatch_assume_zero(err);
-			break;
-		}
-		return;
-	}
-
-	for (i = 0; i < r; i++) {
-		dispatch_muxnote_t dmn;
-		eventfd_t value;
-
-		if (ev[i].events & EPOLLFREE) {
-			DISPATCH_CLIENT_CRASH(0, "Do not close random Unix descriptors");
-		}
-
-		switch (ev[i].data.u32) {
-		case DISPATCH_EPOLL_EVENTFD:
-			dispatch_assume_zero(eventfd_read(_dispatch_eventfd, &value));
-			break;
-
-		case DISPATCH_EPOLL_CLOCK_WALL:
-			_dispatch_event_merge_timer(DISPATCH_CLOCK_WALL);
-			break;
-
-		case DISPATCH_EPOLL_CLOCK_UPTIME:
-			_dispatch_event_merge_timer(DISPATCH_CLOCK_UPTIME);
-			break;
-
-		case DISPATCH_EPOLL_CLOCK_MONOTONIC:
-			_dispatch_event_merge_timer(DISPATCH_CLOCK_MONOTONIC);
-			break;
-
-		default:
-			dmn = ev[i].data.ptr;
-			switch (dmn->dmn_filter) {
-			case EVFILT_SIGNAL:
-				_dispatch_event_merge_signal(dmn);
-				break;
-
-			case EVFILT_READ:
-				_dispatch_event_merge_fd(dmn, ev[i].events);
-				break;
-			}
-		}
-	}
-}
-
-void
-_dispatch_event_loop_cancel_waiter(dispatch_sync_context_t dsc)
-{
-	(void)dsc;
-}
-
-void
-_dispatch_event_loop_wake_owner(dispatch_sync_context_t dsc,
-		dispatch_wlh_t wlh, uint64_t old_state, uint64_t new_state)
-{
-	(void)dsc; (void)wlh; (void)old_state; (void)new_state;
-}
-
-void
-_dispatch_event_loop_wait_for_ownership(dispatch_sync_context_t dsc)
-{
-	if (dsc->dsc_release_storage) {
-		_dispatch_queue_release_storage(dsc->dc_data);
-	}
-}
-
-void
-_dispatch_event_loop_end_ownership(dispatch_wlh_t wlh, uint64_t old_state,
-		uint64_t new_state, uint32_t flags)
-{
-	(void)wlh; (void)old_state; (void)new_state; (void)flags;
-}
-
-#if DISPATCH_WLH_DEBUG
-void
-_dispatch_event_loop_assert_not_owned(dispatch_wlh_t wlh)
-{
-	(void)wlh;
-}
-#endif
-
-void
-_dispatch_event_loop_leave_immediate(uint64_t dq_state)
-{
-	(void)dq_state;
-}
-
-#endif // DISPATCH_EVENT_BACKEND_EPOLL
--- a/Telegram/ThirdParty/dispatch/src/event/event_internal.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/event/event_internal.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,718 +0,0 @@
-/*
- * Copyright (c) 2008-2016 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-/*
- * IMPORTANT: This header file describes INTERNAL interfaces to libdispatch
- * which are subject to change in future releases of Mac OS X. Any applications
- * relying on these interfaces WILL break.
- */
-
-#ifndef __DISPATCH_EVENT_EVENT_INTERNAL__
-#define __DISPATCH_EVENT_EVENT_INTERNAL__
-
-#include "event_config.h"
-
-/*
- * The unote state has 3 pieces of information and reflects the state
- * of the unote registration and mirrors the state of the knote if any.
- *
- * This state is peculiar in the sense that it can be read concurrently, but
- * is never written to concurrently. This is achieved by serializing through
- * kevent calls from appropriate synchronization context (referred as `dkq`
- * for dispatch kevent queue in the dispatch source code).
- *
- * DU_STATE_ARMED
- *
- *   This bit represents the fact that the registration is active and may
- *   receive events at any given time. This bit can only be set if the WLH bits
- *   are set and the DU_STATE_NEEDS_DELETE bit is not.
- *
- * DU_STATE_NEEDS_DELETE
- *
- *   The kernel has indicated that it wants the next event for this unote to be
- *   an unregistration. This bit can only be set if the DU_STATE_ARMED bit is
- *   not set.
- *
- *   DU_STATE_NEEDS_DELETE may be the only bit set in the unote state
- *
- * DU_STATE_WLH_MASK
- *
- *   The most significant bits of du_state represent which event loop this unote
- *   is registered with, and has a storage reference on it taken with
- *   _dispatch_wlh_retain().
- *
- * Registration
- *
- *   Unote registration attempt is made with _dispatch_unote_register().
- *   On succes, it will set the WLH bits and the DU_STATE_ARMED bit, on failure
- *   the state is 0.
- *
- *   _dispatch_unote_register() must be called from the appropriate
- *   synchronization context depending on the unote type.
- *
- * Event delivery
- *
- *   When an event is delivered for a unote type that requires explicit
- *   re-arming (EV_DISPATCH or EV_ONESHOT), the DU_STATE_ARMED bit is cleared.
- *   If the event is marked as EV_ONESHOT, then the DU_STATE_NEEDS_DELETE bit
- *   is also set, initiating the "deferred delete" state machine.
- *
- *   For other unote types, the state isn't touched, unless the event is
- *   EV_ONESHOT, in which case it causes an automatic unregistration.
- *
- * Unregistration
- *
- *   The unote owner can attempt unregistering the unote with
- *   _dispatch_unote_unregister() from the proper synchronization context
- *   at any given time. When successful, the state will be set to 0 and the
- *   unote is no longer active. Unregistration is always successful for events
- *   that don't require explcit re-arming.
- *
- *   When this unregistration fails, then the unote owner must wait for the
- *   next event delivery for this unote.
- */
-typedef uintptr_t dispatch_unote_state_t;
-#define DU_STATE_ARMED            ((dispatch_unote_state_t)0x1ul)
-#define DU_STATE_NEEDS_DELETE     ((dispatch_unote_state_t)0x2ul)
-#define DU_STATE_WLH_MASK         ((dispatch_unote_state_t)~0x3ul)
-#define DU_STATE_UNREGISTERED     ((dispatch_unote_state_t)0)
-
-struct dispatch_sync_context_s;
-typedef struct dispatch_wlh_s *dispatch_wlh_t; // opaque handle
-#define DISPATCH_WLH_ANON       ((dispatch_wlh_t)(void*)(~0x3ul))
-#define DISPATCH_WLH_MANAGER    ((dispatch_wlh_t)(void*)(~0x7ul))
-
-DISPATCH_ENUM(dispatch_unote_timer_flags, uint8_t,
-	/* DISPATCH_TIMER_STRICT 0x1 */
-	/* DISPATCH_TIMER_BACKGROUND = 0x2, */
-	DISPATCH_TIMER_CLOCK_UPTIME = DISPATCH_CLOCK_UPTIME << 2,
-	DISPATCH_TIMER_CLOCK_MONOTONIC = DISPATCH_CLOCK_MONOTONIC << 2,
-	DISPATCH_TIMER_CLOCK_WALL = DISPATCH_CLOCK_WALL << 2,
-#define _DISPATCH_TIMER_CLOCK_MASK (0x3 << 2)
-	DISPATCH_TIMER_INTERVAL = 0x10,
-	/* DISPATCH_INTERVAL_UI_ANIMATION = 0x20 */ // See source_private.h
-	DISPATCH_TIMER_AFTER = 0x40,
-);
-
-static inline dispatch_clock_t
-_dispatch_timer_flags_to_clock(dispatch_unote_timer_flags_t flags)
-{
-	return (dispatch_clock_t)((flags & _DISPATCH_TIMER_CLOCK_MASK) >> 2);
-}
-
-static inline dispatch_unote_timer_flags_t
-_dispatch_timer_flags_from_clock(dispatch_clock_t clock)
-{
-	return (dispatch_unote_timer_flags_t)(clock << 2);
-}
-
-#if defined(_WIN32)
-typedef uintptr_t dispatch_unote_ident_t;
-#else
-typedef uint32_t dispatch_unote_ident_t;
-#endif
-
-#define DISPATCH_UNOTE_CLASS_HEADER() \
-	dispatch_source_type_t du_type; \
-	uintptr_t du_owner_wref; /* "weak" back reference to the owner object */ \
-	os_atomic(dispatch_unote_state_t) du_state; \
-	dispatch_unote_ident_t du_ident; \
-	int8_t    du_filter; \
-	uint8_t   du_is_direct : 1; \
-	uint8_t   du_is_timer : 1; \
-	uint8_t   du_has_extended_status : 1; \
-	uint8_t   du_memorypressure_override : 1; \
-	uint8_t   du_vmpressure_override : 1; \
-	uint8_t   du_can_be_wlh : 1; \
-	uint8_t   dmrr_handler_is_block : 1; \
-	uint8_t   du_unused_flag : 1; \
-	union { \
-		uint8_t   du_timer_flags; \
-		os_atomic(bool) dmsr_notification_armed; \
-		bool dmr_reply_port_owned; \
-	}; \
-	uint8_t   du_unused; \
-	uint32_t  du_fflags; \
-	dispatch_priority_t du_priority
-
-#define _dispatch_ptr2wref(ptr) (~(uintptr_t)(ptr))
-#define _dispatch_wref2ptr(ref) ((void*)~(ref))
-#define _dispatch_source_from_refs(dr) \
-		((dispatch_source_t)_dispatch_wref2ptr((dr)->du_owner_wref))
-
-typedef struct dispatch_unote_class_s {
-	DISPATCH_UNOTE_CLASS_HEADER();
-} *dispatch_unote_class_t;
-
-enum {
-	DS_EVENT_HANDLER = 0,
-	DS_CANCEL_HANDLER,
-	DS_REGISTN_HANDLER,
-};
-
-#define DISPATCH_SOURCE_REFS_HEADER() \
-	DISPATCH_UNOTE_CLASS_HEADER(); \
-	struct dispatch_continuation_s *volatile ds_handler[3]; \
-	uint64_t ds_data DISPATCH_ATOMIC64_ALIGN; \
-	uint64_t ds_pending_data DISPATCH_ATOMIC64_ALIGN
-
-
-// Extracts source data from the ds_data field
-#define DISPATCH_SOURCE_GET_DATA(d) ((d) & 0xFFFFFFFF)
-
-// Extracts status from the ds_data field
-#define DISPATCH_SOURCE_GET_STATUS(d) ((d) >> 32)
-
-// Combine data and status for the ds_data field
-#define DISPATCH_SOURCE_COMBINE_DATA_AND_STATUS(data, status) \
-		((((uint64_t)(status)) << 32) | (data))
-
-#define DISPATCH_TIMER_DISARMED_MARKER  1ul
-
-
-// Source state which may contain references to the source object
-// Separately allocated so that 'leaks' can see sources <rdar://problem/9050566>
-typedef struct dispatch_source_refs_s {
-	DISPATCH_SOURCE_REFS_HEADER();
-} *dispatch_source_refs_t;
-
-typedef struct dispatch_timer_delay_s {
-	uint64_t delay, leeway;
-} dispatch_timer_delay_s;
-
-#define DTH_INVALID_ID  (~0u)
-#define DTH_TARGET_ID   0u
-#define DTH_DEADLINE_ID 1u
-#define DTH_ID_COUNT    2u
-
-typedef struct dispatch_timer_source_s {
-	union {
-		struct {
-			uint64_t target;
-			uint64_t deadline;
-		};
-		uint64_t heap_key[DTH_ID_COUNT];
-	};
-	uint64_t interval;
-} *dispatch_timer_source_t;
-
-typedef struct dispatch_timer_config_s {
-	struct dispatch_timer_source_s dtc_timer;
-	dispatch_clock_t dtc_clock;
-} *dispatch_timer_config_t;
-
-typedef struct dispatch_timer_source_refs_s {
-	DISPATCH_SOURCE_REFS_HEADER();
-	struct dispatch_timer_source_s dt_timer;
-	struct dispatch_timer_config_s *dt_pending_config;
-	uint32_t dt_heap_entry[DTH_ID_COUNT];
-} *dispatch_timer_source_refs_t;
-
-typedef struct dispatch_timer_heap_s {
-	uint32_t dth_count;
-	uint8_t dth_segments;
-	uint8_t dth_max_qos;
-#define DTH_DIRTY_GLOBAL   0x80
-#define DTH_DIRTY_QOS_MASK ((1u << DISPATCH_TIMER_QOS_COUNT) - 1)
-	uint8_t dth_dirty_bits; // Only used in the first heap
-	uint8_t dth_armed : 1;
-	uint8_t dth_needs_program : 1;
-	dispatch_timer_source_refs_t dth_min[DTH_ID_COUNT];
-	void **dth_heap;
-} *dispatch_timer_heap_t;
-
-#if HAVE_MACH
-#if DISPATCH_MACHPORT_DEBUG
-void dispatch_debug_machport(mach_port_t name, const char *str);
-#define _dispatch_debug_machport(name) \
-		dispatch_debug_machport((name), __func__)
-#else
-#define _dispatch_debug_machport(name) ((void)(name))
-#endif // DISPATCH_MACHPORT_DEBUG
-
-// Mach channel state which may contain references to the channel object
-// layout must match dispatch_source_refs_s
-struct dispatch_mach_recv_refs_s {
-	DISPATCH_UNOTE_CLASS_HEADER();
-	dispatch_mach_handler_function_t dmrr_handler_func;
-	void *dmrr_handler_ctxt;
-};
-typedef struct dispatch_mach_recv_refs_s *dispatch_mach_recv_refs_t;
-
-struct dispatch_mach_reply_refs_s {
-	DISPATCH_UNOTE_CLASS_HEADER();
-	pthread_priority_t dmr_priority : 32;
-	void *dmr_ctxt;
-	voucher_t dmr_voucher;
-	LIST_ENTRY(dispatch_mach_reply_refs_s) dmr_list;
-};
-typedef struct dispatch_mach_reply_refs_s *dispatch_mach_reply_refs_t;
-
-struct dispatch_mach_reply_wait_refs_s {
-	struct dispatch_mach_reply_refs_s dwr_refs;
-	mach_port_t dwr_waiter_tid;
-};
-typedef struct dispatch_mach_reply_wait_refs_s *dispatch_mach_reply_wait_refs_t;
-
-#define _DISPATCH_MACH_STATE_UNUSED_MASK        0xffffff8000000000ull
-#define DISPATCH_MACH_STATE_ENQUEUED            0x0000008000000000ull
-#define DISPATCH_MACH_STATE_DIRTY               0x0000002000000000ull
-#define DISPATCH_MACH_STATE_PENDING_BARRIER     0x0000001000000000ull
-#define DISPATCH_MACH_STATE_RECEIVED_OVERRIDE   0x0000000800000000ull
-#define DISPATCH_MACH_STATE_MAX_QOS_MASK        0x0000000700000000ull
-#define DISPATCH_MACH_STATE_MAX_QOS_SHIFT       32
-#define DISPATCH_MACH_STATE_UNLOCK_MASK         0x00000000ffffffffull
-
-struct dispatch_mach_send_refs_s {
-	DISPATCH_UNOTE_CLASS_HEADER();
-	dispatch_unfair_lock_s dmsr_replies_lock;
-	dispatch_mach_msg_t dmsr_checkin;
-	LIST_HEAD(, dispatch_mach_reply_refs_s) dmsr_replies;
-#define DISPATCH_MACH_NEVER_CONNECTED      0x80000000
-	DISPATCH_UNION_LE(uint64_t volatile dmsr_state,
-		dispatch_unfair_lock_s dmsr_state_lock,
-		uint32_t dmsr_state_bits
-	) DISPATCH_ATOMIC64_ALIGN;
-	struct dispatch_object_s *volatile dmsr_tail;
-	struct dispatch_object_s *volatile dmsr_head;
-	uint32_t volatile dmsr_disconnect_cnt;
-	mach_port_t dmsr_send, dmsr_checkin_port;
-};
-typedef struct dispatch_mach_send_refs_s *dispatch_mach_send_refs_t;
-
-bool _dispatch_mach_notification_armed(dispatch_mach_send_refs_t dmsr);
-void _dispatch_mach_notification_set_armed(dispatch_mach_send_refs_t dmsr);
-
-struct dispatch_xpc_term_refs_s {
-	DISPATCH_UNOTE_CLASS_HEADER();
-};
-typedef struct dispatch_xpc_term_refs_s *dispatch_xpc_term_refs_t;
-void _dispatch_sync_ipc_handoff_begin(dispatch_wlh_t wlh, mach_port_t port,
-		uint64_t _Atomic *addr);
-void _dispatch_sync_ipc_handoff_end(dispatch_wlh_t wlh, mach_port_t port);
-#endif // HAVE_MACH
-
-typedef union dispatch_unote_u {
-	dispatch_unote_class_t _du;
-	dispatch_source_refs_t _dr;
-	dispatch_timer_source_refs_t _dt;
-#if HAVE_MACH
-	dispatch_mach_recv_refs_t _dmrr;
-	dispatch_mach_send_refs_t _dmsr;
-	dispatch_mach_reply_refs_t _dmr;
-	dispatch_xpc_term_refs_t _dxtr;
-#endif
-} dispatch_unote_t DISPATCH_TRANSPARENT_UNION;
-
-#define DISPATCH_UNOTE_NULL ((dispatch_unote_t){ ._du = NULL })
-
-#if TARGET_OS_IPHONE
-#define DSL_HASH_SIZE  64u // must be a power of two
-#else
-#define DSL_HASH_SIZE 256u // must be a power of two
-#endif
-#define DSL_HASH(x) ((x) & (DSL_HASH_SIZE - 1))
-
-typedef struct dispatch_unote_linkage_s {
-	LIST_ENTRY(dispatch_unote_linkage_s) du_link;
-	struct dispatch_muxnote_s *du_muxnote;
-} DISPATCH_ATOMIC64_ALIGN *dispatch_unote_linkage_t;
-
-DISPATCH_ENUM(dispatch_unote_action, uint8_t,
-	DISPATCH_UNOTE_ACTION_PASS_DATA,        // pass ke->data
-	DISPATCH_UNOTE_ACTION_PASS_FFLAGS,      // pass ke->fflags
-	DISPATCH_UNOTE_ACTION_SOURCE_OR_FFLAGS, // ds_pending_data |= ke->fflags
-	DISPATCH_UNOTE_ACTION_SOURCE_SET_DATA,  // ds_pending_data = ~ke->data
-	DISPATCH_UNOTE_ACTION_SOURCE_ADD_DATA,  // ds_pending_data += ke->data
-	DISPATCH_UNOTE_ACTION_SOURCE_TIMER,     // timer
-);
-
-typedef struct dispatch_source_type_s {
-	const char *dst_kind;
-	int8_t     dst_filter;
-	dispatch_unote_action_t dst_action;
-	uint8_t    dst_per_trigger_qos : 1;
-	uint8_t    dst_strict : 1;
-	uint8_t    dst_timer_flags;
-	uint16_t   dst_flags;
-#if DISPATCH_EVENT_BACKEND_KEVENT
-	uint16_t   dst_data;
-#endif
-	uint32_t   dst_fflags;
-	uint32_t   dst_mask;
-	uint32_t   dst_size;
-
-	dispatch_unote_t (*dst_create)(dispatch_source_type_t dst,
-			uintptr_t handle, uintptr_t mask);
-#if DISPATCH_EVENT_BACKEND_KEVENT
-	bool (*dst_update_mux)(struct dispatch_muxnote_s *dmn);
-#endif
-	void (*dst_merge_evt)(dispatch_unote_t du, uint32_t flags, uintptr_t data,
-			pthread_priority_t pp);
-#if HAVE_MACH
-	void (*dst_merge_msg)(dispatch_unote_t du, uint32_t flags,
-			mach_msg_header_t *msg, mach_msg_size_t sz,
-			pthread_priority_t msg_pp, pthread_priority_t override_pp);
-#endif
-} dispatch_source_type_s;
-
-#define dux_create(dst, handle, mask)	(dst)->dst_create(dst, handle, mask)
-#define dux_type(du)           (du)->du_type
-#define dux_needs_rearm(du)    (dux_type(du)->dst_flags & (EV_ONESHOT | EV_DISPATCH))
-#define dux_merge_evt(du, ...) dux_type(du)->dst_merge_evt(du, __VA_ARGS__)
-#define dux_merge_msg(du, ...) dux_type(du)->dst_merge_msg(du, __VA_ARGS__)
-
-extern const dispatch_source_type_s _dispatch_source_type_after;
-
-#if HAVE_MACH
-extern const dispatch_source_type_s _dispatch_mach_type_notification;
-extern const dispatch_source_type_s _dispatch_mach_type_send;
-extern const dispatch_source_type_s _dispatch_mach_type_recv;
-extern const dispatch_source_type_s _dispatch_mach_type_reply;
-extern const dispatch_source_type_s _dispatch_xpc_type_sigterm;
-#define DISPATCH_MACH_TYPE_WAITER ((const dispatch_source_type_s *)-2)
-#endif
-extern const dispatch_source_type_s _dispatch_source_type_timer_with_clock;
-
-#pragma mark -
-#pragma mark deferred items
-
-#if DISPATCH_EVENT_BACKEND_KEVENT
-#if DISPATCH_USE_KEVENT_QOS
-typedef struct kevent_qos_s dispatch_kevent_s;
-#else
-typedef struct kevent dispatch_kevent_s;
-#endif
-typedef dispatch_kevent_s *dispatch_kevent_t;
-#endif // DISPATCH_EVENT_BACKEND_KEVENT
-
-#define DISPATCH_DEFERRED_ITEMS_EVENT_COUNT 16
-
-typedef struct dispatch_deferred_items_s {
-	dispatch_queue_global_t ddi_stashed_rq;
-	dispatch_object_t ddi_stashed_dou;
-	dispatch_qos_t ddi_stashed_qos;
-	dispatch_wlh_t ddi_wlh;
-#if DISPATCH_EVENT_BACKEND_KEVENT
-	dispatch_kevent_t ddi_eventlist;
-	uint16_t ddi_nevents;
-	uint16_t ddi_maxevents;
-	bool     ddi_can_stash;
-	uint16_t ddi_wlh_needs_delete : 1;
-	uint16_t ddi_wlh_needs_update : 1;
-	uint16_t ddi_wlh_servicing : 1;
-#endif
-} dispatch_deferred_items_s, *dispatch_deferred_items_t;
-
-#pragma mark -
-#pragma mark inlines
-
-#if DISPATCH_PURE_C
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_deferred_items_set(dispatch_deferred_items_t ddi)
-{
-	_dispatch_thread_setspecific(dispatch_deferred_items_key, (void *)ddi);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_deferred_items_t
-_dispatch_deferred_items_get(void)
-{
-	return (dispatch_deferred_items_t)
-			_dispatch_thread_getspecific(dispatch_deferred_items_key);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dispatch_needs_to_return_to_kernel(void)
-{
-	return (uintptr_t)_dispatch_thread_getspecific(dispatch_r2k_key) != 0;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_set_return_to_kernel(void)
-{
-	_dispatch_thread_setspecific(dispatch_r2k_key, (void *)1);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_clear_return_to_kernel(void)
-{
-	_dispatch_thread_setspecific(dispatch_r2k_key, (void *)0);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_wlh_t
-_du_state_wlh(dispatch_unote_state_t du_state)
-{
-	return (dispatch_wlh_t)(du_state & DU_STATE_WLH_MASK);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_du_state_registered(dispatch_unote_state_t du_state)
-{
-	return du_state != DU_STATE_UNREGISTERED;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_du_state_armed(dispatch_unote_state_t du_state)
-{
-	return du_state & DU_STATE_ARMED;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_du_state_needs_delete(dispatch_unote_state_t du_state)
-{
-	return du_state & DU_STATE_NEEDS_DELETE;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_du_state_needs_rearm(dispatch_unote_state_t du_state)
-{
-	return _du_state_registered(du_state) && !_du_state_armed(du_state) &&
-			!_du_state_needs_delete(du_state);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_unote_state_t
-_dispatch_unote_state(dispatch_unote_t du)
-{
-	return os_atomic_load(&du._du->du_state, relaxed);
-}
-#define _dispatch_unote_wlh(du) \
-		_du_state_wlh(_dispatch_unote_state(du))
-#define _dispatch_unote_registered(du) \
-		_du_state_registered(_dispatch_unote_state(du))
-#define _dispatch_unote_armed(du) \
-		_du_state_armed(_dispatch_unote_state(du))
-#define _dispatch_unote_needs_delete(du) \
-		_du_state_needs_delete(_dispatch_unote_state(du))
-#define _dispatch_unote_needs_rearm(du) \
-		_du_state_needs_rearm(_dispatch_unote_state(du))
-
-DISPATCH_ALWAYS_INLINE DISPATCH_OVERLOADABLE
-static inline void
-_dispatch_unote_state_set(dispatch_unote_t du, dispatch_unote_state_t value)
-{
-	os_atomic_store(&du._du->du_state, value, relaxed);
-}
-
-DISPATCH_ALWAYS_INLINE DISPATCH_OVERLOADABLE
-static inline void
-_dispatch_unote_state_set(dispatch_unote_t du, dispatch_wlh_t wlh,
-		dispatch_unote_state_t bits)
-{
-	_dispatch_unote_state_set(du, (dispatch_unote_state_t)wlh | bits);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_unote_state_set_bit(dispatch_unote_t du, dispatch_unote_state_t bit)
-{
-	_dispatch_unote_state_set(du, _dispatch_unote_state(du) | bit);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_unote_state_clear_bit(dispatch_unote_t du, dispatch_unote_state_t bit)
-{
-	_dispatch_unote_state_set(du, _dispatch_unote_state(du) & ~bit);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dispatch_unote_wlh_changed(dispatch_unote_t du, dispatch_wlh_t expected_wlh)
-{
-	dispatch_wlh_t wlh = _dispatch_unote_wlh(du);
-	return wlh && wlh != DISPATCH_WLH_ANON && wlh != expected_wlh;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_unote_linkage_t
-_dispatch_unote_get_linkage(dispatch_unote_t du)
-{
-	dispatch_assert(!du._du->du_is_direct);
-	return (dispatch_unote_linkage_t)((char *)du._du
-			- sizeof(struct dispatch_unote_linkage_s));
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_unote_t
-_dispatch_unote_linkage_get_unote(dispatch_unote_linkage_t dul)
-{
-	return (dispatch_unote_t){ ._du = (dispatch_unote_class_t)(dul + 1) };
-}
-
-#endif // DISPATCH_PURE_C
-
-DISPATCH_ALWAYS_INLINE
-static inline unsigned long
-_dispatch_timer_unote_compute_missed(dispatch_timer_source_refs_t dt,
-		uint64_t now, unsigned long prev)
-{
-	uint64_t missed = (now - dt->dt_timer.target) / dt->dt_timer.interval;
-	if (++missed + prev > LONG_MAX) {
-		missed = LONG_MAX - prev;
-	}
-	if (dt->dt_timer.interval < INT64_MAX) {
-		uint64_t push_by = missed * dt->dt_timer.interval;
-		dt->dt_timer.target += push_by;
-		dt->dt_timer.deadline += push_by;
-	} else {
-		dt->dt_timer.target = UINT64_MAX;
-		dt->dt_timer.deadline = UINT64_MAX;
-	}
-	prev += missed;
-	return prev;
-}
-
-#pragma mark -
-#pragma mark prototypes
-
-#if DISPATCH_HAVE_TIMER_QOS
-#define DISPATCH_TIMER_QOS_NORMAL       0u
-#define DISPATCH_TIMER_QOS_CRITICAL     1u
-#define DISPATCH_TIMER_QOS_BACKGROUND   2u
-#define DISPATCH_TIMER_QOS_COUNT        3u
-#else
-#define DISPATCH_TIMER_QOS_NORMAL       0u
-#define DISPATCH_TIMER_QOS_COUNT        1u
-#endif
-
-#define DISPATCH_TIMER_QOS(tidx)   ((uint32_t)(tidx) % DISPATCH_TIMER_QOS_COUNT)
-#define DISPATCH_TIMER_CLOCK(tidx) (dispatch_clock_t)((tidx) / DISPATCH_TIMER_QOS_COUNT)
-
-#define DISPATCH_TIMER_INDEX(clock, qos) (((clock) * DISPATCH_TIMER_QOS_COUNT) + (qos))
-#define DISPATCH_TIMER_COUNT \
-		DISPATCH_TIMER_INDEX(DISPATCH_CLOCK_COUNT, 0)
-// Workloops do not support optimizing WALL timers
-#define DISPATCH_TIMER_WLH_COUNT \
-		DISPATCH_TIMER_INDEX(DISPATCH_CLOCK_WALL, 0)
-
-#define DISPATCH_TIMER_IDENT_CANCELED    (~0u)
-
-extern struct dispatch_timer_heap_s _dispatch_timers_heap[DISPATCH_TIMER_COUNT];
-
-dispatch_unote_t _dispatch_unote_create_with_handle(dispatch_source_type_t dst,
-		uintptr_t handle, uintptr_t mask);
-dispatch_unote_t _dispatch_unote_create_with_fd(dispatch_source_type_t dst,
-		uintptr_t handle, uintptr_t mask);
-dispatch_unote_t _dispatch_unote_create_without_handle(
-		dispatch_source_type_t dst, uintptr_t handle, uintptr_t mask);
-void _dispatch_unote_dispose(dispatch_unote_t du);
-
-/*
- * @const DUU_DELETE_ACK
- * Unregistration can acknowledge the "needs-delete" state of a unote.
- * There must be some sort of synchronization between callers passing this flag
- * for a given unote.
- *
- * @const DUU_PROBE
- * This flag is passed for the first unregistration attempt of a unote.
- * When passed, it allows the unregistration to speculatively try to do the
- * unregistration syscalls and maybe get lucky. If the flag isn't passed,
- * unregistration will preflight the attempt, and will not perform any syscall
- * if it cannot guarantee their success.
- *
- * @const DUU_MUST_SUCCEED
- * The caller expects the unregistration to always succeeed.
- * _dispatch_unote_unregister will either crash or return true.
- */
-#define DUU_DELETE_ACK   0x1
-#define DUU_PROBE        0x2
-#define DUU_MUST_SUCCEED 0x4
-bool _dispatch_unote_unregister(dispatch_unote_t du, uint32_t flags);
-bool _dispatch_unote_register(dispatch_unote_t du, dispatch_wlh_t wlh,
-		dispatch_priority_t pri);
-void _dispatch_unote_resume(dispatch_unote_t du);
-
-bool _dispatch_unote_unregister_muxed(dispatch_unote_t du);
-bool _dispatch_unote_register_muxed(dispatch_unote_t du);
-void _dispatch_unote_resume_muxed(dispatch_unote_t du);
-
-#if DISPATCH_HAVE_DIRECT_KNOTES
-bool _dispatch_unote_unregister_direct(dispatch_unote_t du, uint32_t flags);
-bool _dispatch_unote_register_direct(dispatch_unote_t du, dispatch_wlh_t wlh);
-void _dispatch_unote_resume_direct(dispatch_unote_t du);
-#endif
-
-void _dispatch_timer_unote_configure(dispatch_timer_source_refs_t dt);
-
-#if !DISPATCH_EVENT_BACKEND_WINDOWS
-void _dispatch_event_loop_atfork_child(void);
-#endif
-#define DISPATCH_EVENT_LOOP_CONSUME_2 DISPATCH_WAKEUP_CONSUME_2
-#define DISPATCH_EVENT_LOOP_OVERRIDE  0x80000000
-void _dispatch_event_loop_poke(dispatch_wlh_t wlh, uint64_t dq_state,
-		uint32_t flags);
-void _dispatch_event_loop_cancel_waiter(struct dispatch_sync_context_s *dsc);
-void _dispatch_event_loop_wake_owner(struct dispatch_sync_context_s *dsc,
-		dispatch_wlh_t wlh, uint64_t old_state, uint64_t new_state);
-void _dispatch_event_loop_wait_for_ownership(
-		struct dispatch_sync_context_s *dsc);
-void _dispatch_event_loop_end_ownership(dispatch_wlh_t wlh,
-		uint64_t old_state, uint64_t new_state, uint32_t flags);
-#if DISPATCH_WLH_DEBUG
-void _dispatch_event_loop_assert_not_owned(dispatch_wlh_t wlh);
-#else
-#undef _dispatch_event_loop_assert_not_owned
-#define _dispatch_event_loop_assert_not_owned(wlh) ((void)wlh)
-#endif
-void _dispatch_event_loop_leave_immediate(uint64_t dq_state);
-#if DISPATCH_EVENT_BACKEND_KEVENT
-void _dispatch_event_loop_leave_deferred(dispatch_deferred_items_t ddi,
-		uint64_t dq_state);
-void _dispatch_event_loop_merge(dispatch_kevent_t events, int nevents);
-#endif
-void _dispatch_event_loop_drain(uint32_t flags);
-
-void _dispatch_event_loop_timer_arm(dispatch_timer_heap_t dth, uint32_t tidx,
-		dispatch_timer_delay_s range, dispatch_clock_now_cache_t nows);
-void _dispatch_event_loop_timer_delete(dispatch_timer_heap_t dth, uint32_t tidx);
-
-void _dispatch_event_loop_drain_timers(dispatch_timer_heap_t dth, uint32_t count);
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_timers_heap_dirty(dispatch_timer_heap_t dth, uint32_t tidx)
-{
-	// Note: the dirty bits are only maintained in the first heap for any tidx
-	dth[0].dth_dirty_bits |= (1 << DISPATCH_TIMER_QOS(tidx)) | DTH_DIRTY_GLOBAL;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_event_loop_drain_anon_timers(void)
-{
-	if (_dispatch_timers_heap[0].dth_dirty_bits) {
-		_dispatch_event_loop_drain_timers(_dispatch_timers_heap,
-				DISPATCH_TIMER_COUNT);
-	}
-}
-
-#endif /* __DISPATCH_EVENT_EVENT_INTERNAL__ */
--- a/Telegram/ThirdParty/dispatch/src/event/event_kevent.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/event/event_kevent.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,3304 +0,0 @@
-/*
- * Copyright (c) 2008-2016 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include "internal.h"
-#if DISPATCH_EVENT_BACKEND_KEVENT
-#if HAVE_MACH
-#include "protocol.h"
-#include "protocolServer.h"
-#endif
-
-#if DISPATCH_USE_KEVENT_WORKQUEUE && !DISPATCH_USE_KEVENT_QOS
-#error unsupported configuration
-#endif
-
-#define DISPATCH_KEVENT_MUXED_MARKER  1ul
-#define DISPATCH_MACH_AUDIT_TOKEN_PID (5)
-
-#define dispatch_kevent_udata_t  __typeof__(((dispatch_kevent_t)NULL)->udata)
-
-typedef struct dispatch_muxnote_s {
-	LIST_ENTRY(dispatch_muxnote_s) dmn_list;
-	LIST_HEAD(, dispatch_unote_linkage_s) dmn_unotes_head;
-	dispatch_kevent_s dmn_kev DISPATCH_ATOMIC64_ALIGN;
-} *dispatch_muxnote_t;
-
-LIST_HEAD(dispatch_muxnote_bucket_s, dispatch_muxnote_s);
-
-DISPATCH_STATIC_GLOBAL(bool _dispatch_timers_force_max_leeway);
-DISPATCH_STATIC_GLOBAL(dispatch_once_t _dispatch_kq_poll_pred);
-DISPATCH_STATIC_GLOBAL(struct dispatch_muxnote_bucket_s _dispatch_sources[DSL_HASH_SIZE]);
-
-#if defined(__APPLE__)
-#define DISPATCH_NOTE_CLOCK_WALL      NOTE_NSECONDS | NOTE_MACH_CONTINUOUS_TIME
-#define DISPATCH_NOTE_CLOCK_MONOTONIC NOTE_MACHTIME | NOTE_MACH_CONTINUOUS_TIME
-#define DISPATCH_NOTE_CLOCK_UPTIME    NOTE_MACHTIME
-#else
-#define DISPATCH_NOTE_CLOCK_WALL      0
-#define DISPATCH_NOTE_CLOCK_MONOTONIC 0
-#define DISPATCH_NOTE_CLOCK_UPTIME    0
-#endif
-
-static const uint32_t _dispatch_timer_index_to_fflags[] = {
-#define DISPATCH_TIMER_FFLAGS_INIT(kind, qos, note) \
-	[DISPATCH_TIMER_INDEX(DISPATCH_CLOCK_##kind, DISPATCH_TIMER_QOS_##qos)] = \
-			DISPATCH_NOTE_CLOCK_##kind | NOTE_ABSOLUTE | NOTE_LEEWAY | (note)
-	DISPATCH_TIMER_FFLAGS_INIT(WALL, NORMAL, 0),
-	DISPATCH_TIMER_FFLAGS_INIT(UPTIME, NORMAL, 0),
-	DISPATCH_TIMER_FFLAGS_INIT(MONOTONIC, NORMAL, 0),
-#if DISPATCH_HAVE_TIMER_QOS
-	DISPATCH_TIMER_FFLAGS_INIT(WALL, CRITICAL, NOTE_CRITICAL),
-	DISPATCH_TIMER_FFLAGS_INIT(UPTIME, CRITICAL, NOTE_CRITICAL),
-	DISPATCH_TIMER_FFLAGS_INIT(MONOTONIC, CRITICAL, NOTE_CRITICAL),
-	DISPATCH_TIMER_FFLAGS_INIT(WALL, BACKGROUND, NOTE_BACKGROUND),
-	DISPATCH_TIMER_FFLAGS_INIT(UPTIME, BACKGROUND, NOTE_BACKGROUND),
-	DISPATCH_TIMER_FFLAGS_INIT(MONOTONIC, BACKGROUND, NOTE_BACKGROUND),
-#endif
-#undef DISPATCH_TIMER_FFLAGS_INIT
-};
-
-static inline void _dispatch_kevent_timer_drain(dispatch_kevent_t ke);
-#if DISPATCH_USE_KEVENT_WORKLOOP
-static void _dispatch_kevent_workloop_poke_drain(dispatch_kevent_t ke);
-#endif
-
-#pragma mark -
-#pragma mark kevent debug
-
-DISPATCH_NOINLINE
-static const char *
-_evfiltstr(short filt)
-{
-	switch (filt) {
-#define _evfilt2(f) case (f): return #f
-	_evfilt2(EVFILT_READ);
-	_evfilt2(EVFILT_WRITE);
-	_evfilt2(EVFILT_SIGNAL);
-	_evfilt2(EVFILT_TIMER);
-
-#ifdef DISPATCH_EVENT_BACKEND_KEVENT
-	_evfilt2(EVFILT_AIO);
-	_evfilt2(EVFILT_VNODE);
-	_evfilt2(EVFILT_PROC);
-#if HAVE_MACH
-	_evfilt2(EVFILT_MACHPORT);
-	_evfilt2(DISPATCH_EVFILT_MACH_NOTIFICATION);
-#endif
-	_evfilt2(EVFILT_FS);
-	_evfilt2(EVFILT_USER);
-#ifdef EVFILT_SOCK
-	_evfilt2(EVFILT_SOCK);
-#endif
-#ifdef EVFILT_MEMORYSTATUS
-	_evfilt2(EVFILT_MEMORYSTATUS);
-#endif
-#if DISPATCH_USE_KEVENT_WORKLOOP
-	_evfilt2(EVFILT_WORKLOOP);
-#endif // DISPATCH_USE_KEVENT_WORKLOOP
-#endif // DISPATCH_EVENT_BACKEND_KEVENT
-
-	_evfilt2(DISPATCH_EVFILT_TIMER);
-	_evfilt2(DISPATCH_EVFILT_TIMER_WITH_CLOCK);
-	_evfilt2(DISPATCH_EVFILT_CUSTOM_ADD);
-	_evfilt2(DISPATCH_EVFILT_CUSTOM_OR);
-	_evfilt2(DISPATCH_EVFILT_CUSTOM_REPLACE);
-	default:
-		return "EVFILT_missing";
-	}
-}
-
-#if DISPATCH_DEBUG
-static const char *
-_evflagstr2(uint16_t *flagsp)
-{
-#define _evflag2(f) \
-	if ((*flagsp & (f)) == (f) && (f)) { \
-		*flagsp &= ~(f); \
-		return #f "|"; \
-	}
-	_evflag2(EV_ADD);
-	_evflag2(EV_DELETE);
-	_evflag2(EV_ENABLE);
-	_evflag2(EV_DISABLE);
-	_evflag2(EV_ONESHOT);
-	_evflag2(EV_CLEAR);
-	_evflag2(EV_RECEIPT);
-	_evflag2(EV_DISPATCH);
-	_evflag2(EV_UDATA_SPECIFIC);
-#ifdef EV_POLL
-	_evflag2(EV_POLL);
-#endif
-#ifdef EV_OOBAND
-	_evflag2(EV_OOBAND);
-#endif
-	_evflag2(EV_ERROR);
-	_evflag2(EV_EOF);
-	_evflag2(EV_VANISHED);
-	*flagsp = 0;
-	return "EV_UNKNOWN ";
-}
-
-DISPATCH_NOINLINE
-static const char *
-_evflagstr(uint16_t flags, char *str, size_t strsize)
-{
-	str[0] = 0;
-	while (flags) {
-		strlcat(str, _evflagstr2(&flags), strsize);
-	}
-	size_t sz = strlen(str);
-	if (sz) str[sz-1] = 0;
-	return str;
-}
-
-DISPATCH_NOINLINE
-static void
-dispatch_kevent_debug(const char *verb, const dispatch_kevent_s *kev,
-		int i, int n, const char *function, unsigned int line)
-{
-	char flagstr[256];
-	char i_n[31];
-
-	if (n > 1) {
-		snprintf(i_n, sizeof(i_n), "%d/%d ", i + 1, n);
-	} else {
-		i_n[0] = '\0';
-	}
-	if (verb == NULL) {
-		if (kev->flags & EV_DELETE) {
-			verb = "deleting";
-		} else if (kev->flags & EV_ADD) {
-			verb = "adding";
-		} else {
-			verb = "updating";
-		}
-	}
-#if DISPATCH_USE_KEVENT_QOS
-	_dispatch_debug("%s kevent[%p] %s= { ident = 0x%llx, filter = %s, "
-			"flags = %s (0x%x), fflags = 0x%x, data = 0x%llx, udata = 0x%llx, "
-			"qos = 0x%x, ext[0] = 0x%llx, ext[1] = 0x%llx, ext[2] = 0x%llx, "
-			"ext[3] = 0x%llx }: %s #%u", verb, kev, i_n,
-			(unsigned long long)kev->ident, _evfiltstr(kev->filter),
-			_evflagstr(kev->flags, flagstr, sizeof(flagstr)), kev->flags, kev->fflags,
-			(unsigned long long)kev->data, (unsigned long long)kev->udata, kev->qos,
-			kev->ext[0], kev->ext[1], kev->ext[2], kev->ext[3],
-			function, line);
-#else
-	_dispatch_debug("%s kevent[%p] %s= { ident = 0x%llx, filter = %s, "
-			"flags = %s (0x%x), fflags = 0x%x, data = 0x%llx, udata = 0x%llx}: "
-			"%s #%u", verb, kev, i_n,
-			(unsigned long long)kev->ident, _evfiltstr(kev->filter),
-			_evflagstr(kev->flags, flagstr, sizeof(flagstr)), kev->flags,
-			kev->fflags, (unsigned long long)kev->data,
-			(unsigned long long)kev->udata,
-			function, line);
-#endif
-}
-#else
-static inline void
-dispatch_kevent_debug(const char *verb, const dispatch_kevent_s *kev,
-		int i, int n, const char *function, unsigned int line)
-{
-	(void)verb; (void)kev; (void)i; (void)n; (void)function; (void)line;
-}
-#endif // DISPATCH_DEBUG
-#define _dispatch_kevent_debug_n(verb, _kev, i, n) \
-		dispatch_kevent_debug(verb, _kev, i, n, __FUNCTION__, __LINE__)
-#define _dispatch_kevent_debug(verb, _kev) \
-		_dispatch_kevent_debug_n(verb, _kev, 0, 0)
-#if DISPATCH_MGR_QUEUE_DEBUG
-#define _dispatch_kevent_mgr_debug(verb, kev) _dispatch_kevent_debug(verb, kev)
-#else
-#define _dispatch_kevent_mgr_debug(verb, kev) ((void)verb, (void)kev)
-#endif // DISPATCH_MGR_QUEUE_DEBUG
-#if DISPATCH_WLH_DEBUG
-#define _dispatch_kevent_wlh_debug(verb, kev) _dispatch_kevent_debug(verb, kev)
-#else
-#define _dispatch_kevent_wlh_debug(verb, kev)  ((void)verb, (void)kev)
-#endif // DISPATCH_WLH_DEBUG
-
-#define _dispatch_du_debug(what, du) \
-		_dispatch_debug("kevent-source[%p]: %s kevent[%p] " \
-				"{ filter = %s, ident = 0x%x }", \
-				_dispatch_wref2ptr((du)->du_owner_wref), what, \
-				(du), _evfiltstr((du)->du_filter), (du)->du_ident)
-
-#if DISPATCH_MACHPORT_DEBUG
-#ifndef MACH_PORT_TYPE_SPREQUEST
-#define MACH_PORT_TYPE_SPREQUEST 0x40000000
-#endif
-
-DISPATCH_NOINLINE
-void
-dispatch_debug_machport(mach_port_t name, const char* str)
-{
-	mach_port_type_t type;
-	mach_msg_bits_t ns = 0, nr = 0, nso = 0, nd = 0;
-	unsigned int dnreqs = 0, dnrsiz;
-	kern_return_t kr = mach_port_type(mach_task_self(), name, &type);
-	if (kr) {
-		_dispatch_log("machport[0x%08x] = { error(0x%x) \"%s\" }: %s", name,
-				kr, mach_error_string(kr), str);
-		return;
-	}
-	if (type & MACH_PORT_TYPE_SEND) {
-		(void)dispatch_assume_zero(mach_port_get_refs(mach_task_self(), name,
-				MACH_PORT_RIGHT_SEND, &ns));
-	}
-	if (type & MACH_PORT_TYPE_SEND_ONCE) {
-		(void)dispatch_assume_zero(mach_port_get_refs(mach_task_self(), name,
-				MACH_PORT_RIGHT_SEND_ONCE, &nso));
-	}
-	if (type & MACH_PORT_TYPE_DEAD_NAME) {
-		(void)dispatch_assume_zero(mach_port_get_refs(mach_task_self(), name,
-				MACH_PORT_RIGHT_DEAD_NAME, &nd));
-	}
-	if (type & (MACH_PORT_TYPE_RECEIVE|MACH_PORT_TYPE_SEND)) {
-		kr = mach_port_dnrequest_info(mach_task_self(), name, &dnrsiz, &dnreqs);
-		if (kr != KERN_INVALID_RIGHT) (void)dispatch_assume_zero(kr);
-	}
-	if (type & MACH_PORT_TYPE_RECEIVE) {
-		mach_port_status_t status = { .mps_pset = 0, };
-		mach_msg_type_number_t cnt = MACH_PORT_RECEIVE_STATUS_COUNT;
-		(void)dispatch_assume_zero(mach_port_get_refs(mach_task_self(), name,
-				MACH_PORT_RIGHT_RECEIVE, &nr));
-		(void)dispatch_assume_zero(mach_port_get_attributes(mach_task_self(),
-				name, MACH_PORT_RECEIVE_STATUS, (void*)&status, &cnt));
-		_dispatch_log("machport[0x%08x] = { R(%03u) S(%03u) SO(%03u) D(%03u) "
-				"dnreqs(%03u) spreq(%s) nsreq(%s) pdreq(%s) srights(%s) "
-				"sorights(%03u) qlim(%03u) msgcount(%03u) mkscount(%03u) "
-				"seqno(%03u) }: %s", name, nr, ns, nso, nd, dnreqs,
-				type & MACH_PORT_TYPE_SPREQUEST ? "Y":"N",
-				status.mps_nsrequest ? "Y":"N", status.mps_pdrequest ? "Y":"N",
-				status.mps_srights ? "Y":"N", status.mps_sorights,
-				status.mps_qlimit, status.mps_msgcount, status.mps_mscount,
-				status.mps_seqno, str);
-	} else if (type & (MACH_PORT_TYPE_SEND|MACH_PORT_TYPE_SEND_ONCE|
-			MACH_PORT_TYPE_DEAD_NAME)) {
-		_dispatch_log("machport[0x%08x] = { R(%03u) S(%03u) SO(%03u) D(%03u) "
-				"dnreqs(%03u) spreq(%s) }: %s", name, nr, ns, nso, nd, dnreqs,
-				type & MACH_PORT_TYPE_SPREQUEST ? "Y":"N", str);
-	} else {
-		_dispatch_log("machport[0x%08x] = { type(0x%08x) }: %s", name, type,
-				str);
-	}
-}
-#endif
-
-#pragma mark dispatch_kevent_t
-
-#if HAVE_MACH
-
-DISPATCH_STATIC_GLOBAL(dispatch_once_t _dispatch_mach_host_port_pred);
-DISPATCH_STATIC_GLOBAL(mach_port_t _dispatch_mach_host_port);
-
-static inline void*
-_dispatch_kevent_mach_msg_buf(dispatch_kevent_t ke)
-{
-	return (void*)ke->ext[0];
-}
-
-static inline mach_msg_size_t
-_dispatch_kevent_mach_msg_size(dispatch_kevent_t ke)
-{
-	// buffer size in the successful receive case, but message size (like
-	// msgh_size) in the MACH_RCV_TOO_LARGE case, i.e. add trailer size.
-	return (mach_msg_size_t)ke->ext[1];
-}
-
-static void _dispatch_kevent_mach_msg_drain(dispatch_kevent_t ke);
-static inline void _dispatch_mach_host_calendar_change_register(void);
-
-// DISPATCH_MACH_NOTIFICATION_ARMED are muxnotes that aren't registered with
-// kevent for real, but with mach_port_request_notification()
-//
-// the kevent structure is used for bookkeeping:
-// - ident, filter, flags and fflags have their usual meaning
-// - data is used to monitor the actual state of the
-//   mach_port_request_notification()
-// - ext[0] is a boolean that trackes whether the notification is armed or not
-#define DISPATCH_MACH_NOTIFICATION_ARMED(dmn) ((dmn)->dmn_kev.ext[0])
-#endif
-
-DISPATCH_ALWAYS_INLINE
-static dispatch_muxnote_t
-_dispatch_kevent_get_muxnote(dispatch_kevent_t ke)
-{
-	uintptr_t dmn_addr = (uintptr_t)ke->udata & ~DISPATCH_KEVENT_MUXED_MARKER;
-	return (dispatch_muxnote_t)dmn_addr;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dispatch_kevent_unote_is_muxed(dispatch_kevent_t ke)
-{
-	return ((uintptr_t)ke->udata) & DISPATCH_KEVENT_MUXED_MARKER;
-}
-
-DISPATCH_ALWAYS_INLINE
-static dispatch_unote_t
-_dispatch_kevent_get_unote(dispatch_kevent_t ke)
-{
-	dispatch_assert(_dispatch_kevent_unote_is_muxed(ke) == false);
-	return (dispatch_unote_t){ ._du = (dispatch_unote_class_t)ke->udata };
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_kevent_print_error(dispatch_kevent_t ke)
-{
-	dispatch_unote_class_t du = NULL;
-	_dispatch_debug("kevent[0x%llx]: handling error",
-			(unsigned long long)ke->udata);
-	if (ke->flags & EV_DELETE) {
-		if (ke->flags & EV_UDATA_SPECIFIC) {
-			if (ke->data == EINPROGRESS) {
-				// deferred EV_DELETE
-				return;
-			}
-		}
-		// for EV_DELETE if the update was deferred we may have reclaimed
-		// the udata already, and it is unsafe to dereference it now.
-	} else if (_dispatch_kevent_unote_is_muxed(ke)) {
-		ke->flags |= _dispatch_kevent_get_muxnote(ke)->dmn_kev.flags;
-	} else if (ke->udata) {
-		du = (dispatch_unote_class_t)(uintptr_t)ke->udata;
-		if (!_dispatch_unote_registered(du)) {
-			ke->flags |= EV_ADD;
-		}
-	}
-
-	switch (ke->data) {
-	case 0:
-		return;
-	case ERANGE: /* A broken QoS was passed to kevent_id() */
-		DISPATCH_INTERNAL_CRASH(ke->qos, "Invalid kevent priority");
-	default:
-		// log the unexpected error
-		_dispatch_bug_kevent_client("kevent", _evfiltstr(ke->filter),
-				!ke->udata ? NULL :
-				ke->flags & EV_DELETE ? "delete" :
-				ke->flags & EV_ADD ? "add" :
-				ke->flags & EV_ENABLE ? "enable" : "monitor",
-				(int)ke->data, ke->ident, ke->udata, du);
-	}
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_kevent_merge_ev_flags(dispatch_unote_t du, uint32_t flags)
-{
-	if (unlikely(!(flags & EV_UDATA_SPECIFIC) && (flags & EV_ONESHOT))) {
-		_dispatch_unote_unregister(du, DUU_DELETE_ACK | DUU_MUST_SUCCEED);
-		return;
-	}
-
-	if (flags & EV_DELETE) {
-		// When a speculative deletion is requested by libdispatch,
-		// and the kernel is about to deliver an event, it can acknowledge
-		// our wish by delivering the event as a (EV_DELETE | EV_ONESHOT)
-		// event and dropping the knote at once.
-		_dispatch_unote_state_set(du, DU_STATE_NEEDS_DELETE);
-	} else if (flags & (EV_ONESHOT | EV_VANISHED)) {
-		// EV_VANISHED events if re-enabled will produce another EV_VANISHED
-		// event. To avoid an infinite loop of such events, mark the unote
-		// as needing deletion so that _dispatch_unote_needs_rearm()
-		// eventually returns false.
-		//
-		// mach channels crash on EV_VANISHED, and dispatch sources stay
-		// in a limbo until canceled (explicitly or not).
-		dispatch_unote_state_t du_state = _dispatch_unote_state(du);
-		du_state |= DU_STATE_NEEDS_DELETE;
-		du_state &= ~DU_STATE_ARMED;
-		_dispatch_unote_state_set(du, du_state);
-	} else if (likely(flags & EV_DISPATCH)) {
-		_dispatch_unote_state_clear_bit(du, DU_STATE_ARMED);
-	} else {
-		return;
-	}
-
-	_dispatch_du_debug((flags & EV_VANISHED) ? "vanished" :
-			(flags & EV_DELETE) ? "deleted oneshot" :
-			(flags & EV_ONESHOT) ? "oneshot" : "disarmed", du._du);
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_kevent_merge(dispatch_unote_t du, dispatch_kevent_t ke)
-{
-	dispatch_unote_action_t action = dux_type(du._du)->dst_action;
-	pthread_priority_t pp = 0;
-	uintptr_t data;
-
-	// once we modify the queue atomic flags below, it will allow concurrent
-	// threads running _dispatch_source_invoke2 to dispose of the source,
-	// so we can't safely borrow the reference we get from the muxnote udata
-	// anymore, and need our own <rdar://20382435>
-	_dispatch_retain_unote_owner(du);
-
-	switch (action) {
-	case DISPATCH_UNOTE_ACTION_PASS_DATA:
-		data = (uintptr_t)ke->data;
-		break;
-
-	case DISPATCH_UNOTE_ACTION_PASS_FFLAGS:
-		data = (uintptr_t)ke->fflags;
-#if HAVE_MACH
-		if (du._du->du_filter == EVFILT_MACHPORT) {
-			data = DISPATCH_MACH_RECV_MESSAGE;
-		}
-#endif
-		break;
-
-	case DISPATCH_UNOTE_ACTION_SOURCE_SET_DATA:
-		// ke->data is signed and "negative available data" makes no sense
-		// zero bytes happens when EV_EOF is set
-		dispatch_assert(ke->data >= 0l);
-		data = (unsigned long)ke->data;
-		os_atomic_store2o(du._dr, ds_pending_data, ~data, relaxed);
-		break;
-
-	case DISPATCH_UNOTE_ACTION_SOURCE_ADD_DATA:
-		data = (unsigned long)ke->data;
-		if (data) os_atomic_add2o(du._dr, ds_pending_data, data, relaxed);
-		break;
-
-	case DISPATCH_UNOTE_ACTION_SOURCE_OR_FFLAGS:
-		data = ke->fflags & du._du->du_fflags;
-		if (du._dr->du_has_extended_status) {
-			uint64_t odata, ndata, value;
-			uint32_t status = (uint32_t)ke->data;
-
-			// We combine the data and status into a single 64-bit value.
-			value = DISPATCH_SOURCE_COMBINE_DATA_AND_STATUS(data, status);
-			os_atomic_rmw_loop2o(du._dr, ds_pending_data, odata, ndata, relaxed, {
-				ndata = DISPATCH_SOURCE_GET_DATA(odata) | value;
-			});
-#if HAVE_MACH
-		} else if (du._du->du_filter == EVFILT_MACHPORT) {
-			data = DISPATCH_MACH_RECV_MESSAGE;
-			os_atomic_store2o(du._dr, ds_pending_data, data, relaxed);
-#endif
-		} else {
-			if (data) os_atomic_or2o(du._dr, ds_pending_data, data, relaxed);
-		}
-		break;
-
-	default:
-		DISPATCH_INTERNAL_CRASH(action, "Corrupt unote action");
-	}
-
-	_dispatch_kevent_merge_ev_flags(du, ke->flags);
-#if DISPATCH_USE_KEVENT_QOS
-	pp = ((pthread_priority_t)ke->qos) & ~_PTHREAD_PRIORITY_FLAGS_MASK;
-#endif
-	return dux_merge_evt(du._du, ke->flags, data, pp);
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_kevent_merge_muxed(dispatch_kevent_t ke)
-{
-	dispatch_muxnote_t dmn = _dispatch_kevent_get_muxnote(ke);
-	dispatch_unote_linkage_t dul, dul_next;
-
-	if (ke->flags & (EV_ONESHOT | EV_DELETE)) {
-		// tell _dispatch_unote_unregister_muxed() the kernel half is gone
-		dmn->dmn_kev.flags |= EV_DELETE;
-	}
-	LIST_FOREACH_SAFE(dul, &dmn->dmn_unotes_head, du_link, dul_next) {
-		_dispatch_kevent_merge(_dispatch_unote_linkage_get_unote(dul), ke);
-	}
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_kevent_drain(dispatch_kevent_t ke)
-{
-	if (ke->filter == EVFILT_USER) {
-		_dispatch_kevent_mgr_debug("received", ke);
-		return;
-	}
-#if DISPATCH_USE_KEVENT_WORKLOOP
-	if (ke->filter == EVFILT_WORKLOOP) {
-		return _dispatch_kevent_workloop_poke_drain(ke);
-	}
-#endif // DISPATCH_USE_KEVENT_WORKLOOP
-	_dispatch_kevent_debug("received", ke);
-	if (unlikely(ke->flags & EV_ERROR)) {
-		if (ke->filter == EVFILT_PROC && ke->data == ESRCH) {
-			// <rdar://problem/5067725&6626350> EVFILT_PROC may fail with ESRCH
-			// when the process exists but is a zombie. As a workaround, we
-			// simulate an exit event for any EVFILT_PROC with an invalid pid.
-			ke->flags  = EV_UDATA_SPECIFIC | EV_ONESHOT | EV_DELETE;
-			ke->fflags = NOTE_EXIT;
-			ke->data   = 0;
-			_dispatch_kevent_debug("synthetic NOTE_EXIT", ke);
-		} else {
-			return _dispatch_kevent_print_error(ke);
-		}
-	}
-	if (ke->filter == EVFILT_TIMER) {
-		return _dispatch_kevent_timer_drain(ke);
-	}
-
-#if HAVE_MACH
-	if (ke->filter == EVFILT_MACHPORT && _dispatch_kevent_mach_msg_size(ke)) {
-		return _dispatch_kevent_mach_msg_drain(ke);
-	}
-#endif
-
-	if (_dispatch_kevent_unote_is_muxed(ke)) {
-		return _dispatch_kevent_merge_muxed(ke);
-	}
-	return _dispatch_kevent_merge(_dispatch_kevent_get_unote(ke), ke);
-}
-
-#pragma mark dispatch_kq
-
-#if DISPATCH_USE_MGR_THREAD
-DISPATCH_NOINLINE
-static void
-_dispatch_kq_create(intptr_t *fd_ptr)
-{
-	static const dispatch_kevent_s kev = {
-		.ident = 1,
-		.filter = EVFILT_USER,
-		.flags = EV_ADD|EV_CLEAR,
-		.udata = (dispatch_kevent_udata_t)DISPATCH_WLH_MANAGER,
-	};
-	int kqfd;
-
-	_dispatch_fork_becomes_unsafe();
-#if DISPATCH_USE_GUARDED_FD
-	guardid_t guard = (uintptr_t)fd_ptr;
-	kqfd = guarded_kqueue_np(&guard, GUARD_CLOSE | GUARD_DUP);
-#else
-	(void)guard_ptr;
-	kqfd = kqueue();
-#endif
-	if (kqfd == -1) {
-		int err = errno;
-		switch (err) {
-		case EMFILE:
-			DISPATCH_CLIENT_CRASH(err, "kqueue() failure: "
-					"process is out of file descriptors");
-			break;
-		case ENFILE:
-			DISPATCH_CLIENT_CRASH(err, "kqueue() failure: "
-					"system is out of file descriptors");
-			break;
-		case ENOMEM:
-			DISPATCH_CLIENT_CRASH(err, "kqueue() failure: "
-					"kernel is out of memory");
-			break;
-		default:
-			DISPATCH_INTERNAL_CRASH(err, "kqueue() failure");
-			break;
-		}
-	}
-#if DISPATCH_USE_KEVENT_QOS
-	dispatch_assume_zero(kevent_qos(kqfd, &kev, 1, NULL, 0, NULL, NULL, 0));
-#else
-	dispatch_assume_zero(kevent(kqfd, &kev, 1, NULL, 0, NULL));
-#endif
-	*fd_ptr = kqfd;
-}
-#endif
-
-static inline int
-_dispatch_kq_fd(void)
-{
-	return (int)(intptr_t)_dispatch_mgr_q.do_ctxt;
-}
-
-static void
-_dispatch_kq_init(void *context)
-{
-	bool *kq_initialized = context;
-
-	_dispatch_fork_becomes_unsafe();
-	if (unlikely(getenv("LIBDISPATCH_TIMERS_FORCE_MAX_LEEWAY"))) {
-		_dispatch_timers_force_max_leeway = true;
-	}
-	*kq_initialized = true;
-
-#if DISPATCH_USE_KEVENT_WORKQUEUE
-	_dispatch_kevent_workqueue_init();
-	if (_dispatch_kevent_workqueue_enabled) {
-		int r;
-		int kqfd = _dispatch_kq_fd();
-		const dispatch_kevent_s ke = {
-			.ident = 1,
-			.filter = EVFILT_USER,
-			.flags = EV_ADD|EV_CLEAR,
-			.qos = _PTHREAD_PRIORITY_EVENT_MANAGER_FLAG,
-			.udata = (dispatch_kevent_udata_t)DISPATCH_WLH_MANAGER,
-		};
-retry:
-		r = kevent_qos(kqfd, &ke, 1, NULL, 0, NULL, NULL,
-				KEVENT_FLAG_WORKQ|KEVENT_FLAG_IMMEDIATE);
-		if (unlikely(r == -1)) {
-			int err = errno;
-			switch (err) {
-			case EINTR:
-				goto retry;
-			default:
-				DISPATCH_CLIENT_CRASH(err,
-						"Failed to initalize workqueue kevent");
-				break;
-			}
-		}
-		return;
-	}
-#endif // DISPATCH_USE_KEVENT_WORKQUEUE
-#if DISPATCH_USE_MGR_THREAD
-	_dispatch_kq_create((intptr_t *)&_dispatch_mgr_q.do_ctxt);
-	_dispatch_trace_item_push(_dispatch_mgr_q.do_targetq, &_dispatch_mgr_q);
-	dx_push(_dispatch_mgr_q.do_targetq, &_dispatch_mgr_q, 0);
-#endif // DISPATCH_USE_MGR_THREAD
-}
-
-#if DISPATCH_USE_MEMORYPRESSURE_SOURCE
-static void _dispatch_memorypressure_init(void);
-#else
-#define _dispatch_memorypressure_init() ((void)0)
-#endif
-
-DISPATCH_NOINLINE
-static int
-_dispatch_kq_poll(dispatch_wlh_t wlh, dispatch_kevent_t ke, int n,
-		dispatch_kevent_t ke_out, int n_out, void *buf, size_t *avail,
-		uint32_t flags)
-{
-	bool kq_initialized = false;
-	int r = 0;
-
-	dispatch_once_f(&_dispatch_kq_poll_pred, &kq_initialized, _dispatch_kq_init);
-	if (unlikely(kq_initialized)) {
-		// The calling thread was the one doing the initialization
-		//
-		// The event loop needs the memory pressure source and debug channel,
-		// however creating these will recursively call _dispatch_kq_poll(),
-		// so we can't quite initialize them under the dispatch once.
-		_dispatch_memorypressure_init();
-		_voucher_activity_debug_channel_init();
-	}
-
-#if !DISPATCH_USE_KEVENT_QOS
-	if (flags & KEVENT_FLAG_ERROR_EVENTS) {
-		// emulate KEVENT_FLAG_ERROR_EVENTS
-		for (r = 0; r < n; r++) {
-			ke[r].flags |= EV_RECEIPT;
-		}
-		n_out = n;
-	}
-#endif
-
-retry:
-	if (unlikely(wlh == NULL)) {
-		DISPATCH_INTERNAL_CRASH(wlh, "Invalid wlh");
-	} else if (wlh == DISPATCH_WLH_ANON) {
-		int kqfd = _dispatch_kq_fd();
-#if DISPATCH_USE_KEVENT_QOS
-		if (_dispatch_kevent_workqueue_enabled) {
-			flags |= KEVENT_FLAG_WORKQ;
-		}
-		r = kevent_qos(kqfd, ke, n, ke_out, n_out, buf, avail, flags);
-#else
-		(void)buf;
-		(void)avail;
-		const struct timespec timeout_immediately = {}, *timeout = NULL;
-		if (flags & KEVENT_FLAG_IMMEDIATE) timeout = &timeout_immediately;
-		r = kevent(kqfd, ke, n, ke_out, n_out, timeout);
-#endif
-#if DISPATCH_USE_KEVENT_WORKLOOP
-	} else {
-		flags |= KEVENT_FLAG_WORKLOOP;
-		if (!(flags & KEVENT_FLAG_ERROR_EVENTS)) {
-			flags |= KEVENT_FLAG_DYNAMIC_KQ_MUST_EXIST;
-		}
-		r = kevent_id((uintptr_t)wlh, ke, n, ke_out, n_out, buf, avail, flags);
-#endif // DISPATCH_USE_KEVENT_WORKLOOP
-	}
-	if (unlikely(r == -1)) {
-		int err = errno;
-		switch (err) {
-		case ENOMEM:
-			_dispatch_temporary_resource_shortage();
-			/* FALLTHROUGH */
-		case EINTR:
-			goto retry;
-		case EBADF:
-			DISPATCH_CLIENT_CRASH(err, "Do not close random Unix descriptors");
-#if DISPATCH_USE_KEVENT_WORKLOOP
-		case ENOENT:
-			if ((flags & KEVENT_FLAG_ERROR_EVENTS) &&
-					(flags & KEVENT_FLAG_DYNAMIC_KQ_MUST_EXIST)) {
-				return 0;
-			}
-			/* FALLTHROUGH */
-#endif // DISPATCH_USE_KEVENT_WORKLOOP
-		default:
-			DISPATCH_CLIENT_CRASH(err, "Unexpected error from kevent");
-		}
-	}
-	return r;
-}
-
-DISPATCH_NOINLINE
-static int
-_dispatch_kq_drain(dispatch_wlh_t wlh, dispatch_kevent_t ke, int n,
-		uint32_t flags)
-{
-	dispatch_kevent_s ke_out[DISPATCH_DEFERRED_ITEMS_EVENT_COUNT];
-	bool poll_for_events = !(flags & KEVENT_FLAG_ERROR_EVENTS);
-	int i, n_out = countof(ke_out), r = 0;
-	size_t *avail = NULL;
-	void *buf = NULL;
-
-#if DISPATCH_USE_KEVENT_QOS
-	size_t size;
-	if (poll_for_events) {
-		size = DISPATCH_MACH_RECEIVE_MAX_INLINE_MESSAGE_SIZE +
-				DISPATCH_MACH_TRAILER_SIZE;
-		buf = alloca(size);
-		avail = &size;
-	}
-#endif
-
-#if DISPATCH_DEBUG
-	for (r = 0; r < n; r++) {
-		if (ke[r].filter != EVFILT_USER || DISPATCH_MGR_QUEUE_DEBUG) {
-			_dispatch_kevent_debug_n(NULL, ke + r, r, n);
-		}
-	}
-#endif
-
-	if (poll_for_events) _dispatch_clear_return_to_kernel();
-	n = _dispatch_kq_poll(wlh, ke, n, ke_out, n_out, buf, avail, flags);
-	if (n == 0) {
-		r = 0;
-	} else if (flags & KEVENT_FLAG_ERROR_EVENTS) {
-		for (i = 0, r = 0; i < n; i++) {
-			if ((ke_out[i].flags & EV_ERROR) && ke_out[i].data) {
-				_dispatch_kevent_drain(&ke_out[i]);
-				r = (int)ke_out[i].data;
-			}
-		}
-	} else {
-#if DISPATCH_USE_KEVENT_WORKLOOP
-		if (ke_out[0].flags & EV_ERROR) {
-			// When kevent returns errors it doesn't process the kqueue
-			// and doesn't rearm the return-to-kernel notification
-			// We need to assume we have to go back.
-			_dispatch_set_return_to_kernel();
-		}
-#endif // DISPATCH_USE_KEVENT_WORKLOOP
-		for (i = 0, r = 0; i < n; i++) {
-			_dispatch_kevent_drain(&ke_out[i]);
-		}
-	}
-	return r;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline int
-_dispatch_kq_update_one(dispatch_wlh_t wlh, dispatch_kevent_t ke)
-{
-	return _dispatch_kq_drain(wlh, ke, 1,
-			KEVENT_FLAG_IMMEDIATE | KEVENT_FLAG_ERROR_EVENTS);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_kq_update_all(dispatch_wlh_t wlh, dispatch_kevent_t ke, int n)
-{
-	(void)_dispatch_kq_drain(wlh, ke, n,
-			KEVENT_FLAG_IMMEDIATE | KEVENT_FLAG_ERROR_EVENTS);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_kq_unote_set_kevent(dispatch_unote_t _du, dispatch_kevent_t dk,
-		uint16_t action)
-{
-	dispatch_unote_class_t du = _du._du;
-	dispatch_source_type_t dst = dux_type(du);
-	uint16_t flags = dst->dst_flags | action;
-
-	if ((flags & EV_VANISHED) && !(flags & EV_ADD)) {
-		flags &= ~EV_VANISHED;
-	}
-
-	*dk = (dispatch_kevent_s){
-		.ident  = du->du_ident,
-		.filter = dst->dst_filter,
-		.flags  = flags,
-		.udata  = (dispatch_kevent_udata_t)du,
-		.fflags = du->du_fflags | dst->dst_fflags,
-		.data   = (__typeof__(dk->data))dst->dst_data,
-#if DISPATCH_USE_KEVENT_QOS
-		.qos    = (__typeof__(dk->qos))_dispatch_priority_to_pp_prefer_fallback(
-				du->du_priority),
-#endif
-	};
-	(void)pp; // if DISPATCH_USE_KEVENT_QOS == 0
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline int
-_dispatch_kq_deferred_find_slot(dispatch_deferred_items_t ddi,
-		int16_t filter, uint64_t ident, dispatch_kevent_udata_t udata)
-{
-	dispatch_kevent_t events = ddi->ddi_eventlist;
-	int i;
-
-	for (i = 0; i < ddi->ddi_nevents; i++) {
-		if (events[i].filter == filter && events[i].ident == ident &&
-				events[i].udata == udata) {
-			break;
-		}
-	}
-	return i;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_kevent_t
-_dispatch_kq_deferred_reuse_slot(dispatch_wlh_t wlh,
-		dispatch_deferred_items_t ddi, int slot)
-{
-	if (wlh != DISPATCH_WLH_ANON) _dispatch_set_return_to_kernel();
-	if (unlikely(slot == ddi->ddi_maxevents)) {
-		int nevents = ddi->ddi_nevents;
-		ddi->ddi_nevents = 1;
-		_dispatch_kq_update_all(wlh, ddi->ddi_eventlist, nevents);
-		dispatch_assert(ddi->ddi_nevents == 1);
-		slot = 0;
-	} else if (slot == ddi->ddi_nevents) {
-		ddi->ddi_nevents++;
-	}
-	return ddi->ddi_eventlist + slot;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_kq_deferred_discard_slot(dispatch_deferred_items_t ddi, int slot)
-{
-	if (slot < ddi->ddi_nevents) {
-		int last = --ddi->ddi_nevents;
-		if (slot != last) {
-			ddi->ddi_eventlist[slot] = ddi->ddi_eventlist[last];
-		}
-	}
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_kq_deferred_update(dispatch_wlh_t wlh, dispatch_kevent_t ke)
-{
-	dispatch_deferred_items_t ddi = _dispatch_deferred_items_get();
-
-	if (ddi && ddi->ddi_wlh == wlh && ddi->ddi_maxevents) {
-		int slot = _dispatch_kq_deferred_find_slot(ddi, ke->filter, ke->ident,
-				ke->udata);
-		dispatch_kevent_t dk = _dispatch_kq_deferred_reuse_slot(wlh, ddi, slot);
-		*dk = *ke;
-		if (ke->filter != EVFILT_USER) {
-			_dispatch_kevent_mgr_debug("deferred", ke);
-		}
-	} else {
-		_dispatch_kq_update_one(wlh, ke);
-	}
-}
-
-DISPATCH_NOINLINE
-static int
-_dispatch_kq_immediate_update(dispatch_wlh_t wlh, dispatch_kevent_t ke)
-{
-	dispatch_deferred_items_t ddi = _dispatch_deferred_items_get();
-	if (ddi && ddi->ddi_wlh == wlh) {
-		int slot = _dispatch_kq_deferred_find_slot(ddi, ke->filter, ke->ident,
-				ke->udata);
-		_dispatch_kq_deferred_discard_slot(ddi, slot);
-	}
-	return _dispatch_kq_update_one(wlh, ke);
-}
-
-#if HAVE_MACH
-void
-_dispatch_sync_ipc_handoff_begin(dispatch_wlh_t wlh, mach_port_t port,
-		uint64_t _Atomic *addr)
-{
-#ifdef NOTE_WL_SYNC_IPC
-	dispatch_kevent_s ke = {
-		.ident  = port,
-		.filter = EVFILT_WORKLOOP,
-		.flags  = EV_ADD | EV_DISABLE,
-		.fflags = NOTE_WL_SYNC_IPC | NOTE_WL_IGNORE_ESTALE,
-		.udata  = (uintptr_t)wlh,
-		.ext[EV_EXTIDX_WL_ADDR]  = (uintptr_t)addr,
-		.ext[EV_EXTIDX_WL_MASK]  = ~(uintptr_t)0,
-		.ext[EV_EXTIDX_WL_VALUE] = (uintptr_t)wlh,
-	};
-	int rc = _dispatch_kq_immediate_update(wlh, &ke);
-	if (unlikely(rc)) {
-		DISPATCH_INTERNAL_CRASH(rc, "Unexpected error from kevent");
-	}
-#else
-	(void)wlh; (void)port; (void)addr;
-#endif
-}
-
-void
-_dispatch_sync_ipc_handoff_end(dispatch_wlh_t wlh, mach_port_t port)
-{
-#ifdef NOTE_WL_SYNC_IPC
-	dispatch_kevent_s ke = {
-		.ident  = port,
-		.filter = EVFILT_WORKLOOP,
-		.flags  = EV_ADD | EV_DELETE | EV_ENABLE,
-		.fflags = NOTE_WL_SYNC_IPC,
-		.udata  = (uintptr_t)wlh,
-	};
-	_dispatch_kq_deferred_update(wlh, &ke);
-#else
-	(void)wlh; (void)port;
-#endif // NOTE_WL_SYNC_IPC
-}
-#endif
-
-DISPATCH_NOINLINE
-static bool
-_dispatch_kq_unote_update(dispatch_wlh_t wlh, dispatch_unote_t _du,
-		uint16_t action_flags)
-{
-	dispatch_deferred_items_t ddi = _dispatch_deferred_items_get();
-	dispatch_unote_class_t du = _du._du;
-	dispatch_kevent_t ke;
-	int r = 0;
-
-	if (action_flags & EV_ADD) {
-		// as soon as we register we may get an event delivery and it has to
-		// see du_state already set, else it will not unregister the kevent
-		_dispatch_wlh_retain(wlh);
-		_dispatch_unote_state_set(du, wlh, DU_STATE_ARMED);
-	}
-
-	if (ddi && ddi->ddi_wlh == wlh) {
-		int slot = _dispatch_kq_deferred_find_slot(ddi,
-				du->du_filter, du->du_ident, (dispatch_kevent_udata_t)du);
-		if (slot < ddi->ddi_nevents) {
-			// <rdar://problem/26202376> when deleting and an enable is pending,
-			// we must merge EV_ENABLE to do an immediate deletion
-			action_flags |= (ddi->ddi_eventlist[slot].flags & EV_ENABLE);
-		}
-
-		if (!(action_flags & EV_ADD) && (action_flags & EV_ENABLE)) {
-			// can be deferred, so do it!
-			ke = _dispatch_kq_deferred_reuse_slot(wlh, ddi, slot);
-			_dispatch_kq_unote_set_kevent(du, ke, action_flags);
-			_dispatch_kevent_debug("deferred", ke);
-			goto done;
-		}
-
-		// get rid of the deferred item if any, we can't wait
-		_dispatch_kq_deferred_discard_slot(ddi, slot);
-	}
-
-	if (action_flags) {
-		dispatch_kevent_s dk;
-		_dispatch_kq_unote_set_kevent(du, &dk, action_flags);
-		r = _dispatch_kq_update_one(wlh, &dk);
-	}
-
-done:
-	if (action_flags & EV_ADD) {
-		if (unlikely(r)) {
-			_dispatch_wlh_release(wlh);
-			_dispatch_unote_state_set(du, DU_STATE_UNREGISTERED);
-		} else {
-			_dispatch_du_debug("installed", du);
-		}
-		return r == 0;
-	}
-
-	if (action_flags & EV_DELETE) {
-		if (r == EINPROGRESS) {
-			_dispatch_du_debug("deferred delete", du);
-			return false;
-		}
-		_dispatch_wlh_release(wlh);
-		_dispatch_unote_state_set(du, DU_STATE_UNREGISTERED);
-		_dispatch_du_debug("deleted", du);
-	} else if (action_flags & EV_ENABLE) {
-		_dispatch_du_debug("rearmed", du);
-	}
-
-	dispatch_assume_zero(r);
-	return true;
-}
-
-#pragma mark dispatch_muxnote_t
-
-DISPATCH_ALWAYS_INLINE
-static inline struct dispatch_muxnote_bucket_s *
-_dispatch_muxnote_bucket(uint64_t ident, int16_t filter)
-{
-	switch (filter) {
-#if HAVE_MACH
-	case EVFILT_MACHPORT:
-	case DISPATCH_EVFILT_MACH_NOTIFICATION:
-		ident = MACH_PORT_INDEX(ident);
-		break;
-#endif
-	case EVFILT_SIGNAL: // signo
-	case EVFILT_PROC: // pid_t
-	default: // fd
-		break;
-	}
-
-	return &_dispatch_sources[DSL_HASH((uintptr_t)ident)];
-}
-#define _dispatch_unote_muxnote_bucket(du) \
-	_dispatch_muxnote_bucket(du._du->du_ident, du._du->du_filter)
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_muxnote_t
-_dispatch_muxnote_find(struct dispatch_muxnote_bucket_s *dmb,
-		uint64_t ident, int16_t filter)
-{
-	dispatch_muxnote_t dmn;
-	LIST_FOREACH(dmn, dmb, dmn_list) {
-		if (dmn->dmn_kev.ident == ident && dmn->dmn_kev.filter == filter) {
-			break;
-		}
-	}
-	return dmn;
-}
-
-#if HAVE_MACH
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_muxnote_t
-_dispatch_mach_muxnote_find(mach_port_t name, int16_t filter)
-{
-	struct dispatch_muxnote_bucket_s *dmb;
-	dmb = _dispatch_muxnote_bucket(name, filter);
-	return _dispatch_muxnote_find(dmb, name, filter);
-}
-#endif
-
-bool
-_dispatch_unote_register_muxed(dispatch_unote_t du)
-{
-	struct dispatch_muxnote_bucket_s *dmb = _dispatch_unote_muxnote_bucket(du);
-	dispatch_muxnote_t dmn;
-	bool installed = true;
-
-	dmn = _dispatch_muxnote_find(dmb, du._du->du_ident, du._du->du_filter);
-	if (dmn) {
-		uint32_t flags = du._du->du_fflags & ~dmn->dmn_kev.fflags;
-		if (flags) {
-			dmn->dmn_kev.fflags |= flags;
-			if (unlikely(dux_type(du._du)->dst_update_mux)) {
-				installed = dux_type(du._du)->dst_update_mux(dmn);
-			} else {
-				installed = !_dispatch_kq_immediate_update(DISPATCH_WLH_ANON,
-						&dmn->dmn_kev);
-			}
-			if (!installed) dmn->dmn_kev.fflags &= ~flags;
-		}
-	} else {
-		dmn = _dispatch_calloc(1, sizeof(struct dispatch_muxnote_s));
-		_dispatch_kq_unote_set_kevent(du, &dmn->dmn_kev, EV_ADD | EV_ENABLE);
-#if DISPATCH_USE_KEVENT_QOS
-		dmn->dmn_kev.qos = _PTHREAD_PRIORITY_EVENT_MANAGER_FLAG;
-#endif
-		dmn->dmn_kev.udata = (dispatch_kevent_udata_t)((uintptr_t)dmn |
-				DISPATCH_KEVENT_MUXED_MARKER);
-		if (unlikely(dux_type(du._du)->dst_update_mux)) {
-			installed = dux_type(du._du)->dst_update_mux(dmn);
-		} else {
-			installed = !_dispatch_kq_immediate_update(DISPATCH_WLH_ANON,
-					&dmn->dmn_kev);
-		}
-		if (installed) {
-			dmn->dmn_kev.flags &= ~(EV_ADD | EV_VANISHED);
-			LIST_INSERT_HEAD(dmb, dmn, dmn_list);
-		} else {
-			free(dmn);
-		}
-	}
-
-	if (installed) {
-		dispatch_unote_linkage_t dul = _dispatch_unote_get_linkage(du);
-		LIST_INSERT_HEAD(&dmn->dmn_unotes_head, dul, du_link);
-#if HAVE_MACH
-		if (du._du->du_filter == DISPATCH_EVFILT_MACH_NOTIFICATION) {
-			os_atomic_store2o(du._dmsr, dmsr_notification_armed,
-					DISPATCH_MACH_NOTIFICATION_ARMED(dmn), relaxed);
-		}
-#endif
-		dul->du_muxnote = dmn;
-		_dispatch_unote_state_set(du, DISPATCH_WLH_ANON, DU_STATE_ARMED);
-		_dispatch_du_debug("installed", du._du);
-	}
-	return installed;
-}
-
-void
-_dispatch_unote_resume_muxed(dispatch_unote_t du)
-{
-	_dispatch_unote_state_set_bit(du, DU_STATE_ARMED);
-	if (unlikely(dux_type(du._du)->dst_update_mux)) {
-		dispatch_unote_linkage_t dul = _dispatch_unote_get_linkage(du);
-		dux_type(du._du)->dst_update_mux(dul->du_muxnote);
-	} else {
-		dispatch_unote_linkage_t dul = _dispatch_unote_get_linkage(du);
-		dispatch_muxnote_t dmn = dul->du_muxnote;
-		_dispatch_kq_deferred_update(DISPATCH_WLH_ANON, &dmn->dmn_kev);
-	}
-}
-
-bool
-_dispatch_unote_unregister_muxed(dispatch_unote_t du)
-{
-	dispatch_unote_linkage_t dul = _dispatch_unote_get_linkage(du);
-	dispatch_muxnote_t dmn = dul->du_muxnote;
-	bool update = false, dispose = false;
-
-#if HAVE_MACH
-	if (dmn->dmn_kev.filter == DISPATCH_EVFILT_MACH_NOTIFICATION) {
-		os_atomic_store2o(du._dmsr, dmsr_notification_armed, false, relaxed);
-	}
-#endif
-	_dispatch_unote_state_set(du, DU_STATE_UNREGISTERED);
-	LIST_REMOVE(dul, du_link);
-	_LIST_TRASH_ENTRY(dul, du_link);
-	dul->du_muxnote = NULL;
-
-	if (LIST_EMPTY(&dmn->dmn_unotes_head)) {
-		dispose = true;
-		update = !(dmn->dmn_kev.flags & EV_DELETE);
-		dmn->dmn_kev.flags |= EV_DELETE;
-	} else {
-		uint32_t fflags = dux_type(du._du)->dst_fflags;
-		LIST_FOREACH(dul, &dmn->dmn_unotes_head, du_link) {
-			du = _dispatch_unote_linkage_get_unote(dul);
-			fflags |= du._du->du_fflags;
-		}
-		if (dmn->dmn_kev.fflags & ~fflags) {
-			dmn->dmn_kev.fflags &= fflags;
-			update = true;
-		}
-	}
-	if (update) {
-		if (unlikely(dux_type(du._du)->dst_update_mux)) {
-			dispatch_assume(dux_type(du._du)->dst_update_mux(dmn));
-		} else {
-			_dispatch_kq_deferred_update(DISPATCH_WLH_ANON, &dmn->dmn_kev);
-		}
-	}
-	if (dispose) {
-		LIST_REMOVE(dmn, dmn_list);
-		free(dmn);
-	}
-	_dispatch_du_debug("deleted", du._du);
-	return true;
-}
-
-#if DISPATCH_HAVE_DIRECT_KNOTES
-bool
-_dispatch_unote_register_direct(dispatch_unote_t du, dispatch_wlh_t wlh)
-{
-	return _dispatch_kq_unote_update(wlh, du, EV_ADD | EV_ENABLE);
-}
-
-void
-_dispatch_unote_resume_direct(dispatch_unote_t du)
-{
-	_dispatch_unote_state_set_bit(du, DU_STATE_ARMED);
-	_dispatch_kq_unote_update(_dispatch_unote_wlh(du), du, EV_ENABLE);
-}
-
-bool
-_dispatch_unote_unregister_direct(dispatch_unote_t du, uint32_t flags)
-{
-	dispatch_unote_state_t du_state = _dispatch_unote_state(du);
-	dispatch_wlh_t du_wlh = _du_state_wlh(du_state);
-	dispatch_deferred_items_t ddi = _dispatch_deferred_items_get();
-	uint16_t action = EV_DELETE;
-	if (likely(du_wlh != DISPATCH_WLH_ANON && ddi && ddi->ddi_wlh == du_wlh)) {
-#if DISPATCH_USE_KEVENT_WORKLOOP
-		// Workloops are special: event delivery and servicing a workloop
-		// cannot race because the kernel can reason about these.
-		// Unregistering from a workloop is always safe and should always
-		// succeed immediately.
-#endif
-		action |= EV_ENABLE;
-		flags |= DUU_DELETE_ACK | DUU_MUST_SUCCEED;
-	}
-
-	if (!_du_state_needs_delete(du_state) || (flags & DUU_DELETE_ACK)) {
-		if (du_state == DU_STATE_NEEDS_DELETE) {
-			// There is no knote to unregister anymore, just do it.
-			_dispatch_unote_state_set(du, DU_STATE_UNREGISTERED);
-			_dispatch_du_debug("acknowledged deleted oneshot", du._du);
-			return true;
-		}
-		if (!_du_state_armed(du_state)) {
-			action |= EV_ENABLE;
-			flags |= DUU_MUST_SUCCEED;
-		}
-		if ((action & EV_ENABLE) || (flags & DUU_PROBE)) {
-			if (_dispatch_kq_unote_update(du_wlh, du, action)) {
-				return true;
-			}
-		}
-	}
-	if (flags & DUU_MUST_SUCCEED) {
-		DISPATCH_INTERNAL_CRASH(0, "Unregistration failed");
-	}
-	return false;
-}
-#endif // DISPATCH_HAVE_DIRECT_KNOTES
-
-#pragma mark -
-#pragma mark dispatch_event_loop
-
-enum {
-	DISPATCH_WORKLOOP_ASYNC,
-	DISPATCH_WORKLOOP_ASYNC_FROM_SYNC,
-	DISPATCH_WORKLOOP_ASYNC_DISCOVER_SYNC,
-	DISPATCH_WORKLOOP_ASYNC_QOS_UPDATE,
-	DISPATCH_WORKLOOP_ASYNC_LEAVE,
-	DISPATCH_WORKLOOP_ASYNC_LEAVE_FROM_SYNC,
-	DISPATCH_WORKLOOP_ASYNC_LEAVE_FROM_TRANSFER,
-	DISPATCH_WORKLOOP_ASYNC_FORCE_END_OWNERSHIP,
-	DISPATCH_WORKLOOP_RETARGET,
-
-	DISPATCH_WORKLOOP_SYNC_WAIT,
-	DISPATCH_WORKLOOP_SYNC_WAKE,
-	DISPATCH_WORKLOOP_SYNC_FAKE,
-	DISPATCH_WORKLOOP_SYNC_END,
-};
-
-static char const * const _dispatch_workloop_actions[] = {
-	[DISPATCH_WORKLOOP_ASYNC]                       = "async",
-	[DISPATCH_WORKLOOP_ASYNC_FROM_SYNC]             = "async (from sync)",
-	[DISPATCH_WORKLOOP_ASYNC_DISCOVER_SYNC]         = "discover sync",
-	[DISPATCH_WORKLOOP_ASYNC_QOS_UPDATE]            = "qos update",
-	[DISPATCH_WORKLOOP_ASYNC_LEAVE]                 = "leave",
-	[DISPATCH_WORKLOOP_ASYNC_LEAVE_FROM_SYNC]       = "leave (from sync)",
-	[DISPATCH_WORKLOOP_ASYNC_LEAVE_FROM_TRANSFER]   = "leave (from transfer)",
-	[DISPATCH_WORKLOOP_ASYNC_FORCE_END_OWNERSHIP]   = "leave (forced)",
-	[DISPATCH_WORKLOOP_RETARGET]                    = "retarget",
-
-	[DISPATCH_WORKLOOP_SYNC_WAIT]                   = "sync-wait",
-	[DISPATCH_WORKLOOP_SYNC_FAKE]                   = "sync-fake",
-	[DISPATCH_WORKLOOP_SYNC_WAKE]                   = "sync-wake",
-	[DISPATCH_WORKLOOP_SYNC_END]                    = "sync-end",
-};
-
-void
-_dispatch_event_loop_atfork_child(void)
-{
-#if HAVE_MACH
-	_dispatch_mach_host_port_pred = 0;
-	_dispatch_mach_host_port = MACH_PORT_NULL;
-#endif
-}
-
-#if DISPATCH_USE_KEVENT_WORKLOOP
-#if DISPATCH_WLH_DEBUG
-/*
- * Debug information for current thread & workloop:
- *
- * fflags:
- * - NOTE_WL_THREAD_REQUEST is set if there is a thread request knote
- * - NOTE_WL_SYNC_WAIT is set if there is at least one waiter
- *
- * ext[0]: 64bit thread ID of the owner if any
- * ext[1]: 64bit thread ID of the servicer if any
- * ext[2]: number of workloops owned by the caller thread
- *
- * If this interface is supported by the kernel, the returned error is EBUSY,
- * if not it is EINVAL.
- */
-static bool
-_dispatch_kevent_workloop_get_info(dispatch_wlh_t wlh, dispatch_kevent_t ke)
-{
-	uint32_t kev_flags = KEVENT_FLAG_IMMEDIATE | KEVENT_FLAG_ERROR_EVENTS |
-			KEVENT_FLAG_DYNAMIC_KQ_MUST_EXIST;
-	*ke = (dispatch_kevent_s){
-		.filter = EVFILT_WORKLOOP,
-		.flags  = EV_ADD | EV_ENABLE,
-	};
-	if (_dispatch_kq_poll(wlh, ke, 1, ke, 1, NULL, NULL, kev_flags)) {
-		dispatch_assert(ke->flags & EV_ERROR);
-		return ke->data == EBUSY;
-	}
-	*ke = (dispatch_kevent_s){
-		.flags = EV_ERROR,
-		.data  = ENOENT,
-	};
-	return true;
-}
-#endif
-
-DISPATCH_ALWAYS_INLINE
-static inline pthread_priority_t
-_dispatch_kevent_workloop_priority(dispatch_queue_t dq, int which,
-		dispatch_qos_t qos)
-{
-	dispatch_priority_t rq_pri = dq->do_targetq->dq_priority;
-	if (qos < _dispatch_priority_qos(rq_pri)) {
-		qos = _dispatch_priority_qos(rq_pri);
-	}
-	if (qos == DISPATCH_QOS_UNSPECIFIED) {
-#if 0 // we need to understand why this is happening first...
-		if (which != DISPATCH_WORKLOOP_ASYNC_FROM_SYNC) {
-			DISPATCH_INTERNAL_CRASH(which, "Should have had a QoS");
-		}
-#else
-		(void)which;
-#endif
-		//
-		// <rdar://32326125> When an enqueue happens right when a barrier ends,
-		// the barrier that ends may notice the next item before the enqueuer
-		// has had the time to set the max QoS on the queue.
-		//
-		// It is inconvenient to drop this thread request, and this case is rare
-		// enough that we instead ask for MAINTENANCE to avoid the kernel
-		// failing with ERANGE.
-		//
-		qos = DISPATCH_QOS_MAINTENANCE;
-	}
-	pthread_priority_t pp = _dispatch_qos_to_pp(qos);
-	return pp | (rq_pri & DISPATCH_PRIORITY_FLAG_OVERCOMMIT);
-}
-
-DISPATCH_ALWAYS_INLINE_NDEBUG
-static void
-_dispatch_kq_fill_workloop_event(dispatch_kevent_t ke, int which,
-		dispatch_wlh_t wlh, uint64_t dq_state)
-{
-	dispatch_queue_t dq = (dispatch_queue_t)wlh;
-	dispatch_qos_t qos = _dq_state_max_qos(dq_state);
-	pthread_priority_t pp = 0;
-	uint32_t fflags = 0;
-	uint64_t mask = 0;
-	uint16_t action = 0;
-
-	switch (which) {
-	case DISPATCH_WORKLOOP_ASYNC_FROM_SYNC:
-		fflags |= NOTE_WL_END_OWNERSHIP;
-		/* FALLTHROUGH */
-	case DISPATCH_WORKLOOP_ASYNC:
-	case DISPATCH_WORKLOOP_ASYNC_DISCOVER_SYNC:
-	case DISPATCH_WORKLOOP_ASYNC_QOS_UPDATE:
-		dispatch_assert(_dq_state_is_base_wlh(dq_state));
-		dispatch_assert(_dq_state_is_enqueued_on_target(dq_state));
-		action = EV_ADD | EV_ENABLE;
-		mask |= DISPATCH_QUEUE_ROLE_MASK;
-		mask |= DISPATCH_QUEUE_ENQUEUED;
-		mask |= DISPATCH_QUEUE_MAX_QOS_MASK;
-		if (which == DISPATCH_WORKLOOP_ASYNC_DISCOVER_SYNC) {
-			dispatch_assert(!_dq_state_in_sync_transfer(dq_state));
-			dispatch_assert(_dq_state_drain_locked(dq_state));
-			mask |= DISPATCH_QUEUE_SYNC_TRANSFER;
-			fflags |= NOTE_WL_DISCOVER_OWNER;
-		} else {
-			fflags |= NOTE_WL_IGNORE_ESTALE;
-		}
-		fflags |= NOTE_WL_UPDATE_QOS;
-		pp = _dispatch_kevent_workloop_priority(dq, which, qos);
-		break;
-
-	case DISPATCH_WORKLOOP_ASYNC_LEAVE_FROM_SYNC:
-		fflags |= NOTE_WL_END_OWNERSHIP;
-		/* FALLTHROUGH */
-	case DISPATCH_WORKLOOP_ASYNC_LEAVE_FROM_TRANSFER:
-		fflags |= NOTE_WL_IGNORE_ESTALE;
-		/* FALLTHROUGH */
-	case DISPATCH_WORKLOOP_ASYNC_LEAVE:
-		dispatch_assert(!_dq_state_is_enqueued_on_target(dq_state));
-		action = EV_ADD | EV_DELETE | EV_ENABLE;
-		mask |= DISPATCH_QUEUE_ENQUEUED;
-		break;
-
-	case DISPATCH_WORKLOOP_ASYNC_FORCE_END_OWNERSHIP:
-		// 0 is never a valid queue state, so the knote attach will fail due to
-		// the debounce. However, NOTE_WL_END_OWNERSHIP is always observed even
-		// when ESTALE is returned, which is the side effect we're after here.
-		fflags |= NOTE_WL_END_OWNERSHIP;
-		fflags |= NOTE_WL_IGNORE_ESTALE;
-		action = EV_ADD | EV_ENABLE;
-		mask = ~0ull;
-		dq_state = 0;
-		pp = _dispatch_kevent_workloop_priority(dq, which, qos);
-		break;
-
-	case DISPATCH_WORKLOOP_RETARGET:
-		action = EV_ADD | EV_DELETE | EV_ENABLE;
-		fflags |= NOTE_WL_END_OWNERSHIP;
-		break;
-
-	default:
-		DISPATCH_INTERNAL_CRASH(which, "Invalid transition");
-	}
-
-	*ke = (dispatch_kevent_s){
-		.ident  = (uintptr_t)wlh,
-		.filter = EVFILT_WORKLOOP,
-		.flags  = action,
-		.fflags = fflags | NOTE_WL_THREAD_REQUEST,
-		.qos    = (__typeof__(ke->qos))pp,
-		.udata  = (uintptr_t)wlh,
-
-		.ext[EV_EXTIDX_WL_ADDR]  = (uintptr_t)&dq->dq_state,
-		.ext[EV_EXTIDX_WL_MASK]  = mask,
-		.ext[EV_EXTIDX_WL_VALUE] = dq_state,
-	};
-	_dispatch_kevent_wlh_debug(_dispatch_workloop_actions[which], ke);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_kq_fill_ddi_workloop_event(dispatch_deferred_items_t ddi,
-		int which, dispatch_wlh_t wlh, uint64_t dq_state)
-{
-	int slot = _dispatch_kq_deferred_find_slot(ddi, EVFILT_WORKLOOP,
-			(uint64_t)wlh, (uint64_t)wlh);
-	if (slot == ddi->ddi_nevents) {
-		dispatch_assert(slot < DISPATCH_DEFERRED_ITEMS_EVENT_COUNT);
-		ddi->ddi_nevents++;
-	}
-	_dispatch_kq_fill_workloop_event(&ddi->ddi_eventlist[slot],
-			which, wlh, dq_state);
-}
-
-DISPATCH_ALWAYS_INLINE_NDEBUG
-static void
-_dispatch_kq_fill_workloop_sync_event(dispatch_kevent_t ke, int which,
-		dispatch_wlh_t wlh, uint64_t dq_state, dispatch_tid tid)
-{
-	dispatch_queue_t dq = (dispatch_queue_t)wlh;
-	pthread_priority_t pp = 0;
-	uint32_t fflags = 0;
-	uint64_t mask = 0;
-	uint16_t action = 0;
-
-	switch (which) {
-	case DISPATCH_WORKLOOP_SYNC_WAIT:
-		action = EV_ADD | EV_DISABLE;
-		fflags = NOTE_WL_SYNC_WAIT;
-		pp     = _dispatch_get_priority();
-		if (_dispatch_qos_from_pp(pp) == 0) {
-			pp = _dispatch_qos_to_pp(DISPATCH_QOS_DEFAULT);
-		}
-		if (_dq_state_received_sync_wait(dq_state)) {
-			fflags |= NOTE_WL_DISCOVER_OWNER;
-			mask = DISPATCH_QUEUE_ROLE_MASK | DISPATCH_QUEUE_RECEIVED_SYNC_WAIT;
-		}
-		break;
-
-	case DISPATCH_WORKLOOP_SYNC_FAKE:
-		action = EV_ADD | EV_DISABLE;
-		fflags = NOTE_WL_SYNC_WAKE;
-		break;
-
-	case DISPATCH_WORKLOOP_SYNC_WAKE:
-		dispatch_assert(_dq_state_drain_locked_by(dq_state, tid));
-		action = EV_ADD | EV_DISABLE;
-		fflags = NOTE_WL_SYNC_WAKE | NOTE_WL_DISCOVER_OWNER;
-		break;
-
-	case DISPATCH_WORKLOOP_SYNC_END:
-		action = EV_DELETE | EV_ENABLE;
-		fflags = NOTE_WL_SYNC_WAKE | NOTE_WL_END_OWNERSHIP;
-		break;
-
-	default:
-		DISPATCH_INTERNAL_CRASH(which, "Invalid transition");
-	}
-
-	*ke = (dispatch_kevent_s){
-		.ident  = tid,
-		.filter = EVFILT_WORKLOOP,
-		.flags  = action,
-		.fflags = fflags,
-		.udata  = (uintptr_t)wlh,
-		.qos    = (__typeof__(ke->qos))pp,
-
-		.ext[EV_EXTIDX_WL_MASK] = mask,
-		.ext[EV_EXTIDX_WL_VALUE] = dq_state,
-	};
-	if (fflags & NOTE_WL_DISCOVER_OWNER) {
-		ke->ext[EV_EXTIDX_WL_ADDR] = (uintptr_t)&dq->dq_state;
-	}
-	_dispatch_kevent_wlh_debug(_dispatch_workloop_actions[which], ke);
-}
-
-#define DISPATCH_KEVENT_WORKLOOP_ALLOW_ENOENT 1
-#define DISPATCH_KEVENT_WORKLOOP_ALLOW_ESTALE 2
-#define DISPATCH_KEVENT_WORKLOOP_ALLOW_EINTR  4
-
-DISPATCH_ALWAYS_INLINE
-static inline int
-_dispatch_kevent_workloop_drain_error(dispatch_kevent_t ke, long flags)
-{
-	int err = (int)ke->data;
-
-	_dispatch_kevent_wlh_debug("received error", ke);
-	dispatch_assert(ke->flags & EV_ERROR);
-	//
-	// Clear the error so that we can use the same struct to redrive as is
-	// but leave a breadcrumb about the error in xflags for debugging
-	//
-	ke->flags &= ~EV_ERROR;
-	ke->xflags = (uint32_t)err;
-	ke->data = 0;
-
-	switch (err) {
-	case EINTR:
-		if ((flags & DISPATCH_KEVENT_WORKLOOP_ALLOW_EINTR) &&
-				(ke->fflags & NOTE_WL_SYNC_WAIT)) {
-			return EINTR;
-		}
-		break;
-	case ENOENT:
-		if ((flags & DISPATCH_KEVENT_WORKLOOP_ALLOW_ENOENT) &&
-				(ke->flags & EV_DELETE) && (ke->fflags & NOTE_WL_SYNC_WAKE) &&
-				(ke->fflags & NOTE_WL_END_OWNERSHIP)) {
-			//
-			// When breaking out a waiter because of a retarget, that waiter may
-			// not have made his wait syscall yet, and we can't really prepost
-			// an EV_DELETE, so we have to redrive on ENOENT in this case
-			//
-			return ENOENT;
-		}
-		break;
-	case ESTALE:
-		if ((flags & DISPATCH_KEVENT_WORKLOOP_ALLOW_ESTALE) &&
-				!(ke->fflags & NOTE_WL_IGNORE_ESTALE) &&
-				ke->ext[EV_EXTIDX_WL_ADDR] && ke->ext[EV_EXTIDX_WL_MASK]) {
-			return ESTALE;
-		}
-		break;
-	case ERANGE:
-		DISPATCH_INTERNAL_CRASH((uintptr_t)ke->qos, "Broken priority");
-	case EOWNERDEAD:
-		DISPATCH_CLIENT_CRASH((uintptr_t)ke->ext[EV_EXTIDX_WL_VALUE],
-				"Invalid workloop owner, possible memory corruption");
-	default:
-		break;
-	}
-	DISPATCH_INTERNAL_CRASH(err, "Unexpected error from kevent");
-}
-
-DISPATCH_ALWAYS_INLINE
-static void
-_dispatch_kevent_workloop_stash(dispatch_wlh_t wlh, dispatch_kevent_t ke,
-		dispatch_deferred_items_t ddi)
-{
-	dispatch_queue_t dq = (dispatch_queue_t)wlh;
-	dispatch_assert(!ddi->ddi_stashed_dou._dq);
-	ddi->ddi_wlh_needs_delete = true;
-	_dispatch_retain(dq);
-	ddi->ddi_stashed_rq = upcast(dq->do_targetq)._dgq;
-	ddi->ddi_stashed_dou._dq = dq;
-	ddi->ddi_stashed_qos = _dispatch_qos_from_pp((pthread_priority_t)ke->qos);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline int
-_dispatch_event_loop_get_action_for_state(uint64_t dq_state)
-{
-	dispatch_assert(_dq_state_is_base_wlh(dq_state));
-
-	if (!_dq_state_is_enqueued_on_target(dq_state)) {
-		return DISPATCH_WORKLOOP_ASYNC_LEAVE;
-	}
-	if (!_dq_state_drain_locked(dq_state)) {
-		return DISPATCH_WORKLOOP_ASYNC;
-	}
-	if (!_dq_state_in_sync_transfer(dq_state)) {
-		return DISPATCH_WORKLOOP_ASYNC_DISCOVER_SYNC;
-	}
-	return DISPATCH_WORKLOOP_ASYNC_QOS_UPDATE;
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_kevent_workloop_poke_drain(dispatch_kevent_t ke)
-{
-	dispatch_deferred_items_t ddi = _dispatch_deferred_items_get();
-	dispatch_wlh_t wlh = (dispatch_wlh_t)ke->udata;
-
-	dispatch_assert(ke->fflags & NOTE_WL_THREAD_REQUEST);
-	if (ke->flags & EV_ERROR) {
-		uint64_t dq_state = ke->ext[EV_EXTIDX_WL_VALUE];
-
-		_dispatch_kevent_workloop_drain_error(ke,
-				DISPATCH_KEVENT_WORKLOOP_ALLOW_ESTALE);
-
-		if (!_dq_state_is_base_wlh(dq_state)) {
-			dispatch_assert((ke->flags & EV_DELETE) == 0);
-			//
-			// A late async request bounced because the queue is no longer
-			// a workloop. There is a DISPATCH_WORKLOOP_RETARGET transition that
-			// will take care of deleting the thread request
-			//
-			return _dispatch_kevent_wlh_debug("ignoring", ke);
-		}
-
-		//
-		// We're draining a failed _dispatch_event_loop_leave_deferred()
-		// so repeat its logic.
-		//
-		int action = _dispatch_event_loop_get_action_for_state(dq_state);
-		if (action == DISPATCH_WORKLOOP_ASYNC) {
-			_dispatch_kevent_wlh_debug("retry drain", ke);
-			return _dispatch_kevent_workloop_stash(wlh, ke, ddi);
-		} else {
-			_dispatch_kq_fill_workloop_event(ke, action, wlh, dq_state);
-			return _dispatch_kq_deferred_update(wlh, ke);
-		}
-	} else if (ddi->ddi_wlh_needs_delete) {
-		//
-		// we knew about this thread request because we learned about it
-		// in _dispatch_kevent_workloop_poke_self() while merging another event.
-		// It has already been accounted for, so just swallow it.
-		//
-		return _dispatch_kevent_wlh_debug("ignoring", ke);
-	} else {
-		//
-		// This is a new thread request, it is carrying a +1 reference.
-		//
-		_dispatch_kevent_wlh_debug("got drain", ke);
-		return _dispatch_kevent_workloop_stash(wlh, ke, ddi);
-	}
-}
-
-static void
-_dispatch_kevent_workloop_poke(dispatch_wlh_t wlh, uint64_t dq_state,
-		uint32_t flags)
-{
-	uint32_t kev_flags = KEVENT_FLAG_IMMEDIATE | KEVENT_FLAG_ERROR_EVENTS;
-	dispatch_kevent_s ke;
-	int action;
-
-	dispatch_assert(_dq_state_is_enqueued_on_target(dq_state));
-	dispatch_assert(!_dq_state_is_enqueued_on_manager(dq_state));
-	action = _dispatch_event_loop_get_action_for_state(dq_state);
-override:
-	_dispatch_kq_fill_workloop_event(&ke, action, wlh, dq_state);
-
-	if (_dispatch_kq_poll(wlh, &ke, 1, &ke, 1, NULL, NULL, kev_flags)) {
-		_dispatch_kevent_workloop_drain_error(&ke,
-				DISPATCH_KEVENT_WORKLOOP_ALLOW_ESTALE);
-		dispatch_assert(action == DISPATCH_WORKLOOP_ASYNC_DISCOVER_SYNC);
-		dq_state = ke.ext[EV_EXTIDX_WL_VALUE];
-		//
-		// There are 4 things that can cause an ESTALE for DISCOVER_SYNC:
-		// - the queue role changed, we don't want to redrive
-		// - the queue is no longer enqueued, we don't want to redrive
-		// - the max QoS changed, whoever changed it is doing the same
-		//   transition, so we don't need to redrive
-		// - the DISPATCH_QUEUE_IN_SYNC_TRANFER bit got set
-		//
-		// The interesting case is the last one, and will only happen in the
-		// following chain of events:
-		// 1. uncontended dispatch_sync()
-		// 2. contended dispatch_sync()
-		// 3. contended dispatch_async()
-		//
-		// And this code is running because of (3). It is possible that (1)
-		// hands off to (2) while this call is being made, causing the
-		// DISPATCH_QUEUE_IN_TRANSFER_SYNC to be set, and we don't need to tell
-		// the kernel about the owner anymore. However, the async in that case
-		// will have set a QoS on the queue (since dispatch_sync()s don't but
-		// dispatch_async()s always do), and we need to redrive to tell it
-		// to the kernel.
-		//
-		if (_dq_state_is_base_wlh(dq_state) &&
-				_dq_state_is_enqueued_on_target(dq_state) &&
-				_dq_state_in_sync_transfer(dq_state)) {
-			action = DISPATCH_WORKLOOP_ASYNC;
-			goto override;
-		}
-	}
-
-	if (!(flags & DISPATCH_EVENT_LOOP_OVERRIDE)) {
-		// Consume the reference that kept the workloop valid
-		// for the duration of the syscall.
-		return _dispatch_release_tailcall((dispatch_queue_t)wlh);
-	}
-	if (flags & DISPATCH_EVENT_LOOP_CONSUME_2) {
-		return _dispatch_release_2_tailcall((dispatch_queue_t)wlh);
-	}
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_kevent_workloop_override_self(dispatch_deferred_items_t ddi,
-		uint64_t dq_state, uint32_t flags)
-{
-	dispatch_wlh_t wlh = ddi->ddi_wlh;
-	uint32_t kev_flags = KEVENT_FLAG_IMMEDIATE | KEVENT_FLAG_ERROR_EVENTS;
-	dispatch_kevent_s ke;
-	//
-	// The workloop received work from itself that caused an override
-	// after the drain lock has been taken, just comply and move on.
-	//
-	dispatch_assert(ddi->ddi_wlh_needs_delete);
-	ddi->ddi_wlh_needs_update = false;
-
-	_dispatch_kq_fill_workloop_event(&ke, DISPATCH_WORKLOOP_ASYNC,
-			wlh, dq_state);
-	if (_dispatch_kq_poll(wlh, &ke, 1, &ke, 1, NULL, NULL, kev_flags)) {
-		_dispatch_kevent_workloop_drain_error(&ke, 0);
-		__builtin_unreachable();
-	}
-	if (flags & DISPATCH_EVENT_LOOP_CONSUME_2) {
-		return _dispatch_release_2_no_dispose((dispatch_queue_t)wlh);
-	}
-}
-
-static void
-_dispatch_kevent_workloop_poke_self(dispatch_deferred_items_t ddi,
-		uint64_t dq_state, uint32_t flags)
-{
-	dispatch_queue_t dq = (dispatch_queue_t)ddi->ddi_wlh;
-
-	if (ddi->ddi_wlh_servicing) {
-		dispatch_assert(ddi->ddi_wlh_needs_delete);
-		if (flags & DISPATCH_EVENT_LOOP_OVERRIDE) {
-			return _dispatch_kevent_workloop_override_self(ddi, dq_state,flags);
-		}
-		//
-		// dx_invoke() wants to re-enqueue itself e.g.  because the thread pool
-		// needs narrowing, or the queue is suspended, or any other reason that
-		// interrupts the drain.
-		//
-		// This is called with a +2 on the queue, a +1 goes to the thread
-		// request, the other we dispose of.
-		//
-		dispatch_assert(!_dq_state_drain_locked(dq_state));
-		dispatch_assert(_dq_state_is_enqueued_on_target(dq_state));
-		dispatch_assert(flags & DISPATCH_EVENT_LOOP_CONSUME_2);
-		_dispatch_release_no_dispose(dq);
-		return _dispatch_event_loop_leave_deferred(ddi, dq_state);
-	}
-
-	//
-	// This codepath is only used during the initial phase of merging
-	// incoming kernel events in _dispatch_workloop_worker_thread, before
-	// trying to take the drain lock in order to drain the workloop.
-	//
-	// Once we have taken the drain lock, wakeups will not reach this codepath
-	// because ddi->ddi_wlh_servicing will be set.
-	//
-
-	if (ddi->ddi_wlh_needs_delete) {
-		//
-		// We know there is a thread request already (stolen or real).
-		// However, an event is causing the workloop to be overridden.
-		// The kernel already has applied the override, so we can
-		// safely swallow this event, which carries no refcount.
-		//
-		dispatch_assert(flags & DISPATCH_EVENT_LOOP_OVERRIDE);
-		dispatch_assert(ddi->ddi_stashed_dou._dq);
-		if (flags & DISPATCH_EVENT_LOOP_CONSUME_2) {
-			return _dispatch_release_2_no_dispose(dq);
-		}
-		return;
-	}
-
-	if (flags & DISPATCH_EVENT_LOOP_OVERRIDE) {
-		//
-		// An event delivery is causing an override, but didn't know
-		// about a thread request yet. However, since we're receving an override
-		// it means this initial thread request either exists in the kernel
-		// or is about to be made.
-		//
-		// If it is about to be made, it is possible that it will bounce with
-		// ESTALE, and will not be retried. It means we can't be sure there
-		// really is or even will be a knote in the kernel for it.
-		//
-		// We still want to take over the +1 this thread request carries whether
-		// it made it (or will make it) to the kernel, and turn it into a +2
-		// below.
-		//
-		// Overrides we receive in this way are coalesced and acknowleged
-		// only when we have to do a kevent() call for other reasons. The kernel
-		// will continue to apply the overrides in question until we acknowledge
-		// them, so there's no rush.
-		//
-		ddi->ddi_wlh_needs_update = true;
-		if (flags & DISPATCH_EVENT_LOOP_CONSUME_2) {
-			_dispatch_release_no_dispose(dq);
-		} else {
-			_dispatch_retain(dq);
-		}
-	} else {
-		//
-		// Merging events causes a thread request to be issued, this means
-		// the queue is empty in userland and the kernel event is the first
-		// thing enqueued. Consume the caller's +2.
-		//
-		dispatch_assert(flags & DISPATCH_EVENT_LOOP_CONSUME_2);
-	}
-	dispatch_assert(!ddi->ddi_stashed_dou._dq);
-	ddi->ddi_wlh_needs_delete = true;
-	ddi->ddi_stashed_rq = upcast(dq->do_targetq)._dgq;
-	ddi->ddi_stashed_dou._dq = dq;
-	ddi->ddi_stashed_qos = _dq_state_max_qos(dq_state);
-}
-#endif // DISPATCH_USE_KEVENT_WORKLOOP
-
-DISPATCH_NOINLINE
-void
-_dispatch_event_loop_poke(dispatch_wlh_t wlh, uint64_t dq_state, uint32_t flags)
-{
-	if (wlh == DISPATCH_WLH_MANAGER) {
-		dispatch_kevent_s ke = (dispatch_kevent_s){
-			.ident  = 1,
-			.filter = EVFILT_USER,
-			.fflags = NOTE_TRIGGER,
-			.udata = (dispatch_kevent_udata_t)DISPATCH_WLH_MANAGER,
-		};
-		return _dispatch_kq_deferred_update(DISPATCH_WLH_ANON, &ke);
-	} else if (wlh && wlh != DISPATCH_WLH_ANON) {
-#if DISPATCH_USE_KEVENT_WORKLOOP
-		dispatch_queue_t dq = (dispatch_queue_t)wlh;
-		dispatch_assert(_dq_state_is_base_wlh(dq_state));
-		if (unlikely(_dq_state_is_enqueued_on_manager(dq_state))) {
-			dispatch_assert(!(flags & DISPATCH_EVENT_LOOP_OVERRIDE));
-			dispatch_assert(flags & DISPATCH_EVENT_LOOP_CONSUME_2);
-			_dispatch_trace_item_push(&_dispatch_mgr_q, dq);
-			return dx_push(_dispatch_mgr_q._as_dq, dq, 0);
-		}
-		dispatch_deferred_items_t ddi = _dispatch_deferred_items_get();
-		if (ddi && ddi->ddi_wlh == wlh) {
-			return _dispatch_kevent_workloop_poke_self(ddi, dq_state, flags);
-		}
-		return _dispatch_kevent_workloop_poke(wlh, dq_state, flags);
-#else
-		(void)dq_state; (void)flags;
-#endif // DISPATCH_USE_KEVENT_WORKLOOP
-	}
-	DISPATCH_INTERNAL_CRASH(wlh, "Unsupported wlh configuration");
-}
-
-DISPATCH_NOINLINE
-void
-_dispatch_event_loop_drain(uint32_t flags)
-{
-	dispatch_deferred_items_t ddi = _dispatch_deferred_items_get();
-	dispatch_wlh_t wlh = ddi->ddi_wlh;
-	int n;
-
-again:
-#if DISPATCH_USE_KEVENT_WORKLOOP
-	if (ddi->ddi_wlh_needs_update) {
-		// see _dispatch_event_loop_drain() comments about the lazy handling
-		// of DISPATCH_EVENT_LOOP_OVERRIDE
-		dispatch_queue_t dq = (dispatch_queue_t)wlh;
-		uint64_t dq_state = os_atomic_load2o(dq, dq_state, relaxed);
-
-		dispatch_assert(ddi->ddi_wlh_needs_delete);
-		ddi->ddi_wlh_needs_update = false;
-		_dispatch_kq_fill_ddi_workloop_event(ddi,
-				DISPATCH_WORKLOOP_ASYNC_QOS_UPDATE, wlh, dq_state);
-	}
-#endif // DISPATCH_USE_KEVENT_WORKLOOP
-	n = ddi->ddi_nevents;
-	ddi->ddi_nevents = 0;
-	_dispatch_kq_drain(wlh, ddi->ddi_eventlist, n, flags);
-
-#if DISPATCH_USE_KEVENT_WORKLOOP
-	dispatch_workloop_t dwl = _dispatch_wlh_to_workloop(wlh);
-	if (dwl) {
-		dispatch_timer_heap_t dth = dwl->dwl_timer_heap;
-		if (dth && dth[0].dth_dirty_bits) {
-			_dispatch_event_loop_drain_timers(dth, DISPATCH_TIMER_WLH_COUNT);
-		}
-	}
-#endif // DISPATCH_USE_KEVENT_WORKLOOP
-
-	if ((flags & KEVENT_FLAG_IMMEDIATE) &&
-			!(flags & KEVENT_FLAG_ERROR_EVENTS) &&
-			_dispatch_needs_to_return_to_kernel()) {
-		goto again;
-	}
-}
-
-void
-_dispatch_event_loop_merge(dispatch_kevent_t events, int nevents)
-{
-	dispatch_deferred_items_t ddi = _dispatch_deferred_items_get();
-	dispatch_wlh_t wlh = ddi->ddi_wlh;
-	dispatch_kevent_s kev[nevents];
-
-	// now we can re-use the whole event list, but we need to save one slot
-	// for the event loop poke
-	memcpy(kev, events, sizeof(kev));
-	ddi->ddi_maxevents = DISPATCH_DEFERRED_ITEMS_EVENT_COUNT - 2;
-
-	for (int i = 0; i < nevents; i++) {
-		_dispatch_kevent_drain(&kev[i]);
-	}
-
-	if (wlh == DISPATCH_WLH_ANON) {
-		if (ddi->ddi_stashed_dou._do && ddi->ddi_nevents) {
-			// We will drain the stashed item and not return to the kernel
-			// right away. As a consequence, do not delay these updates.
-			_dispatch_event_loop_drain(KEVENT_FLAG_IMMEDIATE |
-					KEVENT_FLAG_ERROR_EVENTS);
-		}
-#if DISPATCH_USE_KEVENT_WORKLOOP
-	} else if (dx_metatype((dispatch_queue_t)wlh) == _DISPATCH_WORKLOOP_TYPE) {
-		dispatch_timer_heap_t dth = ((dispatch_workloop_t)wlh)->dwl_timer_heap;
-		if (dth && dth[0].dth_dirty_bits) {
-			_dispatch_event_loop_drain_timers(dth, DISPATCH_TIMER_WLH_COUNT);
-		}
-#endif // DISPATCH_USE_KEVENT_WORKLOOP
-	}
-}
-
-void
-_dispatch_event_loop_leave_immediate(uint64_t dq_state)
-{
-#if DISPATCH_USE_KEVENT_WORKLOOP
-	dispatch_deferred_items_t ddi = _dispatch_deferred_items_get();
-	dispatch_wlh_t wlh = ddi->ddi_wlh;
-	uint32_t kev_flags = KEVENT_FLAG_IMMEDIATE | KEVENT_FLAG_ERROR_EVENTS |
-			KEVENT_FLAG_DYNAMIC_KQ_MUST_EXIST;
-	dispatch_kevent_s ke;
-	dispatch_assert(!_dq_state_is_base_wlh(dq_state));
-
-	//
-	// A workloop is being retargeted, we need to synchronously destroy
-	// the thread request as delivering it later would confuse the workloop
-	// thread into trying to drain this queue as a bottom one.
-	//
-	// Doing it synchronously prevents races where the queue is retargeted
-	// again, and becomes a workloop again
-	//
-	dispatch_assert(ddi->ddi_wlh_needs_delete);
-	ddi->ddi_wlh_needs_delete = false;
-	ddi->ddi_wlh_needs_update = false;
-	_dispatch_kq_fill_workloop_event(&ke,
-			DISPATCH_WORKLOOP_RETARGET, wlh, dq_state);
-	if (_dispatch_kq_poll(wlh, &ke, 1, &ke, 1, NULL, NULL, kev_flags)) {
-		_dispatch_kevent_workloop_drain_error(&ke, 0);
-		__builtin_unreachable();
-	}
-#else
-	(void)dq_state;
-#endif // DISPATCH_USE_KEVENT_WORKLOOP
-}
-
-void
-_dispatch_event_loop_leave_deferred(dispatch_deferred_items_t ddi,
-		uint64_t dq_state)
-{
-#if DISPATCH_USE_KEVENT_WORKLOOP
-	int action = _dispatch_event_loop_get_action_for_state(dq_state);
-	dispatch_assert(ddi->ddi_wlh_needs_delete);
-	ddi->ddi_wlh_needs_delete = false;
-	ddi->ddi_wlh_needs_update = false;
-	_dispatch_kq_fill_ddi_workloop_event(ddi, action, ddi->ddi_wlh, dq_state);
-#else
-	(void)ddi; (void)dq_state;
-#endif // DISPATCH_USE_KEVENT_WORKLOOP
-}
-
-void
-_dispatch_event_loop_cancel_waiter(dispatch_sync_context_t dsc)
-{
-#if DISPATCH_USE_KEVENT_WORKLOOP
-	dispatch_wlh_t wlh = dsc->dc_data;
-	uint32_t kev_flags = KEVENT_FLAG_IMMEDIATE | KEVENT_FLAG_ERROR_EVENTS;
-	dispatch_kevent_s ke;
-
-	_dispatch_kq_fill_workloop_sync_event(&ke, DISPATCH_WORKLOOP_SYNC_END,
-			wlh, 0, dsc->dsc_waiter);
-	if (_dispatch_kq_poll(wlh, &ke, 1, &ke, 1, NULL, NULL, kev_flags)) {
-		_dispatch_kevent_workloop_drain_error(&ke, dsc->dsc_waiter_needs_cancel ?
-				0 : DISPATCH_KEVENT_WORKLOOP_ALLOW_ENOENT);
-		//
-		// Our deletion attempt is opportunistic as in most cases we will find
-		// the matching knote and break the waiter out.
-		//
-		// However, if the waiter hasn't had a chance to make the syscall
-		// to wait yet, we get ENOENT. In this case, pre-post the WAKE,
-		// and transfer the responsibility to delete the knote to the waiter.
-		//
-		dsc->dsc_waiter_needs_cancel = true;
-		_dispatch_kq_fill_workloop_sync_event(&ke,
-				DISPATCH_WORKLOOP_SYNC_FAKE, wlh, 0, dsc->dsc_waiter);
-		if (_dispatch_kq_poll(wlh, &ke, 1, &ke, 1, NULL, NULL, kev_flags)) {
-			_dispatch_kevent_workloop_drain_error(&ke, 0);
-			__builtin_unreachable();
-		}
-	}
-#else
-	(void)dsc;
-#endif // DISPATCH_USE_KEVENT_WORKLOOP
-}
-
-void
-_dispatch_event_loop_wake_owner(dispatch_sync_context_t dsc,
-		dispatch_wlh_t wlh, uint64_t old_state, uint64_t new_state)
-{
-#if DISPATCH_USE_KEVENT_WORKLOOP
-	dispatch_deferred_items_t ddi = _dispatch_deferred_items_get();
-	dispatch_wlh_t waiter_wlh = dsc->dc_data;
-	uint32_t kev_flags = KEVENT_FLAG_IMMEDIATE | KEVENT_FLAG_ERROR_EVENTS;
-	dispatch_kevent_s ke[3];
-	int action, n = 0;
-
-	dispatch_assert(_dq_state_drain_locked_by(new_state, dsc->dsc_waiter));
-
-	if (wlh != DISPATCH_WLH_ANON && ddi && ddi->ddi_wlh == wlh) {
-		dispatch_assert(ddi->ddi_wlh_needs_delete);
-		ddi->ddi_wlh_needs_delete = false;
-		ddi->ddi_wlh_needs_update = false;
-
-		if (wlh == waiter_wlh) { // async -> sync handoff
-			dispatch_assert(_dq_state_is_enqueued_on_target(old_state));
-			dispatch_assert(!_dq_state_in_sync_transfer(old_state));
-			dispatch_assert(_dq_state_in_sync_transfer(new_state));
-
-			if (_dq_state_is_enqueued_on_target(new_state)) {
-				action = DISPATCH_WORKLOOP_ASYNC_QOS_UPDATE;
-			} else {
-				action = DISPATCH_WORKLOOP_ASYNC_LEAVE_FROM_TRANSFER;
-			}
-			_dispatch_kq_fill_ddi_workloop_event(ddi, action, wlh, new_state);
-
-			int slot = _dispatch_kq_deferred_find_slot(ddi, EVFILT_WORKLOOP,
-					(uint64_t)wlh, dsc->dsc_waiter);
-			if (slot == ddi->ddi_nevents) {
-				dispatch_assert(slot < DISPATCH_DEFERRED_ITEMS_EVENT_COUNT);
-				ddi->ddi_nevents++;
-			}
-			_dispatch_kq_fill_workloop_sync_event(&ddi->ddi_eventlist[slot],
-					DISPATCH_WORKLOOP_SYNC_WAKE, wlh, new_state, dsc->dsc_waiter);
-			return;
-		}
-	}
-
-	if ((old_state ^ new_state) & DISPATCH_QUEUE_ENQUEUED) {
-		dispatch_assert(_dq_state_is_enqueued_on_target(old_state));
-		dispatch_assert(_dq_state_in_sync_transfer(new_state));
-		// During the handoff, the waiter noticed there was no work *after*
-		// that last work item, so we want to kill the thread request while
-		// there's an owner around to avoid races betwen knote_process() and
-		// knote_drop() in the kernel.
-		_dispatch_kq_fill_workloop_event(&ke[n++],
-				DISPATCH_WORKLOOP_ASYNC_LEAVE_FROM_TRANSFER, wlh, new_state);
-	}
-	if (_dq_state_in_sync_transfer(new_state)) {
-		// Even when waiter_wlh != wlh we can pretend we got woken up
-		// which is a knote we will be able to delete later with a SYNC_END.
-		// This allows rectifying incorrect ownership sooner, and also happens
-		// on resume if the first item is a sync waiter.
-		_dispatch_kq_fill_workloop_sync_event(&ke[n++],
-				DISPATCH_WORKLOOP_SYNC_WAKE, wlh, new_state, dsc->dsc_waiter);
-	}
-	if (_dq_state_in_sync_transfer(old_state)) {
-		dispatch_tid tid = _dispatch_tid_self();
-		_dispatch_kq_fill_workloop_sync_event(&ke[n++],
-				DISPATCH_WORKLOOP_SYNC_END, wlh, new_state, tid);
-	}
-	//
-	// Past this call it is not safe to look at `wlh` anymore as the callers
-	// sometimes borrow the refcount of the waiter which we will wake up.
-	//
-	if (_dispatch_kq_poll(wlh, ke, n, ke, n, NULL, NULL, kev_flags)) {
-		_dispatch_kevent_workloop_drain_error(&ke[0], 0);
-		__builtin_unreachable();
-	}
-
-	if (unlikely(waiter_wlh != DISPATCH_WLH_ANON && waiter_wlh != wlh)) {
-		_dispatch_bug_deprecated("Changing target queue hierarchy "
-				"with a dispatch_sync in flight");
-		_dispatch_event_loop_cancel_waiter(dsc);
-	}
-#else
-	(void)dsc; (void)wlh; (void)old_state; (void)new_state;
-#endif // DISPATCH_USE_KEVENT_WORKLOOP
-}
-
-void
-_dispatch_event_loop_wait_for_ownership(dispatch_sync_context_t dsc)
-{
-#if DISPATCH_USE_KEVENT_WORKLOOP
-	dispatch_wlh_t wlh = dsc->dc_data;
-	dispatch_kevent_s ke[2];
-	uint32_t kev_flags = KEVENT_FLAG_IMMEDIATE | KEVENT_FLAG_ERROR_EVENTS;
-	uint64_t dq_state;
-	int i, n = 0;
-
-	dq_state = os_atomic_load2o((dispatch_queue_t)wlh, dq_state, relaxed);
-	if (dsc->dsc_wlh_was_first && !_dq_state_drain_locked(dq_state) &&
-			_dq_state_is_enqueued_on_target(dq_state)) {
-		//
-		// <rdar://problem/32123779>
-		//
-		// When an enqueuer is racing with the servicer draining the item that
-		// is being enqueued and going away, it is possible for the enqueuer to
-		// mark an empty queue as enqueued and make a thread request for it.
-		//
-		// If then a thread is selected to deliver this event, but doesn't make
-		// it to userland to take the drain lock, any sync waiter will
-		// nevertheless have to wait for that servicer to consume the thread
-		// request, trying to delete it will be no good. This is why
-		// _dispatch_push_sync_waiter() for workloops will not try to "save
-		// itself" if the enqueued bit is set.
-		//
-		// However, we don't know whether this thread request exists, it may
-		// have bounced, or still be in the process of being added by a much
-		// lower priority thread, so we need to drive it once to avoid priority
-		// inversions.
-		//
-		_dispatch_kq_fill_workloop_event(&ke[n++], DISPATCH_WORKLOOP_ASYNC,
-				wlh, dq_state);
-	}
-
-again:
-	_dispatch_kq_fill_workloop_sync_event(&ke[n++], DISPATCH_WORKLOOP_SYNC_WAIT,
-			wlh, dq_state, dsc->dsc_waiter);
-	n = _dispatch_kq_poll(wlh, ke, n, ke, n, NULL, NULL, kev_flags);
-	for (i = 0; i < n; i++) {
-		long flags = 0;
-		if (ke[i].fflags & NOTE_WL_SYNC_WAIT) {
-			flags = DISPATCH_KEVENT_WORKLOOP_ALLOW_EINTR |
-					DISPATCH_KEVENT_WORKLOOP_ALLOW_ESTALE;
-		}
-		_dispatch_kevent_workloop_drain_error(&ke[i], flags);
-	}
-	if (n) {
-		dispatch_assert(n == 1 && (ke[0].fflags & NOTE_WL_SYNC_WAIT));
-		_dispatch_kevent_wlh_debug("restarting", &ke[0]);
-		dq_state = ke[0].ext[EV_EXTIDX_WL_VALUE];
-		n = 0;
-		goto again;
-	}
-#endif
-	if (dsc->dsc_waiter_needs_cancel) {
-		_dispatch_event_loop_cancel_waiter(dsc);
-		dsc->dsc_waiter_needs_cancel = false;
-	}
-	if (dsc->dsc_release_storage) {
-		_dispatch_queue_release_storage(dsc->dc_data);
-	}
-}
-
-void
-_dispatch_event_loop_end_ownership(dispatch_wlh_t wlh, uint64_t old_state,
-		uint64_t new_state, uint32_t flags)
-{
-#if DISPATCH_USE_KEVENT_WORKLOOP
-	uint32_t kev_flags = KEVENT_FLAG_IMMEDIATE | KEVENT_FLAG_ERROR_EVENTS;
-	dispatch_kevent_s ke[2];
-	bool needs_forceful_end_ownership = false;
-	int n = 0;
-
-	dispatch_assert(_dq_state_is_base_wlh(new_state));
-	if (_dq_state_is_enqueued_on_target(new_state)) {
-		_dispatch_kq_fill_workloop_event(&ke[n++],
-				DISPATCH_WORKLOOP_ASYNC_FROM_SYNC, wlh, new_state);
-	} else if (_dq_state_is_enqueued_on_target(old_state)) {
-		//
-		// <rdar://problem/41389180> Because the thread request knote may not
-		// have made it, DISPATCH_WORKLOOP_ASYNC_LEAVE_FROM_SYNC may silently
-		// turn into a no-op.
-		//
-		// However, the kernel may know about our ownership anyway, so we need
-		// to make sure it is forcefully ended.
-		//
-		needs_forceful_end_ownership = true;
-		dispatch_assert(_dq_state_is_suspended(new_state));
-		_dispatch_kq_fill_workloop_event(&ke[n++],
-				DISPATCH_WORKLOOP_ASYNC_LEAVE_FROM_SYNC, wlh, new_state);
-	} else if (_dq_state_received_sync_wait(old_state)) {
-		//
-		// This case happens when the current workloop got waited on by some
-		// thread calling _dispatch_event_loop_wait_for_ownership.
-		//
-		// When the workloop became IDLE, it didn't find the sync waiter
-		// continuation, didn't have a thread request to cancel either, and so
-		// we need the kernel to forget about the current thread ownership
-		// of the workloop.
-		//
-		// To forget this ownership, we create a fake WAKE knote that can not
-		// coalesce with any meaningful one, just so that we can EV_DELETE it
-		// with the NOTE_WL_END_OWNERSHIP.
-		//
-		// This is a gross hack, but this will really only ever happen for
-		// cases where a sync waiter started to wait on a workloop, but his part
-		// of the graph got mutated and retargeted onto a different workloop.
-		// In doing so, that sync waiter has snitched to the kernel about
-		// ownership, and the workloop he's bogusly waiting on will go through
-		// this codepath.
-		//
-		needs_forceful_end_ownership = true;
-	}
-
-	if (_dq_state_in_sync_transfer(old_state)) {
-		dispatch_tid tid = _dispatch_tid_self();
-		_dispatch_kq_fill_workloop_sync_event(&ke[n++],
-				DISPATCH_WORKLOOP_SYNC_END, wlh, new_state, tid);
-	} else if (needs_forceful_end_ownership) {
-		kev_flags |= KEVENT_FLAG_DYNAMIC_KQ_MUST_EXIST;
-		_dispatch_kq_fill_workloop_event(&ke[n++],
-				DISPATCH_WORKLOOP_ASYNC_FORCE_END_OWNERSHIP, wlh, new_state);
-	}
-
-	if (_dispatch_kq_poll(wlh, ke, n, ke, n, NULL, NULL, kev_flags)) {
-		_dispatch_kevent_workloop_drain_error(&ke[0], 0);
-		__builtin_unreachable();
-	}
-
-	_dispatch_event_loop_assert_not_owned(wlh);
-
-	int extra_refs = (flags & DISPATCH_EVENT_LOOP_CONSUME_2) ? 2 : 0;
-	if (_dq_state_is_enqueued_on_target(old_state)) extra_refs++;
-	if (_dq_state_is_enqueued_on_target(new_state)) extra_refs--;
-	dispatch_assert(extra_refs >= 0);
-	if (extra_refs > 0) _dispatch_release_n((dispatch_queue_t)wlh, extra_refs);
-#else
-	(void)wlh; (void)old_state; (void)new_state; (void)flags;
-#endif // DISPATCH_USE_KEVENT_WORKLOOP
-}
-
-#if DISPATCH_WLH_DEBUG
-void
-_dispatch_event_loop_assert_not_owned(dispatch_wlh_t wlh)
-{
-#if DISPATCH_USE_KEVENT_WORKLOOP
-	if (wlh != DISPATCH_WLH_ANON) {
-		dispatch_kevent_s ke;
-		if (_dispatch_kevent_workloop_get_info(wlh, &ke)) {
-			dispatch_assert(ke.ext[0] != _pthread_threadid_self_np_direct());
-		}
-	}
-#else
-	(void)wlh;
-#endif // DISPATCH_USE_KEVENT_WORKLOOP
-}
-#endif // DISPATCH_WLH_DEBUG
-
-#pragma mark -
-#pragma mark dispatch_event_loop timers
-
-#define DISPATCH_KEVENT_TIMEOUT_IDENT_MASK (~0ull << 8)
-
-DISPATCH_NOINLINE
-static void
-_dispatch_event_loop_timer_program(dispatch_timer_heap_t dth, uint32_t tidx,
-		uint64_t target, uint64_t leeway, uint16_t action)
-{
-	dispatch_wlh_t wlh = _dispatch_get_wlh();
-#if DISPATCH_USE_KEVENT_QOS
-	pthread_priority_t pp = _PTHREAD_PRIORITY_EVENT_MANAGER_FLAG;
-	if (wlh != DISPATCH_WLH_ANON) {
-		pp = _dispatch_qos_to_pp(dth[tidx].dth_max_qos);
-	}
-#endif
-	dispatch_kevent_s ke = {
-		.ident = DISPATCH_KEVENT_TIMEOUT_IDENT_MASK | tidx,
-		.filter = EVFILT_TIMER,
-		.flags = action | EV_ONESHOT,
-		.fflags = _dispatch_timer_index_to_fflags[tidx],
-		.data = (int64_t)target,
-		.udata = (dispatch_kevent_udata_t)dth,
-#if DISPATCH_HAVE_TIMER_COALESCING
-		.ext[1] = leeway,
-#endif
-#if DISPATCH_USE_KEVENT_QOS
-		.qos = (__typeof__(ke.qos))pp,
-#endif
-	};
-	(void)leeway; // if !DISPATCH_HAVE_TIMER_COALESCING
-
-	_dispatch_kq_deferred_update(wlh, &ke);
-}
-
-void
-_dispatch_event_loop_timer_arm(dispatch_timer_heap_t dth, uint32_t tidx,
-		dispatch_timer_delay_s range, dispatch_clock_now_cache_t nows)
-{
-	dispatch_clock_t clock = DISPATCH_TIMER_CLOCK(tidx);
-	uint64_t target = range.delay + _dispatch_time_now_cached(clock, nows);
-	if (unlikely(_dispatch_timers_force_max_leeway)) {
-		target += range.leeway;
-		range.leeway = 0;
-	}
-
-	_dispatch_event_loop_timer_program(dth, tidx, target, range.leeway,
-			EV_ADD | EV_ENABLE);
-#if HAVE_MACH
-	if (clock == DISPATCH_CLOCK_WALL) {
-		_dispatch_mach_host_calendar_change_register();
-	}
-#endif
-}
-
-void
-_dispatch_event_loop_timer_delete(dispatch_timer_heap_t dth, uint32_t tidx)
-{
-	_dispatch_event_loop_timer_program(dth, tidx, 0, 0, EV_DELETE);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_kevent_timer_drain(dispatch_kevent_t ke)
-{
-	dispatch_timer_heap_t dth = (dispatch_timer_heap_t)ke->udata;
-	uint32_t tidx = ke->ident & ~DISPATCH_KEVENT_TIMEOUT_IDENT_MASK;
-
-	dispatch_assert(ke->data > 0);
-	dispatch_assert(ke->ident == (tidx | DISPATCH_KEVENT_TIMEOUT_IDENT_MASK));
-	dispatch_assert(tidx < DISPATCH_TIMER_COUNT);
-
-	_dispatch_timers_heap_dirty(dth, tidx);
-	dth[tidx].dth_needs_program = true;
-	dth[tidx].dth_armed = false;
-}
-
-#pragma mark -
-#pragma mark kevent specific sources
-
-static dispatch_unote_t
-_dispatch_source_proc_create(dispatch_source_type_t dst DISPATCH_UNUSED,
-		uintptr_t handle, unsigned long mask DISPATCH_UNUSED)
-{
-	dispatch_unote_t du = _dispatch_unote_create_with_handle(dst, handle, mask);
-	if (du._du && (mask & DISPATCH_PROC_EXIT_STATUS)) {
-		du._du->du_has_extended_status = true;
-	}
-	return du;
-}
-
-const dispatch_source_type_s _dispatch_source_type_proc = {
-	.dst_kind       = "proc",
-	.dst_filter     = EVFILT_PROC,
-	.dst_flags      = DISPATCH_EV_DIRECT|EV_CLEAR,
-	.dst_fflags     = NOTE_EXIT, // rdar://16655831
-	.dst_mask       = NOTE_EXIT|NOTE_FORK|NOTE_EXEC|NOTE_EXITSTATUS
-#if HAVE_DECL_NOTE_SIGNAL
-			|NOTE_SIGNAL
-#endif
-#if HAVE_DECL_NOTE_REAP
-			|NOTE_REAP
-#endif
-			,
-	.dst_action     = DISPATCH_UNOTE_ACTION_SOURCE_OR_FFLAGS,
-	.dst_size       = sizeof(struct dispatch_source_refs_s),
-	.dst_strict     = false,
-
-	.dst_create     = _dispatch_source_proc_create,
-	.dst_merge_evt  = _dispatch_source_merge_evt,
-};
-
-const dispatch_source_type_s _dispatch_source_type_vnode = {
-	.dst_kind       = "vnode",
-	.dst_filter     = EVFILT_VNODE,
-	.dst_flags      = DISPATCH_EV_DIRECT|EV_CLEAR|EV_VANISHED,
-	.dst_mask       = NOTE_DELETE|NOTE_WRITE|NOTE_EXTEND|NOTE_ATTRIB|NOTE_LINK
-			|NOTE_RENAME|NOTE_FUNLOCK
-#if HAVE_DECL_NOTE_REVOKE
-			|NOTE_REVOKE
-#endif
-#if HAVE_DECL_NOTE_NONE
-			|NOTE_NONE
-#endif
-			,
-	.dst_action     = DISPATCH_UNOTE_ACTION_SOURCE_OR_FFLAGS,
-	.dst_size       = sizeof(struct dispatch_source_refs_s),
-	.dst_strict     = false,
-
-	.dst_create     = _dispatch_unote_create_with_fd,
-	.dst_merge_evt  = _dispatch_source_merge_evt,
-};
-
-const dispatch_source_type_s _dispatch_source_type_vfs = {
-	.dst_kind       = "vfs",
-	.dst_filter     = EVFILT_FS,
-	.dst_flags      = DISPATCH_EV_DIRECT|EV_CLEAR,
-	.dst_mask       = VQ_NOTRESP|VQ_NEEDAUTH|VQ_LOWDISK|VQ_MOUNT|VQ_UNMOUNT
-			|VQ_DEAD|VQ_ASSIST|VQ_NOTRESPLOCK
-#if HAVE_DECL_VQ_UPDATE
-			|VQ_UPDATE
-#endif
-#if HAVE_DECL_VQ_VERYLOWDISK
-			|VQ_VERYLOWDISK
-#endif
-#if HAVE_DECL_VQ_QUOTA
-			|VQ_QUOTA
-#endif
-#if HAVE_DECL_VQ_NEARLOWDISK
-			|VQ_NEARLOWDISK
-#endif
-#if HAVE_DECL_VQ_DESIRED_DISK
-			|VQ_DESIRED_DISK
-#endif
-#if HAVE_DECL_VQ_FREE_SPACE_CHANGE
-			|VQ_FREE_SPACE_CHANGE
-#endif
-			,
-	.dst_action     = DISPATCH_UNOTE_ACTION_SOURCE_OR_FFLAGS,
-	.dst_size       = sizeof(struct dispatch_source_refs_s),
-	.dst_strict     = false,
-
-	.dst_create     = _dispatch_unote_create_without_handle,
-	.dst_merge_evt  = _dispatch_source_merge_evt,
-};
-
-#ifdef EVFILT_SOCK
-const dispatch_source_type_s _dispatch_source_type_sock = {
-	.dst_kind       = "sock",
-	.dst_filter     = EVFILT_SOCK,
-	.dst_flags      = DISPATCH_EV_DIRECT|EV_CLEAR|EV_VANISHED,
-	.dst_mask       = NOTE_CONNRESET|NOTE_READCLOSED|NOTE_WRITECLOSED
-			|NOTE_TIMEOUT|NOTE_NOSRCADDR|NOTE_IFDENIED|NOTE_SUSPEND|NOTE_RESUME
-			|NOTE_KEEPALIVE
-#ifdef NOTE_ADAPTIVE_WTIMO
-			|NOTE_ADAPTIVE_WTIMO|NOTE_ADAPTIVE_RTIMO
-#endif
-#ifdef NOTE_CONNECTED
-			|NOTE_CONNECTED|NOTE_DISCONNECTED|NOTE_CONNINFO_UPDATED
-#endif
-#ifdef NOTE_NOTIFY_ACK
-			|NOTE_NOTIFY_ACK
-#endif
-		,
-	.dst_action     = DISPATCH_UNOTE_ACTION_SOURCE_OR_FFLAGS,
-	.dst_size       = sizeof(struct dispatch_source_refs_s),
-	.dst_strict     = false,
-
-	.dst_create     = _dispatch_unote_create_with_fd,
-	.dst_merge_evt  = _dispatch_source_merge_evt,
-};
-#endif // EVFILT_SOCK
-
-#ifdef EVFILT_NW_CHANNEL
-const dispatch_source_type_s _dispatch_source_type_nw_channel = {
-	.dst_kind       = "nw_channel",
-	.dst_filter     = EVFILT_NW_CHANNEL,
-	.dst_flags      = DISPATCH_EV_DIRECT|EV_CLEAR|EV_VANISHED,
-	.dst_mask       = NOTE_FLOW_ADV_UPDATE,
-	.dst_action     = DISPATCH_UNOTE_ACTION_SOURCE_OR_FFLAGS,
-	.dst_size       = sizeof(struct dispatch_source_refs_s),
-	.dst_strict     = false,
-
-	.dst_create     = _dispatch_unote_create_with_fd,
-	.dst_merge_evt  = _dispatch_source_merge_evt,
-};
-#endif // EVFILT_NW_CHANNEL
-
-#if DISPATCH_USE_MEMORYSTATUS
-
-#if DISPATCH_USE_MEMORYPRESSURE_SOURCE
-#define DISPATCH_MEMORYPRESSURE_SOURCE_MASK ( \
-		DISPATCH_MEMORYPRESSURE_NORMAL | \
-		DISPATCH_MEMORYPRESSURE_WARN | \
-		DISPATCH_MEMORYPRESSURE_CRITICAL | \
-		DISPATCH_MEMORYPRESSURE_PROC_LIMIT_WARN | \
-		DISPATCH_MEMORYPRESSURE_PROC_LIMIT_CRITICAL | \
-		DISPATCH_MEMORYPRESSURE_MSL_STATUS)
-
-#define DISPATCH_MEMORYPRESSURE_MALLOC_MASK ( \
-		DISPATCH_MEMORYPRESSURE_WARN | \
-		DISPATCH_MEMORYPRESSURE_CRITICAL | \
-		DISPATCH_MEMORYPRESSURE_PROC_LIMIT_WARN | \
-		DISPATCH_MEMORYPRESSURE_PROC_LIMIT_CRITICAL | \
-		DISPATCH_MEMORYPRESSURE_MSL_STATUS)
-
-
-static void
-_dispatch_memorypressure_handler(void *context)
-{
-	dispatch_source_t ds = context;
-	unsigned long memorypressure = dispatch_source_get_data(ds);
-
-	if (memorypressure & DISPATCH_MEMORYPRESSURE_NORMAL) {
-		_dispatch_memory_warn = false;
-		_dispatch_continuation_cache_limit = DISPATCH_CONTINUATION_CACHE_LIMIT;
-#if VOUCHER_USE_MACH_VOUCHER
-		if (_firehose_task_buffer) {
-			firehose_buffer_clear_bank_flags(_firehose_task_buffer,
-					FIREHOSE_BUFFER_BANK_FLAG_LOW_MEMORY);
-		}
-#endif
-	}
-	if (memorypressure & DISPATCH_MEMORYPRESSURE_WARN) {
-		_dispatch_memory_warn = true;
-		_dispatch_continuation_cache_limit =
-				DISPATCH_CONTINUATION_CACHE_LIMIT_MEMORYPRESSURE_PRESSURE_WARN;
-#if VOUCHER_USE_MACH_VOUCHER
-		if (_firehose_task_buffer) {
-			firehose_buffer_set_bank_flags(_firehose_task_buffer,
-					FIREHOSE_BUFFER_BANK_FLAG_LOW_MEMORY);
-		}
-#endif
-	}
-	memorypressure &= DISPATCH_MEMORYPRESSURE_MALLOC_MASK;
-	if (memorypressure) {
-		malloc_memory_event_handler(memorypressure);
-	}
-}
-
-static void
-_dispatch_memorypressure_init(void)
-{
-	dispatch_source_t ds = dispatch_source_create(
-			DISPATCH_SOURCE_TYPE_MEMORYPRESSURE, 0,
-			DISPATCH_MEMORYPRESSURE_SOURCE_MASK, _dispatch_mgr_q._as_dq);
-	dispatch_set_context(ds, ds);
-	dispatch_source_set_event_handler_f(ds, _dispatch_memorypressure_handler);
-	dispatch_activate(ds);
-}
-#endif // DISPATCH_USE_MEMORYPRESSURE_SOURCE
-
-#if TARGET_OS_SIMULATOR // rdar://problem/9219483
-static int _dispatch_ios_simulator_memory_warnings_fd = -1;
-static void
-_dispatch_ios_simulator_memorypressure_init(void *context DISPATCH_UNUSED)
-{
-	char *e = getenv("SIMULATOR_MEMORY_WARNINGS");
-	if (!e) return;
-	_dispatch_ios_simulator_memory_warnings_fd = open(e, O_EVTONLY);
-	if (_dispatch_ios_simulator_memory_warnings_fd == -1) {
-		(void)dispatch_assume_zero(errno);
-	}
-}
-
-static dispatch_unote_t
-_dispatch_source_memorypressure_create(dispatch_source_type_t dst,
-	uintptr_t handle, unsigned long mask)
-{
-	static dispatch_once_t pred;
-	dispatch_once_f(&pred, NULL, _dispatch_ios_simulator_memorypressure_init);
-
-	if (handle) {
-		return DISPATCH_UNOTE_NULL;
-	}
-
-	dst = &_dispatch_source_type_vnode;
-	handle = (uintptr_t)_dispatch_ios_simulator_memory_warnings_fd;
-	mask = NOTE_ATTRIB;
-
-	dispatch_unote_t du = dux_create(dst, handle, mask);
-	if (du._du) {
-		du._du->du_memorypressure_override = true;
-	}
-	return du;
-}
-#endif // TARGET_OS_SIMULATOR
-
-const dispatch_source_type_s _dispatch_source_type_memorypressure = {
-	.dst_kind       = "memorystatus",
-	.dst_filter     = EVFILT_MEMORYSTATUS,
-	.dst_flags      = EV_UDATA_SPECIFIC|EV_DISPATCH,
-	.dst_mask       = NOTE_MEMORYSTATUS_PRESSURE_NORMAL
-			|NOTE_MEMORYSTATUS_PRESSURE_WARN|NOTE_MEMORYSTATUS_PRESSURE_CRITICAL
-			|NOTE_MEMORYSTATUS_LOW_SWAP|NOTE_MEMORYSTATUS_PROC_LIMIT_WARN
-			|NOTE_MEMORYSTATUS_PROC_LIMIT_CRITICAL
-			|NOTE_MEMORYSTATUS_MSL_STATUS,
-	.dst_action     = DISPATCH_UNOTE_ACTION_SOURCE_OR_FFLAGS,
-	.dst_size       = sizeof(struct dispatch_source_refs_s),
-	.dst_strict     = false,
-
-#if TARGET_OS_SIMULATOR
-	.dst_create     = _dispatch_source_memorypressure_create,
-	// redirected to _dispatch_source_type_vnode
-#else
-	.dst_create     = _dispatch_unote_create_without_handle,
-	.dst_merge_evt  = _dispatch_source_merge_evt,
-#endif
-};
-
-static dispatch_unote_t
-_dispatch_source_vm_create(dispatch_source_type_t dst DISPATCH_UNUSED,
-		uintptr_t handle, unsigned long mask DISPATCH_UNUSED)
-{
-	// Map legacy vm pressure to memorypressure warning rdar://problem/15907505
-	dispatch_unote_t du = dux_create(&_dispatch_source_type_memorypressure,
-			handle, NOTE_MEMORYSTATUS_PRESSURE_WARN);
-	if (du._du) {
-		du._du->du_vmpressure_override = 1;
-	}
-	return du;
-}
-
-const dispatch_source_type_s _dispatch_source_type_vm = {
-	.dst_kind       = "vm (deprecated)",
-	.dst_filter     = EVFILT_MEMORYSTATUS,
-	.dst_flags      = EV_UDATA_SPECIFIC|EV_DISPATCH,
-	.dst_mask       = NOTE_VM_PRESSURE,
-	.dst_action     = DISPATCH_UNOTE_ACTION_SOURCE_OR_FFLAGS,
-	.dst_size       = sizeof(struct dispatch_source_refs_s),
-	.dst_strict     = false,
-
-	.dst_create     = _dispatch_source_vm_create,
-	// redirected to _dispatch_source_type_memorypressure
-};
-#endif // DISPATCH_USE_MEMORYSTATUS
-
-#pragma mark mach send / notifications
-#if HAVE_MACH
-
-// Flags for all notifications that are registered/unregistered when a
-// send-possible notification is requested/delivered
-#define _DISPATCH_MACH_SP_FLAGS (DISPATCH_MACH_SEND_POSSIBLE| \
-		DISPATCH_MACH_SEND_DEAD|DISPATCH_MACH_SEND_DELETED)
-
-static void _dispatch_mach_host_notify_update(void *context);
-
-DISPATCH_STATIC_GLOBAL(dispatch_once_t _dispatch_mach_notify_port_pred);
-DISPATCH_STATIC_GLOBAL(dispatch_once_t _dispatch_mach_calendar_pred);
-DISPATCH_STATIC_GLOBAL(mach_port_t _dispatch_mach_notify_port);
-
-static void
-_dispatch_timers_calendar_change(void)
-{
-	dispatch_timer_heap_t dth = _dispatch_timers_heap;
-	uint32_t qos, tidx;
-
-	// calendar change may have gone past the wallclock deadline
-	for (qos = 0; qos < DISPATCH_TIMER_QOS_COUNT; qos++) {
-		tidx = DISPATCH_TIMER_INDEX(DISPATCH_CLOCK_WALL, qos);
-		_dispatch_timers_heap_dirty(dth, tidx);
-		dth[tidx].dth_needs_program = true;
-	}
-}
-
-static mach_msg_audit_trailer_t *
-_dispatch_mach_msg_get_audit_trailer(mach_msg_header_t *hdr)
-{
-	mach_msg_trailer_t *tlr = NULL;
-	mach_msg_audit_trailer_t *audit_tlr = NULL;
-	tlr = (mach_msg_trailer_t *)((unsigned char *)hdr +
-			round_msg(hdr->msgh_size));
-	// The trailer should always be of format zero.
-	if (tlr->msgh_trailer_type == MACH_MSG_TRAILER_FORMAT_0) {
-		if (tlr->msgh_trailer_size >= sizeof(mach_msg_audit_trailer_t)) {
-			audit_tlr = (mach_msg_audit_trailer_t *)tlr;
-		}
-	}
-	return audit_tlr;
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_mach_notification_merge_msg(dispatch_unote_t du, uint32_t flags,
-		mach_msg_header_t *hdr, mach_msg_size_t msgsz DISPATCH_UNUSED,
-		pthread_priority_t msg_pp DISPATCH_UNUSED,
-		pthread_priority_t ovr_pp DISPATCH_UNUSED)
-{
-	mig_reply_error_t reply;
-	mach_msg_audit_trailer_t *tlr = NULL;
-	dispatch_assert(sizeof(mig_reply_error_t) == sizeof(union
-		__ReplyUnion___dispatch_libdispatch_internal_protocol_subsystem));
-	dispatch_assert(sizeof(mig_reply_error_t) <
-			DISPATCH_MACH_RECEIVE_MAX_INLINE_MESSAGE_SIZE);
-	tlr = _dispatch_mach_msg_get_audit_trailer(hdr);
-	if (!tlr) {
-		DISPATCH_INTERNAL_CRASH(0, "message received without expected trailer");
-	}
-	if (hdr->msgh_id <= MACH_NOTIFY_LAST &&
-			dispatch_assume_zero(tlr->msgh_audit.val[
-			DISPATCH_MACH_AUDIT_TOKEN_PID])) {
-		mach_msg_destroy(hdr);
-		goto out;
-	}
-
-	boolean_t success = libdispatch_internal_protocol_server(hdr, &reply.Head);
-	if (!success && reply.RetCode == MIG_BAD_ID &&
-			(hdr->msgh_id == HOST_CALENDAR_SET_REPLYID ||
-			hdr->msgh_id == HOST_CALENDAR_CHANGED_REPLYID)) {
-		_dispatch_debug("calendar-change notification");
-		_dispatch_timers_calendar_change();
-		_dispatch_mach_host_notify_update(NULL);
-		success = TRUE;
-		reply.RetCode = KERN_SUCCESS;
-	}
-	if (dispatch_assume(success) && reply.RetCode != MIG_NO_REPLY) {
-		(void)dispatch_assume_zero(reply.RetCode);
-	}
-	if (!success || (reply.RetCode && reply.RetCode != MIG_NO_REPLY)) {
-		mach_msg_destroy(hdr);
-	}
-
-out:
-	if (flags & DISPATCH_EV_MSG_NEEDS_FREE) {
-		free(hdr);
-	}
-	return _dispatch_unote_resume(du);
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_mach_notify_port_init(void *context DISPATCH_UNUSED)
-{
-	mach_port_options_t opts = { .flags = MPO_CONTEXT_AS_GUARD | MPO_STRICT };
-	mach_port_context_t guard = (uintptr_t)&_dispatch_mach_notify_port;
-	kern_return_t kr;
-
-	kr = mach_port_construct(mach_task_self(), &opts, guard,
-			&_dispatch_mach_notify_port);
-	if (unlikely(kr)) {
-		DISPATCH_CLIENT_CRASH(kr,
-				"mach_port_construct() failed: cannot create receive right");
-	}
-
-	dispatch_unote_t du = dux_create(&_dispatch_mach_type_notification,
-			_dispatch_mach_notify_port, 0);
-
-	// make sure _dispatch_kevent_mach_msg_recv can call
-	// _dispatch_retain_unote_owner
-	du._du->du_owner_wref = _dispatch_ptr2wref(&_dispatch_mgr_q);
-
-	dispatch_assume(_dispatch_unote_register(du, DISPATCH_WLH_ANON,
-			DISPATCH_PRIORITY_FLAG_MANAGER));
-}
-
-static void
-_dispatch_mach_host_port_init(void *ctxt DISPATCH_UNUSED)
-{
-	kern_return_t kr;
-	mach_port_t mp, mhp = mach_host_self();
-	kr = host_get_host_port(mhp, &mp);
-	DISPATCH_VERIFY_MIG(kr);
-	if (likely(!kr)) {
-		// mach_host_self returned the HOST_PRIV port
-		kr = mach_port_deallocate(mach_task_self(), mhp);
-		DISPATCH_VERIFY_MIG(kr);
-		mhp = mp;
-	} else if (kr != KERN_INVALID_ARGUMENT) {
-		(void)dispatch_assume_zero(kr);
-	}
-	if (unlikely(!mhp)) {
-		DISPATCH_CLIENT_CRASH(kr, "Could not get unprivileged host port");
-	}
-	_dispatch_mach_host_port = mhp;
-}
-
-mach_port_t
-_dispatch_get_mach_host_port(void)
-{
-	dispatch_once_f(&_dispatch_mach_host_port_pred, NULL,
-			_dispatch_mach_host_port_init);
-	return _dispatch_mach_host_port;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline mach_port_t
-_dispatch_get_mach_notify_port(void)
-{
-	dispatch_once_f(&_dispatch_mach_notify_port_pred, NULL,
-			_dispatch_mach_notify_port_init);
-	return _dispatch_mach_notify_port;
-}
-
-static void
-_dispatch_mach_host_notify_update(void *context DISPATCH_UNUSED)
-{
-	kern_return_t kr;
-	_dispatch_debug("registering for calendar-change notification");
-
-	kr = host_request_notification(_dispatch_get_mach_host_port(),
-			HOST_NOTIFY_CALENDAR_SET, _dispatch_get_mach_notify_port());
-	DISPATCH_VERIFY_MIG(kr);
-	(void)dispatch_assume_zero(kr);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_mach_host_calendar_change_register(void)
-{
-	dispatch_once_f(&_dispatch_mach_calendar_pred, NULL,
-			_dispatch_mach_host_notify_update);
-}
-
-static kern_return_t
-_dispatch_mach_notify_update(dispatch_muxnote_t dmn, uint32_t new_flags,
-		uint32_t del_flags, uint32_t mask, mach_msg_id_t notify_msgid,
-		mach_port_mscount_t notify_sync)
-{
-	mach_port_t previous, port = (mach_port_t)dmn->dmn_kev.ident;
-	__typeof__(dmn->dmn_kev.data) prev = dmn->dmn_kev.data;
-	kern_return_t kr, krr = 0;
-
-	// Update notification registration state.
-	dmn->dmn_kev.data |= (new_flags | dmn->dmn_kev.fflags) & mask;
-	dmn->dmn_kev.data &= ~(del_flags & mask);
-
-	_dispatch_debug_machport(port);
-	if ((dmn->dmn_kev.data & mask) && !(prev & mask)) {
-		_dispatch_debug("machport[0x%08x]: registering for send-possible "
-				"notification", port);
-		previous = MACH_PORT_NULL;
-		krr = mach_port_request_notification(mach_task_self(), port,
-				notify_msgid, notify_sync, _dispatch_get_mach_notify_port(),
-				MACH_MSG_TYPE_MAKE_SEND_ONCE, &previous);
-		DISPATCH_VERIFY_MIG(krr);
-
-		switch (krr) {
-		case KERN_INVALID_NAME:
-		case KERN_INVALID_RIGHT:
-			// Suppress errors & clear registration state
-			dmn->dmn_kev.data &= ~mask;
-			break;
-		default:
-			// Else, we don't expect any errors from mach. Log any errors
-			if (dispatch_assume_zero(krr)) {
-				// log the error & clear registration state
-				dmn->dmn_kev.data &= ~mask;
-			} else if (dispatch_assume_zero(previous)) {
-				// Another subsystem has beat libdispatch to requesting the
-				// specified Mach notification on this port. We should
-				// technically cache the previous port and message it when the
-				// kernel messages our port. Or we can just say screw those
-				// subsystems and deallocate the previous port.
-				// They should adopt libdispatch :-P
-				kr = mach_port_deallocate(mach_task_self(), previous);
-				DISPATCH_VERIFY_MIG(kr);
-				(void)dispatch_assume_zero(kr);
-				previous = MACH_PORT_NULL;
-			}
-		}
-	} else if (!(dmn->dmn_kev.data & mask) && (prev & mask)) {
-		_dispatch_debug("machport[0x%08x]: unregistering for send-possible "
-				"notification", port);
-		previous = MACH_PORT_NULL;
-		kr = mach_port_request_notification(mach_task_self(), port,
-				notify_msgid, notify_sync, MACH_PORT_NULL,
-				MACH_MSG_TYPE_MOVE_SEND_ONCE, &previous);
-		DISPATCH_VERIFY_MIG(kr);
-
-		switch (kr) {
-		case KERN_INVALID_NAME:
-		case KERN_INVALID_RIGHT:
-		case KERN_INVALID_ARGUMENT:
-			break;
-		default:
-			if (dispatch_assume_zero(kr)) {
-				// log the error
-			}
-		}
-	} else {
-		return 0;
-	}
-	if (unlikely(previous)) {
-		// the kernel has not consumed the send-once right yet
-		(void)dispatch_assume_zero(
-				_dispatch_send_consume_send_once_right(previous));
-	}
-	return krr;
-}
-
-static bool
-_dispatch_kevent_mach_notify_resume(dispatch_muxnote_t dmn, uint32_t new_flags,
-		uint32_t del_flags)
-{
-	kern_return_t kr = KERN_SUCCESS;
-	dispatch_assert_zero(new_flags & del_flags);
-	if ((new_flags & _DISPATCH_MACH_SP_FLAGS) ||
-			(del_flags & _DISPATCH_MACH_SP_FLAGS)) {
-		// Requesting a (delayed) non-sync send-possible notification
-		// registers for both immediate dead-name notification and delayed-arm
-		// send-possible notification for the port.
-		// The send-possible notification is armed when a mach_msg() with the
-		// the MACH_SEND_NOTIFY to the port times out.
-		// If send-possible is unavailable, fall back to immediate dead-name
-		// registration rdar://problem/2527840&9008724
-		kr = _dispatch_mach_notify_update(dmn, new_flags, del_flags,
-				_DISPATCH_MACH_SP_FLAGS, MACH_NOTIFY_SEND_POSSIBLE,
-				MACH_NOTIFY_SEND_POSSIBLE == MACH_NOTIFY_DEAD_NAME);
-	}
-	return kr == KERN_SUCCESS;
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_mach_notify_merge(mach_port_t name, uint32_t data, bool final)
-{
-	dispatch_unote_linkage_t dul, dul_next;
-	dispatch_muxnote_t dmn;
-	uint32_t flags = EV_ENABLE;
-
-	_dispatch_debug_machport(name);
-	dmn = _dispatch_mach_muxnote_find(name, DISPATCH_EVFILT_MACH_NOTIFICATION);
-	if (!dmn) {
-		return;
-	}
-
-	dmn->dmn_kev.data &= ~_DISPATCH_MACH_SP_FLAGS;
-	if (final || !_dispatch_kevent_mach_notify_resume(dmn, data, 0)) {
-		flags = EV_ONESHOT;
-		dmn->dmn_kev.flags |= EV_DELETE;
-	}
-	os_atomic_store(&DISPATCH_MACH_NOTIFICATION_ARMED(dmn), 0, relaxed);
-
-	LIST_FOREACH_SAFE(dul, &dmn->dmn_unotes_head, du_link, dul_next) {
-		if (os_atomic_load(&DISPATCH_MACH_NOTIFICATION_ARMED(dmn), relaxed)) {
-			dispatch_assert(!final);
-			break;
-		}
-		dispatch_unote_t du = _dispatch_unote_linkage_get_unote(dul);
-		uint32_t fflags = (data & du._du->du_fflags);
-		os_atomic_store2o(du._du, dmsr_notification_armed, 0, relaxed);
-		if (final || fflags) {
-			// consumed by dux_merge_evt()
-			_dispatch_retain_unote_owner(du);
-			if (final) _dispatch_unote_unregister_muxed(du);
-			if (fflags && dux_type(du._du)->dst_action ==
-					DISPATCH_UNOTE_ACTION_SOURCE_OR_FFLAGS) {
-				os_atomic_or2o(du._dr, ds_pending_data, fflags, relaxed);
-			}
-			dux_merge_evt(du._du, flags, fflags, 0);
-		}
-	}
-}
-
-kern_return_t
-_dispatch_mach_notify_port_deleted(mach_port_t notify DISPATCH_UNUSED,
-		mach_port_name_t name)
-{
-#if DISPATCH_DEBUG
-	_dispatch_log("Corruption: Mach send/send-once/dead-name right 0x%x "
-			"deleted prematurely", name);
-#endif
-	_dispatch_debug_machport(name);
-	_dispatch_mach_notify_merge(name, DISPATCH_MACH_SEND_DELETED, true);
-	return KERN_SUCCESS;
-}
-
-kern_return_t
-_dispatch_mach_notify_dead_name(mach_port_t notify DISPATCH_UNUSED,
-		mach_port_name_t name)
-{
-	kern_return_t kr;
-
-	_dispatch_debug("machport[0x%08x]: dead-name notification", name);
-	_dispatch_debug_machport(name);
-	_dispatch_mach_notify_merge(name, DISPATCH_MACH_SEND_DEAD, true);
-
-	// the act of receiving a dead name notification allocates a dead-name
-	// right that must be deallocated
-	kr = mach_port_deallocate(mach_task_self(), name);
-	DISPATCH_VERIFY_MIG(kr);
-	//(void)dispatch_assume_zero(kr);
-	return KERN_SUCCESS;
-}
-
-kern_return_t
-_dispatch_mach_notify_send_possible(mach_port_t notify DISPATCH_UNUSED,
-		mach_port_name_t name)
-{
-	_dispatch_debug("machport[0x%08x]: send-possible notification", name);
-	_dispatch_debug_machport(name);
-	_dispatch_mach_notify_merge(name, DISPATCH_MACH_SEND_POSSIBLE, false);
-	return KERN_SUCCESS;
-}
-
-void
-_dispatch_mach_notification_set_armed(dispatch_mach_send_refs_t dmsr)
-{
-	dispatch_muxnote_t dmn = _dispatch_unote_get_linkage(dmsr)->du_muxnote;
-	dispatch_unote_linkage_t dul;
-	if (dmn) {
-#if HAVE_MACH
-		os_atomic_store(&DISPATCH_MACH_NOTIFICATION_ARMED(dmn), 1, relaxed);
-		LIST_FOREACH(dul, &dmn->dmn_unotes_head, du_link) {
-			dispatch_unote_t du = _dispatch_unote_linkage_get_unote(dul);
-			os_atomic_store2o(du._du, dmsr_notification_armed, 1, relaxed);
-		}
-		_dispatch_debug("machport[0x%08x]: send-possible notification armed",
-				(mach_port_name_t)dmn->dmn_kev.ident);
-#endif
-	}
-}
-
-static dispatch_unote_t
-_dispatch_source_mach_send_create(dispatch_source_type_t dst,
-		uintptr_t handle, unsigned long mask)
-{
-	if (!mask) {
-		// Preserve legacy behavior that (mask == 0) => DISPATCH_MACH_SEND_DEAD
-		mask = DISPATCH_MACH_SEND_DEAD;
-	}
-	if (!handle) {
-		handle = MACH_PORT_DEAD; // <rdar://problem/27651332>
-	}
-	return _dispatch_unote_create_with_handle(dst, handle, mask);
-}
-
-static bool
-_dispatch_mach_send_update(dispatch_muxnote_t dmn)
-{
-	if (dmn->dmn_kev.flags & EV_DELETE) {
-		return _dispatch_kevent_mach_notify_resume(dmn, 0, dmn->dmn_kev.fflags);
-	} else {
-		return _dispatch_kevent_mach_notify_resume(dmn, dmn->dmn_kev.fflags, 0);
-	}
-}
-
-const dispatch_source_type_s _dispatch_source_type_mach_send = {
-	.dst_kind       = "mach_send",
-	.dst_filter     = DISPATCH_EVFILT_MACH_NOTIFICATION,
-	.dst_flags      = EV_CLEAR,
-	.dst_mask       = DISPATCH_MACH_SEND_DEAD|DISPATCH_MACH_SEND_POSSIBLE,
-	.dst_action     = DISPATCH_UNOTE_ACTION_SOURCE_OR_FFLAGS,
-	.dst_size       = sizeof(struct dispatch_source_refs_s),
-	.dst_strict     = false,
-
-	.dst_create     = _dispatch_source_mach_send_create,
-	.dst_update_mux = _dispatch_mach_send_update,
-	.dst_merge_evt  = _dispatch_source_merge_evt,
-};
-
-static dispatch_unote_t
-_dispatch_mach_send_create(dispatch_source_type_t dst,
-	uintptr_t handle, unsigned long mask)
-{
-	// without handle because the mach code will set the ident later
-	dispatch_unote_t du =
-			_dispatch_unote_create_without_handle(dst, handle, mask);
-	if (du._dmsr) {
-		du._dmsr->dmsr_disconnect_cnt = DISPATCH_MACH_NEVER_CONNECTED;
-		LIST_INIT(&du._dmsr->dmsr_replies);
-	}
-	return du;
-}
-
-const dispatch_source_type_s _dispatch_mach_type_send = {
-	.dst_kind       = "mach_send (mach)",
-	.dst_filter     = DISPATCH_EVFILT_MACH_NOTIFICATION,
-	.dst_flags      = EV_CLEAR,
-	.dst_mask       = DISPATCH_MACH_SEND_DEAD|DISPATCH_MACH_SEND_POSSIBLE,
-	.dst_action     = DISPATCH_UNOTE_ACTION_PASS_FFLAGS,
-	.dst_size       = sizeof(struct dispatch_mach_send_refs_s),
-	.dst_strict     = false,
-
-	.dst_create     = _dispatch_mach_send_create,
-	.dst_update_mux = _dispatch_mach_send_update,
-	.dst_merge_evt  = _dispatch_mach_notification_merge_evt,
-};
-
-#endif // HAVE_MACH
-#pragma mark mach recv / reply
-#if HAVE_MACH
-
-static void
-_dispatch_kevent_mach_msg_recv(dispatch_unote_t du, uint32_t flags,
-		mach_msg_header_t *hdr, pthread_priority_t msg_pp,
-		pthread_priority_t ovr_pp)
-{
-	mach_port_t name = hdr->msgh_local_port;
-	mach_msg_size_t siz;
-
-	if (os_add_overflow(hdr->msgh_size, DISPATCH_MACH_TRAILER_SIZE, &siz)) {
-		DISPATCH_CLIENT_CRASH(hdr->msgh_size, "Overlarge message received");
-	}
-	if (os_unlikely(name == MACH_PORT_NULL)) {
-		DISPATCH_CLIENT_CRASH(hdr->msgh_id, "Received message with "
-				"MACH_PORT_NULL msgh_local_port");
-	}
-
-	_dispatch_debug_machport(name);
-	// consumed by dux_merge_evt()
-	_dispatch_retain_unote_owner(du);
-	_dispatch_kevent_merge_ev_flags(du, flags);
-	return dux_merge_msg(du._du, flags, hdr, siz, msg_pp, ovr_pp);
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_kevent_mach_msg_drain(dispatch_kevent_t ke)
-{
-	mach_msg_header_t *hdr = _dispatch_kevent_mach_msg_buf(ke);
-	dispatch_unote_t du = _dispatch_kevent_get_unote(ke);
-	pthread_priority_t msg_pp = (pthread_priority_t)(ke->ext[2] >> 32);
-	pthread_priority_t ovr_pp = (pthread_priority_t)ke->qos;
-	uint32_t flags = ke->flags;
-	mach_msg_size_t siz;
-	mach_msg_return_t kr = (mach_msg_return_t)ke->fflags;
-
-	if (unlikely(!hdr)) {
-		DISPATCH_INTERNAL_CRASH(kr, "EVFILT_MACHPORT with no message");
-	}
-	if (likely(!kr)) {
-		return _dispatch_kevent_mach_msg_recv(du, flags, hdr, msg_pp, ovr_pp);
-	}
-	if (kr != MACH_RCV_TOO_LARGE) {
-		goto out;
-	}
-
-	if (!ke->data) {
-		DISPATCH_INTERNAL_CRASH(0, "MACH_RCV_LARGE_IDENTITY with no identity");
-	}
-	if (unlikely(ke->ext[1] > (UINT_MAX - DISPATCH_MACH_TRAILER_SIZE))) {
-		DISPATCH_INTERNAL_CRASH(ke->ext[1],
-				"EVFILT_MACHPORT with overlarge message");
-	}
-	const mach_msg_option_t options = ((DISPATCH_MACH_RCV_OPTIONS |
-			MACH_RCV_TIMEOUT) & ~MACH_RCV_LARGE);
-	siz = _dispatch_kevent_mach_msg_size(ke) + DISPATCH_MACH_TRAILER_SIZE;
-	hdr = malloc(siz); // mach_msg will return TOO_LARGE if hdr/siz is NULL/0
-	kr = mach_msg(hdr, options, 0, dispatch_assume(hdr) ? siz : 0,
-			(mach_port_name_t)ke->data, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
-	if (likely(!kr)) {
-		flags |= DISPATCH_EV_MSG_NEEDS_FREE;
-		return _dispatch_kevent_mach_msg_recv(du, flags, hdr, msg_pp, ovr_pp);
-	}
-
-	if (kr == MACH_RCV_TOO_LARGE) {
-		_dispatch_log("BUG in libdispatch client: "
-				"_dispatch_kevent_mach_msg_drain: dropped message too "
-				"large to fit in memory: id = 0x%x, size = %u",
-				hdr->msgh_id, _dispatch_kevent_mach_msg_size(ke));
-		kr = MACH_MSG_SUCCESS;
-	}
-	free(hdr);
-
-out:
-	if (unlikely(kr)) {
-		_dispatch_bug_mach_client("_dispatch_kevent_mach_msg_drain: "
-				"message reception failed", kr);
-	}
-}
-
-const dispatch_source_type_s _dispatch_source_type_mach_recv = {
-	.dst_kind       = "mach_recv",
-	.dst_filter     = EVFILT_MACHPORT,
-	.dst_flags      = EV_UDATA_SPECIFIC|EV_DISPATCH|EV_VANISHED,
-	.dst_fflags     = 0,
-	.dst_action     = DISPATCH_UNOTE_ACTION_SOURCE_OR_FFLAGS,
-	.dst_size       = sizeof(struct dispatch_source_refs_s),
-	.dst_strict     = false,
-
-	.dst_create     = _dispatch_unote_create_with_handle,
-	.dst_merge_evt  = _dispatch_source_merge_evt,
-	.dst_merge_msg  = NULL, // never receives messages directly
-
-	.dst_per_trigger_qos = true,
-};
-
-static void
-_dispatch_mach_notification_event(dispatch_unote_t du, uint32_t flags DISPATCH_UNUSED,
-		uintptr_t data DISPATCH_UNUSED, pthread_priority_t pp DISPATCH_UNUSED)
-{
-	DISPATCH_CLIENT_CRASH(du._du->du_ident, "Unexpected non message event");
-}
-
-const dispatch_source_type_s _dispatch_mach_type_notification = {
-	.dst_kind       = "mach_notification",
-	.dst_filter     = EVFILT_MACHPORT,
-	.dst_flags      = EV_UDATA_SPECIFIC|EV_DISPATCH|EV_VANISHED,
-	.dst_fflags     = DISPATCH_MACH_RCV_OPTIONS,
-	.dst_action     = DISPATCH_UNOTE_ACTION_PASS_FFLAGS,
-	.dst_size       = sizeof(struct dispatch_unote_class_s),
-	.dst_strict     = false,
-
-	.dst_create     = _dispatch_unote_create_with_handle,
-	.dst_merge_evt  = _dispatch_mach_notification_event,
-	.dst_merge_msg  = _dispatch_mach_notification_merge_msg,
-
-	.dst_per_trigger_qos = true,
-};
-
-static void
-_dispatch_mach_recv_direct_merge_evt(dispatch_unote_t du, uint32_t flags,
-		uintptr_t data, pthread_priority_t pp)
-{
-	if (flags & EV_VANISHED) {
-		DISPATCH_CLIENT_CRASH(du._du->du_ident,
-				"Unexpected EV_VANISHED (do not destroy random mach ports)");
-	}
-	return _dispatch_source_merge_evt(du, flags, data, pp);
-}
-
-const dispatch_source_type_s _dispatch_mach_type_recv = {
-	.dst_kind       = "mach_recv (channel)",
-	.dst_filter     = EVFILT_MACHPORT,
-	.dst_flags      = EV_UDATA_SPECIFIC|EV_DISPATCH|EV_VANISHED,
-	.dst_fflags     = DISPATCH_MACH_RCV_OPTIONS,
-	.dst_action     = DISPATCH_UNOTE_ACTION_PASS_FFLAGS,
-	.dst_size       = sizeof(struct dispatch_mach_recv_refs_s),
-	.dst_strict     = false,
-
-	// without handle because the mach code will set the ident after connect
-	.dst_create     = _dispatch_unote_create_without_handle,
-	.dst_merge_evt  = _dispatch_mach_recv_direct_merge_evt,
-	.dst_merge_msg  = _dispatch_mach_merge_msg,
-
-	.dst_per_trigger_qos = true,
-};
-
-DISPATCH_NORETURN
-static void
-_dispatch_mach_reply_merge_evt(dispatch_unote_t du,
-		uint32_t flags DISPATCH_UNUSED, uintptr_t data DISPATCH_UNUSED,
-		pthread_priority_t pp DISPATCH_UNUSED)
-{
-	DISPATCH_INTERNAL_CRASH(du._du->du_ident, "Unexpected event");
-}
-
-const dispatch_source_type_s _dispatch_mach_type_reply = {
-	.dst_kind       = "mach reply",
-	.dst_filter     = EVFILT_MACHPORT,
-	.dst_flags      = EV_UDATA_SPECIFIC|EV_DISPATCH|EV_ONESHOT|EV_VANISHED,
-	.dst_fflags     = DISPATCH_MACH_RCV_OPTIONS,
-	.dst_action     = DISPATCH_UNOTE_ACTION_PASS_FFLAGS,
-	.dst_size       = sizeof(struct dispatch_mach_reply_refs_s),
-	.dst_strict     = false,
-
-	.dst_create     = _dispatch_unote_create_with_handle,
-	.dst_merge_evt  = _dispatch_mach_reply_merge_evt,
-	.dst_merge_msg  = _dispatch_mach_reply_merge_msg,
-};
-
-#pragma mark Mach channel SIGTERM notification (for XPC channels only)
-
-const dispatch_source_type_s _dispatch_xpc_type_sigterm = {
-	.dst_kind       = "sigterm (xpc)",
-	.dst_filter     = EVFILT_SIGNAL,
-	.dst_flags      = DISPATCH_EV_DIRECT|EV_CLEAR|EV_ONESHOT,
-	.dst_fflags     = 0,
-	.dst_action     = DISPATCH_UNOTE_ACTION_PASS_DATA,
-	.dst_size       = sizeof(struct dispatch_xpc_term_refs_s),
-	.dst_strict     = false,
-
-	.dst_create     = _dispatch_unote_create_with_handle,
-	.dst_merge_evt  = _dispatch_xpc_sigterm_merge_evt,
-};
-
-#endif // HAVE_MACH
-
-#endif // DISPATCH_EVENT_BACKEND_KEVENT
--- a/Telegram/ThirdParty/dispatch/src/event/event_windows.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/event/event_windows.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,991 +0,0 @@
-/*
- * Copyright (c) 2018 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include "internal.h"
-#if DISPATCH_EVENT_BACKEND_WINDOWS
-
-static HANDLE hPort = NULL;
-enum _dispatch_windows_port {
-	DISPATCH_PORT_POKE = 0,
-	DISPATCH_PORT_TIMER_CLOCK_WALL,
-	DISPATCH_PORT_TIMER_CLOCK_UPTIME,
-	DISPATCH_PORT_TIMER_CLOCK_MONOTONIC,
-	DISPATCH_PORT_FILE_HANDLE,
-	DISPATCH_PORT_PIPE_HANDLE_READ,
-	DISPATCH_PORT_PIPE_HANDLE_WRITE,
-	DISPATCH_PORT_SOCKET_READ,
-	DISPATCH_PORT_SOCKET_WRITE,
-};
-
-enum _dispatch_muxnote_events {
-	DISPATCH_MUXNOTE_EVENT_READ = 1 << 0,
-	DISPATCH_MUXNOTE_EVENT_WRITE = 1 << 1,
-};
-
-#pragma mark dispatch_unote_t
-
-typedef struct dispatch_muxnote_s {
-	LIST_ENTRY(dispatch_muxnote_s) dmn_list;
-	LIST_HEAD(, dispatch_unote_linkage_s) dmn_readers_head;
-	LIST_HEAD(, dispatch_unote_linkage_s) dmn_writers_head;
-
-	// This refcount solves a race condition that can happen with I/O completion
-	// ports. When we enqueue packets with muxnote pointers associated with
-	// them, it's possible that those packets might not be processed until after
-	// the event has been unregistered. We increment this upon creating a
-	// muxnote or posting to a completion port, and we decrement it upon
-	// unregistering the event or processing a packet. When it hits zero, we
-	// dispose the muxnote.
-	os_atomic(uintptr_t) dmn_refcount;
-
-	dispatch_unote_ident_t dmn_ident;
-	int8_t dmn_filter;
-	enum _dispatch_muxnote_handle_type {
-		DISPATCH_MUXNOTE_HANDLE_TYPE_INVALID,
-		DISPATCH_MUXNOTE_HANDLE_TYPE_FILE,
-		DISPATCH_MUXNOTE_HANDLE_TYPE_PIPE,
-		DISPATCH_MUXNOTE_HANDLE_TYPE_SOCKET,
-	} dmn_handle_type;
-	enum _dispatch_muxnote_events dmn_events;
-
-	// For pipes, this event is used to synchronize the monitoring thread with
-	// I/O completion port processing. For sockets, this is the event used with
-	// WSAEventSelect().
-	HANDLE dmn_event;
-
-	// Pipe monitoring thread control
-	HANDLE dmn_thread;
-	os_atomic(bool) dmn_stop;
-
-	// Socket events registered with WSAEventSelect()
-	long dmn_network_events;
-
-	// Threadpool wait handle for socket events
-	PTP_WAIT dmn_threadpool_wait;
-} *dispatch_muxnote_t;
-
-static LIST_HEAD(dispatch_muxnote_bucket_s, dispatch_muxnote_s)
-    _dispatch_sources[DSL_HASH_SIZE];
-
-DISPATCH_ALWAYS_INLINE
-static inline struct dispatch_muxnote_bucket_s *
-_dispatch_unote_muxnote_bucket(uint32_t ident)
-{
-	return &_dispatch_sources[DSL_HASH(ident)];
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_muxnote_t
-_dispatch_unote_muxnote_find(struct dispatch_muxnote_bucket_s *dmb,
-		dispatch_unote_ident_t ident, int8_t filter)
-{
-	dispatch_muxnote_t dmn;
-	if (filter == EVFILT_WRITE) filter = EVFILT_READ;
-	LIST_FOREACH(dmn, dmb, dmn_list) {
-		if (dmn->dmn_ident == ident && dmn->dmn_filter == filter) {
-			break;
-		}
-	}
-	return dmn;
-}
-
-static dispatch_muxnote_t
-_dispatch_muxnote_create(dispatch_unote_t du,
-		enum _dispatch_muxnote_events events)
-{
-	dispatch_muxnote_t dmn;
-	int8_t filter = du._du->du_filter;
-	HANDLE handle = (HANDLE)du._du->du_ident;
-
-	dmn = _dispatch_calloc(1, sizeof(*dmn));
-	if (dmn == NULL) {
-		DISPATCH_INTERNAL_CRASH(0, "_dispatch_calloc");
-	}
-	os_atomic_store(&dmn->dmn_refcount, 1, relaxed);
-	dmn->dmn_ident = (dispatch_unote_ident_t)handle;
-	dmn->dmn_filter = filter;
-	dmn->dmn_events = events;
-	LIST_INIT(&dmn->dmn_readers_head);
-	LIST_INIT(&dmn->dmn_writers_head);
-
-	switch (filter) {
-	case EVFILT_SIGNAL:
-		WIN_PORT_ERROR();
-		free(dmn);
-		return NULL;
-
-	case EVFILT_WRITE:
-	case EVFILT_READ:
-		switch (GetFileType(handle)) {
-		case FILE_TYPE_UNKNOWN:
-			// ensure that an invalid handle was not passed
-			(void)dispatch_assume(GetLastError() == NO_ERROR);
-			DISPATCH_INTERNAL_CRASH(0, "unknown handle type");
-
-		case FILE_TYPE_REMOTE:
-			DISPATCH_INTERNAL_CRASH(0, "unused handle type");
-
-		case FILE_TYPE_CHAR:
-			// The specified file is a character file, typically a
-			// LPT device or a console.
-			WIN_PORT_ERROR();
-			free(dmn);
-			return NULL;
-
-		case FILE_TYPE_DISK:
-			// The specified file is a disk file
-			dmn->dmn_handle_type = DISPATCH_MUXNOTE_HANDLE_TYPE_FILE;
-			break;
-
-		case FILE_TYPE_PIPE:
-			// The specified file is a socket, a named pipe, or an
-			// anonymous pipe.
-			dmn->dmn_handle_type = _dispatch_handle_is_socket(handle)
-					? DISPATCH_MUXNOTE_HANDLE_TYPE_SOCKET
-					: DISPATCH_MUXNOTE_HANDLE_TYPE_PIPE;
-			break;
-		}
-
-		break;
-
-	default:
-		DISPATCH_INTERNAL_CRASH(0, "unexpected filter");
-	}
-
-
-	return dmn;
-}
-
-static void
-_dispatch_muxnote_disarm_events(dispatch_muxnote_t dmn,
-		enum _dispatch_muxnote_events events)
-{
-	long lNetworkEvents;
-	dmn->dmn_events &= ~events;
-	switch (dmn->dmn_handle_type) {
-	case DISPATCH_MUXNOTE_HANDLE_TYPE_INVALID:
-		DISPATCH_INTERNAL_CRASH(0, "invalid handle");
-
-	case DISPATCH_MUXNOTE_HANDLE_TYPE_FILE:
-		break;
-
-	case DISPATCH_MUXNOTE_HANDLE_TYPE_PIPE:
-		if ((events & DISPATCH_MUXNOTE_EVENT_READ) && dmn->dmn_thread) {
-			// Keep trying to cancel ReadFile() until the thread exits
-			os_atomic_store(&dmn->dmn_stop, true, relaxed);
-			SetEvent(dmn->dmn_event);
-			do {
-				CancelIoEx((HANDLE)dmn->dmn_ident, /* lpOverlapped */ NULL);
-			} while (WaitForSingleObject(dmn->dmn_thread, 1) == WAIT_TIMEOUT);
-			CloseHandle(dmn->dmn_thread);
-			dmn->dmn_thread = NULL;
-		}
-		break;
-
-	case DISPATCH_MUXNOTE_HANDLE_TYPE_SOCKET:
-		lNetworkEvents = dmn->dmn_network_events;
-		if (events & DISPATCH_MUXNOTE_EVENT_READ) {
-			lNetworkEvents &= ~FD_READ;
-		}
-		if (events & DISPATCH_MUXNOTE_EVENT_WRITE) {
-			lNetworkEvents &= ~FD_WRITE;
-		}
-		if (lNetworkEvents == dmn->dmn_network_events) {
-			break;
-		}
-		int iResult;
-		if (lNetworkEvents & (FD_READ | FD_WRITE)) {
-			iResult = WSAEventSelect((SOCKET)dmn->dmn_ident,
-					(WSAEVENT)dmn->dmn_event, lNetworkEvents);
-		} else {
-			lNetworkEvents = 0;
-			iResult = WSAEventSelect((SOCKET)dmn->dmn_ident, NULL, 0);
-		}
-		if (iResult != 0) {
-			DISPATCH_INTERNAL_CRASH(WSAGetLastError(), "WSAEventSelect");
-		}
-		dmn->dmn_network_events = lNetworkEvents;
-		if (!lNetworkEvents && dmn->dmn_threadpool_wait) {
-			SetThreadpoolWait(dmn->dmn_threadpool_wait, NULL, NULL);
-			WaitForThreadpoolWaitCallbacks(dmn->dmn_threadpool_wait,
-					/* fCancelPendingCallbacks */ FALSE);
-			CloseThreadpoolWait(dmn->dmn_threadpool_wait);
-			dmn->dmn_threadpool_wait = NULL;
-		}
-		break;
-	}
-}
-
-static void
-_dispatch_muxnote_dispose(dispatch_muxnote_t dmn)
-{
-	if (dmn->dmn_thread || dmn->dmn_threadpool_wait) {
-		DISPATCH_INTERNAL_CRASH(0, "disposed a muxnote with an active thread");
-	}
-	if (dmn->dmn_event) {
-		CloseHandle(dmn->dmn_event);
-	}
-	free(dmn);
-}
-
-static void
-_dispatch_muxnote_retain(dispatch_muxnote_t dmn)
-{
-	uintptr_t refcount = os_atomic_inc(&dmn->dmn_refcount, relaxed);
-	if (refcount == 0) {
-		DISPATCH_INTERNAL_CRASH(0, "muxnote refcount overflow");
-	}
-	if (refcount == 1) {
-		DISPATCH_INTERNAL_CRASH(0, "retained a disposing muxnote");
-	}
-}
-
-static void
-_dispatch_muxnote_release(dispatch_muxnote_t dmn)
-{
-	uintptr_t refcount = os_atomic_dec(&dmn->dmn_refcount, relaxed);
-	if (refcount == 0) {
-		_dispatch_muxnote_dispose(dmn);
-	} else if (refcount == UINTPTR_MAX) {
-		DISPATCH_INTERNAL_CRASH(0, "muxnote refcount underflow");
-	}
-}
-
-static unsigned WINAPI
-_dispatch_pipe_monitor_thread(void *context)
-{
-	dispatch_muxnote_t dmn = (dispatch_muxnote_t)context;
-	HANDLE hPipe = (HANDLE)dmn->dmn_ident;
-	do {
-		char cBuffer[1];
-		DWORD dwNumberOfBytesTransferred;
-		OVERLAPPED ov = {0};
-		BOOL bSuccess = ReadFile(hPipe, cBuffer, /* nNumberOfBytesToRead */ 0,
-				&dwNumberOfBytesTransferred, &ov);
-		DWORD dwBytesAvailable;
-		DWORD dwError = GetLastError();
-		if (!bSuccess && dwError == ERROR_IO_PENDING) {
-			bSuccess = GetOverlappedResult(hPipe, &ov,
-					&dwNumberOfBytesTransferred, /* bWait */ TRUE);
-			dwError = GetLastError();
-		}
-		if (bSuccess) {
-			bSuccess = PeekNamedPipe(hPipe, NULL, 0, NULL, &dwBytesAvailable,
-					NULL);
-			dwError = GetLastError();
-		}
-		if (bSuccess) {
-			if (dwBytesAvailable == 0) {
-				// This can happen with a zero-byte write. Try again.
-				continue;
-			}
-		} else if (dwError == ERROR_NO_DATA) {
-			// The pipe is nonblocking. Try again.
-			Sleep(0);
-			continue;
-		} else {
-			_dispatch_debug("pipe[0x%llx]: GetLastError() returned %lu",
-					(long long)hPipe, dwError);
-			if (dwError == ERROR_OPERATION_ABORTED) {
-				continue;
-			}
-			os_atomic_store(&dmn->dmn_stop, true, relaxed);
-			dwBytesAvailable = 0;
-		}
-
-		// Make sure the muxnote stays alive until the packet is dequeued
-		_dispatch_muxnote_retain(dmn);
-
-		// The lpOverlapped parameter does not actually need to point to an
-		// OVERLAPPED struct. It's really just a pointer to pass back to
-		// GetQueuedCompletionStatus().
-		bSuccess = PostQueuedCompletionStatus(hPort,
-				dwBytesAvailable, (ULONG_PTR)DISPATCH_PORT_PIPE_HANDLE_READ,
-				(LPOVERLAPPED)dmn);
-		if (!bSuccess) {
-			DISPATCH_INTERNAL_CRASH(GetLastError(),
-					"PostQueuedCompletionStatus");
-		}
-
-		// If data is written into the pipe and not read right away, ReadFile()
-		// will keep returning immediately and we'll flood the completion port.
-		// This event lets us synchronize with _dispatch_event_loop_drain() so
-		// that we only post events when it's ready for them.
-		WaitForSingleObject(dmn->dmn_event, INFINITE);
-	} while (!os_atomic_load(&dmn->dmn_stop, relaxed));
-	_dispatch_debug("pipe[0x%llx]: monitor exiting", (long long)hPipe);
-	return 0;
-}
-
-static DWORD
-_dispatch_pipe_write_availability(HANDLE hPipe)
-{
-	IO_STATUS_BLOCK iosb;
-	FILE_PIPE_LOCAL_INFORMATION fpli;
-	NTSTATUS status = _dispatch_NtQueryInformationFile(hPipe, &iosb, &fpli,
-			sizeof(fpli), FilePipeLocalInformation);
-	if (!NT_SUCCESS(status)) {
-		return 1;
-	}
-	return fpli.WriteQuotaAvailable;
-}
-
-static VOID CALLBACK
-_dispatch_socket_callback(PTP_CALLBACK_INSTANCE inst, void *context,
-		PTP_WAIT pwa, TP_WAIT_RESULT res)
-{
-	dispatch_muxnote_t dmn = (dispatch_muxnote_t)context;
-	SOCKET sock = (SOCKET)dmn->dmn_ident;
-	WSANETWORKEVENTS events;
-	if (WSAEnumNetworkEvents(sock, (WSAEVENT)dmn->dmn_event, &events) == 0) {
-		long lNetworkEvents = events.lNetworkEvents;
-		DWORD dwBytesAvailable = 1;
-		if (lNetworkEvents & FD_CLOSE) {
-			dwBytesAvailable = 0;
-		} else if (lNetworkEvents & FD_READ) {
-			ioctlsocket(sock, FIONREAD, &dwBytesAvailable);
-		}
-		if ((lNetworkEvents & FD_CLOSE) ||
-			((lNetworkEvents & FD_READ) && (dwBytesAvailable > 0))) {
-			_dispatch_muxnote_retain(dmn);
-			if (!PostQueuedCompletionStatus(hPort, dwBytesAvailable,
-					(ULONG_PTR)DISPATCH_PORT_SOCKET_READ, (LPOVERLAPPED)dmn)) {
-				DISPATCH_INTERNAL_CRASH(GetLastError(),
-						"PostQueuedCompletionStatus");
-			}
-		}
-		if ((lNetworkEvents & FD_CLOSE) || (lNetworkEvents & FD_WRITE)) {
-			_dispatch_muxnote_retain(dmn);
-			if (!PostQueuedCompletionStatus(hPort,
-					lNetworkEvents & FD_CLOSE ? 0 : 1,
-					(ULONG_PTR)DISPATCH_PORT_SOCKET_WRITE, (LPOVERLAPPED)dmn)) {
-				DISPATCH_INTERNAL_CRASH(GetLastError(),
-						"PostQueuedCompletionStatus");
-			}
-		}
-	} else {
-		_dispatch_debug("socket[0x%llx]: WSAEnumNetworkEvents() failed (%d)",
-				(long long)sock, WSAGetLastError());
-	}
-	SetThreadpoolWait(pwa, dmn->dmn_event, /* pftTimeout */ NULL);
-}
-
-static BOOL
-_dispatch_io_trigger(dispatch_muxnote_t dmn)
-{
-	BOOL bSuccess;
-	long lNetworkEvents;
-
-	switch (dmn->dmn_handle_type) {
-	case DISPATCH_MUXNOTE_HANDLE_TYPE_INVALID:
-		DISPATCH_INTERNAL_CRASH(0, "invalid handle");
-
-	case DISPATCH_MUXNOTE_HANDLE_TYPE_FILE:
-		_dispatch_muxnote_retain(dmn);
-		bSuccess = PostQueuedCompletionStatus(hPort, 0,
-			(ULONG_PTR)DISPATCH_PORT_FILE_HANDLE, (LPOVERLAPPED)dmn);
-		if (bSuccess == FALSE) {
-			DISPATCH_INTERNAL_CRASH(GetLastError(),
-				"PostQueuedCompletionStatus");
-		}
-		break;
-
-	case DISPATCH_MUXNOTE_HANDLE_TYPE_PIPE:
-		if ((dmn->dmn_events & DISPATCH_MUXNOTE_EVENT_READ) &&
-				!dmn->dmn_thread) {
-			dmn->dmn_thread = (HANDLE)_beginthreadex(/* security */ NULL,
-					/* stack_size */ 1, _dispatch_pipe_monitor_thread,
-					(void *)dmn, /* initflag */ 0, /* thrdaddr */ NULL);
-			if (!dmn->dmn_thread) {
-				DISPATCH_INTERNAL_CRASH(errno, "_beginthread");
-			}
-			dmn->dmn_event = CreateEventW(NULL, /* bManualReset */ FALSE,
-					/* bInitialState */ FALSE, NULL);
-			if (!dmn->dmn_event) {
-				DISPATCH_INTERNAL_CRASH(GetLastError(), "CreateEventW");
-			}
-		}
-		if (dmn->dmn_events & DISPATCH_MUXNOTE_EVENT_WRITE) {
-			_dispatch_muxnote_retain(dmn);
-			DWORD available;
-			if (dmn->dmn_events & DISPATCH_MUXNOTE_EVENT_READ) {
-				// We can't query a pipe which has a read source open on it
-				// because the ReadFile() in the background thread might cause
-				// NtQueryInformationFile() to block
-				available = 1;
-			} else {
-				available =
-					_dispatch_pipe_write_availability((HANDLE)dmn->dmn_ident);
-			}
-			bSuccess = PostQueuedCompletionStatus(hPort, available,
-					(ULONG_PTR)DISPATCH_PORT_PIPE_HANDLE_WRITE,
-					(LPOVERLAPPED)dmn);
-			if (bSuccess == FALSE) {
-				DISPATCH_INTERNAL_CRASH(GetLastError(),
-						"PostQueuedCompletionStatus");
-			}
-		}
-		break;
-
-	case DISPATCH_MUXNOTE_HANDLE_TYPE_SOCKET:
-		if (!dmn->dmn_event) {
-			dmn->dmn_event = CreateEventW(NULL, /* bManualReset */ FALSE,
-					/* bInitialState */ FALSE, NULL);
-			if (!dmn->dmn_event) {
-				DISPATCH_INTERNAL_CRASH(GetLastError(), "CreateEventW");
-			}
-		}
-		if (!dmn->dmn_threadpool_wait) {
-			dmn->dmn_threadpool_wait = CreateThreadpoolWait(
-					_dispatch_socket_callback, dmn,
-					/* PTP_CALLBACK_ENVIRON */ NULL);
-			if (!dmn->dmn_threadpool_wait) {
-				DISPATCH_INTERNAL_CRASH(GetLastError(), "CreateThreadpoolWait");
-			}
-			SetThreadpoolWait(dmn->dmn_threadpool_wait, dmn->dmn_event,
-					/* pftTimeout */ NULL);
-		}
-		lNetworkEvents = FD_CLOSE;
-		if (dmn->dmn_events & DISPATCH_MUXNOTE_EVENT_READ) {
-			lNetworkEvents |= FD_READ;
-		}
-		if (dmn->dmn_events & DISPATCH_MUXNOTE_EVENT_WRITE) {
-			lNetworkEvents |= FD_WRITE;
-		}
-		if (dmn->dmn_network_events != lNetworkEvents) {
-			if (WSAEventSelect((SOCKET)dmn->dmn_ident, (WSAEVENT)dmn->dmn_event,
-					lNetworkEvents) != 0) {
-				DISPATCH_INTERNAL_CRASH(WSAGetLastError(), "WSAEventSelect");
-			}
-			dmn->dmn_network_events = lNetworkEvents;
-		}
-		if (dmn->dmn_events & DISPATCH_MUXNOTE_EVENT_WRITE) {
-			// FD_WRITE is edge-triggered, not level-triggered, so it will only
-			// be signaled if the socket becomes writable after a send() fails
-			// with WSAEWOULDBLOCK. We can work around this by performing a
-			// zero-byte send(). If the socket is writable, the send() will
-			// succeed and we can immediately post a packet, and if it isn't, it
-			// will fail with WSAEWOULDBLOCK and WSAEventSelect() will report
-			// the next time it becomes available.
-			if (send((SOCKET)dmn->dmn_ident, "", 0, 0) == 0) {
-				_dispatch_muxnote_retain(dmn);
-				bSuccess = PostQueuedCompletionStatus(hPort, 1,
-						(ULONG_PTR)DISPATCH_PORT_SOCKET_WRITE,
-						(LPOVERLAPPED)dmn);
-				if (bSuccess == FALSE) {
-					DISPATCH_INTERNAL_CRASH(GetLastError(),
-							"PostQueuedCompletionStatus");
-				}
-			}
-		}
-		break;
-	}
-
-	return TRUE;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline enum _dispatch_muxnote_events
-_dispatch_unote_required_events(dispatch_unote_t du)
-{
-	switch (du._du->du_filter) {
-	case DISPATCH_EVFILT_CUSTOM_ADD:
-	case DISPATCH_EVFILT_CUSTOM_OR:
-	case DISPATCH_EVFILT_CUSTOM_REPLACE:
-		return 0;
-	case EVFILT_WRITE:
-		return DISPATCH_MUXNOTE_EVENT_WRITE;
-	default:
-		return DISPATCH_MUXNOTE_EVENT_READ;
-	}
-}
-
-bool
-_dispatch_unote_register_muxed(dispatch_unote_t du)
-{
-	struct dispatch_muxnote_bucket_s *dmb;
-	dispatch_muxnote_t dmn;
-	enum _dispatch_muxnote_events events;
-
-	events = _dispatch_unote_required_events(du);
-
-	dmb = _dispatch_unote_muxnote_bucket(du._du->du_ident);
-	dmn = _dispatch_unote_muxnote_find(dmb, du._du->du_ident,
-		du._du->du_filter);
-	if (dmn) {
-		if (events & ~dmn->dmn_events) {
-			dmn->dmn_events |= events;
-			if (_dispatch_io_trigger(dmn) == FALSE) {
-				return false;
-			}
-		}
-	} else {
-		dmn = _dispatch_muxnote_create(du, events);
-		if (!dmn) {
-			return false;
-		}
-		if (_dispatch_io_trigger(dmn) == FALSE) {
-			_dispatch_muxnote_release(dmn);
-			return false;
-		}
-		LIST_INSERT_HEAD(dmb, dmn, dmn_list);
-	}
-
-	dispatch_unote_linkage_t dul = _dispatch_unote_get_linkage(du);
-	switch (dmn->dmn_handle_type) {
-	case DISPATCH_MUXNOTE_HANDLE_TYPE_INVALID:
-		DISPATCH_INTERNAL_CRASH(0, "invalid handle");
-
-	case DISPATCH_MUXNOTE_HANDLE_TYPE_FILE:
-	case DISPATCH_MUXNOTE_HANDLE_TYPE_PIPE:
-	case DISPATCH_MUXNOTE_HANDLE_TYPE_SOCKET:
-		if (events & DISPATCH_MUXNOTE_EVENT_READ) {
-			LIST_INSERT_HEAD(&dmn->dmn_readers_head, dul, du_link);
-		} else if (events & DISPATCH_MUXNOTE_EVENT_WRITE) {
-			LIST_INSERT_HEAD(&dmn->dmn_writers_head, dul, du_link);
-		}
-		break;
-	}
-
-	dul->du_muxnote = dmn;
-	_dispatch_unote_state_set(du, DISPATCH_WLH_ANON, DU_STATE_ARMED);
-
-	return true;
-}
-
-void
-_dispatch_unote_resume_muxed(dispatch_unote_t du)
-{
-	dispatch_unote_linkage_t dul = _dispatch_unote_get_linkage(du);
-	dispatch_muxnote_t dmn = dul->du_muxnote;
-	dispatch_assert(_dispatch_unote_registered(du));
-	_dispatch_io_trigger(dmn);
-}
-
-bool
-_dispatch_unote_unregister_muxed(dispatch_unote_t du)
-{
-	dispatch_unote_linkage_t dul = _dispatch_unote_get_linkage(du);
-	dispatch_muxnote_t dmn = dul->du_muxnote;
-
-	switch (dmn->dmn_handle_type) {
-	case DISPATCH_MUXNOTE_HANDLE_TYPE_INVALID:
-		DISPATCH_INTERNAL_CRASH(0, "invalid handle");
-
-	case DISPATCH_MUXNOTE_HANDLE_TYPE_FILE:
-	case DISPATCH_MUXNOTE_HANDLE_TYPE_PIPE:
-	case DISPATCH_MUXNOTE_HANDLE_TYPE_SOCKET:
-		LIST_REMOVE(dul, du_link);
-		_LIST_TRASH_ENTRY(dul, du_link);
-		break;
-	}
-	dul->du_muxnote = NULL;
-
-	enum _dispatch_muxnote_events disarmed = 0;
-	if (LIST_EMPTY(&dmn->dmn_readers_head)) {
-		disarmed |= DISPATCH_MUXNOTE_EVENT_READ;
-	}
-	if (LIST_EMPTY(&dmn->dmn_writers_head)) {
-		disarmed |= DISPATCH_MUXNOTE_EVENT_WRITE;
-	}
-	_dispatch_muxnote_disarm_events(dmn, disarmed);
-	if (!dmn->dmn_events) {
-		LIST_REMOVE(dmn, dmn_list);
-		_dispatch_muxnote_release(dmn);
-	}
-
-	_dispatch_unote_state_set(du, DU_STATE_UNREGISTERED);
-	return true;
-}
-
-static void
-_dispatch_event_merge_file_handle(dispatch_muxnote_t dmn)
-{
-	dispatch_unote_linkage_t dul, dul_next;
-	LIST_FOREACH_SAFE(dul, &dmn->dmn_readers_head, du_link, dul_next) {
-		dispatch_unote_t du = _dispatch_unote_linkage_get_unote(dul);
-		// consumed by dux_merge_evt()
-		_dispatch_retain_unote_owner(du);
-		dispatch_assert(dux_needs_rearm(du._du));
-		_dispatch_unote_state_clear_bit(du, DU_STATE_ARMED);
-		os_atomic_store2o(du._dr, ds_pending_data, ~1, relaxed);
-		dux_merge_evt(du._du, EV_ADD | EV_ENABLE | EV_DISPATCH, 1, 0);
-	}
-	LIST_FOREACH_SAFE(dul, &dmn->dmn_writers_head, du_link, dul_next) {
-		dispatch_unote_t du = _dispatch_unote_linkage_get_unote(dul);
-		// consumed by dux_merge_evt()
-		_dispatch_retain_unote_owner(du);
-		dispatch_assert(dux_needs_rearm(du._du));
-		_dispatch_unote_state_clear_bit(du, DU_STATE_ARMED);
-		os_atomic_store2o(du._dr, ds_pending_data, ~1, relaxed);
-		dux_merge_evt(du._du, EV_ADD | EV_ENABLE | EV_DISPATCH, 1, 0);
-	}
-	// Retained when posting the completion packet
-	_dispatch_muxnote_release(dmn);
-}
-
-static void
-_dispatch_event_merge_pipe_handle_read(dispatch_muxnote_t dmn,
-		DWORD dwBytesAvailable)
-{
-	dispatch_unote_linkage_t dul, dul_next;
-	LIST_FOREACH_SAFE(dul, &dmn->dmn_readers_head, du_link, dul_next) {
-		dispatch_unote_t du = _dispatch_unote_linkage_get_unote(dul);
-		// consumed by dux_merge_evt()
-		_dispatch_retain_unote_owner(du);
-		dispatch_unote_state_t du_state = _dispatch_unote_state(du);
-		du_state &= ~DU_STATE_ARMED;
-		uintptr_t data = dwBytesAvailable;
-		uint32_t flags;
-		if (dwBytesAvailable > 0) {
-			flags = EV_ADD | EV_ENABLE | EV_DISPATCH;
-		} else {
-			du_state |= DU_STATE_NEEDS_DELETE;
-			flags = EV_DELETE | EV_DISPATCH;
-		}
-		_dispatch_unote_state_set(du, du_state);
-		os_atomic_store2o(du._dr, ds_pending_data, ~data, relaxed);
-		dux_merge_evt(du._du, flags, data, 0);
-	}
-	SetEvent(dmn->dmn_event);
-	// Retained when posting the completion packet
-	_dispatch_muxnote_release(dmn);
-}
-
-static void
-_dispatch_event_merge_pipe_handle_write(dispatch_muxnote_t dmn,
-		DWORD dwBytesAvailable)
-{
-	dispatch_unote_linkage_t dul, dul_next;
-	LIST_FOREACH_SAFE(dul, &dmn->dmn_writers_head, du_link, dul_next) {
-		dispatch_unote_t du = _dispatch_unote_linkage_get_unote(dul);
-		// consumed by dux_merge_evt()
-		_dispatch_retain_unote_owner(du);
-		_dispatch_unote_state_clear_bit(du, DU_STATE_ARMED);
-		uintptr_t data = dwBytesAvailable;
-		if (dwBytesAvailable > 0) {
-			os_atomic_store2o(du._dr, ds_pending_data, ~data, relaxed);
-		} else {
-			os_atomic_store2o(du._dr, ds_pending_data, 0, relaxed);
-		}
-		dux_merge_evt(du._du, EV_ADD | EV_ENABLE | EV_DISPATCH, data, 0);
-	}
-	// Retained when posting the completion packet
-	_dispatch_muxnote_release(dmn);
-}
-
-static void
-_dispatch_event_merge_socket(dispatch_unote_t du, DWORD dwBytesAvailable)
-{
-	// consumed by dux_merge_evt()
-	_dispatch_retain_unote_owner(du);
-	dispatch_unote_state_t du_state = _dispatch_unote_state(du);
-	du_state &= ~DU_STATE_ARMED;
-	uintptr_t data = dwBytesAvailable;
-	uint32_t flags;
-	if (dwBytesAvailable > 0) {
-		flags = EV_ADD | EV_ENABLE | EV_DISPATCH;
-	} else {
-		du_state |= DU_STATE_NEEDS_DELETE;
-		flags = EV_DELETE | EV_DISPATCH;
-	}
-	_dispatch_unote_state_set(du, du_state);
-	os_atomic_store2o(du._dr, ds_pending_data, ~data, relaxed);
-	dux_merge_evt(du._du, flags, data, 0);
-}
-
-static void
-_dispatch_event_merge_socket_read(dispatch_muxnote_t dmn,
-		DWORD dwBytesAvailable)
-{
-	dispatch_unote_linkage_t dul, dul_next;
-	LIST_FOREACH_SAFE(dul, &dmn->dmn_readers_head, du_link, dul_next) {
-		dispatch_unote_t du = _dispatch_unote_linkage_get_unote(dul);
-		_dispatch_event_merge_socket(du, dwBytesAvailable);
-	}
-	// Retained when posting the completion packet
-	_dispatch_muxnote_release(dmn);
-}
-
-static void
-_dispatch_event_merge_socket_write(dispatch_muxnote_t dmn,
-		DWORD dwBytesAvailable)
-{
-	dispatch_unote_linkage_t dul, dul_next;
-	LIST_FOREACH_SAFE(dul, &dmn->dmn_writers_head, du_link, dul_next) {
-		dispatch_unote_t du = _dispatch_unote_linkage_get_unote(dul);
-		_dispatch_event_merge_socket(du, dwBytesAvailable);
-	}
-	// Retained when posting the completion packet
-	_dispatch_muxnote_release(dmn);
-}
-
-#pragma mark timers
-
-typedef struct _dispatch_windows_timeout_s {
-	PTP_TIMER pTimer;
-	enum _dispatch_windows_port ullIdent;
-	bool bArmed;
-} *dispatch_windows_timeout_t;
-
-#define DISPATCH_WINDOWS_TIMEOUT_INITIALIZER(clock)                             \
-	[DISPATCH_CLOCK_##clock] = {                                            \
-		.pTimer = NULL,                                                 \
-		.ullIdent = DISPATCH_PORT_TIMER_CLOCK_##clock,                  \
-		.bArmed = FALSE,                                                \
-	}
-
-static struct _dispatch_windows_timeout_s _dispatch_windows_timeout[] = {
-	DISPATCH_WINDOWS_TIMEOUT_INITIALIZER(WALL),
-	DISPATCH_WINDOWS_TIMEOUT_INITIALIZER(UPTIME),
-	DISPATCH_WINDOWS_TIMEOUT_INITIALIZER(MONOTONIC),
-};
-
-static void
-_dispatch_event_merge_timer(dispatch_clock_t clock)
-{
-	uint32_t tidx = DISPATCH_TIMER_INDEX(clock, 0);
-
-	_dispatch_windows_timeout[clock].bArmed = FALSE;
-
-	_dispatch_timers_heap_dirty(_dispatch_timers_heap, tidx);
-	_dispatch_timers_heap[tidx].dth_needs_program = true;
-	_dispatch_timers_heap[tidx].dth_armed = false;
-}
-
-static void CALLBACK
-_dispatch_timer_callback(PTP_CALLBACK_INSTANCE Instance, PVOID Context,
-	PTP_TIMER Timer)
-{
-	BOOL bSuccess;
-
-	bSuccess = PostQueuedCompletionStatus(hPort, 0, (ULONG_PTR)Context,
-		NULL);
-	if (bSuccess == FALSE) {
-		DISPATCH_INTERNAL_CRASH(GetLastError(),
-			"PostQueuedCompletionStatus");
-	}
-}
-
-void
-_dispatch_event_loop_timer_arm(dispatch_timer_heap_t dth DISPATCH_UNUSED,
-		uint32_t tidx, dispatch_timer_delay_s range,
-		dispatch_clock_now_cache_t nows)
-{
-	dispatch_windows_timeout_t timer;
-	FILETIME ftDueTime;
-	LARGE_INTEGER liTime;
-
-	switch (DISPATCH_TIMER_CLOCK(tidx)) {
-	case DISPATCH_CLOCK_WALL:
-		timer = &_dispatch_windows_timeout[DISPATCH_CLOCK_WALL];
-		liTime.QuadPart = range.delay +
-			_dispatch_time_now_cached(DISPATCH_TIMER_CLOCK(tidx), nows);
-		break;
-
-	case DISPATCH_CLOCK_UPTIME:
-	case DISPATCH_CLOCK_MONOTONIC:
-		timer = &_dispatch_windows_timeout[DISPATCH_TIMER_CLOCK(tidx)];
-		liTime.QuadPart = -((range.delay + 99) / 100);
-		break;
-	}
-
-	if (timer->pTimer == NULL) {
-		timer->pTimer = CreateThreadpoolTimer(_dispatch_timer_callback,
-			(LPVOID)timer->ullIdent, NULL);
-		if (timer->pTimer == NULL) {
-			DISPATCH_INTERNAL_CRASH(GetLastError(),
-				"CreateThreadpoolTimer");
-		}
-	}
-
-	ftDueTime.dwHighDateTime = liTime.HighPart;
-	ftDueTime.dwLowDateTime = liTime.LowPart;
-
-	SetThreadpoolTimer(timer->pTimer, &ftDueTime, /*msPeriod=*/0,
-		/*msWindowLength=*/0);
-	timer->bArmed = TRUE;
-}
-
-void
-_dispatch_event_loop_timer_delete(dispatch_timer_heap_t dth DISPATCH_UNUSED,
-		uint32_t tidx)
-{
-	dispatch_windows_timeout_t timer;
-
-	switch (DISPATCH_TIMER_CLOCK(tidx)) {
-	case DISPATCH_CLOCK_WALL:
-		timer = &_dispatch_windows_timeout[DISPATCH_CLOCK_WALL];
-		break;
-
-	case DISPATCH_CLOCK_UPTIME:
-	case DISPATCH_CLOCK_MONOTONIC:
-		timer = &_dispatch_windows_timeout[DISPATCH_TIMER_CLOCK(tidx)];
-		break;
-	}
-
-	SetThreadpoolTimer(timer->pTimer, NULL, /*msPeriod=*/0,
-		/*msWindowLength=*/0);
-	timer->bArmed = FALSE;
-}
-
-#pragma mark dispatch_loop
-
-static void
-_dispatch_windows_port_init(void *context DISPATCH_UNUSED)
-{
-	hPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 1);
-	if (hPort == NULL) {
-		DISPATCH_INTERNAL_CRASH(GetLastError(),
-			"CreateIoCompletionPort");
-	}
-
-#if DISPATCH_USE_MGR_THREAD
-	_dispatch_trace_item_push(_dispatch_mgr_q.do_targetq, &_dispatch_mgr_q);
-	dx_push(_dispatch_mgr_q.do_targetq, &_dispatch_mgr_q, 0);
-#endif
-}
-
-void
-_dispatch_event_loop_poke(dispatch_wlh_t wlh DISPATCH_UNUSED,
-		uint64_t dq_state DISPATCH_UNUSED, uint32_t flags DISPATCH_UNUSED)
-{
-	static dispatch_once_t _dispatch_windows_port_init_pred;
-	BOOL bSuccess;
-
-	dispatch_once_f(&_dispatch_windows_port_init_pred, NULL,
-		_dispatch_windows_port_init);
-	bSuccess = PostQueuedCompletionStatus(hPort, 0, DISPATCH_PORT_POKE,
-		NULL);
-	(void)dispatch_assume(bSuccess);
-}
-
-DISPATCH_NOINLINE
-void
-_dispatch_event_loop_drain(uint32_t flags)
-{
-	DWORD dwNumberOfBytesTransferred;
-	ULONG_PTR ulCompletionKey;
-	LPOVERLAPPED pOV;
-	BOOL bSuccess;
-
-	pOV = (LPOVERLAPPED)&pOV;
-	bSuccess = GetQueuedCompletionStatus(hPort, &dwNumberOfBytesTransferred,
-		&ulCompletionKey, &pOV,
-		(flags & KEVENT_FLAG_IMMEDIATE) ? 0 : INFINITE);
-	while (bSuccess) {
-		switch (ulCompletionKey) {
-		case DISPATCH_PORT_POKE:
-			break;
-
-		case DISPATCH_PORT_TIMER_CLOCK_WALL:
-			_dispatch_event_merge_timer(DISPATCH_CLOCK_WALL);
-			break;
-
-		case DISPATCH_PORT_TIMER_CLOCK_UPTIME:
-			_dispatch_event_merge_timer(DISPATCH_CLOCK_UPTIME);
-			break;
-
-		case DISPATCH_PORT_TIMER_CLOCK_MONOTONIC:
-			_dispatch_event_merge_timer(DISPATCH_CLOCK_MONOTONIC);
-			break;
-
-		case DISPATCH_PORT_FILE_HANDLE:
-			_dispatch_event_merge_file_handle((dispatch_muxnote_t)pOV);
-			break;
-
-		case DISPATCH_PORT_PIPE_HANDLE_READ:
-			_dispatch_event_merge_pipe_handle_read((dispatch_muxnote_t)pOV,
-					dwNumberOfBytesTransferred);
-			break;
-
-		case DISPATCH_PORT_PIPE_HANDLE_WRITE:
-			_dispatch_event_merge_pipe_handle_write((dispatch_muxnote_t)pOV,
-					dwNumberOfBytesTransferred);
-			break;
-
-		case DISPATCH_PORT_SOCKET_READ:
-			_dispatch_event_merge_socket_read((dispatch_muxnote_t)pOV,
-					dwNumberOfBytesTransferred);
-			break;
-
-		case DISPATCH_PORT_SOCKET_WRITE:
-			_dispatch_event_merge_socket_write((dispatch_muxnote_t)pOV,
-					dwNumberOfBytesTransferred);
-			break;
-
-		default:
-			DISPATCH_INTERNAL_CRASH(ulCompletionKey,
-				"unsupported completion key");
-		}
-
-		bSuccess = GetQueuedCompletionStatus(hPort,
-			&dwNumberOfBytesTransferred, &ulCompletionKey, &pOV, 0);
-	}
-
-	if (bSuccess == FALSE && pOV != NULL) {
-		DISPATCH_INTERNAL_CRASH(GetLastError(),
-			"GetQueuedCompletionStatus");
-	}
-}
-
-void
-_dispatch_event_loop_cancel_waiter(dispatch_sync_context_t dsc DISPATCH_UNUSED)
-{
-	WIN_PORT_ERROR();
-}
-
-void
-_dispatch_event_loop_wake_owner(dispatch_sync_context_t dsc,
-		dispatch_wlh_t wlh, uint64_t old_state, uint64_t new_state)
-{
-	(void)dsc; (void)wlh; (void)old_state; (void)new_state;
-}
-
-void
-_dispatch_event_loop_wait_for_ownership(dispatch_sync_context_t dsc)
-{
-	if (dsc->dsc_release_storage) {
-		_dispatch_queue_release_storage(dsc->dc_data);
-	}
-}
-
-void
-_dispatch_event_loop_end_ownership(dispatch_wlh_t wlh, uint64_t old_state,
-		uint64_t new_state, uint32_t flags)
-{
-	(void)wlh; (void)old_state; (void)new_state; (void)flags;
-}
-
-#if DISPATCH_WLH_DEBUG
-void
-_dispatch_event_loop_assert_not_owned(dispatch_wlh_t wlh)
-{
-	(void)wlh;
-}
-#endif
-
-void
-_dispatch_event_loop_leave_immediate(uint64_t dq_state)
-{
-	(void)dq_state;
-}
-
-#endif // DISPATCH_EVENT_BACKEND_WINDOWS
--- a/Telegram/ThirdParty/dispatch/src/event/workqueue.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/event/workqueue.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,325 +0,0 @@
-/*
- * Copyright (c) 2017-2017 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include "internal.h"
-
-#if DISPATCH_USE_INTERNAL_WORKQUEUE
-
-#if defined(_WIN32)
-#include <wct.h>
-#endif
-
-/*
- * dispatch_workq monitors the thread pool that is
- * executing the work enqueued on libdispatch's pthread
- * root queues and dynamically adjusts its size.
- *
- * The dynamic monitoring could be implemented using either
- *   (a) low-frequency user-level approximation of the number of runnable
- *       worker threads via reading the /proc file system
- *   (b) a Linux kernel extension that hooks the process change handler
- *       to accurately track the number of runnable normal worker threads
- * This file provides an implementation of option (a).
- *
- * Using either form of monitoring, if (i) there appears to be
- * work available in the monitored pthread root queue, (ii) the
- * number of runnable workers is below the target size for the pool,
- * and (iii) the total number of worker threads is below an upper limit,
- * then an additional worker thread will be added to the pool.
- */
-
-#pragma mark static data for monitoring subsystem
-
-/*
- * State for the user-level monitoring of a workqueue.
- */
-typedef struct dispatch_workq_monitor_s {
-	/* The dispatch_queue we are monitoring */
-	dispatch_queue_global_t dq;
-
-	/* The observed number of runnable worker threads */
-	int32_t num_runnable;
-
-	/* The desired number of runnable worker threads */
-	int32_t target_runnable;
-
-	/*
-	 * Tracking of registered workers; all accesses must hold lock.
-	 * Invariant: registered_tids[0]...registered_tids[num_registered_tids-1]
-	 *   contain the dispatch_tids of the worker threads we are monitoring.
-	 */
-	dispatch_unfair_lock_s registered_tid_lock;
-	dispatch_tid *registered_tids;
-	int num_registered_tids;
-} dispatch_workq_monitor_s, *dispatch_workq_monitor_t;
-
-#if HAVE_DISPATCH_WORKQ_MONITORING
-static dispatch_workq_monitor_s _dispatch_workq_monitors[DISPATCH_QOS_NBUCKETS];
-#endif
-
-#pragma mark Implementation of the monitoring subsystem.
-
-#define WORKQ_MAX_TRACKED_TIDS DISPATCH_WORKQ_MAX_PTHREAD_COUNT
-#define WORKQ_OVERSUBSCRIBE_FACTOR 2
-
-static void _dispatch_workq_init_once(void *context DISPATCH_UNUSED);
-static dispatch_once_t _dispatch_workq_init_once_pred;
-
-void
-_dispatch_workq_worker_register(dispatch_queue_global_t root_q)
-{
-	dispatch_once_f(&_dispatch_workq_init_once_pred, NULL, &_dispatch_workq_init_once);
-
-#if HAVE_DISPATCH_WORKQ_MONITORING
-	dispatch_qos_t qos = _dispatch_priority_qos(root_q->dq_priority);
-	if (qos == 0) qos = DISPATCH_QOS_DEFAULT;
-	int bucket = DISPATCH_QOS_BUCKET(qos);
-	dispatch_workq_monitor_t mon = &_dispatch_workq_monitors[bucket];
-	dispatch_assert(mon->dq == root_q);
-	dispatch_tid tid = _dispatch_tid_self();
-	_dispatch_unfair_lock_lock(&mon->registered_tid_lock);
-	dispatch_assert(mon->num_registered_tids < WORKQ_MAX_TRACKED_TIDS-1);
-	int worker_id = mon->num_registered_tids++;
-	mon->registered_tids[worker_id] = tid;
-	_dispatch_unfair_lock_unlock(&mon->registered_tid_lock);
-#else
-	(void)root_q;
-#endif // HAVE_DISPATCH_WORKQ_MONITORING
-}
-
-void
-_dispatch_workq_worker_unregister(dispatch_queue_global_t root_q)
-{
-#if HAVE_DISPATCH_WORKQ_MONITORING
-	dispatch_qos_t qos = _dispatch_priority_qos(root_q->dq_priority);
-	if (qos == 0) qos = DISPATCH_QOS_DEFAULT;
-	int bucket = DISPATCH_QOS_BUCKET(qos);
-	dispatch_workq_monitor_t mon = &_dispatch_workq_monitors[bucket];
-	dispatch_assert(mon->dq == root_q);
-	dispatch_tid tid = _dispatch_tid_self();
-	_dispatch_unfair_lock_lock(&mon->registered_tid_lock);
-	for (int i = 0; i < mon->num_registered_tids; i++) {
-		if (mon->registered_tids[i] == tid) {
-			int last = mon->num_registered_tids - 1;
-			mon->registered_tids[i] = mon->registered_tids[last];
-			mon->registered_tids[last] = 0;
-			mon->num_registered_tids--;
-			break;
-		}
-	}
-	_dispatch_unfair_lock_unlock(&mon->registered_tid_lock);
-#else
-	(void)root_q;
-#endif // HAVE_DISPATCH_WORKQ_MONITORING
-}
-
-
-#if HAVE_DISPATCH_WORKQ_MONITORING
-#if defined(__linux__)
-/*
- * For each pid that is a registered worker, read /proc/[pid]/stat
- * to get a count of the number of them that are actually runnable.
- * See the proc(5) man page for the format of the contents of /proc/[pid]/stat
- */
-static void
-_dispatch_workq_count_runnable_workers(dispatch_workq_monitor_t mon)
-{
-	char path[128];
-	char buf[4096];
-	int running_count = 0;
-
-	_dispatch_unfair_lock_lock(&mon->registered_tid_lock);
-
-	for (int i = 0; i < mon->num_registered_tids; i++) {
-		dispatch_tid tid = mon->registered_tids[i];
-		int fd;
-		ssize_t bytes_read = -1;
-
-		int r = snprintf(path, sizeof(path), "/proc/%d/stat", tid);
-		dispatch_assert(r > 0 && r < (int)sizeof(path));
-
-		fd = open(path, O_RDONLY | O_NONBLOCK);
-		if (unlikely(fd == -1)) {
-			DISPATCH_CLIENT_CRASH(tid,
-					"workq: registered worker exited prematurely");
-		} else {
-			bytes_read = read(fd, buf, sizeof(buf)-1);
-			(void)close(fd);
-		}
-
-		if (bytes_read > 0) {
-			buf[bytes_read] = '\0';
-			char state;
-			if (sscanf(buf, "%*d %*s %c", &state) == 1) {
-				// _dispatch_debug("workq: Worker %d, state %c\n", tid, state);
-				if (state == 'R') {
-					running_count++;
-				}
-			} else {
-				_dispatch_debug("workq: sscanf of state failed for %d", tid);
-			}
-		} else {
-			_dispatch_debug("workq: Failed to read %s", path);
-		}
-	}
-
-	mon->num_runnable = running_count;
-
-	_dispatch_unfair_lock_unlock(&mon->registered_tid_lock);
-}
-#elif defined(_WIN32)
-static void
-_dispatch_workq_init_wct(void *hWCTSession)
-{
-	// TODO(compnerd) this should have an associated CloseThreadWaitChainSession
-	*(HWCT **)hWCTSession = OpenThreadWaitChainSession(0, NULL);
-}
-
-static void
-_dispatch_workq_count_runnable_workers(dispatch_workq_monitor_t mon)
-{
-	static dispatch_once_t _wct_init_pred;
-	static HWCT hWCTSession;
-	static WAITCHAIN_NODE_INFO wait_chain[WCT_MAX_NODE_COUNT];
-
-	dispatch_once_f(&_wct_init_pred, &hWCTSession, &_dispatch_workq_init_wct);
-
-	int running_count = 0;
-
-	_dispatch_unfair_lock_lock(&mon->registered_tid_lock);
-
-	for (int i = 0; i < mon->num_registered_tids; ++i) {
-		/* See _dispatch_tid_self() */
-		dispatch_tid tid = mon->registered_tids[i] >> 2;
-
-		DWORD count = WCT_MAX_NODE_COUNT;
-		BOOL cycle = FALSE;
-		if (GetThreadWaitChain(hWCTSession, 0, 0, tid, &count, wait_chain, &cycle)) {
-			// Check the deepest entry to see what the thread is waiting on.
-			DWORD index = MIN(count, WCT_MAX_NODE_COUNT) - 1;
-			if (wait_chain[index].ObjectType == WctThreadType) {
-				if (wait_chain[index].ObjectStatus != WctStatusRunning) {
-					continue;
-				}
-			}
-		}
-
-		// Ensure that the thread is not waiting on IO
-		// XXX(compnerd) is this needed? The wait chain reports SMB
-		// and Socket IO, but it is unclear if that includes normal IO.
-		HANDLE hThread = OpenThread(THREAD_QUERY_INFORMATION, FALSE, tid);
-		if (hThread == NULL) {
-			_dispatch_debug("workq: unable to open thread %u: %u", tid, GetLastError());
-			continue;
-		}
-
-		BOOL IOPending = TRUE;
-		if (GetThreadIOPendingFlag(hThread, &IOPending))
-			if (!IOPending)
-				++running_count;
-
-		CloseHandle(hThread);
-	}
-
-	mon->num_runnable = running_count;
-
-	_dispatch_unfair_lock_unlock(&mon->registered_tid_lock);
-}
-#else
-#error must define _dispatch_workq_count_runnable_workers
-#endif
-
-#define foreach_qos_bucket_reverse(name) \
-		for (name = DISPATCH_QOS_BUCKET(DISPATCH_QOS_MAX); \
-				name >= DISPATCH_QOS_BUCKET(DISPATCH_QOS_MAINTENANCE); name--)
-
-static void
-_dispatch_workq_monitor_pools(void *context DISPATCH_UNUSED)
-{
-	int global_soft_max = WORKQ_OVERSUBSCRIBE_FACTOR * (int)dispatch_hw_config(active_cpus);
-	int global_runnable = 0, i;
-	foreach_qos_bucket_reverse(i) {
-		dispatch_workq_monitor_t mon = &_dispatch_workq_monitors[i];
-		dispatch_queue_global_t dq = mon->dq;
-
-		if (!_dispatch_queue_class_probe(dq)) {
-			_dispatch_debug("workq: %s is empty.", dq->dq_label);
-			continue;
-		}
-
-		_dispatch_workq_count_runnable_workers(mon);
-		_dispatch_debug("workq: %s has %d runnable wokers (target is %d)",
-				dq->dq_label, mon->num_runnable, mon->target_runnable);
-
-		global_runnable += mon->num_runnable;
-
-		if (mon->num_runnable == 0) {
-			// We have work, but no worker is runnable.
-			// It is likely the program is stalled. Therefore treat
-			// this as if dq were an overcommit queue and call poke
-			// with the limit being the maximum number of workers for dq.
-			int32_t floor = mon->target_runnable - WORKQ_MAX_TRACKED_TIDS;
-			_dispatch_debug("workq: %s has no runnable workers; poking with floor %d",
-					dq->dq_label, floor);
-			_dispatch_root_queue_poke(dq, 1, floor);
-			global_runnable += 1; // account for poke in global estimate
-		} else if (mon->num_runnable < mon->target_runnable &&
-				   global_runnable < global_soft_max) {
-			// We are below target, but some workers are still runnable.
-			// We want to oversubscribe to hit the desired load target.
-			// However, this under-utilization may be transitory so set the
-			// floor as a small multiple of threads per core.
-			int32_t floor = (1 - WORKQ_OVERSUBSCRIBE_FACTOR) * mon->target_runnable;
-			int32_t floor2 = mon->target_runnable - WORKQ_MAX_TRACKED_TIDS;
-			floor = MAX(floor, floor2);
-			_dispatch_debug("workq: %s under utilization target; poking with floor %d",
-					dq->dq_label, floor);
-			_dispatch_root_queue_poke(dq, 1, floor);
-			global_runnable += 1; // account for poke in global estimate
-		}
-	}
-}
-#endif // HAVE_DISPATCH_WORKQ_MONITORING
-
-static void
-_dispatch_workq_init_once(void *context DISPATCH_UNUSED)
-{
-#if HAVE_DISPATCH_WORKQ_MONITORING
-	int i, target_runnable = (int)dispatch_hw_config(active_cpus);
-	foreach_qos_bucket_reverse(i) {
-		dispatch_workq_monitor_t mon = &_dispatch_workq_monitors[i];
-		mon->dq = _dispatch_get_root_queue(DISPATCH_QOS_FOR_BUCKET(i), false);
-		void *buf = _dispatch_calloc(WORKQ_MAX_TRACKED_TIDS, sizeof(dispatch_tid));
-		mon->registered_tids = buf;
-		mon->target_runnable = target_runnable;
-	}
-
-	// Create monitoring timer that will periodically run on dispatch_mgr_q
-	dispatch_source_t ds = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER,
-			0, 0, _dispatch_mgr_q._as_dq);
-	dispatch_source_set_timer(ds, dispatch_time(DISPATCH_TIME_NOW, 0),
-			NSEC_PER_SEC, 0);
-	dispatch_source_set_event_handler_f(ds, _dispatch_workq_monitor_pools);
-	dispatch_set_context(ds, ds); // avoid appearing as leaked
-	dispatch_activate(ds);
-#endif // HAVE_DISPATCH_WORKQ_MONITORING
-}
-
-#endif // DISPATCH_USE_INTERNAL_WORKQUEUE
--- a/Telegram/ThirdParty/dispatch/src/event/workqueue_internal.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/event/workqueue_internal.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,40 +0,0 @@
-/*
- * Copyright (c) 2017-2017 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-/*
- * IMPORTANT: This header file describes INTERNAL interfaces to libdispatch
- * which are subject to change in future releases of Mac OS X. Any applications
- * relying on these interfaces WILL break.
- */
-
-#ifndef __DISPATCH_WORKQUEUE_INTERNAL__
-#define __DISPATCH_WORKQUEUE_INTERNAL__
-
-void _dispatch_workq_worker_register(dispatch_queue_global_t root_q);
-void _dispatch_workq_worker_unregister(dispatch_queue_global_t root_q);
-
-#if defined(__linux__) || defined(_WIN32)
-#define HAVE_DISPATCH_WORKQ_MONITORING 1
-#else
-#define HAVE_DISPATCH_WORKQ_MONITORING 0
-#endif
-
-#endif /* __DISPATCH_WORKQUEUE_INTERNAL__ */
-
--- a/Telegram/ThirdParty/dispatch/src/firehose/firehose_buffer.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/firehose/firehose_buffer.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,1437 +0,0 @@
-/*
- * Copyright (c) 2015 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include <mach/vm_statistics.h> // VM_MEMORY_GENEALOGY
-#ifdef KERNEL
-
-#define OS_VOUCHER_ACTIVITY_SPI_TYPES 1
-#define OS_FIREHOSE_SPI 1
-#define __OS_EXPOSE_INTERNALS_INDIRECT__ 1
-
-#define DISPATCH_PURE_C 1
-#define os_likely(x) __builtin_expect(!!(x), 1)
-#define os_unlikely(x) __builtin_expect(!!(x), 0)
-#define likely(x)   __builtin_expect(!!(x), 1)
-#define unlikely(x) __builtin_expect(!!(x), 0)
-
-#ifndef OS_FALLTHROUGH
-#define OS_FALLTHROUGH
-#endif
-
-#define DISPATCH_INTERNAL_CRASH(ac, msg) ({ panic(msg); __builtin_trap(); })
-
-#if defined(__x86_64__) || defined(__i386__)
-#define dispatch_hardware_pause() __asm__("pause")
-#elif (defined(__arm__) && defined(_ARM_ARCH_7) && defined(__thumb__)) || \
-		defined(__arm64__)
-#define dispatch_hardware_pause() __asm__("yield")
-#define dispatch_hardware_wfe()   __asm__("wfe")
-#else
-#define dispatch_hardware_pause() __asm__("")
-#endif
-
-#define _dispatch_wait_until(c) ({ \
-		__typeof__(c) _c; \
-		for (;;) { \
-			if (likely(_c = (c))) break; \
-			dispatch_hardware_pause(); \
-		} \
-		_c; })
-#define dispatch_compiler_barrier()  __asm__ __volatile__("" ::: "memory")
-
-typedef uint32_t dispatch_lock;
-typedef struct dispatch_gate_s {
-	dispatch_lock dgl_lock;
-} dispatch_gate_s, *dispatch_gate_t;
-#define DLOCK_LOCK_DATA_CONTENTION 0
-static void _dispatch_firehose_gate_wait(dispatch_gate_t l, uint32_t flags);
-
-#define fcp_quarntined fcp_quarantined
-
-#include <kern/debug.h>
-#include <machine/cpu_number.h>
-#include <kern/thread.h>
-#include <mach/port.h>
-#include <stdbool.h>
-#include <string.h>
-#include <sys/param.h>
-#include <sys/types.h>
-#include <vm/vm_kern.h>
-#include <internal/atomic.h> // os/internal/atomic.h
-#include <firehose_types_private.h> // <firehose/firehose_types_private.h>
-#include <tracepoint_private.h> // <firehose/tracepoint_private.h>
-#include <chunk_private.h> // <firehose/chunk_private.h>
-#include "os/firehose_buffer_private.h"
-#include "firehose_buffer_internal.h"
-#include "firehose_inline_internal.h"
-#else
-#include "internal.h"
-#include "firehose.h" // MiG
-#include "firehose_replyServer.h" // MiG
-#endif
-
-#if OS_FIREHOSE_SPI
-
-#if __has_feature(c_static_assert)
-_Static_assert(sizeof(((firehose_stream_state_u *)NULL)->fss_gate) ==
-		sizeof(((firehose_stream_state_u *)NULL)->fss_allocator),
-		"fss_gate and fss_allocator alias");
-_Static_assert(offsetof(firehose_stream_state_u, fss_gate) ==
-		offsetof(firehose_stream_state_u, fss_allocator),
-		"fss_gate and fss_allocator alias");
-_Static_assert(sizeof(struct firehose_buffer_header_s) ==
-				FIREHOSE_CHUNK_SIZE,
-		"firehose buffer header must be 4k");
-_Static_assert(offsetof(struct firehose_buffer_header_s, fbh_unused) <=
-				FIREHOSE_CHUNK_SIZE - FIREHOSE_BUFFER_LIBTRACE_HEADER_SIZE,
-		"we must have enough space for the libtrace header");
-_Static_assert(powerof2(FIREHOSE_BUFFER_CHUNK_COUNT),
-		"CHUNK_COUNT Must be a power of two");
-_Static_assert(FIREHOSE_BUFFER_CHUNK_COUNT <= 64,
-		"CHUNK_COUNT must be less than 64 (bitmap in uint64_t)");
-#ifdef FIREHOSE_BUFFER_MADVISE_CHUNK_COUNT
-_Static_assert(powerof2(FIREHOSE_BUFFER_MADVISE_CHUNK_COUNT),
-		"madvise chunk count must be a power of two");
-#endif
-_Static_assert(sizeof(struct firehose_buffer_stream_s) == 128,
-		"firehose buffer stream must be small (single cacheline if possible)");
-_Static_assert(sizeof(struct firehose_tracepoint_s) == 24,
-		"tracepoint header should be exactly 24 bytes");
-#endif
-
-#ifdef KERNEL
-static firehose_buffer_t kernel_firehose_buffer = NULL;
-
-_Static_assert(FIREHOSE_BUFFER_KERNEL_MAX_CHUNK_COUNT == FIREHOSE_BUFFER_CHUNK_COUNT,
-		"FIREHOSE_BUFFER_KERNEL_MAX_CHUNK_COUNT must match FIREHOSE_BUFFER_CHUNK_COUNT");
-_Static_assert(FIREHOSE_BUFFER_KERNEL_DEFAULT_IO_PAGES <= FIREHOSE_BUFFER_KERNEL_DEFAULT_CHUNK_COUNT * 3 / 4,
-		"FIREHOSE_BUFFER_KERNEL_DEFAULT_IO_PAGES cannot exceed 3/4 of FIREHOSE_BUFFER_KERNEL_DEFAULT_CHUNK_COUNT");
-#endif
-
-#pragma mark -
-#pragma mark Client IPC to the log daemon
-#ifndef KERNEL
-
-static mach_port_t
-firehose_client_reconnect(firehose_buffer_t fb, mach_port_t oldsendp,
-		firehose_buffer_pushport_t pushport)
-{
-	mach_port_t cursendp = MACH_PORT_NULL;
-	mach_port_t mem_port = MACH_PORT_NULL, extra_info_port = MACH_PORT_NULL;
-	mach_vm_size_t extra_info_size = 0;
-	kern_return_t kr;
-	bool reconnecting = (oldsendp != MACH_PORT_NULL);
-
-	dispatch_assert(fb->fb_header.fbh_logd_port);
-	dispatch_assert(fb->fb_header.fbh_recvp);
-	dispatch_assert(fb->fb_header.fbh_uniquepid != 0);
-
-	_dispatch_unfair_lock_lock(&fb->fb_header.fbh_logd_lock);
-	cursendp = fb->fb_header.fbh_sendp[pushport];
-	if (cursendp != oldsendp || cursendp == MACH_PORT_DEAD) {
-		// someone beat us to reconnecting or logd was unloaded, just go away
-		goto unlock;
-	}
-
-	if (reconnecting) {
-		for (int i = 0; i < FIREHOSE_BUFFER_NPUSHPORTS; i++) {
-			mach_port_t spi = fb->fb_header.fbh_sendp[i];
-			dispatch_assert(spi);
-			// same trick as _xpc_pipe_dispose: keeping a send right maintains
-			// the name, so that we can destroy the receive right in case we
-			// still have it.
-			(void)firehose_mach_port_recv_dispose(spi, fb);
-			firehose_mach_port_send_release(spi);
-			fb->fb_header.fbh_sendp[i] = MACH_PORT_NULL;
-		}
-	}
-
-	/* Create a memory port for the buffer VM region */
-	vm_prot_t flags = VM_PROT_READ | MAP_MEM_VM_SHARE;
-	memory_object_size_t size = sizeof(union firehose_buffer_u);
-	mach_vm_address_t addr = (vm_address_t)fb;
-
-	kr = mach_make_memory_entry_64(mach_task_self(), &size, addr,
-			flags, &mem_port, MACH_PORT_NULL);
-	if (size < sizeof(union firehose_buffer_u)) {
-		DISPATCH_CLIENT_CRASH(size, "Invalid size for the firehose buffer");
-	}
-	if (unlikely(kr)) {
-		// the client probably has some form of memory corruption
-		// and/or a port leak
-		DISPATCH_CLIENT_CRASH(kr, "Unable to make memory port");
-	}
-
-	if (reconnecting && _voucher_libtrace_hooks->vah_get_reconnect_info) {
-		kr = _voucher_libtrace_hooks->vah_get_reconnect_info(&addr, &size);
-		if (likely(kr == KERN_SUCCESS) && addr && size) {
-			extra_info_size = size;
-			kr = mach_make_memory_entry_64(mach_task_self(), &size, addr,
-					flags, &extra_info_port, MACH_PORT_NULL);
-			if (unlikely(kr)) {
-				// the client probably has some form of memory corruption
-				// and/or a port leak
-				DISPATCH_CLIENT_CRASH(kr, "Unable to make memory port");
-			}
-			kr = mach_vm_deallocate(mach_task_self(), addr, size);
-			(void)dispatch_assume_zero(kr);
-		}
-	}
-
-	/* Create memory and IO communication ports to the logging daemon */
-	uint32_t opts = MPO_CONTEXT_AS_GUARD | MPO_TEMPOWNER | MPO_INSERT_SEND_RIGHT;
-	mach_port_t sendp[FIREHOSE_BUFFER_NPUSHPORTS];
-	for (int i = 0; i < FIREHOSE_BUFFER_NPUSHPORTS; i++) {
-		sendp[i] = firehose_mach_port_allocate(opts, 1, fb);
-	}
-	cursendp = sendp[pushport];
-
-	/* Call the firehose_register() MIG routine */
-	kr = firehose_send_register(fb->fb_header.fbh_logd_port, mem_port,
-			sizeof(union firehose_buffer_u),
-			sendp[FIREHOSE_BUFFER_PUSHPORT_MEM],
-			sendp[FIREHOSE_BUFFER_PUSHPORT_IO], fb->fb_header.fbh_recvp,
-			extra_info_port, extra_info_size);
-	if (likely(kr == KERN_SUCCESS)) {
-		for (int i = 0; i < FIREHOSE_BUFFER_NPUSHPORTS; i++) {
-			fb->fb_header.fbh_sendp[i] = sendp[i];
-		}
-	} else if (unlikely(kr == MACH_SEND_INVALID_DEST)) {
-		// MACH_SEND_INVALID_DEST here means that logd's boostrap port
-		// turned into a dead name, which in turn means that logd has been
-		// unloaded. The only option here, is to give up permanently.
-		for (int i = 0; i < FIREHOSE_BUFFER_NPUSHPORTS; i++) {
-			// same trick as _xpc_pipe_dispose: keeping a send right maintains
-			// the name, so that we can destroy the receive right in case we
-			// still have it.
-			(void)firehose_mach_port_recv_dispose(sendp[i], fb);
-			firehose_mach_port_send_release(sendp[i]);
-			fb->fb_header.fbh_sendp[i] = MACH_PORT_DEAD;
-		}
-		cursendp = MACH_PORT_DEAD;
-		firehose_mach_port_send_release(mem_port);
-		if (extra_info_port) firehose_mach_port_send_release(extra_info_port);
-	} else {
-		// the client probably has some form of memory corruption
-		// and/or a port leak
-		DISPATCH_CLIENT_CRASH(kr, "Unable to register with logd");
-	}
-
-unlock:
-	_dispatch_unfair_lock_unlock(&fb->fb_header.fbh_logd_lock);
-	return cursendp;
-}
-
-static void
-firehose_buffer_update_limits_unlocked(firehose_buffer_t fb)
-{
-	firehose_bank_state_u old, new;
-	firehose_buffer_bank_t fbb = &fb->fb_header.fbh_bank;
-	unsigned long fbb_flags = fbb->fbb_flags;
-	uint16_t io_streams = 0, mem_streams = 0;
-	uint16_t total = 0;
-
-	for (size_t i = 0; i < countof(fb->fb_header.fbh_stream); i++) {
-		firehose_buffer_stream_t fbs = fb->fb_header.fbh_stream + i;
-
-		if (fbs->fbs_state.fss_current == FIREHOSE_STREAM_STATE_PRISTINE) {
-			continue;
-		}
-		if ((1UL << i) & firehose_stream_uses_io_bank) {
-			io_streams++;
-		} else {
-			mem_streams++;
-		}
-	}
-
-	if (fbb_flags & FIREHOSE_BUFFER_BANK_FLAG_LOW_MEMORY) {
-		if (fbb_flags & FIREHOSE_BUFFER_BANK_FLAG_HIGH_RATE) {
-			total = 1 + 4 * mem_streams + io_streams;		// usually 10
-		} else {
-			total = 1 + 2 + mem_streams + io_streams;		// usually 6
-		}
-	} else {
-		if (fbb_flags & FIREHOSE_BUFFER_BANK_FLAG_HIGH_RATE) {
-			total = 1 + 6 * mem_streams + 3 * io_streams;	// usually 16
-		} else {
-			total = 1 + 2 * (mem_streams + io_streams);		// usually 7
-		}
-	}
-
-	uint16_t ratio = (uint16_t)(PAGE_SIZE / FIREHOSE_CHUNK_SIZE);
-	if (ratio > 1) {
-		total = roundup(total, ratio);
-	}
-	total = MAX(total, FIREHOSE_BUFFER_CHUNK_PREALLOCATED_COUNT);
-	if (!(fbb_flags & FIREHOSE_BUFFER_BANK_FLAG_LOW_MEMORY)) {
-		total = MAX(total, TARGET_OS_IPHONE ? 8 : 12);
-	}
-
-	new = (firehose_bank_state_u) {
-		.fbs_max_ref = (firehose_chunk_ref_t)(total + 1),
-		.fbs_mem_bank = total - 1,
-		.fbs_io_bank  = MAX(3 * total / 8, 2 * io_streams),
-	};
-
-	old = fbb->fbb_limits;
-	fbb->fbb_limits = new;
-	if (old.fbs_atomic_state == new.fbs_atomic_state) {
-		return;
-	}
-	os_atomic_add2o(&fb->fb_header, fbh_bank.fbb_state.fbs_atomic_state,
-			new.fbs_atomic_state - old.fbs_atomic_state, relaxed);
-}
-#endif // !KERNEL
-
-firehose_buffer_t
-firehose_buffer_create(mach_port_t logd_port, uint64_t unique_pid,
-		unsigned long bank_flags)
-{
-	firehose_buffer_header_t fbh;
-	firehose_buffer_t fb;
-
-#ifndef KERNEL
-	mach_vm_address_t vm_addr = 0;
-	kern_return_t kr;
-
-	vm_addr = vm_page_size;
-	const size_t madvise_bytes = FIREHOSE_BUFFER_MADVISE_CHUNK_COUNT *
-			FIREHOSE_CHUNK_SIZE;
-	if (unlikely(madvise_bytes % PAGE_SIZE)) {
-		DISPATCH_INTERNAL_CRASH(madvise_bytes,
-				"Invalid values for MADVISE_CHUNK_COUNT / CHUNK_SIZE");
-	}
-
-	kr = mach_vm_map(mach_task_self(), &vm_addr, sizeof(*fb), 0,
-			VM_FLAGS_ANYWHERE | VM_FLAGS_PURGABLE |
-			VM_MAKE_TAG(VM_MEMORY_GENEALOGY), MEMORY_OBJECT_NULL, 0, FALSE,
-			VM_PROT_DEFAULT, VM_PROT_ALL, VM_INHERIT_NONE);
-	if (unlikely(kr)) {
-		if (kr != KERN_NO_SPACE) dispatch_assume_zero(kr);
-		firehose_mach_port_send_release(logd_port);
-		return NULL;
-	}
-
-	uint32_t opts = MPO_CONTEXT_AS_GUARD | MPO_STRICT | MPO_INSERT_SEND_RIGHT;
-#else
-	vm_offset_t vm_addr = 0;
-	vm_size_t size;
-
-	size = FIREHOSE_BUFFER_KERNEL_CHUNK_COUNT * FIREHOSE_CHUNK_SIZE;
-	__firehose_allocate(&vm_addr, size);
-
-	(void)logd_port; (void)unique_pid;
-#endif // KERNEL
-
-	fb = (firehose_buffer_t)vm_addr;
-	fbh = &fb->fb_header;
-#ifndef KERNEL
-	fbh->fbh_logd_port = logd_port;
-	fbh->fbh_pid = getpid();
-	fbh->fbh_uniquepid = unique_pid;
-	fbh->fbh_recvp = firehose_mach_port_allocate(opts, MACH_PORT_QLIMIT_BASIC,
-			fb);
-#endif // !KERNEL
-	fbh->fbh_spi_version = OS_FIREHOSE_SPI_VERSION;
-	fbh->fbh_bank.fbb_flags = bank_flags;
-
-#ifndef KERNEL
-	for (size_t i = 0; i < countof(fbh->fbh_stream); i++) {
-		firehose_buffer_stream_t fbs = fbh->fbh_stream + i;
-		if (i != firehose_stream_metadata) {
-			fbs->fbs_state.fss_current = FIREHOSE_STREAM_STATE_PRISTINE;
-		}
-	}
-	firehose_buffer_update_limits_unlocked(fb);
-#else
-	uint16_t total = FIREHOSE_BUFFER_CHUNK_PREALLOCATED_COUNT;
-	const uint16_t num_kernel_io_pages = __firehose_num_kernel_io_pages;
-	uint16_t io_pages = num_kernel_io_pages;
-	fbh->fbh_bank.fbb_state = (firehose_bank_state_u){
-		.fbs_max_ref = (firehose_chunk_ref_t)(total + 1),
-		.fbs_io_bank = io_pages,
-		.fbs_mem_bank = total - io_pages,
-	};
-	fbh->fbh_bank.fbb_limits = fbh->fbh_bank.fbb_state;
-#endif // KERNEL
-
-	// now pre-allocate some chunks in the ring directly
-#ifdef KERNEL
-	const uint16_t pre_allocated = FIREHOSE_BUFFER_CHUNK_PREALLOCATED_COUNT - 1;
-#else
-	const uint16_t pre_allocated = FIREHOSE_BUFFER_CHUNK_PREALLOCATED_COUNT;
-#endif
-
-	fbh->fbh_bank.fbb_bitmap = (1U << (1 + pre_allocated)) - 1;
-
-	for (uint16_t i = 0; i < pre_allocated; i++) {
-		fbh->fbh_mem_ring[i] = i + 1;
-	}
-	fbh->fbh_bank.fbb_mem_flushed = pre_allocated;
-	fbh->fbh_ring_mem_head = pre_allocated;
-
-
-#ifdef KERNEL
-	// install the early boot page as the current one for persist
-	fbh->fbh_stream[firehose_stream_persist].fbs_state.fss_current =
-			FIREHOSE_BUFFER_CHUNK_PREALLOCATED_COUNT;
-	fbh->fbh_bank.fbb_state.fbs_io_bank -= 1;
-#endif
-
-	fbh->fbh_ring_tail = (firehose_ring_tail_u){
-		.frp_mem_flushed = pre_allocated,
-	};
-	return fb;
-}
-
-#ifndef KERNEL
-static char const * const _firehose_key = "firehose";
-
-static bool
-firehose_drain_notifications_once(firehose_buffer_t fb)
-{
-	mach_msg_options_t opts = MACH_RCV_MSG | MACH_RCV_TIMEOUT |
-			MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_CTX) | MACH_RCV_LARGE |
-			MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0);
-
-	const size_t maxsize =
-			sizeof(union __RequestUnion__firehose_client_firehoseReply_subsystem);
-	const size_t maxreplysize =
-			sizeof(union __ReplyUnion__firehose_client_firehoseReply_subsystem);
-	mach_msg_size_t rcv_size = maxsize + MAX_TRAILER_SIZE;
-	mig_reply_error_t *msg = alloca(rcv_size);
-	kern_return_t kr;
-
-	kr = mach_msg(&msg->Head, opts, 0, rcv_size, fb->fb_header.fbh_recvp, 0, 0);
-
-	if (kr == KERN_SUCCESS) {
-		dispatch_thread_context_s firehose_ctxt = {
-			.dtc_key = _firehose_key,
-			.dtc_fb = fb,
-		};
-		_dispatch_thread_context_push(&firehose_ctxt);
-		firehose_mig_server(firehoseReply_server, maxreplysize, &msg->Head);
-		_dispatch_thread_context_pop(&firehose_ctxt);
-	} else if (kr != MACH_RCV_TIMED_OUT) {
-		DISPATCH_CLIENT_CRASH(kr, "firehose_drain_notifications_once() failed");
-	}
-	return kr == KERN_SUCCESS;
-}
-
-static void
-firehose_client_send_push_async(firehose_buffer_t fb, qos_class_t qos,
-		bool for_io)
-{
-	firehose_buffer_pushport_t pushport = for_io;
-	mach_port_t sendp = fb->fb_header.fbh_sendp[pushport];
-	kern_return_t kr = KERN_FAILURE;
-
-	if (unlikely(sendp == MACH_PORT_DEAD)) {
-		return;
-	}
-
-	if (likely(sendp)) {
-		kr = firehose_send_push_async(sendp, qos, 0);
-		if (likely(kr == KERN_SUCCESS || kr == MACH_SEND_TIMED_OUT)) {
-			return;
-		}
-		if (kr != MACH_SEND_INVALID_DEST) {
-			DISPATCH_VERIFY_MIG(kr);
-			dispatch_assume_zero(kr);
-		}
-	}
-
-	sendp = firehose_client_reconnect(fb, sendp, pushport);
-	if (likely(MACH_PORT_VALID(sendp))) {
-		kr = firehose_send_push_async(sendp, qos, 0);
-		if (likely(kr == KERN_SUCCESS || kr == MACH_SEND_TIMED_OUT)) {
-			return;
-		}
-		if (kr != MACH_SEND_INVALID_DEST) {
-			DISPATCH_VERIFY_MIG(kr);
-			dispatch_assume_zero(kr);
-		}
-	}
-}
-
-OS_NOINLINE
-static void
-firehose_client_start_quarantine(firehose_buffer_t fb)
-{
-	if (_voucher_libtrace_hooks->vah_version < 5) return;
-	if (!_voucher_libtrace_hooks->vah_quarantine_starts) return;
-
-	_voucher_libtrace_hooks->vah_quarantine_starts();
-
-	fb->fb_header.fbh_quarantined = true;
-	firehose_buffer_stream_flush(fb, firehose_stream_special);
-	firehose_buffer_stream_flush(fb, firehose_stream_persist);
-	firehose_buffer_stream_flush(fb, firehose_stream_memory);
-}
-#endif // !KERNEL
-
-static void
-firehose_client_merge_updates(firehose_buffer_t fb, bool async_notif,
-		firehose_push_reply_t reply, bool quarantined,
-		firehose_bank_state_u *state_out)
-{
-	firehose_buffer_header_t fbh = &fb->fb_header;
-	firehose_bank_state_u state;
-	firehose_ring_tail_u otail, ntail;
-	uint64_t old_flushed_pos, bank_updates;
-	uint16_t io_delta = 0;
-	uint16_t mem_delta = 0;
-
-	if (quarantined) {
-#ifndef KERNEL
-		// this isn't a dispatch_once so that the upcall to libtrace
-		// can actually log itself without blocking on the gate.
-		if (os_atomic_load(&fbh->fbh_quarantined_state, relaxed) ==
-				FBH_QUARANTINE_NONE) {
-			os_atomic_cmpxchg(&fbh->fbh_quarantined_state, FBH_QUARANTINE_NONE,
-					FBH_QUARANTINE_PENDING, relaxed);
-		}
-#endif
-	}
-
-	if (firehose_atomic_maxv2o(fbh, fbh_bank.fbb_mem_flushed,
-			reply.fpr_mem_flushed_pos, &old_flushed_pos, relaxed)) {
-		mem_delta = (uint16_t)(reply.fpr_mem_flushed_pos - old_flushed_pos);
-	}
-	if (firehose_atomic_maxv2o(fbh, fbh_bank.fbb_io_flushed,
-			reply.fpr_io_flushed_pos, &old_flushed_pos, relaxed)) {
-		io_delta = (uint16_t)(reply.fpr_io_flushed_pos - old_flushed_pos);
-	}
-#ifndef KERNEL
-	_dispatch_debug("client side: mem: +%d->%llx, io: +%d->%llx",
-			mem_delta, reply.fpr_mem_flushed_pos,
-			io_delta, reply.fpr_io_flushed_pos);
-#endif
-
-	if (!mem_delta && !io_delta) {
-		if (state_out) {
-			state_out->fbs_atomic_state = os_atomic_load2o(fbh,
-					fbh_bank.fbb_state.fbs_atomic_state, relaxed);
-		}
-		return;
-	}
-
-	__firehose_critical_region_enter();
-	os_atomic_rmw_loop2o(fbh, fbh_ring_tail.frp_atomic_tail,
-			otail.frp_atomic_tail, ntail.frp_atomic_tail, relaxed, {
-		ntail = otail;
-		// overflow handles the generation wraps
-		ntail.frp_io_flushed += io_delta;
-		ntail.frp_mem_flushed += mem_delta;
-	});
-
-	bank_updates = ((uint64_t)mem_delta << FIREHOSE_BANK_SHIFT(0)) |
-			((uint64_t)io_delta << FIREHOSE_BANK_SHIFT(1));
-	state.fbs_atomic_state = os_atomic_add2o(fbh,
-			fbh_bank.fbb_state.fbs_atomic_state, bank_updates, release);
-	__firehose_critical_region_leave();
-
-	if (state_out) *state_out = state;
-
-	if (async_notif) {
-		if (io_delta) {
-			os_atomic_inc2o(fbh, fbh_bank.fbb_io_notifs, relaxed);
-		}
-		if (mem_delta) {
-			os_atomic_inc2o(fbh, fbh_bank.fbb_mem_notifs, relaxed);
-		}
-	}
-}
-
-#ifndef KERNEL
-void *
-firehose_buffer_get_logging_prefs(firehose_buffer_t fb, size_t *length)
-{
-	mach_port_t sendp = fb->fb_header.fbh_logd_port;
-	mach_port_t mem_port = MACH_PORT_NULL;
-	mach_vm_size_t size = 0;
-	mach_vm_address_t addr = 0;
-	kern_return_t kr;
-
-	if (unlikely(!MACH_PORT_VALID(sendp))) {
-		*length = 0;
-		return NULL;
-	}
-
-	kr = firehose_send_get_logging_prefs(sendp, &mem_port, &size);
-	if (unlikely(kr != KERN_SUCCESS)) {
-		if (kr != MACH_SEND_INVALID_DEST) {
-			DISPATCH_VERIFY_MIG(kr);
-			dispatch_assume_zero(kr);
-		}
-		*length = 0;
-		return NULL;
-	}
-
-	/* Map the memory handle into the server address space */
-	kr = mach_vm_map(mach_task_self(), &addr, size, 0,
-			VM_FLAGS_ANYWHERE, mem_port, 0, FALSE,
-			VM_PROT_READ, VM_PROT_READ, VM_INHERIT_NONE);
-	DISPATCH_VERIFY_MIG(kr);
-	if (dispatch_assume_zero(kr)) {
-		addr = 0;
-		size = 0;
-	}
-	kr = mach_port_deallocate(mach_task_self(), mem_port);
-	DISPATCH_VERIFY_MIG(kr);
-	dispatch_assume_zero(kr);
-
-	*length = (size_t)size;
-	return (void *)addr;
-}
-
-bool
-firehose_buffer_should_send_strings(firehose_buffer_t fb)
-{
-	mach_port_t sendp = fb->fb_header.fbh_sendp[FIREHOSE_BUFFER_PUSHPORT_MEM];
-	kern_return_t kr;
-	boolean_t result = false;
-
-	if (unlikely(sendp == MACH_PORT_DEAD)) {
-		return false;
-	}
-
-	if (likely(sendp)) {
-		kr = firehose_send_should_send_strings(sendp, &result);
-		if (likely(kr == KERN_SUCCESS)) {
-			return result;
-		}
-		if (kr != MACH_SEND_INVALID_DEST) {
-			DISPATCH_VERIFY_MIG(kr);
-			dispatch_assume_zero(kr);
-		}
-	}
-
-	sendp = firehose_client_reconnect(fb, sendp, FIREHOSE_BUFFER_PUSHPORT_MEM);
-	if (likely(MACH_PORT_VALID(sendp))) {
-		kr = firehose_send_should_send_strings(sendp, &result);
-		if (likely(kr == KERN_SUCCESS)) {
-			return result;
-		}
-		if (kr != MACH_SEND_INVALID_DEST) {
-			DISPATCH_VERIFY_MIG(kr);
-			dispatch_assume_zero(kr);
-		}
-	}
-	return false;
-}
-
-OS_NOT_TAIL_CALLED OS_NOINLINE
-static void
-firehose_client_send_push_and_wait(firehose_buffer_t fb, bool for_io,
-		firehose_bank_state_u *state_out)
-{
-	firehose_buffer_pushport_t pushport = for_io;
-	mach_port_t sendp = fb->fb_header.fbh_sendp[pushport];
-	firehose_push_reply_t push_reply = { };
-	boolean_t quarantined = false;
-	kern_return_t kr;
-
-	if (unlikely(sendp == MACH_PORT_DEAD)) {
-		return;
-	}
-	if (likely(sendp)) {
-		kr = firehose_send_push_and_wait(sendp, &push_reply, &quarantined);
-		if (likely(kr == KERN_SUCCESS)) {
-			goto success;
-		}
-		if (kr != MACH_SEND_INVALID_DEST) {
-			DISPATCH_VERIFY_MIG(kr);
-			dispatch_assume_zero(kr);
-		}
-	}
-
-	sendp = firehose_client_reconnect(fb, sendp, pushport);
-	if (likely(MACH_PORT_VALID(sendp))) {
-		kr = firehose_send_push_and_wait(sendp, &push_reply, &quarantined);
-		if (likely(kr == KERN_SUCCESS)) {
-			goto success;
-		}
-		if (kr != MACH_SEND_INVALID_DEST) {
-			DISPATCH_VERIFY_MIG(kr);
-			dispatch_assume_zero(kr);
-		}
-	}
-
-	if (state_out) {
-		state_out->fbs_atomic_state = os_atomic_load2o(&fb->fb_header,
-				fbh_bank.fbb_state.fbs_atomic_state, relaxed);
-	}
-	return;
-
-success:
-	if (memcmp(&push_reply, &FIREHOSE_PUSH_REPLY_CORRUPTED,
-			sizeof(push_reply)) == 0) {
-		// TODO: find out the actual cause and log it
-		DISPATCH_CLIENT_CRASH(0, "Memory corruption in the logging buffers");
-	}
-
-	if (for_io) {
-		os_atomic_inc2o(&fb->fb_header, fbh_bank.fbb_io_sync_pushes, relaxed);
-	} else {
-		os_atomic_inc2o(&fb->fb_header, fbh_bank.fbb_mem_sync_pushes, relaxed);
-	}
-	// TODO <rdar://problem/22963876>
-	//
-	// use fbb_*_flushes and fbb_*_sync_pushes to decide to dynamically
-	// allow using more buffers, if not under memory pressure.
-	//
-	// There only is a point for multithreaded clients if:
-	// - enough samples (total_flushes above some limits)
-	// - the ratio is really bad (a push per cycle is definitely a problem)
-	return firehose_client_merge_updates(fb, false, push_reply, quarantined,
-			state_out);
-}
-
-OS_NOT_TAIL_CALLED OS_NOINLINE
-static void
-__FIREHOSE_CLIENT_THROTTLED_DUE_TO_HEAVY_LOGGING__(firehose_buffer_t fb,
-		bool for_io, firehose_bank_state_u *state_out)
-{
-	firehose_client_send_push_and_wait(fb, for_io, state_out);
-}
-
-kern_return_t
-firehose_client_push_reply(mach_port_t req_port OS_UNUSED,
-	kern_return_t rtc, firehose_push_reply_t push_reply OS_UNUSED,
-	boolean_t quarantined OS_UNUSED)
-{
-	DISPATCH_INTERNAL_CRASH(rtc, "firehose_push_reply should never be sent "
-			"to the buffer receive port");
-}
-
-kern_return_t
-firehose_client_push_notify_async(mach_port_t server_port OS_UNUSED,
-	firehose_push_reply_t push_reply, boolean_t quarantined)
-{
-	dispatch_thread_context_t ctxt =
-			_dispatch_thread_context_find(_firehose_key);
-	firehose_buffer_t fb = ctxt->dtc_fb;
-	firehose_client_merge_updates(fb, true, push_reply, quarantined, NULL);
-	return KERN_SUCCESS;
-}
-
-#endif // !KERNEL
-#pragma mark -
-#pragma mark Buffer handling
-
-#ifndef KERNEL
-void
-firehose_buffer_update_limits(firehose_buffer_t fb)
-{
-	dispatch_unfair_lock_t fbb_lock = &fb->fb_header.fbh_bank.fbb_lock;
-	_dispatch_unfair_lock_lock(fbb_lock);
-	firehose_buffer_update_limits_unlocked(fb);
-	_dispatch_unfair_lock_unlock(fbb_lock);
-}
-#endif // !KERNEL
-
-OS_ALWAYS_INLINE
-static inline uint64_t
-firehose_buffer_chunk_apply_stamp_slop(uint64_t stamp)
-{
-	// <rdar://problem/23562733> boot starts mach absolute time at
-	// 0, and wrapping around to values above UINT64_MAX -
-	// FIREHOSE_STAMP_SLOP breaks firehose_buffer_stream_flush()
-	// assumptions
-	return stamp > FIREHOSE_STAMP_SLOP ? stamp - FIREHOSE_STAMP_SLOP : 0;
-}
-
-OS_ALWAYS_INLINE
-static inline bool
-firehose_buffer_chunk_stamp_delta_fits(firehose_chunk_t fc, uint64_t stamp)
-{
-	return !((stamp - fc->fc_timestamp) >> 48);
-}
-
-OS_ALWAYS_INLINE
-static inline firehose_tracepoint_t
-firehose_buffer_chunk_init(firehose_chunk_t fc,
-		firehose_tracepoint_query_t ask, uint8_t **privptr, uint64_t thread,
-		firehose_tracepoint_t *lft, uint64_t loss_start)
-{
-	firehose_tracepoint_t ft;
-	uint64_t stamp_and_len;
-
-	const uint16_t ft_size = offsetof(struct firehose_tracepoint_s, ft_data);
-
-	uint16_t pub_offs = offsetof(struct firehose_chunk_s, fc_data);
-	uint16_t priv_offs = FIREHOSE_CHUNK_SIZE;
-
-	if (unlikely(lft)) {
-		const uint16_t flp_size = sizeof(struct firehose_loss_payload_s);
-		uint64_t stamp, minstamp;
-		uint16_t flp_pub_offs;
-
-		// first, try to make both timestamps fit
-		minstamp = MIN(ask->stamp, loss_start);
-		fc->fc_timestamp =
-				firehose_buffer_chunk_apply_stamp_slop(minstamp);
-
-		// if they can't both fit, use the timestamp of the actual tracepoint:
-		//  a) this should _really_ never happen
-		//  b) if it does, a determined reader can tell that it did by comparing
-		//     the loss event start_stamp payload field with the main stamp
-		if (!firehose_buffer_chunk_stamp_delta_fits(fc, ask->stamp)) {
-			// if ask->stamp didn't fit on the first try it must be greater than
-			// loss_start by > 2^48, so it must also be greater than
-			// FIREHOSE_STAMP_SLOP - so no need to worry about underflow here
-			fc->fc_timestamp = ask->stamp - FIREHOSE_STAMP_SLOP;
-		}
-
-		*lft = (firehose_tracepoint_t)fc->fc_data;
-
-		stamp = firehose_buffer_chunk_stamp_delta_fits(fc, loss_start) ?
-				loss_start : ask->stamp;
-
-		stamp_and_len = stamp - fc->fc_timestamp;
-		stamp_and_len |= (uint64_t)flp_size << 48;
-		os_atomic_store2o(*lft, ft_stamp_and_length, stamp_and_len, relaxed);
-
-		(*lft)->ft_thread = thread; // not really meaningful
-
-		flp_pub_offs = roundup(ft_size + flp_size, 8);
-		pub_offs += flp_pub_offs;
-		ft = (firehose_tracepoint_t)(fc->fc_data + flp_pub_offs);
-	} else {
-		fc->fc_timestamp =
-				firehose_buffer_chunk_apply_stamp_slop(ask->stamp);
-		ft = (firehose_tracepoint_t)fc->fc_data;
-	}
-
-	pub_offs += roundup(ft_size + ask->pubsize, 8);
-	priv_offs -= ask->privsize;
-
-	// Needed for process death handling (tracepoint-begin):
-	// write the length before making the chunk visible
-	stamp_and_len = ask->stamp - fc->fc_timestamp;
-	stamp_and_len |= (uint64_t)ask->pubsize << 48;
-	os_atomic_store2o(ft, ft_stamp_and_length, stamp_and_len, relaxed);
-
-	ft->ft_thread = thread;
-
-	fc->fc_pos = (firehose_chunk_pos_u){
-		.fcp_next_entry_offs = pub_offs,
-		.fcp_private_offs = priv_offs,
-		.fcp_refcnt = 1,
-		.fcp_stream = ask->stream,
-		.fcp_flag_io = ask->for_io,
-		.fcp_quarantined = ask->quarantined,
-	};
-
-	if (privptr) {
-		*privptr = fc->fc_start + priv_offs;
-	}
-	return ft;
-}
-
-OS_NOINLINE
-static firehose_tracepoint_t
-firehose_buffer_stream_chunk_install(firehose_buffer_t fb,
-		firehose_tracepoint_query_t ask, uint8_t **privptr,
-		firehose_chunk_ref_t ref)
-{
-	firehose_stream_state_u state, new_state;
-	firehose_tracepoint_t ft = NULL, lft;
-	firehose_buffer_header_t fbh = &fb->fb_header;
-	firehose_buffer_stream_t fbs = &fbh->fbh_stream[ask->stream];
-
-	if (likely(ref)) {
-		uint64_t thread;
-		bool installed = false;
-		firehose_chunk_t fc = firehose_buffer_ref_to_chunk(fb, ref);
-
-		if (fc->fc_pos.fcp_atomic_pos) {
-			// Needed for process death handling (recycle-reuse):
-			// No atomic fences required, we merely want to make sure the
-			// observers will see memory effects in program (asm) order.
-			// 1. the payload part of the chunk is cleared completely
-			// 2. the chunk is marked as reused
-			// This ensures that if we don't see a reference to a chunk in the
-			// ring and it is dirty, when crawling the chunk, we don't see
-			// remnants of other tracepoints.
-			//
-			// We only do that when the fc_pos is non zero, because zero means
-			// we just faulted the chunk, and the kernel already bzero-ed it.
-			bzero(fc->fc_data, sizeof(fc->fc_data));
-		}
-		dispatch_compiler_barrier();
-
-		if (ask->stream == firehose_stream_metadata) {
-			os_atomic_or2o(fbh, fbh_bank.fbb_metadata_bitmap, 1ULL << ref,
-					relaxed);
-		}
-
-#if KERNEL
-		thread = thread_tid(current_thread());
-#else
-		thread = _pthread_threadid_self_np_direct();
-#endif
-
-		// If no tracepoints were lost at the tail end of this generation, the
-		// chunk timestamp is the stamp of the first tracepoint and the first
-		// tracepoint belongs at the beginning of the chunk.  If, however, we
-		// need to record a loss event, the timestamp has to be the minimum of
-		// the loss stamp and the stamp of the first tracepoint, and the loss
-		// event needs to be placed at the beginning of the chunk in addition to
-		// the first actual tracepoint.
-		state.fss_atomic_state =
-				os_atomic_load2o(fbs, fbs_state.fss_atomic_state, relaxed);
-
-		if (likely(!state.fss_loss)) {
-			ft = firehose_buffer_chunk_init(fc, ask, privptr, thread, NULL, 0);
-
-			// release to publish the chunk init
-			installed = os_atomic_rmw_loop2o(fbs, fbs_state.fss_atomic_state,
-					state.fss_atomic_state, new_state.fss_atomic_state, release, {
-				if (state.fss_loss) {
-					os_atomic_rmw_loop_give_up(break);
-				}
-				// clear the gate, waiter bits and loss count
-				new_state = (firehose_stream_state_u){
-					.fss_current = ref,
-					.fss_generation = state.fss_generation + 1,
-				};
-			});
-		}
-
-		if (unlikely(!installed)) {
-			uint64_t loss_start, loss_end;
-
-			// ensure we can see the start stamp
-			(void)os_atomic_load2o(fbs, fbs_state.fss_atomic_state, acquire);
-			loss_start = fbs->fbs_loss_start;
-			fbs->fbs_loss_start = 0; // reset under fss_gate
-			loss_end = mach_continuous_time();
-
-			ft = firehose_buffer_chunk_init(fc, ask, privptr, thread, &lft,
-					loss_start);
-			os_atomic_rmw_loop2o(fbs, fbs_state.fss_atomic_state,
-					state.fss_atomic_state, new_state.fss_atomic_state, release, {
-				// no giving up this time!
-				new_state = (firehose_stream_state_u){
-					.fss_current = ref,
-					.fss_generation = state.fss_generation + 1,
-				};
-			});
-
-			struct firehose_loss_payload_s flp = {
-				.start_stamp = loss_start,
-				.end_stamp = loss_end,
-				.count = state.fss_loss,
-			};
-			memcpy(lft->ft_data, &flp, sizeof(flp));
-
-			firehose_tracepoint_id_u ftid = { .ftid = {
-				._namespace = firehose_tracepoint_namespace_loss,
-				// no meaningful value for _type
-				// nor for _flags
-				._code = ask->stream,
-			} };
-
-			// publish the contents of the loss tracepoint
-			os_atomic_store2o(lft, ft_id.ftid_atomic_value, ftid.ftid_value,
-					release);
-		}
-	} else {
-		// the allocator gave up - just clear the allocator and waiter bits and
-		// increment the loss count
-		state.fss_atomic_state =
-				os_atomic_load2o(fbs, fbs_state.fss_atomic_state, relaxed);
-		if (!state.fss_timestamped) {
-			fbs->fbs_loss_start = mach_continuous_time();
-
-			// release to publish the timestamp
-			os_atomic_rmw_loop2o(fbs, fbs_state.fss_atomic_state,
-					state.fss_atomic_state, new_state.fss_atomic_state,
-					release, {
-				new_state = (firehose_stream_state_u){
-					.fss_loss =
-							MIN(state.fss_loss + 1, FIREHOSE_LOSS_COUNT_MAX),
-					.fss_timestamped = true,
-					.fss_generation = state.fss_generation,
-				};
-			});
-		} else {
-			os_atomic_rmw_loop2o(fbs, fbs_state.fss_atomic_state,
-					state.fss_atomic_state, new_state.fss_atomic_state,
-					relaxed, {
-				new_state = (firehose_stream_state_u){
-					.fss_loss =
-							MIN(state.fss_loss + 1, FIREHOSE_LOSS_COUNT_MAX),
-					.fss_timestamped = true,
-					.fss_generation = state.fss_generation,
-				};
-			});
-		}
-	}
-
-	// pairs with the one in firehose_buffer_tracepoint_reserve()
-	__firehose_critical_region_leave();
-
-#ifndef KERNEL
-	_dispatch_trace_firehose_chunk_install(((uint64_t *)ask)[0],
-			((uint64_t *)ask)[1], state.fss_atomic_state,
-			new_state.fss_atomic_state);
-	if (unlikely(state.fss_allocator & FIREHOSE_GATE_WAITERS_MASK)) {
-		_dispatch_gate_broadcast_slow(&fbs->fbs_state.fss_gate,
-				state.fss_gate.dgl_lock);
-	}
-
-	if (unlikely(state.fss_current == FIREHOSE_STREAM_STATE_PRISTINE)) {
-		firehose_buffer_update_limits(fb);
-	}
-
-	if (unlikely(os_atomic_load2o(fbh, fbh_quarantined_state, relaxed) ==
-			FBH_QUARANTINE_PENDING)) {
-		if (os_atomic_cmpxchg2o(fbh, fbh_quarantined_state,
-				FBH_QUARANTINE_PENDING, FBH_QUARANTINE_STARTED, relaxed)) {
-			firehose_client_start_quarantine(fb);
-		}
-	}
-#endif // !KERNEL
-
-	return ft;
-}
-
-#ifndef KERNEL
-OS_ALWAYS_INLINE
-static inline firehose_chunk_ref_t
-firehose_buffer_ring_try_grow(firehose_buffer_bank_t fbb, uint16_t limit)
-{
-	firehose_chunk_ref_t ref = 0;
-	uint64_t bitmap;
-
-	_dispatch_unfair_lock_lock(&fbb->fbb_lock);
-	bitmap = ~(fbb->fbb_bitmap | (~0ULL << limit));
-	if (bitmap) {
-		ref = firehose_bitmap_first_set(bitmap);
-		fbb->fbb_bitmap |= 1U << ref;
-	}
-	_dispatch_unfair_lock_unlock(&fbb->fbb_lock);
-	return ref;
-}
-
-OS_ALWAYS_INLINE
-static inline firehose_chunk_ref_t
-firehose_buffer_ring_shrink(firehose_buffer_t fb, firehose_chunk_ref_t ref)
-{
-	const size_t madv_size =
-			FIREHOSE_CHUNK_SIZE * FIREHOSE_BUFFER_MADVISE_CHUNK_COUNT;
-	const size_t madv_mask =
-			(1ULL << FIREHOSE_BUFFER_MADVISE_CHUNK_COUNT) - 1;
-
-	dispatch_unfair_lock_t fbb_lock = &fb->fb_header.fbh_bank.fbb_lock;
-	uint64_t bitmap;
-
-	_dispatch_unfair_lock_lock(fbb_lock);
-	if (ref < fb->fb_header.fbh_bank.fbb_limits.fbs_max_ref) {
-		goto done;
-	}
-
-	bitmap = (fb->fb_header.fbh_bank.fbb_bitmap &= ~(1UL << ref));
-	ref &= ~(FIREHOSE_BUFFER_MADVISE_CHUNK_COUNT - 1);
-	if ((bitmap & (madv_mask << ref)) == 0) {
-		// if MADVISE_WIDTH consecutive chunks are free, madvise them free
-		madvise(firehose_buffer_ref_to_chunk(fb, ref), madv_size, MADV_FREE);
-	}
-	ref = 0;
-done:
-	_dispatch_unfair_lock_unlock(fbb_lock);
-	return ref;
-}
-#endif // !KERNEL
-
-OS_NOINLINE
-void
-firehose_buffer_ring_enqueue(firehose_buffer_t fb, firehose_chunk_ref_t ref)
-{
-	firehose_chunk_t fc = firehose_buffer_ref_to_chunk(fb, ref);
-	uint16_t volatile *fbh_ring;
-	uint16_t volatile *fbh_ring_head;
-	uint16_t head, gen, dummy, idx;
-	firehose_chunk_pos_u fc_pos = fc->fc_pos;
-	bool for_io = fc_pos.fcp_flag_io;
-
-	if (for_io) {
-		fbh_ring = fb->fb_header.fbh_io_ring;
-		fbh_ring_head = &fb->fb_header.fbh_ring_io_head;
-	} else {
-		fbh_ring = fb->fb_header.fbh_mem_ring;
-		fbh_ring_head = &fb->fb_header.fbh_ring_mem_head;
-	}
-
-#ifdef KERNEL
-	// The algorithm in the kernel is simpler:
-	//  1. reserve a write position for the head
-	//  2. store the new reference at that position
-	// Enqueuers can't starve each other that way.
-	//
-	// However, the dequeuers now have to sometimes wait for the value written
-	// in the ring to appear and have to spin, which is okay since the kernel
-	// disables preemption around these two consecutive atomic operations.
-	// See firehose_client_drain.
-	__firehose_critical_region_enter();
-	head = os_atomic_inc_orig(fbh_ring_head, relaxed);
-	gen = head & FIREHOSE_RING_POS_GEN_MASK;
-	idx = head & FIREHOSE_RING_POS_IDX_MASK;
-
-	while (unlikely(!os_atomic_cmpxchgv(&fbh_ring[idx], gen, gen | ref, &dummy,
-			relaxed))) {
-		// can only ever happen if a recycler is slow, this requires having
-		// enough cores (>5 for I/O e.g.)
-		_dispatch_wait_until(fbh_ring[idx] == gen);
-	}
-	__firehose_critical_region_leave();
-	__firehose_buffer_push_to_logd(fb, for_io);
-#else
-	// The algorithm is:
-	//   1. read the head position
-	//   2. cmpxchg head.gen with the (head.gen | ref) at head.idx
-	//   3. if it fails wait until either the head cursor moves,
-	//      or the cell becomes free
-	//
-	// The most likely stall at (3) is because another enqueuer raced us
-	// and made the cell non empty.
-	//
-	// The alternative is to reserve the enqueue slot with an atomic inc.
-	// Then write the ref into the ring. This would be much simpler as the
-	// generation packing wouldn't be required (though setting the ring cell
-	// would still need a cmpxchg loop to avoid clobbering values of slow
-	// dequeuers)
-	//
-	// But then that means that flushers (logd) could be starved until that
-	// finishes, and logd cannot be held forever (that could even be a logd
-	// DoS from malicious programs). Meaning that logd would stop draining
-	// buffer queues when encountering that issue, leading the program to be
-	// stuck in firehose_client_push() apparently waiting on logd, while
-	// really it's waiting on itself. It's better for the scheduler if we
-	// make it clear that we're waiting on ourselves!
-
-	head = os_atomic_load(fbh_ring_head, relaxed);
-	for (;;) {
-		gen = head & FIREHOSE_RING_POS_GEN_MASK;
-		idx = head & FIREHOSE_RING_POS_IDX_MASK;
-
-		// a thread being preempted here for GEN_MASK worth of ring rotations,
-		// it could lead to the cmpxchg succeed, and have a bogus enqueue
-		// (confused enqueuer)
-		if (likely(os_atomic_cmpxchgv(&fbh_ring[idx], gen, gen | ref, &dummy,
-				relaxed))) {
-			if (likely(os_atomic_cmpxchgv(fbh_ring_head, head, head + 1,
-					&head, release))) {
-				__firehose_critical_region_leave();
-				break;
-			}
-			// this thread is a confused enqueuer, need to undo enqueue
-			os_atomic_store(&fbh_ring[idx], gen, relaxed);
-			continue;
-		}
-
-		_dispatch_wait_until(({
-			// wait until either the head moves (another enqueuer is done)
-			// or (not very likely) a recycler is very slow
-			// or (very unlikely) the confused thread undoes its enqueue
-			uint16_t old_head = head;
-			head = *fbh_ring_head;
-			head != old_head || fbh_ring[idx] == gen;
-		}));
-	}
-
-	pthread_priority_t pp = fc_pos.fcp_qos;
-	pp <<= _PTHREAD_PRIORITY_QOS_CLASS_SHIFT;
-	firehose_client_send_push_async(fb, _pthread_qos_class_decode(pp, NULL, NULL),
-			for_io);
-#endif
-}
-
-#ifndef KERNEL
-void
-firehose_buffer_force_connect(firehose_buffer_t fb)
-{
-	mach_port_t sendp = fb->fb_header.fbh_sendp[FIREHOSE_BUFFER_PUSHPORT_MEM];
-	if (sendp == MACH_PORT_NULL) {
-		firehose_client_reconnect(fb, MACH_PORT_NULL,
-				FIREHOSE_BUFFER_PUSHPORT_MEM);
-	}
-}
-#endif
-
-OS_ALWAYS_INLINE
-static inline firehose_chunk_ref_t
-firehose_buffer_ring_try_recycle(firehose_buffer_t fb)
-{
-	firehose_ring_tail_u pos, old;
-	uint16_t volatile *fbh_ring;
-	uint16_t gen, entry, tail;
-	firehose_chunk_ref_t ref;
-	firehose_chunk_t fc;
-	bool for_io;
-
-	os_atomic_rmw_loop2o(&fb->fb_header, fbh_ring_tail.frp_atomic_tail,
-			old.frp_atomic_tail, pos.frp_atomic_tail, relaxed, {
-		pos = old;
-		if (likely(old.frp_mem_tail != old.frp_mem_flushed)) {
-			pos.frp_mem_tail++;
-		} else if (likely(old.frp_io_tail != old.frp_io_flushed)) {
-			pos.frp_io_tail++;
-		} else {
-			os_atomic_rmw_loop_give_up(return 0);
-		}
-	});
-
-	// there's virtually no chance that the lack of acquire barrier above
-	// lets us read a value from the ring so stale that it's still an Empty
-	// marker. For correctness purposes have a cheap loop that should never
-	// really loop, instead of an acquire barrier in the cmpxchg above.
-	for_io = (pos.frp_io_tail != old.frp_io_tail);
-	if (for_io) {
-		fbh_ring = fb->fb_header.fbh_io_ring;
-		tail = old.frp_io_tail & FIREHOSE_RING_POS_IDX_MASK;
-	} else {
-		fbh_ring = fb->fb_header.fbh_mem_ring;
-		tail = old.frp_mem_tail & FIREHOSE_RING_POS_IDX_MASK;
-	}
-	_dispatch_wait_until((entry = fbh_ring[tail]) & FIREHOSE_RING_POS_IDX_MASK);
-
-	// Needed for process death handling (recycle-dequeue):
-	// No atomic fences required, we merely want to make sure the observers
-	// will see memory effects in program (asm) order.
-	// 1. the chunk is marked as "void&full" (clobbering the pos with FULL_BIT)
-	// 2. then we remove any reference to the chunk from the ring
-	// This ensures that if we don't see a reference to a chunk in the ring
-	// and it is dirty, it is a chunk being written to that needs a flush
-	gen = (entry & FIREHOSE_RING_POS_GEN_MASK) + FIREHOSE_RING_POS_GEN_INC;
-	ref = entry & FIREHOSE_RING_POS_IDX_MASK;
-	fc = firehose_buffer_ref_to_chunk(fb, ref);
-
-	if (!for_io && fc->fc_pos.fcp_stream == firehose_stream_metadata) {
-		os_atomic_and2o(fb, fb_header.fbh_bank.fbb_metadata_bitmap,
-				~(1ULL << ref), relaxed);
-	}
-	os_atomic_store2o(fc, fc_pos.fcp_atomic_pos,
-			FIREHOSE_CHUNK_POS_FULL_BIT, relaxed);
-	dispatch_compiler_barrier();
-	os_atomic_store(&fbh_ring[tail], gen | 0, relaxed);
-	return ref;
-}
-
-#ifndef KERNEL
-OS_NOINLINE
-static firehose_tracepoint_t
-firehose_buffer_tracepoint_reserve_wait_for_chunks_from_logd(firehose_buffer_t fb,
-		firehose_tracepoint_query_t ask, uint8_t **privptr)
-{
-	bool for_io = ask->for_io;
-	firehose_buffer_pushport_t pushport = for_io;
-	firehose_buffer_bank_t const fbb = &fb->fb_header.fbh_bank;
-	firehose_bank_state_u state;
-	firehose_chunk_ref_t ref, fbs_max_ref;
-
-	for (int i = MACH_PORT_QLIMIT_BASIC;
-			i-- && firehose_drain_notifications_once(fb); );
-
-	// first wait for our bank to have space, if needed
-	if (unlikely(!ask->is_bank_ok)) {
-		state.fbs_atomic_state =
-				os_atomic_load2o(fbb, fbb_state.fbs_atomic_state, relaxed);
-		while (!firehose_buffer_bank_try_reserve_slot(fb, for_io, &state)) {
-			if (ask->quarantined) {
-				__FIREHOSE_CLIENT_THROTTLED_DUE_TO_HEAVY_LOGGING__(fb, for_io,
-						&state);
-			} else {
-				firehose_client_send_push_and_wait(fb, for_io, &state);
-			}
-			if (unlikely(fb->fb_header.fbh_sendp[pushport] == MACH_PORT_DEAD)) {
-				// logd was unloaded, give up
-				return NULL;
-			}
-		}
-		fbs_max_ref = state.fbs_max_ref;
-	} else {
-		fbs_max_ref = fbb->fbb_state.fbs_max_ref;
-	}
-
-	// third, wait for a chunk to come up, and if not, wait on the daemon
-	for (;;) {
-		if (likely(ref = firehose_buffer_ring_try_recycle(fb))) {
-			if (unlikely(ref >= fbs_max_ref)) {
-				ref = firehose_buffer_ring_shrink(fb, ref);
-				if (!ref) {
-					continue;
-				}
-			}
-			break;
-		}
-		if (likely(ref = firehose_buffer_ring_try_grow(fbb, fbs_max_ref))) {
-			break;
-		}
-		if (ask->quarantined) {
-			__FIREHOSE_CLIENT_THROTTLED_DUE_TO_HEAVY_LOGGING__(fb, for_io,
-					NULL);
-		} else {
-			firehose_client_send_push_and_wait(fb, for_io, NULL);
-		}
-		if (unlikely(fb->fb_header.fbh_sendp[pushport] == MACH_PORT_DEAD)) {
-			// logd was unloaded, give up
-			break;
-		}
-	}
-
-	return firehose_buffer_stream_chunk_install(fb, ask, privptr, ref);
-}
-#else
-static inline dispatch_lock
-_dispatch_gate_lock_load_seq_cst(dispatch_gate_t l)
-{
-	return os_atomic_load(&l->dgl_lock, seq_cst);
-}
-OS_NOINLINE
-static void
-_dispatch_firehose_gate_wait(dispatch_gate_t l, uint32_t flags)
-{
-	(void)flags;
-	_dispatch_wait_until(_dispatch_gate_lock_load_seq_cst(l) == 0);
-}
-#endif // KERNEL
-
-firehose_tracepoint_t
-firehose_buffer_tracepoint_reserve_slow(firehose_buffer_t fb,
-		firehose_tracepoint_query_t ask, uint8_t **privptr)
-{
-	const unsigned for_io = ask->for_io;
-	const firehose_buffer_bank_t fbb = &fb->fb_header.fbh_bank;
-	firehose_bank_state_u state;
-	bool reserved;
-	firehose_chunk_ref_t ref = 0;
-
-#ifndef KERNEL
-	// before we try to allocate anything look at whether there are things logd
-	// already sent back to us
-	firehose_drain_notifications_once(fb);
-#endif // KERNEL
-
-	state.fbs_atomic_state =
-			os_atomic_load2o(fbb, fbb_state.fbs_atomic_state, relaxed);
-	reserved = firehose_buffer_bank_try_reserve_slot(fb, for_io, &state);
-
-#ifndef KERNEL
-	if (likely(reserved)) {
-		while (!ref) {
-			ref = firehose_buffer_ring_try_recycle(fb);
-			if (unlikely(!ref)) {
-				break;
-			}
-
-			if (unlikely(ref >= state.fbs_max_ref)) {
-				ref = firehose_buffer_ring_shrink(fb, ref);
-			}
-		}
-
-		if (unlikely(!ref)) {
-			ref = firehose_buffer_ring_try_grow(fbb, state.fbs_max_ref);
-		}
-	}
-
-	if (likely(ref || !ask->reliable)) {
-		if (!ref && reserved) {
-			firehose_buffer_bank_relinquish_slot(fb, for_io);
-		}
-
-		// installing `0` unlocks the allocator
-		return firehose_buffer_stream_chunk_install(fb, ask, privptr, ref);
-	} else {
-		firehose_buffer_stream_signal_waiting_for_logd(fb, ask->stream);
-
-		ask->is_bank_ok = reserved;
-		return firehose_buffer_tracepoint_reserve_wait_for_chunks_from_logd(fb,
-				ask, privptr);
-	}
-#else
-	if (likely(reserved)) {
-		ref = firehose_buffer_ring_try_recycle(fb);
-		if (unlikely(ref == 0)) {
-			// the kernel has no overlap between I/O and memory chunks, so
-			// having an available bank slot means we must be able to recycle
-			DISPATCH_INTERNAL_CRASH(0, "Unable to recycle a chunk");
-		}
-	}
-	return firehose_buffer_stream_chunk_install(fb, ask, privptr, ref);
-#endif // KERNEL
-}
-
-#ifdef KERNEL
-firehose_tracepoint_t
-__firehose_buffer_tracepoint_reserve(uint64_t stamp, firehose_stream_t stream,
-		uint16_t pubsize, uint16_t privsize, uint8_t **privptr)
-{
-	firehose_buffer_t fb = kernel_firehose_buffer;
-	if (unlikely(!fb)) {
-		return NULL;
-	}
-	return firehose_buffer_tracepoint_reserve(fb, stamp, stream, pubsize,
-			privsize, privptr, false);
-}
-
-firehose_buffer_t
-__firehose_buffer_create(size_t *size)
-{
-	if (!kernel_firehose_buffer) {
-		kernel_firehose_buffer = firehose_buffer_create(MACH_PORT_NULL, 0, 0);
-	}
-
-	if (size) {
-		*size = FIREHOSE_BUFFER_KERNEL_CHUNK_COUNT * FIREHOSE_CHUNK_SIZE;
-	}
-	return kernel_firehose_buffer;
-}
-
-void
-__firehose_buffer_tracepoint_flush(firehose_tracepoint_t ft,
-		firehose_tracepoint_id_u ftid)
-{
-	return firehose_buffer_tracepoint_flush(kernel_firehose_buffer, ft, ftid);
-}
-
-void
-__firehose_merge_updates(firehose_push_reply_t update)
-{
-	firehose_buffer_t fb = kernel_firehose_buffer;
-	if (likely(fb)) {
-		firehose_client_merge_updates(fb, true, update, false, NULL);
-	}
-}
-
-int
-__firehose_kernel_configuration_valid(uint8_t chunk_count, uint8_t io_pages)
-{
-	return (((chunk_count % 4) == 0) &&
-			(chunk_count >= FIREHOSE_BUFFER_KERNEL_MIN_CHUNK_COUNT) &&
-			(chunk_count <= FIREHOSE_BUFFER_KERNEL_MAX_CHUNK_COUNT) &&
-			(io_pages <= (chunk_count * 3 / 4)));
-}
-#endif // KERNEL
-
-#endif // OS_FIREHOSE_SPI
--- a/Telegram/ThirdParty/dispatch/src/firehose/firehose_buffer_internal.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/firehose/firehose_buffer_internal.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,260 +0,0 @@
-/*
- * Copyright (c) 2015 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#ifndef __FIREHOSE_BUFFER_INTERNAL__
-#define __FIREHOSE_BUFFER_INTERNAL__
-
-#if BYTE_ORDER != LITTLE_ENDIAN
-#error unsupported byte order
-#endif
-
-#ifndef KERNEL
-#include <os/lock_private.h>
-#endif
-
-// firehose buffer is CHUNK_COUNT * CHUNK_SIZE big == 256k
-#define FIREHOSE_BUFFER_CHUNK_COUNT					64ul
-#ifndef KERNEL
-#define FIREHOSE_BUFFER_CHUNK_PREALLOCATED_COUNT	4
-#define FIREHOSE_BUFFER_MADVISE_CHUNK_COUNT			4
-#endif
-
-#define FIREHOSE_RING_POS_GEN_INC		((uint16_t)(FIREHOSE_BUFFER_CHUNK_COUNT))
-#define FIREHOSE_RING_POS_IDX_MASK		((uint16_t)(FIREHOSE_RING_POS_GEN_INC - 1))
-#define FIREHOSE_RING_POS_GEN_MASK		((uint16_t)~FIREHOSE_RING_POS_IDX_MASK)
-
-#if __has_feature(c_static_assert)
-_Static_assert(FIREHOSE_RING_POS_IDX_MASK < 0xff,
-		"firehose chunk ref fits in its type with space for PRISTINE");
-#endif
-
-typedef uint8_t firehose_chunk_ref_t;
-
-static const unsigned long firehose_stream_uses_io_bank =
-	(1UL << firehose_stream_persist) |
-	(1UL << firehose_stream_special) |
-	(1UL << firehose_stream_signpost);
-
-typedef union {
-#define FIREHOSE_BANK_SHIFT(bank)			(16 * (bank))
-#define FIREHOSE_BANK_INC(bank)				(1ULL << FIREHOSE_BANK_SHIFT(bank))
-	uint64_t fbs_atomic_state;
-	struct {
-		union {
-			struct {
-				uint16_t fbs_mem_bank;
-				uint16_t fbs_io_bank;
-			};
-			uint16_t fbs_banks[2];
-		};
-		firehose_chunk_ref_t fbs_max_ref;
-		uint8_t fbs_unused1;
-		uint16_t fbs_unused2;
-	};
-} firehose_bank_state_u;
-
-#if __has_feature(c_static_assert)
-_Static_assert(8 * offsetof(firehose_bank_state_u, fbs_mem_bank)
-		== FIREHOSE_BANK_SHIFT(0), "mem bank shift");
-_Static_assert(8 * offsetof(firehose_bank_state_u, fbs_io_bank)
-		== FIREHOSE_BANK_SHIFT(1), "mem bank shift");
-#endif
-
-typedef struct firehose_buffer_bank_s {
-	firehose_bank_state_u volatile fbb_state;
-	uint64_t volatile fbb_metadata_bitmap;
-	uint64_t volatile fbb_mem_flushed;
-	uint64_t volatile fbb_mem_notifs;
-	uint64_t volatile fbb_mem_sync_pushes;
-	uint64_t volatile fbb_io_flushed;
-	uint64_t volatile fbb_io_notifs;
-	uint64_t volatile fbb_io_sync_pushes;
-#define FIREHOSE_BUFFER_BANK_FLAG_LOW_MEMORY	(1UL << 0)
-#define FIREHOSE_BUFFER_BANK_FLAG_HIGH_RATE		(1UL << 1)
-	unsigned long volatile fbb_flags;
-
-	uint64_t fbb_bitmap; // protected by fbb_lock
-	firehose_bank_state_u fbb_limits; // protected by fbb_lock
-#ifdef KERNEL
-	uint32_t _fbb_unused;
-#else
-	dispatch_unfair_lock_s fbb_lock;
-#endif
-} OS_ALIGNED(64) *firehose_buffer_bank_t;
-
-typedef union {
-	uint64_t fss_atomic_state;
-	dispatch_gate_s fss_gate;
-	struct {
-#define FIREHOSE_GATE_RELIABLE_WAITERS_BIT 		0x00000001UL
-#define FIREHOSE_GATE_UNRELIABLE_WAITERS_BIT 	0x00000002UL
-#define FIREHOSE_GATE_WAITERS_MASK 				0x00000003UL
-		uint32_t fss_allocator;
-#define FIREHOSE_STREAM_STATE_PRISTINE		0xff
-		firehose_chunk_ref_t fss_current;
-		uint8_t fss_loss : FIREHOSE_LOSS_COUNT_WIDTH;
-		uint8_t fss_timestamped : 1;
-		uint8_t fss_waiting_for_logd : 1;
-
-		/*
-		 * We use a generation counter to prevent a theoretical ABA problem: a
-		 * thread could try to acquire a tracepoint in a chunk, fail to do so,
-		 * mark it as to be pushed, enqueue it, and then be preempted.  It
-		 * sleeps for a long time, and then tries to acquire the allocator bit
-		 * and uninstall the chunk. Succeeds in doing so, but because the chunk
-		 * actually happened to have cycled all the way back to being installed.
-		 * That thread would effectively hide that unflushed chunk and leak it.
-		 * Having a generation counter prevents the uninstallation of the chunk
-		 * to spuriously succeed when it was a re-incarnation of it.
-		 */
-		uint16_t fss_generation;
-	};
-} firehose_stream_state_u;
-
-typedef struct firehose_buffer_stream_s {
-	firehose_stream_state_u fbs_state;
-	uint64_t fbs_loss_start; // protected by fss_gate
-} OS_ALIGNED(128) *firehose_buffer_stream_t;
-
-typedef union {
-	uint64_t frp_atomic_tail;
-	struct {
-		uint16_t frp_mem_tail;
-		uint16_t frp_mem_flushed;
-		uint16_t frp_io_tail;
-		uint16_t frp_io_flushed;
-	};
-} firehose_ring_tail_u;
-
-OS_ENUM(firehose_buffer_pushport, uint8_t,
-	FIREHOSE_BUFFER_PUSHPORT_MEM,
-	FIREHOSE_BUFFER_PUSHPORT_IO,
-	FIREHOSE_BUFFER_NPUSHPORTS,
-);
-
-/*
- * Rings are circular buffers with CHUNK_COUNT entries, with 3 important markers
- *
- * +--------+-------------------------+------------+---------------------------+
- * |xxxxxxxx|                         |............|xxxxxxxxxxxxxxxxxxxxxxxxxxx|
- * +--------+-------------------------+------------+---------------------------+
- *          ^                         ^            ^
- *        head                       tail       flushed
- *
- * A ring position is a uint16_t made of a generation (see GEN_MASK) and an
- * index (see IDX_MASK). Slots of that ring hold tagged page references. These
- * are made from a generation (see GEN_MASK) and a page reference.
- *
- * A generation is how many times the head wrapped around.
- *
- * These conditions hold:
- *   (uint16_t)(flushed - tail) < FIREHOSE_BUFFER_CHUNK_COUNT
- *   (uint16_t)(head - flushed) < FIREHOSE_BUFFER_CHUNK_COUNT
- * which really means, on the circular buffer, tail <= flushed <= head.
- *
- * Page references span from 1 to (CHUNK_COUNT - 1). 0 is an invalid page
- * (corresponds to the buffer header) and means "unused".
- *
- *
- * - Entries situated between tail and flushed hold references to pages that
- *   the firehose consumer (logd) has flushed, and can be reused.
- *
- * - Entries situated between flushed and head are references to pages waiting
- *   to be flushed.
- *
- * - Entries not situated between tail and head are either slots being modified
- *   or that should be set to Empty. Empty is the 0 page reference associated
- *   with the generation count the head will have the next time it will go over
- *   that slot.
- */
-typedef struct firehose_buffer_header_s {
-	uint16_t volatile				fbh_mem_ring[FIREHOSE_BUFFER_CHUNK_COUNT];
-	uint16_t volatile				fbh_io_ring[FIREHOSE_BUFFER_CHUNK_COUNT];
-
-	firehose_ring_tail_u volatile	fbh_ring_tail OS_ALIGNED(64);
-	uint32_t						fbh_spi_version;
-	uint16_t volatile				fbh_ring_mem_head OS_ALIGNED(64);
-	uint16_t volatile				fbh_ring_io_head OS_ALIGNED(64);
-	struct firehose_buffer_bank_s	fbh_bank;
-	struct firehose_buffer_stream_s fbh_stream[_firehose_stream_max];
-
-	uint64_t						fbh_uniquepid;
-	pid_t							fbh_pid;
-	mach_port_t						fbh_logd_port;
-	mach_port_t volatile			fbh_sendp[FIREHOSE_BUFFER_NPUSHPORTS];
-	mach_port_t						fbh_recvp;
-
-	// past that point fields may be aligned differently between 32 and 64bits
-#ifndef KERNEL
-	dispatch_unfair_lock_s			fbh_logd_lock;
-#define FBH_QUARANTINE_NONE		0
-#define FBH_QUARANTINE_PENDING	1
-#define FBH_QUARANTINE_STARTED	2
-	uint8_t volatile				fbh_quarantined_state;
-	bool							fbh_quarantined;
-#endif
-	uint64_t						fbh_unused[0];
-} OS_ALIGNED(FIREHOSE_CHUNK_SIZE) *firehose_buffer_header_t;
-
-union firehose_buffer_u {
-	struct firehose_buffer_header_s fb_header;
-	struct firehose_chunk_s fb_chunks[FIREHOSE_BUFFER_CHUNK_COUNT];
-};
-
-// used to let the compiler pack these values in 1 or 2 registers
-typedef struct firehose_tracepoint_query_s {
-	uint64_t stamp;
-	uint16_t pubsize;
-	uint16_t privsize;
-	firehose_stream_t stream;
-	bool	 is_bank_ok;
-	bool	 for_io : 1;
-	bool	 quarantined : 1;
-	bool	 reliable : 1;
-} *firehose_tracepoint_query_t;
-
-#ifndef FIREHOSE_SERVER
-
-firehose_buffer_t
-firehose_buffer_create(mach_port_t logd_port, uint64_t unique_pid,
-		unsigned long bank_flags);
-
-firehose_tracepoint_t
-firehose_buffer_tracepoint_reserve_slow(firehose_buffer_t fb,
-		firehose_tracepoint_query_t ask, uint8_t **privptr);
-
-void *
-firehose_buffer_get_logging_prefs(firehose_buffer_t fb, size_t *size);
-
-bool
-firehose_buffer_should_send_strings(firehose_buffer_t fb);
-
-void
-firehose_buffer_update_limits(firehose_buffer_t fb);
-
-void
-firehose_buffer_ring_enqueue(firehose_buffer_t fb, firehose_chunk_ref_t ref);
-
-void
-firehose_buffer_force_connect(firehose_buffer_t fb);
-
-#endif
-
-#endif // __FIREHOSE_BUFFER_INTERNAL__
--- a/Telegram/ThirdParty/dispatch/src/firehose/firehose.defs	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/firehose/firehose.defs	1970-01-01 00:00:00.000000000 -0000
@@ -1,66 +0,0 @@
-/*
- * Copyright (c) 2015 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include <mach/std_types.defs>
-#include <mach/mach_types.defs>
-
-#include "firehose_types.defs"
-
-subsystem firehose  11600;
-serverprefix        firehose_server_;
-userprefix          firehose_send_;
-
-UseSpecialReplyPort 1;
-
-simpleroutine register(
-            server_port     : mach_port_t;
-            mem_port        : mach_port_move_send_t;
-            mem_size        : mach_vm_size_t;
-            comm_mem_recvp  : mach_port_move_receive_t;
-            comm_io_recvp   : mach_port_move_receive_t;
-            comm_sendp      : mach_port_make_send_t;
-            extra_info_port : mach_port_move_send_t;
-            extra_info_size : mach_vm_size_t;
-            ServerAuditToken atoken : audit_token_t
-);
-
-routine push_and_wait(
-RequestPort comm_port       : mach_port_t;
-SReplyPort  reply_port      : mach_port_make_send_once_t;
-out         push_reply      : firehose_push_reply_t;
-out         quarantinedOut  : boolean_t
-);
-
-simpleroutine push_async(
-RequestPort comm_port       : mach_port_t;
-in          qos_class       : qos_class_t;
-WaitTime    timeout         : natural_t
-);
-
-routine get_logging_prefs(
-RequestPort server_port     : mach_port_t;
-out         mem_port        : mach_port_t;
-out         mem_size        : mach_vm_size_t
-);
-
-routine should_send_strings(
-RequestPort server_port     : mach_port_t;
-out         strings_needed  : boolean_t
-);
--- a/Telegram/ThirdParty/dispatch/src/firehose/firehose_inline_internal.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/firehose/firehose_inline_internal.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,542 +0,0 @@
-/*
- * Copyright (c) 2015 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#ifndef __FIREHOSE_INLINE_INTERNAL__
-#define __FIREHOSE_INLINE_INTERNAL__
-
-#ifndef _os_atomic_basetypeof
-#define _os_atomic_basetypeof(p) \
-		__typeof__(atomic_load_explicit(_os_atomic_c11_atomic(p), memory_order_relaxed))
-#endif
-
-#define firehose_atomic_maxv2o(p, f, v, o, m) \
-		os_atomic_rmw_loop2o(p, f, *(o), (v), m, { \
-			if (*(o) >= (v)) os_atomic_rmw_loop_give_up(break); \
-		})
-
-#define firehose_atomic_max2o(p, f, v, m)   ({ \
-		_os_atomic_basetypeof(&(p)->f) _old; \
-		firehose_atomic_maxv2o(p, f, v, &_old, m); \
-	})
-
-#ifndef KERNEL
-// caller must test for non zero first
-OS_ALWAYS_INLINE
-static inline firehose_chunk_ref_t
-firehose_bitmap_first_set(uint64_t bitmap)
-{
-	dispatch_assert(bitmap != 0);
-	// this builtin returns 0 if bitmap is 0, or (first bit set + 1)
-	return (firehose_chunk_ref_t)__builtin_ffsll((long long)bitmap) - 1;
-}
-#endif
-
-#pragma mark -
-#pragma mark Mach Misc.
-#ifndef KERNEL
-
-OS_ALWAYS_INLINE
-static inline mach_port_t
-firehose_mach_port_allocate(uint32_t flags, mach_port_msgcount_t qlimit,
-		void *ctx)
-{
-	mach_port_t port = MACH_PORT_NULL;
-	mach_port_options_t opts = {
-		.flags = flags | MPO_QLIMIT,
-		.mpl = { .mpl_qlimit = qlimit },
-	};
-	kern_return_t kr = mach_port_construct(mach_task_self(), &opts,
-			(mach_port_context_t)ctx, &port);
-	if (unlikely(kr)) {
-		DISPATCH_VERIFY_MIG(kr);
-		DISPATCH_CLIENT_CRASH(kr, "Unable to allocate mach port");
-	}
-	return port;
-}
-
-OS_ALWAYS_INLINE
-static inline kern_return_t
-firehose_mach_port_recv_dispose(mach_port_t port, void *ctx)
-{
-	kern_return_t kr;
-	kr = mach_port_destruct(mach_task_self(), port, 0,
-			(mach_port_context_t)ctx);
-	DISPATCH_VERIFY_MIG(kr);
-	return kr;
-}
-
-OS_ALWAYS_INLINE
-static inline void
-firehose_mach_port_send_release(mach_port_t port)
-{
-	kern_return_t kr = mach_port_deallocate(mach_task_self(), port);
-	DISPATCH_VERIFY_MIG(kr);
-	dispatch_assume_zero(kr);
-}
-
-OS_ALWAYS_INLINE
-static inline void
-firehose_mach_port_guard(mach_port_t port, bool strict, void *ctx)
-{
-	kern_return_t kr = mach_port_guard(mach_task_self(), port,
-			(mach_port_context_t)ctx, strict);
-	DISPATCH_VERIFY_MIG(kr);
-	dispatch_assume_zero(kr);
-}
-
-OS_ALWAYS_INLINE
-static inline void
-firehose_mig_server(dispatch_mig_callback_t demux, size_t maxmsgsz,
-		mach_msg_header_t *hdr)
-{
-	mig_reply_error_t *msg_reply = (mig_reply_error_t *)alloca(maxmsgsz);
-	kern_return_t rc = KERN_SUCCESS;
-	bool expects_reply = false;
-
-	if (MACH_MSGH_BITS_REMOTE(hdr->msgh_bits) == MACH_MSG_TYPE_MOVE_SEND_ONCE) {
-		expects_reply = true;
-	}
-
-	msg_reply->Head = (mach_msg_header_t){ };
-	if (unlikely(!demux(hdr, &msg_reply->Head))) {
-		rc = MIG_BAD_ID;
-	} else if (msg_reply->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) {
-		rc = KERN_SUCCESS;
-	} else {
-		// if MACH_MSGH_BITS_COMPLEX is _not_ set, then msg_reply->RetCode
-		// is present
-		rc = msg_reply->RetCode;
-	}
-
-	if (unlikely(rc == KERN_SUCCESS && expects_reply)) {
-		// if crashing here, some handler returned KERN_SUCCESS
-		// hoping for firehose_mig_server to perform the mach_msg()
-		// call to reply, and it doesn't know how to do that
-		DISPATCH_INTERNAL_CRASH(msg_reply->Head.msgh_id,
-				"firehose_mig_server doesn't handle replies");
-	}
-	if (unlikely(rc != KERN_SUCCESS && rc != MIG_NO_REPLY)) {
-		// destroy the request - but not the reply port
-		hdr->msgh_remote_port = 0;
-		mach_msg_destroy(hdr);
-	}
-}
-
-#endif // !KERNEL
-#pragma mark -
-#pragma mark firehose buffer
-
-OS_ALWAYS_INLINE
-static inline firehose_chunk_t
-firehose_buffer_chunk_for_address(void *addr)
-{
-	uintptr_t chunk_addr = (uintptr_t)addr & ~(FIREHOSE_CHUNK_SIZE - 1);
-	return (firehose_chunk_t)chunk_addr;
-}
-
-OS_ALWAYS_INLINE
-static inline firehose_chunk_ref_t
-firehose_buffer_chunk_to_ref(firehose_buffer_t fb, firehose_chunk_t fbc)
-{
-	return (firehose_chunk_ref_t)(fbc - fb->fb_chunks);
-}
-
-OS_ALWAYS_INLINE
-static inline firehose_chunk_t
-firehose_buffer_ref_to_chunk(firehose_buffer_t fb, firehose_chunk_ref_t ref)
-{
-	return fb->fb_chunks + ref;
-}
-
-#ifndef FIREHOSE_SERVER
-#if DISPATCH_PURE_C
-
-OS_ALWAYS_INLINE
-static inline void
-firehose_buffer_stream_flush(firehose_buffer_t fb, firehose_stream_t stream)
-{
-	firehose_buffer_stream_t fbs = &fb->fb_header.fbh_stream[stream];
-	firehose_stream_state_u old_state, new_state;
-	firehose_chunk_t fc;
-	uint64_t stamp = UINT64_MAX; // will cause the reservation to fail
-	firehose_chunk_ref_t ref;
-	long result;
-
-	old_state.fss_atomic_state =
-			os_atomic_load2o(fbs, fbs_state.fss_atomic_state, relaxed);
-	ref = old_state.fss_current;
-	if (!ref || ref == FIREHOSE_STREAM_STATE_PRISTINE) {
-		// there is no installed page, nothing to flush, go away
-#ifndef KERNEL
-		firehose_buffer_force_connect(fb);
-#endif
-		return;
-	}
-
-	fc = firehose_buffer_ref_to_chunk(fb, old_state.fss_current);
-	result = firehose_chunk_tracepoint_try_reserve(fc, stamp, stream,
-			0, 1, 0, NULL);
-	if (likely(result < 0)) {
-		firehose_buffer_ring_enqueue(fb, old_state.fss_current);
-	}
-	if (unlikely(result > 0)) {
-		// because we pass a silly stamp that requires a flush
-		DISPATCH_INTERNAL_CRASH(result, "Allocation should always fail");
-	}
-
-	// as a best effort try to uninstall the page we just flushed
-	// but failing is okay, let's not contend stupidly for something
-	// allocators know how to handle in the first place
-	new_state = old_state;
-	new_state.fss_current = 0;
-	(void)os_atomic_cmpxchg2o(fbs, fbs_state.fss_atomic_state,
-			old_state.fss_atomic_state, new_state.fss_atomic_state, relaxed);
-}
-
-/**
- * @function firehose_buffer_tracepoint_reserve
- *
- * @abstract
- * Reserves space in the firehose buffer for the tracepoint with specified
- * characteristics.
- *
- * @discussion
- * This returns a slot, with the length of the tracepoint already set, so
- * that in case of a crash, we maximize our chance to be able to skip the
- * tracepoint in case of a partial write.
- *
- * Once the tracepoint has been written, firehose_buffer_tracepoint_flush()
- * must be called.
- *
- * @param fb
- * The buffer to allocate from.
- *
- * @param stream
- * The buffer stream to use.
- *
- * @param pubsize
- * The size of the public data for this tracepoint, cannot be 0, doesn't
- * take the size of the tracepoint header into account.
- *
- * @param privsize
- * The size of the private data for this tracepoint, can be 0.
- *
- * @param privptr
- * The pointer to the private buffer, can be NULL
- *
- * @param reliable
- * Whether we should wait for logd or drop the tracepoint in the event that no
- * chunk is available.
- *
- * @result
- * The pointer to the tracepoint.
- */
-OS_ALWAYS_INLINE
-static inline firehose_tracepoint_t
-firehose_buffer_tracepoint_reserve(firehose_buffer_t fb, uint64_t stamp,
-		firehose_stream_t stream, uint16_t pubsize,
-		uint16_t privsize, uint8_t **privptr, bool reliable)
-{
-	firehose_buffer_stream_t fbs = &fb->fb_header.fbh_stream[stream];
-	firehose_stream_state_u old_state, new_state;
-	firehose_chunk_t fc;
-	bool waited = false;
-	bool success;
-	long result;
-	firehose_chunk_ref_t ref;
-
-	// cannot use os_atomic_rmw_loop2o, _page_try_reserve does a store
-	old_state.fss_atomic_state =
-			os_atomic_load2o(fbs, fbs_state.fss_atomic_state, relaxed);
-	for (;;) {
-		new_state = old_state;
-
-		ref = old_state.fss_current;
-		if (likely(ref && ref != FIREHOSE_STREAM_STATE_PRISTINE)) {
-			fc = firehose_buffer_ref_to_chunk(fb, ref);
-			result = firehose_chunk_tracepoint_try_reserve(fc, stamp, stream,
-					0, pubsize, privsize, privptr);
-			if (likely(result > 0)) {
-				uint64_t thread;
-#if KERNEL
-				thread = thread_tid(current_thread());
-#else
-				thread = _pthread_threadid_self_np_direct();
-#endif
-				return firehose_chunk_tracepoint_begin(fc,
-						stamp, pubsize, thread, result);
-			}
-			if (likely(result < 0)) {
-				firehose_buffer_ring_enqueue(fb, old_state.fss_current);
-			}
-			new_state.fss_current = 0;
-		}
-
-		if (!reliable && ((waited && old_state.fss_timestamped)
-#ifndef KERNEL
-				|| old_state.fss_waiting_for_logd
-#endif
-			)) {
-			new_state.fss_loss =
-					MIN(old_state.fss_loss + 1, FIREHOSE_LOSS_COUNT_MAX);
-
-			success = os_atomic_cmpxchgv2o(fbs, fbs_state.fss_atomic_state,
-					old_state.fss_atomic_state, new_state.fss_atomic_state,
-					&old_state.fss_atomic_state, relaxed);
-			if (success) {
-#ifndef KERNEL
-				_dispatch_trace_firehose_reserver_gave_up(stream, ref, waited,
-						old_state.fss_atomic_state, new_state.fss_atomic_state);
-#endif
-				return NULL;
-			} else {
-				continue;
-			}
-		}
-
-		if (unlikely(old_state.fss_allocator)) {
-#if KERNEL
-			_dispatch_firehose_gate_wait(&fbs->fbs_state.fss_gate,
-					DLOCK_LOCK_DATA_CONTENTION);
-			waited = true;
-
-			old_state.fss_atomic_state =
-					os_atomic_load2o(fbs, fbs_state.fss_atomic_state, relaxed);
-#else
-			if (likely(reliable)) {
-				new_state.fss_allocator |= FIREHOSE_GATE_RELIABLE_WAITERS_BIT;
-			} else {
-				new_state.fss_allocator |= FIREHOSE_GATE_UNRELIABLE_WAITERS_BIT;
-			}
-
-			bool already_equal = (new_state.fss_atomic_state ==
-					old_state.fss_atomic_state);
-			success = already_equal || os_atomic_cmpxchgv2o(fbs,
-					fbs_state.fss_atomic_state, old_state.fss_atomic_state,
-					new_state.fss_atomic_state, &old_state.fss_atomic_state,
-					relaxed);
-			if (success) {
-				_dispatch_trace_firehose_reserver_wait(stream, ref, waited,
-						old_state.fss_atomic_state, new_state.fss_atomic_state,
-						reliable);
-				_dispatch_firehose_gate_wait(&fbs->fbs_state.fss_gate,
-						new_state.fss_allocator,
-						DLOCK_LOCK_DATA_CONTENTION);
-				waited = true;
-
-				old_state.fss_atomic_state = os_atomic_load2o(fbs,
-						fbs_state.fss_atomic_state, relaxed);
-			}
-#endif
-			continue;
-		}
-
-		// if the thread doing the allocation is of low priority we may starve
-		// threads of higher priority, so disable pre-emption before becoming
-		// the allocator (it is re-enabled in
-		// firehose_buffer_stream_chunk_install())
-		__firehose_critical_region_enter();
-#if KERNEL
-		new_state.fss_allocator = (uint32_t)cpu_number();
-#else
-		new_state.fss_allocator = _dispatch_lock_value_for_self();
-#endif
-		success = os_atomic_cmpxchgv2o(fbs, fbs_state.fss_atomic_state,
-				old_state.fss_atomic_state, new_state.fss_atomic_state,
-				&old_state.fss_atomic_state, relaxed);
-		if (likely(success)) {
-			break;
-		}
-		__firehose_critical_region_leave();
-	}
-
-	struct firehose_tracepoint_query_s ask = {
-		.stamp = stamp,
-		.pubsize = pubsize,
-		.privsize = privsize,
-		.stream = stream,
-		.for_io = (firehose_stream_uses_io_bank & (1UL << stream)) != 0,
-#ifndef KERNEL
-		.quarantined = fb->fb_header.fbh_quarantined,
-#endif
-		.reliable = reliable,
-	};
-
-#ifndef KERNEL
-	_dispatch_trace_firehose_allocator(((uint64_t *)&ask)[0],
-			((uint64_t *)&ask)[1], old_state.fss_atomic_state,
-			new_state.fss_atomic_state);
-#endif
-
-	return firehose_buffer_tracepoint_reserve_slow(fb, &ask, privptr);
-}
-
-/**
- * @function firehose_buffer_tracepoint_flush
- *
- * @abstract
- * Flushes a firehose tracepoint, and sends the chunk to the daemon when full
- * and this was the last tracepoint writer for this chunk.
- *
- * @param fb
- * The buffer the tracepoint belongs to.
- *
- * @param ft
- * The tracepoint to flush.
- *
- * @param ftid
- * The firehose tracepoint ID for that tracepoint.
- * It is written last, preventing compiler reordering, so that its absence
- * on crash recovery means the tracepoint is partial.
- */
-OS_ALWAYS_INLINE
-static inline void
-firehose_buffer_tracepoint_flush(firehose_buffer_t fb,
-		firehose_tracepoint_t ft, firehose_tracepoint_id_u ftid)
-{
-	firehose_chunk_t fc = firehose_buffer_chunk_for_address(ft);
-
-	// Needed for process death handling (tracepoint-flush):
-	// We want to make sure the observers
-	// will see memory effects in program (asm) order.
-	// 1. write all the data to the tracepoint
-	// 2. write the tracepoint ID, so that seeing it means the tracepoint
-	//    is valid
-	if (firehose_chunk_tracepoint_end(fc, ft, ftid)) {
-		firehose_buffer_ring_enqueue(fb, firehose_buffer_chunk_to_ref(fb, fc));
-	}
-}
-
-OS_ALWAYS_INLINE
-static inline bool
-firehose_buffer_bank_try_reserve_slot(firehose_buffer_t fb, bool for_io,
-		firehose_bank_state_u *state_in_out)
-{
-	bool success;
-	firehose_buffer_bank_t fbb = &fb->fb_header.fbh_bank;
-
-	firehose_bank_state_u old_state = *state_in_out, new_state;
-	do {
-		if (unlikely(!old_state.fbs_banks[for_io])) {
-			return false;
-		}
-		new_state = old_state;
-		new_state.fbs_banks[for_io]--;
-
-		success = os_atomic_cmpxchgvw(&fbb->fbb_state.fbs_atomic_state,
-				old_state.fbs_atomic_state, new_state.fbs_atomic_state,
-				&old_state.fbs_atomic_state, acquire);
-	} while (unlikely(!success));
-
-	*state_in_out = new_state;
-	return true;
-}
-
-#ifndef KERNEL
-OS_ALWAYS_INLINE
-static inline void
-firehose_buffer_stream_signal_waiting_for_logd(firehose_buffer_t fb,
-		firehose_stream_t stream)
-{
-	firehose_stream_state_u state, new_state;
-	firehose_buffer_stream_t fbs = &fb->fb_header.fbh_stream[stream];
-
-	state.fss_atomic_state =
-			os_atomic_load2o(fbs, fbs_state.fss_atomic_state, relaxed);
-	if (!state.fss_timestamped) {
-		fbs->fbs_loss_start = mach_continuous_time();
-
-		// release to publish the timestamp
-		os_atomic_rmw_loop2o(fbs, fbs_state.fss_atomic_state,
-				state.fss_atomic_state, new_state.fss_atomic_state,
-				release, {
-			new_state = (firehose_stream_state_u){
-				.fss_allocator = (state.fss_allocator &
-						~FIREHOSE_GATE_UNRELIABLE_WAITERS_BIT),
-				.fss_loss = state.fss_loss,
-				.fss_timestamped = true,
-				.fss_waiting_for_logd = true,
-				.fss_generation = state.fss_generation,
-			};
-		});
-	} else {
-		os_atomic_rmw_loop2o(fbs, fbs_state.fss_atomic_state,
-				state.fss_atomic_state, new_state.fss_atomic_state,
-				relaxed, {
-			new_state = (firehose_stream_state_u){
-				.fss_allocator = (state.fss_allocator &
-						~FIREHOSE_GATE_UNRELIABLE_WAITERS_BIT),
-				.fss_loss = state.fss_loss,
-				.fss_timestamped = true,
-				.fss_waiting_for_logd = true,
-				.fss_generation = state.fss_generation,
-			};
-		});
-	}
-
-	_dispatch_trace_firehose_wait_for_logd(stream, fbs->fbs_loss_start,
-			state.fss_atomic_state, new_state.fss_atomic_state);
-	if (unlikely(state.fss_allocator & FIREHOSE_GATE_UNRELIABLE_WAITERS_BIT)) {
-		_dispatch_gate_broadcast_slow(&fbs->fbs_state.fss_gate,
-				state.fss_gate.dgl_lock);
-	}
-}
-
-OS_ALWAYS_INLINE
-static inline void
-firehose_buffer_clear_bank_flags(firehose_buffer_t fb, unsigned long bits)
-{
-	firehose_buffer_bank_t fbb = &fb->fb_header.fbh_bank;
-	unsigned long orig_flags;
-
-	orig_flags = os_atomic_and_orig2o(fbb, fbb_flags, ~bits, relaxed);
-	if (orig_flags != (orig_flags & ~bits)) {
-		firehose_buffer_update_limits(fb);
-	}
-}
-
-OS_ALWAYS_INLINE
-static inline void
-firehose_buffer_set_bank_flags(firehose_buffer_t fb, unsigned long bits)
-{
-	firehose_buffer_bank_t fbb = &fb->fb_header.fbh_bank;
-	unsigned long orig_flags;
-
-	orig_flags = os_atomic_or_orig2o(fbb, fbb_flags, bits, relaxed);
-	if (orig_flags != (orig_flags | bits)) {
-		firehose_buffer_update_limits(fb);
-	}
-}
-
-OS_ALWAYS_INLINE
-static inline void
-firehose_buffer_bank_relinquish_slot(firehose_buffer_t fb, bool for_io)
-{
-	firehose_buffer_bank_t fbb = &fb->fb_header.fbh_bank;
-	os_atomic_add2o(fbb, fbb_state.fbs_atomic_state, FIREHOSE_BANK_INC(for_io),
-			relaxed);
-}
-#endif // !KERNEL
-
-#endif // !defined(FIREHOSE_SERVER)
-
-#endif // DISPATCH_PURE_C
-
-#endif // __FIREHOSE_INLINE_INTERNAL__
--- a/Telegram/ThirdParty/dispatch/src/firehose/firehose_internal.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/firehose/firehose_internal.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,53 +0,0 @@
-/*
- * Copyright (c) 2015 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#ifndef __FIREHOSE_INTERNAL__
-#define __FIREHOSE_INTERNAL__
-
-#if OS_FIREHOSE_SPI
-
-// make sure this is defined so that we get MIG_SERVER_DIED when a send once
-// notification is sent back because of a crashed server
-#ifndef __MigTypeCheck
-#define __MigTypeCheck 1
-#endif
-
-#define fcp_quarntined fcp_quarantined
-
-#include <limits.h>
-#include <machine/endian.h>
-#include <mach/mach_types.h>
-#include <mach/std_types.h>
-#include <os/object.h>
-#include <firehose/private.h>
-#include <mach/mach_types.h>
-#include <mach/std_types.h>
-#include <sys/qos.h>
-
-#include "os/firehose_server_private.h"
-#include "firehose_buffer_internal.h"
-#ifdef FIREHOSE_SERVER
-#include "firehose_server_internal.h"
-#endif
-#include "firehose_inline_internal.h"
-
-#endif // OS_FIREHOSE_SPI
-
-#endif // __FIREHOSE_INTERNAL__
--- a/Telegram/ThirdParty/dispatch/src/firehose/firehose_reply.defs	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/firehose/firehose_reply.defs	1970-01-01 00:00:00.000000000 -0000
@@ -1,49 +0,0 @@
-/*
- * Copyright (c) 2015 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include <mach/std_types.defs>
-#include <mach/mach_types.defs>
-
-#include "firehose_types.defs"
-
-subsystem firehoseReply 11700;
-
-serverprefix firehose_client_;
-userprefix firehose_send_;
-
-skip; // firehose_register
-
-simpleroutine push_reply(
-RequestPort req_port        : mach_port_move_send_once_t;
-in          ReturnCode      : kern_return_t;
-in          push_reply      : firehose_push_reply_t;
-in          quarantined     : boolean_t
-);
-
-simpleroutine push_notify_async(
-RequestPort comm_port       : mach_port_t;
-in          push_reply      : firehose_push_reply_t;
-in          quarantined     : boolean_t;
-WaitTime    timeout         : natural_t
-);
-
-skip; // get_logging_prefs_reply
-
-skip; // should_send_strings
--- a/Telegram/ThirdParty/dispatch/src/firehose/firehose_server.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/firehose/firehose_server.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,1468 +0,0 @@
-/*
- * Copyright (c) 2015 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include <servers/bootstrap.h>
-#include <sys/ioctl.h>
-#include <sys/ttycom.h>
-#include <sys/uio.h>
-#include "internal.h"
-#include "firehoseServer.h" // MiG
-#include "firehose_reply.h" // MiG
-
-#if __has_feature(c_static_assert)
-_Static_assert(offsetof(struct firehose_client_s, fc_mem_sent_flushed_pos)
-		% 8 == 0, "Make sure atomic fields are properly aligned");
-#endif
-
-typedef struct fs_client_queue_s {
-	struct firehose_client_s *volatile fs_client_head;
-	struct firehose_client_s *volatile fs_client_tail;
-} fs_client_queue_s, *fs_client_queue_t;
-
-static struct firehose_server_s {
-	mach_port_t			fs_bootstrap_port;
-	dispatch_mach_t		fs_mach_channel;
-	dispatch_queue_t	fs_snapshot_gate_queue;
-	dispatch_queue_t	fs_io_drain_queue;
-	dispatch_queue_t	fs_mem_drain_queue;
-	firehose_handler_t	fs_handler;
-
-	firehose_snapshot_t fs_snapshot;
-	firehose_client_t	fs_kernel_client;
-	int					fs_kernel_fd;
-
-	mach_port_t         fs_prefs_cache_entry;
-	size_t              fs_prefs_cache_size;
-	void               *fs_prefs_cache;
-
-	TAILQ_HEAD(, firehose_client_s) fs_clients;
-	os_unfair_lock      fs_clients_lock;
-	fs_client_queue_s	fs_queues[4];
-	dispatch_source_t	fs_sources[4];
-} server_config = {
-	.fs_clients = TAILQ_HEAD_INITIALIZER(server_config.fs_clients),
-	.fs_clients_lock = OS_UNFAIR_LOCK_INIT,
-	.fs_kernel_fd = -1,
-};
-
-OS_ALWAYS_INLINE
-static inline void
-fs_clients_lock(void)
-{
-	os_unfair_lock_lock_with_options(&server_config.fs_clients_lock,
-			OS_UNFAIR_LOCK_DATA_SYNCHRONIZATION);
-}
-
-OS_ALWAYS_INLINE
-static inline void
-fs_clients_unlock(void)
-{
-	os_unfair_lock_unlock(&server_config.fs_clients_lock);
-}
-
-static void firehose_client_cancel(firehose_client_t fc);
-static void firehose_client_snapshot_finish(firehose_client_t fc,
-		firehose_snapshot_t snapshot, bool for_io);
-static void firehose_client_handle_death(void *ctxt);
-
-static const struct mig_subsystem *const firehose_subsystems[] = {
-	(mig_subsystem_t)&firehose_server_firehose_subsystem,
-};
-
-#pragma mark -
-#pragma mark firehose client enqueueing
-
-OS_ALWAYS_INLINE
-static inline bool
-fs_idx_is_for_io(size_t idx)
-{
-	return idx & 1;
-}
-
-OS_ALWAYS_INLINE
-static inline bool
-fs_queue_is_for_io(fs_client_queue_t q)
-{
-	return (q - server_config.fs_queues) & 1;
-}
-
-OS_ALWAYS_INLINE
-static inline bool
-fs_queue_is_for_quarantined(fs_client_queue_t q)
-{
-	return (q - server_config.fs_queues) & 2;
-}
-
-OS_ALWAYS_INLINE
-static inline fs_client_queue_t
-fs_queue(bool quarantined, bool for_io)
-{
-	return &server_config.fs_queues[quarantined * 2 + for_io];
-}
-
-OS_ALWAYS_INLINE
-static inline dispatch_source_t
-fs_source(bool quarantined, bool for_io)
-{
-	return server_config.fs_sources[quarantined * 2 + for_io];
-}
-
-OS_ALWAYS_INLINE
-static inline void
-firehose_client_push(firehose_client_t fc, bool quarantined, bool for_io)
-{
-	fs_client_queue_t queue = fs_queue(quarantined, for_io);
-	if (fc && os_mpsc_push_item(os_mpsc(queue, fs_client),
-			fc, fc_next[for_io])) {
-		dispatch_source_merge_data(fs_source(quarantined, for_io), 1);
-	}
-}
-
-OS_ALWAYS_INLINE
-static inline bool
-firehose_client_wakeup(firehose_client_t fc, bool for_io)
-{
-	uint16_t canceled_bit = FC_STATE_CANCELED(for_io);
-	uint16_t enqueued_bit = FC_STATE_ENQUEUED(for_io);
-	uint16_t old_state, new_state;
-
-	os_atomic_rmw_loop(&fc->fc_state, old_state, new_state, relaxed, {
-		if (old_state & canceled_bit) {
-			os_atomic_rmw_loop_give_up(return false);
-		}
-		if (old_state & enqueued_bit) {
-			os_atomic_rmw_loop_give_up(break);
-		}
-		new_state = old_state | enqueued_bit;
-	});
-	firehose_client_push(old_state & enqueued_bit ? NULL : fc,
-			fc->fc_quarantined, for_io);
-	return true;
-}
-
-OS_ALWAYS_INLINE
-static inline void
-firehose_client_start_cancel(firehose_client_t fc, bool for_io)
-{
-	uint16_t canceling_bit = FC_STATE_CANCELING(for_io);
-	uint16_t canceled_bit = FC_STATE_CANCELED(for_io);
-	uint16_t enqueued_bit = FC_STATE_ENQUEUED(for_io);
-	uint16_t old_state, new_state;
-
-	os_atomic_rmw_loop(&fc->fc_state, old_state, new_state, relaxed, {
-		if (old_state & (canceled_bit | canceling_bit)) {
-			os_atomic_rmw_loop_give_up(return);
-		}
-		new_state = old_state | enqueued_bit | canceling_bit;
-	});
-	firehose_client_push(old_state & enqueued_bit ? NULL : fc,
-			fc->fc_quarantined, for_io);
-}
-
-OS_ALWAYS_INLINE
-static inline bool
-firehose_client_dequeue(firehose_client_t fc, bool for_io)
-{
-	uint16_t canceling_bit = FC_STATE_CANCELING(for_io);
-	uint16_t canceled_bit = FC_STATE_CANCELED(for_io);
-	uint16_t enqueued_bit = FC_STATE_ENQUEUED(for_io);
-	uint16_t old_state, new_state;
-
-	os_atomic_rmw_loop(&fc->fc_state, old_state, new_state, relaxed, {
-		new_state = old_state & ~(canceling_bit | enqueued_bit);
-		if (old_state & canceling_bit) {
-			new_state |= canceled_bit;
-		}
-	});
-
-	if (((old_state ^ new_state) & FC_STATE_CANCELED_MASK) &&
-			(new_state & FC_STATE_CANCELED_MASK) == FC_STATE_CANCELED_MASK) {
-		dispatch_async_f(server_config.fs_io_drain_queue, fc,
-				firehose_client_handle_death);
-	}
-	return !(new_state & canceled_bit);
-}
-
-#pragma mark -
-#pragma mark firehose client state machine
-
-static void
-firehose_client_notify(firehose_client_t fc, mach_port_t reply_port)
-{
-	firehose_push_reply_t push_reply = {
-		.fpr_mem_flushed_pos = os_atomic_load2o(fc, fc_mem_flushed_pos,relaxed),
-		.fpr_io_flushed_pos = os_atomic_load2o(fc, fc_io_flushed_pos, relaxed),
-	};
-	kern_return_t kr;
-
-	firehose_atomic_max2o(fc, fc_mem_sent_flushed_pos,
-			push_reply.fpr_mem_flushed_pos, relaxed);
-	firehose_atomic_max2o(fc, fc_io_sent_flushed_pos,
-			push_reply.fpr_io_flushed_pos, relaxed);
-
-	if (!fc->fc_pid) {
-		if (ioctl(server_config.fs_kernel_fd, LOGFLUSHED, &push_reply) < 0) {
-			dispatch_assume_zero(errno);
-		}
-	} else {
-		if (reply_port == fc->fc_sendp) {
-			kr = firehose_send_push_notify_async(reply_port, push_reply,
-					fc->fc_quarantined, 0);
-		} else {
-			kr = firehose_send_push_reply(reply_port, KERN_SUCCESS, push_reply,
-					fc->fc_quarantined);
-		}
-		if (kr != MACH_SEND_INVALID_DEST) {
-			DISPATCH_VERIFY_MIG(kr);
-			dispatch_assume_zero(kr);
-		}
-	}
-}
-
-OS_ALWAYS_INLINE
-static inline uint16_t
-firehose_client_acquire_head(firehose_buffer_t fb, bool for_io)
-{
-	uint16_t head;
-	if (for_io) {
-		head = os_atomic_load2o(&fb->fb_header, fbh_ring_io_head, acquire);
-	} else {
-		head = os_atomic_load2o(&fb->fb_header, fbh_ring_mem_head, acquire);
-	}
-	return head;
-}
-
-OS_NOINLINE OS_COLD
-static void
-firehose_client_mark_corrupted(firehose_client_t fc, mach_port_t reply_port)
-{
-	// this client is really confused, do *not* answer to asyncs anymore
-	fc->fc_memory_corrupted = true;
-
-	// XXX: do not cancel the data sources or a corrupted client could
-	// prevent snapshots from being taken if unlucky with ordering
-
-	if (reply_port) {
-		kern_return_t kr = firehose_send_push_reply(reply_port, 0,
-				FIREHOSE_PUSH_REPLY_CORRUPTED, false);
-		DISPATCH_VERIFY_MIG(kr);
-		dispatch_assume_zero(kr);
-	}
-}
-
-OS_ALWAYS_INLINE
-static inline void
-firehose_client_snapshot_mark_done(firehose_client_t fc,
-		firehose_snapshot_t snapshot, bool for_io)
-{
-	if (for_io) {
-		fc->fc_needs_io_snapshot = false;
-	} else {
-		fc->fc_needs_mem_snapshot = false;
-	}
-	dispatch_group_leave(snapshot->fs_group);
-}
-
-#define DRAIN_BATCH_SIZE  4
-#define FIREHOSE_DRAIN_FOR_IO 0x1
-#define FIREHOSE_DRAIN_POLL 0x2
-
-OS_NOINLINE
-static void
-firehose_client_drain_one(firehose_client_t fc, mach_port_t port, uint32_t flags)
-{
-	firehose_buffer_t fb = fc->fc_buffer;
-	firehose_chunk_t fbc;
-	firehose_event_t evt;
-	uint16_t volatile *fbh_ring;
-	uint16_t flushed, count = 0;
-	firehose_chunk_ref_t ref;
-	uint16_t client_head, client_flushed, sent_flushed;
-	firehose_snapshot_t snapshot = NULL;
-	bool for_io = (flags & FIREHOSE_DRAIN_FOR_IO);
-
-	if (for_io) {
-		evt = FIREHOSE_EVENT_IO_BUFFER_RECEIVED;
-		_Static_assert(FIREHOSE_EVENT_IO_BUFFER_RECEIVED ==
-				FIREHOSE_SNAPSHOT_EVENT_IO_BUFFER, "");
-		fbh_ring = fb->fb_header.fbh_io_ring;
-		sent_flushed = (uint16_t)fc->fc_io_sent_flushed_pos;
-		flushed = (uint16_t)fc->fc_io_flushed_pos;
-		if (fc->fc_needs_io_snapshot) snapshot = server_config.fs_snapshot;
-	} else {
-		evt = FIREHOSE_EVENT_MEM_BUFFER_RECEIVED;
-		_Static_assert(FIREHOSE_EVENT_MEM_BUFFER_RECEIVED ==
-				FIREHOSE_SNAPSHOT_EVENT_MEM_BUFFER, "");
-		fbh_ring = fb->fb_header.fbh_mem_ring;
-		sent_flushed = (uint16_t)fc->fc_mem_sent_flushed_pos;
-		flushed = (uint16_t)fc->fc_mem_flushed_pos;
-		if (fc->fc_needs_mem_snapshot) snapshot = server_config.fs_snapshot;
-	}
-
-	if (unlikely(fc->fc_memory_corrupted)) {
-		goto corrupt;
-	}
-
-	client_head = flushed;
-	do {
-		if ((uint16_t)(flushed + count) == client_head) {
-			client_head = firehose_client_acquire_head(fb, for_io);
-			if ((uint16_t)(flushed + count) == client_head) {
-				break;
-			}
-			if ((uint16_t)(client_head - sent_flushed) >=
-					FIREHOSE_BUFFER_CHUNK_COUNT) {
-				goto corrupt;
-			}
-		}
-
-		// see firehose_buffer_ring_enqueue
-		do {
-			ref = (flushed + count) & FIREHOSE_RING_POS_IDX_MASK;
-			ref = (firehose_chunk_ref_t)os_atomic_load(&fbh_ring[ref], relaxed);
-			ref &= FIREHOSE_RING_POS_IDX_MASK;
-		} while (!fc->fc_pid && !ref);
-		count++;
-		if (!ref) {
-			_dispatch_debug("Ignoring invalid page reference in ring: %d", ref);
-			continue;
-		}
-
-		fbc = firehose_buffer_ref_to_chunk(fb, ref);
-		firehose_chunk_pos_u fc_pos = fbc->fc_pos;
-		if (fc_pos.fcp_stream == firehose_stream_metadata) {
-			// serialize with firehose_client_metadata_stream_peek
-			os_unfair_lock_lock(&fc->fc_lock);
-		}
-		server_config.fs_handler(fc, evt, fbc, fc_pos);
-		if (unlikely(snapshot)) {
-			snapshot->handler(fc, evt, fbc, fc_pos);
-		}
-		if (fc_pos.fcp_stream == firehose_stream_metadata) {
-			os_unfair_lock_unlock(&fc->fc_lock);
-		}
-		// clients not using notifications (single threaded) always drain fully
-		// because they use all their limit, always
-	} while (count < DRAIN_BATCH_SIZE || snapshot);
-
-	if (count) {
-		// we don't load the full fbh_ring_tail because that is a 64bit quantity
-		// and we only need 16bits from it. and on 32bit arm, there's no way to
-		// perform an atomic load of a 64bit quantity on read-only memory.
-		if (for_io) {
-			os_atomic_add2o(fc, fc_io_flushed_pos, count, relaxed);
-			client_flushed = os_atomic_load2o(&fb->fb_header,
-				fbh_ring_tail.frp_io_flushed, relaxed);
-		} else {
-			os_atomic_add2o(fc, fc_mem_flushed_pos, count, relaxed);
-			client_flushed = os_atomic_load2o(&fb->fb_header,
-				fbh_ring_tail.frp_mem_flushed, relaxed);
-		}
-		if (!fc->fc_pid) {
-			// will fire firehose_client_notify() because port is MACH_PORT_DEAD
-			port = fc->fc_sendp;
-		} else if (!port && client_flushed == sent_flushed) {
-			port = fc->fc_sendp;
-		}
-	}
-
-	if (unlikely(snapshot)) {
-		firehose_client_snapshot_finish(fc, snapshot, for_io);
-		firehose_client_snapshot_mark_done(fc, snapshot, for_io);
-	}
-	if (port) {
-		firehose_client_notify(fc, port);
-	}
-	if (!fc->fc_pid) {
-		if (!(flags & FIREHOSE_DRAIN_POLL)) {
-			// see firehose_client_kernel_source_handle_event
-			dispatch_resume(fc->fc_kernel_source);
-		}
-	} else {
-		if (count >= DRAIN_BATCH_SIZE) {
-			// if we hit the drain batch size, the client probably logs a lot
-			// and there's more to drain, so optimistically schedule draining
-			// again this is cheap since the queue is hot, and is fair for other
-			// clients
-			firehose_client_wakeup(fc, for_io);
-		}
-		if (count && server_config.fs_kernel_client) {
-			// the kernel is special because it can drop messages, so if we're
-			// draining, poll the kernel each time while we're bound to a thread
-			firehose_client_drain_one(server_config.fs_kernel_client,
-					MACH_PORT_NULL, flags | FIREHOSE_DRAIN_POLL);
-		}
-	}
-	return;
-
-corrupt:
-	if (snapshot) {
-		firehose_client_snapshot_mark_done(fc, snapshot, for_io);
-	}
-	firehose_client_mark_corrupted(fc, port);
-	// from now on all IO/mem drains depending on `for_io` will be no-op
-	// (needs_<for_io>_snapshot: false, memory_corrupted: true). we can safely
-	// silence the corresponding source of drain wake-ups.
-	if (fc->fc_pid) {
-		firehose_client_start_cancel(fc, for_io);
-	}
-}
-
-static void
-firehose_client_drain(void *ctxt)
-{
-	fs_client_queue_t queue = ctxt;
-	bool for_io = fs_queue_is_for_io(queue);
-	bool quarantined = fs_queue_is_for_quarantined(queue);
-	firehose_client_t fc, fc_next;
-	size_t clients = 0;
-
-	while (queue->fs_client_tail) {
-		fc = os_mpsc_get_head(os_mpsc(queue, fs_client));
-		do {
-			fc_next = os_mpsc_pop_head(os_mpsc(queue, fs_client),
-					fc, fc_next[for_io]);
-			if (firehose_client_dequeue(fc, for_io)) {
-				firehose_client_drain_one(fc, MACH_PORT_NULL,
-						for_io ? FIREHOSE_DRAIN_FOR_IO : 0);
-			}
-			// process quarantined clients 4 times as slow as the other ones
-			// also reasyncing every 4 clients allows for discovering
-			// quarantined suspension faster
-			if (++clients == (quarantined ? 1 : 4)) {
-				dispatch_source_merge_data(fs_source(quarantined, for_io), 1);
-				return;
-			}
-		} while ((fc = fc_next));
-	}
-}
-
-OS_NOINLINE
-static void
-firehose_client_finalize(firehose_client_t fc OS_OBJECT_CONSUMED)
-{
-	firehose_snapshot_t snapshot = server_config.fs_snapshot;
-	firehose_buffer_t fb = fc->fc_buffer;
-
-	dispatch_assert_queue(server_config.fs_io_drain_queue);
-
-	// if a client dies between phase 1 and 2 of starting the snapshot
-	// (see firehose_snapshot_start)) there's no handler to call, but the
-	// dispatch group has to be adjusted for this client going away.
-	if (fc->fc_needs_io_snapshot) {
-		dispatch_group_leave(snapshot->fs_group);
-		fc->fc_needs_io_snapshot = false;
-	}
-	if (fc->fc_needs_mem_snapshot) {
-		dispatch_group_leave(snapshot->fs_group);
-		fc->fc_needs_mem_snapshot = false;
-	}
-	if (fc->fc_memory_corrupted) {
-		server_config.fs_handler(fc, FIREHOSE_EVENT_CLIENT_CORRUPTED,
-				&fb->fb_chunks[0], (firehose_chunk_pos_u){ .fcp_pos = 0 });
-	}
-	server_config.fs_handler(fc, FIREHOSE_EVENT_CLIENT_DIED, NULL,
-			(firehose_chunk_pos_u){ .fcp_pos = 0 });
-
-	fs_clients_lock();
-	TAILQ_REMOVE(&server_config.fs_clients, fc, fc_entry);
-	fs_clients_unlock();
-
-	for (int i = 0; i < FIREHOSE_BUFFER_NPUSHPORTS; i++) {
-		dispatch_release(fc->fc_mach_channel[i]);
-		fc->fc_mach_channel[i] = NULL;
-	}
-	fc->fc_entry.tqe_next = DISPATCH_OBJECT_LISTLESS;
-	fc->fc_entry.tqe_prev = DISPATCH_OBJECT_LISTLESS;
-	_os_object_release(&fc->fc_as_os_object);
-}
-
-OS_NOINLINE
-static void
-firehose_client_handle_death(void *ctxt)
-{
-	firehose_client_t fc = ctxt;
-	firehose_buffer_t fb = fc->fc_buffer;
-	firehose_buffer_header_t fbh = &fb->fb_header;
-	uint64_t mem_bitmap = 0, bitmap;
-
-	if (fc->fc_memory_corrupted) {
-		return firehose_client_finalize(fc);
-	}
-
-	dispatch_assert_queue(server_config.fs_io_drain_queue);
-
-	// acquire to match release barriers from threads that died
-	os_atomic_thread_fence(acquire);
-
-	bitmap = fbh->fbh_bank.fbb_bitmap & ~1ULL;
-	for (int for_io = 0; for_io < 2; for_io++) {
-		uint16_t volatile *fbh_ring;
-		uint16_t tail, flushed;
-
-		if (for_io) {
-			fbh_ring = fbh->fbh_io_ring;
-			tail = fbh->fbh_ring_tail.frp_io_tail;
-			flushed = (uint16_t)fc->fc_io_flushed_pos;
-		} else {
-			fbh_ring = fbh->fbh_mem_ring;
-			tail = fbh->fbh_ring_tail.frp_mem_tail;
-			flushed = (uint16_t)fc->fc_mem_flushed_pos;
-		}
-		if ((uint16_t)(flushed - tail) >= FIREHOSE_BUFFER_CHUNK_COUNT) {
-			fc->fc_memory_corrupted = true;
-			return firehose_client_finalize(fc);
-		}
-
-		// remove the pages that we flushed already from the bitmap
-		for (; tail != flushed; tail++) {
-			uint16_t ring_pos = tail & FIREHOSE_RING_POS_IDX_MASK;
-			firehose_chunk_ref_t ref =
-					fbh_ring[ring_pos] & FIREHOSE_RING_POS_IDX_MASK;
-
-			bitmap &= ~(1ULL << ref);
-		}
-	}
-
-	firehose_snapshot_t snapshot = server_config.fs_snapshot;
-
-	// Then look at all the allocated pages not seen in the ring
-	while (bitmap) {
-		firehose_chunk_ref_t ref = firehose_bitmap_first_set(bitmap);
-		firehose_chunk_t fbc = firehose_buffer_ref_to_chunk(fb, ref);
-		firehose_chunk_pos_u fc_pos = fbc->fc_pos;
-		uint16_t fbc_length = fc_pos.fcp_next_entry_offs;
-
-		bitmap &= ~(1ULL << ref);
-		if (fbc->fc_start + fbc_length <= fbc->fc_data) {
-			// this page has its "recycle-requeue" done, but hasn't gone
-			// through "recycle-reuse", or it has no data, ditch it
-			continue;
-		}
-		if (!((firehose_tracepoint_t)fbc->fc_data)->ft_length) {
-			// this thing has data, but the first tracepoint is unreadable
-			// so also just ditch it
-			continue;
-		}
-		if (!fc_pos.fcp_flag_io) {
-			mem_bitmap |= 1ULL << ref;
-			continue;
-		}
-		server_config.fs_handler(fc, FIREHOSE_EVENT_IO_BUFFER_RECEIVED, fbc,
-				fc_pos);
-		if (fc->fc_needs_io_snapshot) {
-			snapshot->handler(fc, FIREHOSE_SNAPSHOT_EVENT_IO_BUFFER, fbc,
-					fc_pos);
-		}
-	}
-
-	if (!mem_bitmap) {
-		return firehose_client_finalize(fc);
-	}
-
-	dispatch_async(server_config.fs_mem_drain_queue, ^{
-		uint64_t mem_bitmap_copy = mem_bitmap;
-
-		while (mem_bitmap_copy) {
-			firehose_chunk_ref_t ref = firehose_bitmap_first_set(mem_bitmap_copy);
-			firehose_chunk_t fbc = firehose_buffer_ref_to_chunk(fb, ref);
-			firehose_chunk_pos_u fc_pos = fbc->fc_pos;
-
-			mem_bitmap_copy &= ~(1ULL << ref);
-			server_config.fs_handler(fc, FIREHOSE_EVENT_MEM_BUFFER_RECEIVED,
-					fbc, fc_pos);
-			if (fc->fc_needs_mem_snapshot) {
-				snapshot->handler(fc, FIREHOSE_SNAPSHOT_EVENT_MEM_BUFFER,
-						fbc, fc_pos);
-			}
-		}
-
-		dispatch_async_f(server_config.fs_io_drain_queue, fc,
-				(dispatch_function_t)firehose_client_finalize);
-	});
-}
-
-static void
-firehose_client_handle_mach_event(void *ctx, dispatch_mach_reason_t reason,
-		dispatch_mach_msg_t dmsg, mach_error_t error OS_UNUSED)
-{
-	mach_msg_header_t *msg_hdr = NULL;
-	firehose_client_t fc = ctx;
-	mach_port_t port;
-
-	switch (reason) {
-	case DISPATCH_MACH_MESSAGE_RECEIVED:
-		if (dispatch_mach_mig_demux(fc, firehose_subsystems,
-				countof(firehose_subsystems), dmsg)) {
-			break;
-		}
-
-		msg_hdr = dispatch_mach_msg_get_msg(dmsg, NULL);
-		if (msg_hdr->msgh_id == MACH_NOTIFY_NO_SENDERS) {
-			_dispatch_debug("FIREHOSE NO_SENDERS (unique_pid: 0x%llx)",
-					firehose_client_get_unique_pid(fc, NULL));
-			for (int i = 0; i < FIREHOSE_BUFFER_NPUSHPORTS; i++) {
-				dispatch_mach_cancel(fc->fc_mach_channel[i]);
-			}
-		}
-		mach_msg_destroy(msg_hdr);
-		break;
-
-	case DISPATCH_MACH_DISCONNECTED:
-		msg_hdr = dispatch_mach_msg_get_msg(dmsg, NULL);
-		port = msg_hdr->msgh_local_port;
-		if (MACH_PORT_VALID(port)) {
-			int i;
-			for (i = 0; i < FIREHOSE_BUFFER_NPUSHPORTS; i++) {
-				if (fc->fc_recvp[i] == port) {
-					break;
-				}
-			}
-			if (i == FIREHOSE_BUFFER_NPUSHPORTS) {
-				DISPATCH_INTERNAL_CRASH(port, "Unknown recv-right");
-			}
-			firehose_mach_port_recv_dispose(fc->fc_recvp[i], &fc->fc_recvp[i]);
-			fc->fc_recvp[i] = MACH_PORT_NULL;
-		}
-		break;
-
-	case DISPATCH_MACH_CANCELED:
-		if (!_os_atomic_refcnt_sub2o(fc, fc_mach_channel_refcnt, 1)) {
-			_os_atomic_refcnt_dispose_barrier2o(fc, fc_mach_channel_refcnt);
-
-			firehose_mach_port_send_release(fc->fc_sendp);
-			fc->fc_sendp = MACH_PORT_NULL;
-			for (int i = 0; i < FIREHOSE_BUFFER_NPUSHPORTS; i++) {
-				if (MACH_PORT_VALID(fc->fc_recvp[i])) {
-					DISPATCH_INTERNAL_CRASH(fc->fc_recvp[i], "recv-right leak");
-				}
-			}
-
-			firehose_client_cancel(fc);
-		}
-		break;
-	default:
-		break;
-	}
-}
-
-#if !TARGET_OS_SIMULATOR
-static void
-firehose_client_kernel_source_handle_event(void *ctxt)
-{
-	firehose_client_t fc = ctxt;
-
-	// resumed in firehose_client_drain for both memory and I/O
-	dispatch_suspend(fc->fc_kernel_source);
-	dispatch_suspend(fc->fc_kernel_source);
-	firehose_client_wakeup(fc, false);
-	firehose_client_wakeup(fc, true);
-}
-#endif
-
-static inline void
-firehose_client_resume(firehose_client_t fc,
-		const struct firehose_client_connected_info_s *fcci)
-{
-	dispatch_assert_queue(server_config.fs_mem_drain_queue);
-
-	fs_clients_lock();
-	TAILQ_INSERT_TAIL(&server_config.fs_clients, fc, fc_entry);
-	fs_clients_unlock();
-
-	server_config.fs_handler(fc, FIREHOSE_EVENT_CLIENT_CONNECTED, (void *)fcci,
-			(firehose_chunk_pos_u){ .fcp_pos = 0 });
-	if (!fc->fc_pid) {
-		dispatch_activate(fc->fc_kernel_source);
-	} else {
-		for (int i = 0; i < FIREHOSE_BUFFER_NPUSHPORTS; i++) {
-			dispatch_mach_connect(fc->fc_mach_channel[i],
-					fc->fc_recvp[i], MACH_PORT_NULL, NULL);
-		}
-	}
-}
-
-static void
-firehose_client_cancel(firehose_client_t fc)
-{
-	_dispatch_debug("client died (unique_pid: 0x%llx",
-			firehose_client_get_unique_pid(fc, NULL));
-
-	dispatch_assert(fc->fc_sendp == MACH_PORT_NULL);
-	for (int i = 0; i < FIREHOSE_BUFFER_NPUSHPORTS; i++) {
-		dispatch_assert(fc->fc_recvp[i] == MACH_PORT_NULL);
-	}
-	firehose_client_start_cancel(fc, false);
-	firehose_client_start_cancel(fc, true);
-}
-
-static firehose_client_t
-_firehose_client_create(firehose_buffer_t fb)
-{
-	firehose_client_t fc;
-
-	fc = (firehose_client_t)_os_object_alloc_realized(FIREHOSE_CLIENT_CLASS,
-			sizeof(struct firehose_client_s));
-	fc->fc_buffer = fb;
-	fc->fc_mem_flushed_pos = fb->fb_header.fbh_bank.fbb_mem_flushed;
-	fc->fc_mem_sent_flushed_pos = fc->fc_mem_flushed_pos;
-	fc->fc_io_flushed_pos = fb->fb_header.fbh_bank.fbb_io_flushed;
-	fc->fc_io_sent_flushed_pos = fc->fc_io_flushed_pos;
-	return fc;
-}
-
-#pragma pack(4)
-typedef struct firehose_token_s {
-	uid_t auid;
-	uid_t euid;
-	gid_t egid;
-	uid_t ruid;
-	gid_t rgid;
-	pid_t pid;
-	au_asid_t asid;
-	dev_t execcnt;
-} *firehose_token_t;
-#pragma pack()
-
-static firehose_client_t
-firehose_client_create(firehose_buffer_t fb, firehose_token_t token,
-		mach_port_t comm_mem_recvp, mach_port_t comm_io_recvp,
-		mach_port_t comm_sendp)
-{
-	uint64_t unique_pid = fb->fb_header.fbh_uniquepid;
-	firehose_client_t fc = _firehose_client_create(fb);
-	dispatch_mach_t dm;
-
-	fc->fc_pid = token->pid ? token->pid : ~0;
-	fc->fc_euid = token->euid;
-	fc->fc_pidversion = token->execcnt;
-
-	_dispatch_debug("FIREHOSE_REGISTER (unique_pid: 0x%llx)", unique_pid);
-	mach_port_t recvp[] = { comm_mem_recvp, comm_io_recvp };
-	dispatch_queue_t fsqs[] = {
-		server_config.fs_mem_drain_queue,
-		server_config.fs_io_drain_queue
-	};
-	fc->fc_mach_channel_refcnt = FIREHOSE_BUFFER_NPUSHPORTS;
-	for (int i = 0; i < FIREHOSE_BUFFER_NPUSHPORTS; i++) {
-		fc->fc_recvp[i] = recvp[i];
-		firehose_mach_port_guard(fc->fc_recvp[i], true, &fc->fc_recvp[i]);
-		dm = dispatch_mach_create_f("com.apple.firehose.peer", fsqs[i], fc,
-				firehose_client_handle_mach_event);
-		fc->fc_mach_channel[i] = dm;
-	}
-
-	fc->fc_sendp = comm_sendp;
-	return fc;
-}
-
-static void
-firehose_kernel_client_create(void)
-{
-#if !TARGET_OS_SIMULATOR
-	struct firehose_server_s *fs = &server_config;
-	firehose_buffer_map_info_t fb_map;
-	firehose_client_t fc;
-	dispatch_source_t ds;
-	int fd;
-
-	while ((fd = open("/dev/oslog", O_RDWR)) < 0) {
-		if (errno == EINTR) {
-			continue;
-		}
-		if (errno == ENOENT) {
-			return;
-		}
-		DISPATCH_INTERNAL_CRASH(errno, "Unable to open /dev/oslog");
-	}
-
-	while (ioctl(fd, LOGBUFFERMAP, &fb_map) < 0) {
-		if (errno == EINTR) {
-			continue;
-		}
-		DISPATCH_INTERNAL_CRASH(errno, "Unable to map kernel buffer");
-	}
-	if ((fb_map.fbmi_size < FIREHOSE_BUFFER_KERNEL_MIN_CHUNK_COUNT * FIREHOSE_CHUNK_SIZE) ||
-		(fb_map.fbmi_size > FIREHOSE_BUFFER_KERNEL_MAX_CHUNK_COUNT * FIREHOSE_CHUNK_SIZE)) {
-		DISPATCH_INTERNAL_CRASH(fb_map.fbmi_size, "Unexpected kernel buffer size");
-	}
-
-	fc = _firehose_client_create((firehose_buffer_t)(uintptr_t)fb_map.fbmi_addr);
-	ds = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ, (uintptr_t)fd, 0,
-			fs->fs_mem_drain_queue);
-	dispatch_set_qos_class_floor(ds, QOS_CLASS_USER_INITIATED, 0);
-	dispatch_set_context(ds, fc);
-	dispatch_source_set_event_handler_f(ds,
-			firehose_client_kernel_source_handle_event);
-	fc->fc_kernel_source = ds;
-	fc->fc_sendp = MACH_PORT_DEAD; // causes drain() to call notify
-
-	fs->fs_kernel_fd = fd;
-	fs->fs_kernel_client = fc;
-#endif
-}
-
-void
-_firehose_client_dispose(firehose_client_t fc)
-{
-	vm_deallocate(mach_task_self(), (vm_address_t)fc->fc_buffer,
-			sizeof(*fc->fc_buffer));
-	fc->fc_buffer = NULL;
-	server_config.fs_handler(fc, FIREHOSE_EVENT_CLIENT_FINALIZE, NULL,
-			(firehose_chunk_pos_u){ .fcp_pos = 0 });
-}
-
-void
-_firehose_client_xref_dispose(firehose_client_t fc)
-{
-	_dispatch_debug("Cleaning up client info for unique_pid 0x%llx",
-			firehose_client_get_unique_pid(fc, NULL));
-}
-
-uint64_t
-firehose_client_get_unique_pid(firehose_client_t fc, pid_t *pid_out)
-{
-	firehose_buffer_header_t fbh = &fc->fc_buffer->fb_header;
-	if (pid_out) *pid_out = fc->fc_pid;
-	if (!fc->fc_pid) return 0;
-	return fbh->fbh_uniquepid ? fbh->fbh_uniquepid : ~0ull;
-}
-
-uid_t
-firehose_client_get_euid(firehose_client_t fc)
-{
-	return fc->fc_euid;
-}
-
-int
-firehose_client_get_pid_version(firehose_client_t fc)
-{
-	return fc->fc_pidversion;
-}
-
-void *
-firehose_client_get_metadata_buffer(firehose_client_t client, size_t *size)
-{
-	firehose_buffer_header_t fbh = &client->fc_buffer->fb_header;
-
-	*size = FIREHOSE_BUFFER_LIBTRACE_HEADER_SIZE;
-	return (void *)((uintptr_t)(fbh + 1) - *size);
-}
-
-void *
-firehose_client_get_context(firehose_client_t fc)
-{
-	return os_atomic_load2o(fc, fc_ctxt, relaxed);
-}
-
-void
-firehose_client_set_strings_cached(firehose_client_t fc)
-{
-	fc->fc_strings_cached = true;
-}
-
-void *
-firehose_client_set_context(firehose_client_t fc, void *ctxt)
-{
-	return os_atomic_xchg2o(fc, fc_ctxt, ctxt, relaxed);
-}
-
-void
-firehose_client_initiate_quarantine(firehose_client_t fc)
-{
-	fc->fc_quarantined = true;
-}
-
-#pragma mark -
-#pragma mark firehose server
-
-static void
-firehose_server_handle_mach_event(void *ctx,
-		dispatch_mach_reason_t reason, dispatch_mach_msg_t dmsg,
-		mach_error_t error OS_UNUSED)
-{
-	if (reason == DISPATCH_MACH_MESSAGE_RECEIVED) {
-		if (!dispatch_mach_mig_demux(ctx, firehose_subsystems,
-				countof(firehose_subsystems), dmsg)) {
-			mach_msg_destroy(dispatch_mach_msg_get_msg(dmsg, NULL));
-		}
-	}
-}
-
-void
-firehose_server_init(mach_port_t comm_port, firehose_handler_t handler)
-{
-	struct firehose_server_s *fs = &server_config;
-	dispatch_queue_attr_t attr = DISPATCH_QUEUE_SERIAL_WITH_AUTORELEASE_POOL;
-	dispatch_queue_attr_t attr_inactive, attr_utility_inactive;
-	dispatch_mach_t dm;
-	dispatch_source_t ds;
-
-	// just reference the string so that it's captured
-	(void)os_atomic_load(&__libfirehose_serverVersionString[0], relaxed);
-
-	fs->fs_snapshot_gate_queue = dispatch_queue_create_with_target(
-			"com.apple.firehose.snapshot-gate", attr, NULL);
-
-	attr_inactive = dispatch_queue_attr_make_initially_inactive(attr);
-	attr_utility_inactive = dispatch_queue_attr_make_with_qos_class(
-			attr_inactive, QOS_CLASS_UTILITY, 0);
-
-	fs->fs_io_drain_queue = dispatch_queue_create_with_target(
-			"com.apple.firehose.drain-io", attr_utility_inactive, NULL);
-	dispatch_set_qos_class_fallback(fs->fs_io_drain_queue, QOS_CLASS_UTILITY);
-	dispatch_activate(fs->fs_io_drain_queue);
-
-	fs->fs_mem_drain_queue = dispatch_queue_create_with_target(
-			"com.apple.firehose.drain-mem", attr_inactive, NULL);
-	dispatch_set_qos_class_fallback(fs->fs_mem_drain_queue, QOS_CLASS_UTILITY);
-	dispatch_activate(fs->fs_mem_drain_queue);
-
-	dm = dispatch_mach_create_f("com.apple.firehose.listener",
-			fs->fs_mem_drain_queue, NULL, firehose_server_handle_mach_event);
-	fs->fs_bootstrap_port = comm_port;
-	fs->fs_mach_channel = dm;
-	fs->fs_handler = _Block_copy(handler);
-	firehose_kernel_client_create();
-
-	for (size_t i = 0; i < countof(fs->fs_sources); i++) {
-		ds = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_OR, 0, 0,
-				fs_idx_is_for_io(i) ? server_config.fs_io_drain_queue :
-				server_config.fs_mem_drain_queue);
-		dispatch_set_context(ds, &fs->fs_queues[i]);
-		dispatch_source_set_event_handler_f(ds, firehose_client_drain);
-		fs->fs_sources[i] = ds;
-	}
-}
-
-void
-firehose_server_assert_spi_version(uint32_t spi_version)
-{
-	if (spi_version != OS_FIREHOSE_SPI_VERSION) {
-		DISPATCH_CLIENT_CRASH(spi_version, "firehose server version mismatch ("
-				OS_STRINGIFY(OS_FIREHOSE_SPI_VERSION) ")");
-	}
-	if (_firehose_spi_version != OS_FIREHOSE_SPI_VERSION) {
-		DISPATCH_CLIENT_CRASH(_firehose_spi_version,
-				"firehose libdispatch version mismatch ("
-				OS_STRINGIFY(OS_FIREHOSE_SPI_VERSION) ")");
-
-	}
-}
-
-bool
-firehose_server_has_ever_flushed_pages(void)
-{
-	// Use the IO pages flushed count from the kernel client as an
-	// approximation for whether the firehose has ever flushed pages during
-	// this boot. logd uses this detect the first time it starts after a
-	// fresh boot.
-	firehose_client_t fhc = server_config.fs_kernel_client;
-	return !fhc || fhc->fc_io_flushed_pos > 0;
-}
-
-void
-firehose_server_resume(void)
-{
-	struct firehose_server_s *fs = &server_config;
-
-	if (fs->fs_kernel_client) {
-		dispatch_async(fs->fs_mem_drain_queue, ^{
-			struct firehose_client_connected_info_s fcci = {
-				.fcci_version = FIREHOSE_CLIENT_CONNECTED_INFO_VERSION,
-			};
-			firehose_client_resume(fs->fs_kernel_client, &fcci);
-		});
-	}
-	dispatch_mach_connect(fs->fs_mach_channel, fs->fs_bootstrap_port,
-			MACH_PORT_NULL, NULL);
-	for (size_t i = 0; i < countof(fs->fs_sources); i++) {
-		dispatch_activate(fs->fs_sources[i]);
-	}
-}
-
-void
-firehose_server_cancel(void)
-{
-	firehose_client_t fc;
-
-	dispatch_mach_cancel(server_config.fs_mach_channel);
-
-	fs_clients_lock();
-	TAILQ_FOREACH(fc, &server_config.fs_clients, fc_entry) {
-		if (fc->fc_pid) {
-			for (int i = 0; i < FIREHOSE_BUFFER_NPUSHPORTS; i++) {
-				dispatch_mach_cancel(fc->fc_mach_channel[i]);
-			}
-		}
-	}
-	fs_clients_unlock();
-}
-
-void
-firehose_server_set_logging_prefs(void *pointer, size_t length, os_block_t block)
-{
-	dispatch_async(server_config.fs_mem_drain_queue, ^{
-		kern_return_t kr;
-		memory_object_size_t size = (memory_object_size_t)length;
-		if (server_config.fs_prefs_cache_entry) {
-			kr = mach_port_deallocate(mach_task_self(),
-					server_config.fs_prefs_cache_entry);
-			DISPATCH_VERIFY_MIG(kr);
-			dispatch_assume_zero(kr);
-		}
-		if (server_config.fs_prefs_cache) {
-			munmap(server_config.fs_prefs_cache,
-					server_config.fs_prefs_cache_size);
-		}
-
-		server_config.fs_prefs_cache = pointer;
-		server_config.fs_prefs_cache_size = length;
-		server_config.fs_prefs_cache_entry = MACH_PORT_NULL;
-		if (pointer) {
-			kr = mach_make_memory_entry_64(mach_task_self(), &size,
-					(mach_vm_address_t)pointer, VM_PROT_READ | MAP_MEM_VM_SHARE,
-					&server_config.fs_prefs_cache_entry, MACH_PORT_NULL);
-			DISPATCH_VERIFY_MIG(kr);
-			dispatch_assume_zero(kr);
-		}
-		if (block) block();
-	});
-}
-
-dispatch_queue_t
-firehose_server_copy_queue(firehose_server_queue_t which)
-{
-	dispatch_queue_t dq;
-	switch (which) {
-	case FIREHOSE_SERVER_QUEUE_IO:
-		dq = server_config.fs_io_drain_queue;
-		break;
-	case FIREHOSE_SERVER_QUEUE_MEMORY:
-		dq = server_config.fs_mem_drain_queue;
-		break;
-	default:
-		DISPATCH_INTERNAL_CRASH(which, "Invalid firehose server queue type");
-	}
-	dispatch_retain(dq);
-	return dq;
-}
-
-void
-firehose_server_quarantined_suspend(firehose_server_queue_t which)
-{
-	switch (which) {
-	case FIREHOSE_SERVER_QUEUE_IO:
-		dispatch_suspend(fs_source(true, true));
-		break;
-	case FIREHOSE_SERVER_QUEUE_MEMORY:
-		dispatch_suspend(fs_source(true, false));
-		break;
-	default:
-		DISPATCH_INTERNAL_CRASH(which, "Invalid firehose server queue type");
-	}
-}
-
-void
-firehose_server_quarantined_resume(firehose_server_queue_t which)
-{
-	switch (which) {
-	case FIREHOSE_SERVER_QUEUE_IO:
-		dispatch_resume(fs_source(true, true));
-		break;
-	case FIREHOSE_SERVER_QUEUE_MEMORY:
-		dispatch_resume(fs_source(true, false));
-		break;
-	default:
-		DISPATCH_INTERNAL_CRASH(which, "Invalid firehose server queue type");
-	}
-}
-
-
-#pragma mark -
-#pragma mark firehose snapshot and peeking
-
-void
-firehose_client_metadata_stream_peek(firehose_client_t fc,
-		OS_UNUSED firehose_event_t context, bool (^peek_should_start)(void),
-		bool (^peek)(firehose_chunk_t fbc))
-{
-	os_unfair_lock_lock(&fc->fc_lock);
-
-	if (peek_should_start && peek_should_start()) {
-		firehose_buffer_t fb = fc->fc_buffer;
-		firehose_buffer_header_t fbh = &fb->fb_header;
-		uint64_t bitmap = fbh->fbh_bank.fbb_metadata_bitmap;
-
-		while (bitmap) {
-			firehose_chunk_ref_t ref = firehose_bitmap_first_set(bitmap);
-			firehose_chunk_t fbc = firehose_buffer_ref_to_chunk(fb, ref);
-			uint16_t fbc_length = fbc->fc_pos.fcp_next_entry_offs;
-
-			bitmap &= ~(1ULL << ref);
-			if (fbc->fc_start + fbc_length <= fbc->fc_data) {
-				// this page has its "recycle-requeue" done, but hasn't gone
-				// through "recycle-reuse", or it has no data, ditch it
-				continue;
-			}
-			if (!((firehose_tracepoint_t)fbc->fc_data)->ft_length) {
-				// this thing has data, but the first tracepoint is unreadable
-				// so also just ditch it
-				continue;
-			}
-			if (fbc->fc_pos.fcp_stream != firehose_stream_metadata) {
-				continue;
-			}
-			if (!peek(fbc)) {
-				break;
-			}
-		}
-	}
-
-	os_unfair_lock_unlock(&fc->fc_lock);
-}
-
-OS_NOINLINE OS_COLD
-static void
-firehose_client_snapshot_finish(firehose_client_t fc,
-		firehose_snapshot_t snapshot, bool for_io)
-{
-	firehose_buffer_t fb = fc->fc_buffer;
-	firehose_buffer_header_t fbh = &fb->fb_header;
-	firehose_snapshot_event_t evt;
-	uint16_t volatile *fbh_ring;
-	uint16_t tail, flushed;
-	uint64_t bitmap;
-
-	bitmap = ~1ULL;
-
-	if (for_io) {
-		fbh_ring = fbh->fbh_io_ring;
-		tail = fbh->fbh_ring_tail.frp_io_tail;
-		flushed = (uint16_t)fc->fc_io_flushed_pos;
-		evt = FIREHOSE_SNAPSHOT_EVENT_IO_BUFFER;
-	} else {
-		fbh_ring = fbh->fbh_mem_ring;
-		tail = fbh->fbh_ring_tail.frp_mem_tail;
-		flushed = (uint16_t)fc->fc_mem_flushed_pos;
-		evt = FIREHOSE_SNAPSHOT_EVENT_MEM_BUFFER;
-	}
-	if ((uint16_t)(flushed - tail) >= FIREHOSE_BUFFER_CHUNK_COUNT) {
-		fc->fc_memory_corrupted = true;
-		return;
-	}
-
-	// remove the pages that we flushed already from the bitmap
-	for (; tail != flushed; tail++) {
-		uint16_t idx = tail & FIREHOSE_RING_POS_IDX_MASK;
-		firehose_chunk_ref_t ref = fbh_ring[idx] & FIREHOSE_RING_POS_IDX_MASK;
-
-		bitmap &= ~(1ULL << ref);
-	}
-
-	// Remove pages that are free by AND-ing with the allocating bitmap.
-	// The load of fbb_bitmap may not be atomic, but it's ok because bits
-	// being flipped are pages we don't care about snapshotting. The worst thing
-	// that can happen is that we go peek at an unmapped page and we fault it in
-	bitmap &= fbh->fbh_bank.fbb_bitmap;
-
-	// Then look at all the allocated pages not seen in the ring
-	while (bitmap) {
-		firehose_chunk_ref_t ref = firehose_bitmap_first_set(bitmap);
-		firehose_chunk_t fbc = firehose_buffer_ref_to_chunk(fb, ref);
-		firehose_chunk_pos_u fc_pos = fbc->fc_pos;
-		uint16_t fbc_length = fc_pos.fcp_next_entry_offs;
-
-		bitmap &= ~(1ULL << ref);
-		if (fbc->fc_start + fbc_length <= fbc->fc_data) {
-			// this page has its "recycle-requeue" done, but hasn't gone
-			// through "recycle-reuse", or it has no data, ditch it
-			continue;
-		}
-		if (!((firehose_tracepoint_t)fbc->fc_data)->ft_length) {
-			// this thing has data, but the first tracepoint is unreadable
-			// so also just ditch it
-			continue;
-		}
-		if (fc_pos.fcp_flag_io != for_io) {
-			continue;
-		}
-		snapshot->handler(fc, evt, fbc, fc_pos);
-	}
-}
-
-static void
-firehose_snapshot_tickle_clients(firehose_snapshot_t fs, bool for_io)
-{
-	firehose_client_t fc;
-	uint32_t n = 0;
-
-	fs_clients_lock();
-	TAILQ_FOREACH(fc, &server_config.fs_clients, fc_entry) {
-		if (unlikely(fc->fc_memory_corrupted)) {
-			continue;
-		}
-		if (!fc->fc_pid) {
-#if TARGET_OS_SIMULATOR
-			continue;
-#endif
-		} else if (!firehose_client_wakeup(fc, for_io)) {
-			continue;
-		}
-		n++;
-		if (for_io) {
-			fc->fc_needs_io_snapshot = true;
-		} else {
-			fc->fc_needs_mem_snapshot = true;
-		}
-	}
-	fs_clients_unlock();
-
-	// cheating: equivalent to dispatch_group_enter() n times
-	// without the acquire barriers that we don't need
-	if (n) {
-		os_atomic_sub2o(fs->fs_group, dg_bits,
-				n * DISPATCH_GROUP_VALUE_INTERVAL, relaxed);
-	}
-}
-
-static void
-firehose_snapshot_finish(void *ctxt)
-{
-	firehose_snapshot_t fs = ctxt;
-
-	fs->handler(NULL, FIREHOSE_SNAPSHOT_EVENT_COMPLETE, NULL,
-			(firehose_chunk_pos_u){ .fcp_pos = 0 });
-	server_config.fs_snapshot = NULL;
-
-	dispatch_release(fs->fs_group);
-	Block_release(fs->handler);
-	free(fs);
-
-	// resume the snapshot gate queue to maybe handle the next snapshot
-	dispatch_resume(server_config.fs_snapshot_gate_queue);
-}
-
-static void
-firehose_snapshot_gate(void *ctxt)
-{
-	firehose_snapshot_t fs = ctxt;
-
-	// prevent other snapshots from running until done
-
-	dispatch_suspend(server_config.fs_snapshot_gate_queue);
-
-	server_config.fs_snapshot = fs;
-	dispatch_group_async(fs->fs_group, server_config.fs_mem_drain_queue, ^{
-		// start the fs_mem_snapshot, this is what triggers the snapshot
-		// logic from _drain() or handle_death()
-		fs->handler(NULL, FIREHOSE_SNAPSHOT_EVENT_MEM_START, NULL,
-				(firehose_chunk_pos_u){ .fcp_pos = 0 });
-		firehose_snapshot_tickle_clients(fs, false);
-
-		dispatch_group_async(fs->fs_group, server_config.fs_io_drain_queue, ^{
-			// start the fs_io_snapshot, this is what triggers the snapshot
-			// logic from _drain() or handle_death()
-			// 29868879: must always happen after the memory snapshot started
-			fs->handler(NULL, FIREHOSE_SNAPSHOT_EVENT_IO_START, NULL,
-					(firehose_chunk_pos_u){ .fcp_pos = 0 });
-			firehose_snapshot_tickle_clients(fs, true);
-
-#if !TARGET_OS_SIMULATOR
-			if (server_config.fs_kernel_client) {
-				firehose_client_kernel_source_handle_event(
-						server_config.fs_kernel_client);
-			}
-#endif
-		});
-	});
-
-	dispatch_group_notify_f(fs->fs_group, server_config.fs_io_drain_queue,
-			fs, firehose_snapshot_finish);
-}
-
-void
-firehose_snapshot(firehose_snapshot_handler_t handler)
-{
-	firehose_snapshot_t snapshot = malloc(sizeof(struct firehose_snapshot_s));
-
-	snapshot->handler = Block_copy(handler);
-	snapshot->fs_group = dispatch_group_create();
-
-	dispatch_async_f(server_config.fs_snapshot_gate_queue, snapshot,
-			firehose_snapshot_gate);
-}
-
-#pragma mark -
-#pragma mark MiG handler routines
-
-kern_return_t
-firehose_server_register(mach_port_t server_port OS_UNUSED,
-		mach_port_t mem_port, mach_vm_size_t mem_size,
-		mach_port_t comm_mem_recvp, mach_port_t comm_io_recvp,
-		mach_port_t comm_sendp,
-		mach_port_t extra_info_port, mach_vm_size_t extra_info_size,
-		audit_token_t atoken)
-{
-	mach_vm_address_t base_addr = 0;
-	firehose_client_t fc = NULL;
-	kern_return_t kr;
-	struct firehose_client_connected_info_s fcci = {
-		.fcci_version = FIREHOSE_CLIENT_CONNECTED_INFO_VERSION,
-	};
-
-	fc = dispatch_mach_mig_demux_get_context();
-	if (fc != NULL) {
-		return KERN_FAILURE;
-	}
-
-	if (mem_size != sizeof(union firehose_buffer_u)) {
-		return KERN_INVALID_VALUE;
-	}
-
-	/*
-	 * Request a MACH_NOTIFY_NO_SENDERS notification for the mem_recvp. That
-	 * should indicate the client going away.
-	 */
-	mach_port_t previous = MACH_PORT_NULL;
-	kr = mach_port_request_notification(mach_task_self(), comm_mem_recvp,
-			MACH_NOTIFY_NO_SENDERS, 0, comm_mem_recvp,
-			MACH_MSG_TYPE_MAKE_SEND_ONCE, &previous);
-	DISPATCH_VERIFY_MIG(kr);
-	if (dispatch_assume_zero(kr)) {
-		return KERN_FAILURE;
-	}
-	dispatch_assert(previous == MACH_PORT_NULL);
-
-	/* Map the memory handle into the server address space */
-	kr = mach_vm_map(mach_task_self(), &base_addr, mem_size, 0,
-			VM_FLAGS_ANYWHERE, mem_port, 0, FALSE,
-			VM_PROT_READ, VM_PROT_READ, VM_INHERIT_NONE);
-	DISPATCH_VERIFY_MIG(kr);
-	if (dispatch_assume_zero(kr)) {
-		return KERN_NO_SPACE;
-	}
-
-	if (extra_info_port) {
-		if (extra_info_size) {
-			mach_vm_address_t addr = 0;
-			kr = mach_vm_map(mach_task_self(), &addr, extra_info_size, 0,
-					VM_FLAGS_ANYWHERE, extra_info_port, 0, TRUE,
-					VM_PROT_READ, VM_PROT_READ, VM_INHERIT_NONE);
-			if (dispatch_assume_zero(kr)) {
-				mach_vm_deallocate(mach_task_self(), base_addr, mem_size);
-				return KERN_NO_SPACE;
-			}
-			fcci.fcci_data = (void *)(uintptr_t)addr;
-			fcci.fcci_size = (size_t)extra_info_size;
-		}
-		firehose_mach_port_send_release(extra_info_port);
-	}
-
-	firehose_mach_port_send_release(mem_port);
-
-	fc = firehose_client_create((firehose_buffer_t)base_addr,
-			(firehose_token_t)&atoken, comm_mem_recvp, comm_io_recvp,
-			comm_sendp);
-	firehose_client_resume(fc, &fcci);
-
-	if (fcci.fcci_size) {
-		vm_deallocate(mach_task_self(), (vm_address_t)fcci.fcci_data,
-				fcci.fcci_size);
-	}
-
-	return KERN_SUCCESS;
-}
-
-kern_return_t
-firehose_server_push_async(mach_port_t server_port,
-		qos_class_t qos DISPATCH_UNUSED)
-{
-	firehose_client_t fc = dispatch_mach_mig_demux_get_context();
-
-	if (fc == NULL) {
-		return KERN_FAILURE;
-	}
-
-	bool for_io = (server_port == fc->fc_recvp[FIREHOSE_BUFFER_PUSHPORT_IO]);
-
-	_dispatch_debug("FIREHOSE_PUSH_ASYNC (unique_pid %llx)",
-			firehose_client_get_unique_pid(fc, NULL));
-	if (likely(!fc->fc_memory_corrupted)) {
-		firehose_client_wakeup(fc, for_io);
-	}
-	return KERN_SUCCESS;
-}
-
-kern_return_t
-firehose_server_push_and_wait(mach_port_t server_port,
-		mach_port_t reply_port, firehose_push_reply_t *push_reply OS_UNUSED,
-		boolean_t *quarantinedOut OS_UNUSED)
-{
-	firehose_client_t fc = dispatch_mach_mig_demux_get_context();
-
-	if (fc == NULL) {
-		return KERN_FAILURE;
-	}
-
-	bool for_io = (server_port == fc->fc_recvp[FIREHOSE_BUFFER_PUSHPORT_IO]);
-
-	_dispatch_debug("FIREHOSE_PUSH (unique_pid %llx)",
-			firehose_client_get_unique_pid(fc, NULL));
-
-	if (unlikely(fc->fc_memory_corrupted)) {
-		firehose_client_mark_corrupted(fc, reply_port);
-		return MIG_NO_REPLY;
-	}
-
-	dispatch_queue_t q;
-	if (for_io) {
-		q = server_config.fs_io_drain_queue;
-	} else {
-		q = server_config.fs_mem_drain_queue;
-	}
-	dispatch_assert_queue(q);
-
-	firehose_client_drain_one(fc, reply_port,
-			for_io ? FIREHOSE_DRAIN_FOR_IO : 0);
-
-	return MIG_NO_REPLY;
-}
-
-kern_return_t
-firehose_server_get_logging_prefs(mach_port_t server_port OS_UNUSED,
-		mach_port_t *mem_port, mach_vm_size_t *prefs_size)
-{
-	*mem_port = server_config.fs_prefs_cache_entry;
-	*prefs_size = (mach_vm_size_t)server_config.fs_prefs_cache_size;
-	return KERN_SUCCESS;
-}
-
-kern_return_t
-firehose_server_should_send_strings(mach_port_t server_port OS_UNUSED,
-		boolean_t *needs_strings)
-{
-	firehose_client_t fc = dispatch_mach_mig_demux_get_context();
-	if (fc) {
-		*needs_strings = !fc->fc_strings_cached;
-		return KERN_SUCCESS;
-	}
-	return KERN_FAILURE;
-}
--- a/Telegram/ThirdParty/dispatch/src/firehose/firehose_server_internal.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/firehose/firehose_server_internal.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,91 +0,0 @@
-/*
- * Copyright (c) 2015 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#ifndef __FIREHOSE_SERVER_INTERNAL__
-#define __FIREHOSE_SERVER_INTERNAL__
-
-OS_OBJECT_CLASS_DECL(firehose_client);
-#define FIREHOSE_CLIENT_CLASS OS_OBJECT_VTABLE(firehose_client)
-
-typedef struct firehose_snapshot_s *firehose_snapshot_t;
-struct firehose_snapshot_s {
-	firehose_snapshot_handler_t handler;
-	dispatch_group_t fs_group;
-};
-
-struct firehose_client_s {
-	union {
-		_OS_OBJECT_HEADER(void *os_obj_isa, os_obj_ref_cnt, os_obj_xref_cnt);
-		struct _os_object_s fc_as_os_object;
-	};
-	TAILQ_ENTRY(firehose_client_s) fc_entry;
-	struct firehose_client_s *volatile fc_next[2];
-
-	firehose_buffer_t	fc_buffer;
-	uint64_t volatile	fc_mem_sent_flushed_pos;
-	uint64_t volatile	fc_mem_flushed_pos;
-	uint64_t volatile	fc_io_sent_flushed_pos;
-	uint64_t volatile	fc_io_flushed_pos;
-
-#define FC_STATE_ENQUEUED(for_io)      (uint16_t)(0x0001u << (for_io))
-#define FC_STATE_MEM_ENQUEUED           0x0001
-#define FC_STATE_IO_ENQUEUED            0x0002
-
-#define FC_STATE_CANCELING(for_io)     (uint16_t)(0x0010u << (for_io))
-#define FC_STATE_MEM_CANCELING          0x0010
-#define FC_STATE_IO_CANCELING           0x0020
-
-#define FC_STATE_CANCELED(for_io)      (uint16_t)(0x0100u << (for_io))
-#define FC_STATE_MEM_CANCELED           0x0100
-#define FC_STATE_IO_CANCELED            0x0200
-#define FC_STATE_CANCELED_MASK          0x0300
-
-	void *volatile		fc_ctxt;
-
-	union {
-		dispatch_mach_t	fc_mach_channel[FIREHOSE_BUFFER_NPUSHPORTS];
-		dispatch_source_t fc_kernel_source;
-	};
-	mach_port_t			fc_recvp[FIREHOSE_BUFFER_NPUSHPORTS];
-	mach_port_t			fc_sendp;
-	os_unfair_lock      fc_lock;
-	pid_t				fc_pid;
-	int					fc_pidversion;
-	uid_t				fc_euid;
-	os_atomic(uint16_t)	fc_state;
-	os_atomic(uint8_t)	fc_mach_channel_refcnt;
-	// These bits are mutated from different locking domains, and so cannot be
-	// safely consolidated into a bit-field.
-	bool volatile		fc_strings_cached;
-	bool volatile		fc_memory_corrupted;
-	bool volatile		fc_needs_io_snapshot;
-	bool volatile		fc_needs_mem_snapshot;
-	bool volatile		fc_quarantined;
-} DISPATCH_ATOMIC64_ALIGN;
-
-void
-_firehose_client_xref_dispose(struct firehose_client_s *fc);
-void
-_firehose_client_dispose(struct firehose_client_s *fc);
-
-extern unsigned char __libfirehose_serverVersionString[];
-extern double __libfirehose_serverVersionNumber;
-
-#endif // __FIREHOSE_SERVER_INTERNAL__
--- a/Telegram/ThirdParty/dispatch/src/firehose/firehose_server_object.m	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/firehose/firehose_server_object.m	1970-01-01 00:00:00.000000000 -0000
@@ -1,47 +0,0 @@
-/*
- * Copyright (c) 2015 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include "internal.h"
-
-#if !USE_OBJC || _OS_OBJECT_OBJC_ARC
-#error the firehose server requires the objc-runtime, no ARC
-#endif
-
-@implementation OS_OBJECT_CLASS(firehose_client)
-DISPATCH_UNAVAILABLE_INIT()
-+ (void)load { }
-
-- (void)_xref_dispose
-{
-	_firehose_client_xref_dispose((struct firehose_client_s *)self);
-	[super _xref_dispose];
-}
-
-- (void)_dispose
-{
-	_firehose_client_dispose((struct firehose_client_s *)self);
-	[super _dispose];
-}
-
-- (NSString *)debugDescription
-{
-	return nil;
-}
-@end
--- a/Telegram/ThirdParty/dispatch/src/firehose/firehose_types.defs	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/firehose/firehose_types.defs	1970-01-01 00:00:00.000000000 -0000
@@ -1,28 +0,0 @@
-/*
- * Copyright (c) 2015 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include <mach/std_types.defs>
-#include <mach/mach_types.defs>
-
-import <firehose/firehose_types_private.h>;
-import <sys/qos.h>;
-
-type firehose_push_reply_t = struct [2] of uint64_t;
-type qos_class_t = unsigned;
--- a/Telegram/ThirdParty/dispatch/src/.gitignore	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/.gitignore	1970-01-01 00:00:00.000000000 -0000
@@ -1,9 +0,0 @@
-provider.h
-module.map
-module.build.map
-.libs
-*.lo
-*.la
-*.o
-*.swiftmodule
-*.swiftdoc
--- a/Telegram/ThirdParty/dispatch/src/init.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/init.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,1774 +0,0 @@
-/*
- * Copyright (c) 2008-2013 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-// Contains exported global data and initialization & other routines that must
-// only exist once in the shared library even when resolvers are used.
-
-// NOTE: this file must not contain any atomic operations
-
-#include "internal.h"
-#if __linux__
-#include <linux/limits.h> // for PATH_MAX
-#endif
-
-#if HAVE_MACH
-#include "protocolServer.h"
-#endif
-
-#ifdef __linux__
-// The clang compiler in Ubuntu 18.04 has a bug that causes it to crash
-// when compiling _dispatch_bug_kevent_vanished(). As a workaround, use a
-// less capable version of this function on Linux until a fixed version
-// of the compiler is available.
-#define RDAR_49023449 1
-#endif // __linux__
-
-#pragma mark -
-#pragma mark dispatch_init
-
-
-#if USE_LIBDISPATCH_INIT_CONSTRUCTOR
-DISPATCH_NOTHROW __attribute__((constructor))
-void
-_libdispatch_init(void);
-
-DISPATCH_NOTHROW
-void
-_libdispatch_init(void)
-{
-	libdispatch_init();
-}
-#endif
-
-#if !defined(_WIN32)
-DISPATCH_EXPORT DISPATCH_NOTHROW
-void
-dispatch_atfork_prepare(void)
-{
-	_os_object_atfork_prepare();
-}
-
-DISPATCH_EXPORT DISPATCH_NOTHROW
-void
-dispatch_atfork_parent(void)
-{
-	_os_object_atfork_parent();
-}
-
-DISPATCH_EXPORT DISPATCH_NOTHROW
-void
-dispatch_atfork_child(void)
-{
-	_os_object_atfork_child();
-	_voucher_atfork_child();
-	_dispatch_event_loop_atfork_child();
-	if (_dispatch_is_multithreaded_inline()) {
-		_dispatch_child_of_unsafe_fork = true;
-	}
-	_dispatch_queue_atfork_child();
-	// clear the _PROHIBIT and _MULTITHREADED bits if set
-	_dispatch_unsafe_fork = 0;
-}
-
-int
-_dispatch_sigmask(void)
-{
-	sigset_t mask;
-	int r = 0;
-
-	/* Workaround: 6269619 Not all signals can be delivered on any thread */
-	r |= sigfillset(&mask);
-	r |= sigdelset(&mask, SIGILL);
-	r |= sigdelset(&mask, SIGTRAP);
-#if HAVE_DECL_SIGEMT
-	r |= sigdelset(&mask, SIGEMT);
-#endif
-	r |= sigdelset(&mask, SIGFPE);
-	r |= sigdelset(&mask, SIGBUS);
-	r |= sigdelset(&mask, SIGSEGV);
-	r |= sigdelset(&mask, SIGSYS);
-	r |= sigdelset(&mask, SIGPIPE);
-	r |= sigdelset(&mask, SIGPROF);
-	r |= pthread_sigmask(SIG_BLOCK, &mask, NULL);
-	return dispatch_assume_zero(r);
-}
-#endif
-
-#pragma mark -
-#pragma mark dispatch_globals
-
-DISPATCH_HIDE_SYMBOL(dispatch_assert_queue, 10.12, 10.0, 10.0, 3.0);
-DISPATCH_HIDE_SYMBOL(dispatch_assert_queue_not, 10.12, 10.0, 10.0, 3.0);
-DISPATCH_HIDE_SYMBOL(dispatch_queue_create_with_target, 10.12, 10.0, 10.0, 3.0);
-
-#if DISPATCH_COCOA_COMPAT
-void *(*_dispatch_begin_NSAutoReleasePool)(void);
-void (*_dispatch_end_NSAutoReleasePool)(void *);
-#endif
-
-#if DISPATCH_USE_THREAD_LOCAL_STORAGE
-_Thread_local struct dispatch_tsd __dispatch_tsd;
-#if defined(_WIN32)
-DWORD __dispatch_tsd_key;
-#else
-pthread_key_t __dispatch_tsd_key;
-#endif
-#elif !DISPATCH_USE_DIRECT_TSD
-pthread_key_t dispatch_queue_key;
-pthread_key_t dispatch_frame_key;
-pthread_key_t dispatch_cache_key;
-pthread_key_t dispatch_context_key;
-pthread_key_t dispatch_pthread_root_queue_observer_hooks_key;
-pthread_key_t dispatch_basepri_key;
-#if DISPATCH_INTROSPECTION
-pthread_key_t dispatch_introspection_key;
-#elif DISPATCH_PERF_MON
-pthread_key_t dispatch_bcounter_key;
-#endif
-pthread_key_t dispatch_wlh_key;
-pthread_key_t dispatch_voucher_key;
-pthread_key_t dispatch_deferred_items_key;
-#endif // !DISPATCH_USE_DIRECT_TSD && !DISPATCH_USE_THREAD_LOCAL_STORAGE
-
-#if VOUCHER_USE_MACH_VOUCHER
-dispatch_once_t _voucher_task_mach_voucher_pred;
-mach_voucher_t _voucher_task_mach_voucher;
-#if !VOUCHER_USE_EMPTY_MACH_BASE_VOUCHER
-mach_voucher_t _voucher_default_task_mach_voucher;
-#endif
-dispatch_once_t _firehose_task_buffer_pred;
-firehose_buffer_t _firehose_task_buffer;
-const uint32_t _firehose_spi_version = OS_FIREHOSE_SPI_VERSION;
-uint64_t _voucher_unique_pid;
-voucher_activity_hooks_t _voucher_libtrace_hooks;
-dispatch_mach_t _voucher_activity_debug_channel;
-#endif
-#if HAVE_PTHREAD_WORKQUEUE_QOS && DISPATCH_DEBUG
-bool _dispatch_set_qos_class_enabled;
-#endif
-#if DISPATCH_USE_KEVENT_WORKQUEUE && DISPATCH_USE_MGR_THREAD
-bool _dispatch_kevent_workqueue_enabled = 1;
-#endif
-
-DISPATCH_HW_CONFIG();
-uint8_t _dispatch_unsafe_fork;
-uint8_t _dispatch_mode;
-bool _dispatch_child_of_unsafe_fork;
-#if DISPATCH_USE_MEMORYPRESSURE_SOURCE
-bool _dispatch_memory_warn;
-int _dispatch_continuation_cache_limit = DISPATCH_CONTINUATION_CACHE_LIMIT;
-#endif
-
-DISPATCH_NOINLINE
-bool
-_dispatch_is_multithreaded(void)
-{
-	return _dispatch_is_multithreaded_inline();
-}
-
-DISPATCH_NOINLINE
-bool
-_dispatch_is_fork_of_multithreaded_parent(void)
-{
-	return _dispatch_child_of_unsafe_fork;
-}
-
-const struct dispatch_queue_offsets_s dispatch_queue_offsets = {
-	.dqo_version = 6,
-	.dqo_label = offsetof(struct dispatch_queue_s, dq_label),
-	.dqo_label_size = sizeof(((dispatch_queue_t)NULL)->dq_label),
-	.dqo_flags = 0,
-	.dqo_flags_size = 0,
-	.dqo_serialnum = offsetof(struct dispatch_queue_s, dq_serialnum),
-	.dqo_serialnum_size = sizeof(((dispatch_queue_t)NULL)->dq_serialnum),
-	.dqo_width = offsetof(struct dispatch_queue_s, dq_width),
-	.dqo_width_size = sizeof(((dispatch_queue_t)NULL)->dq_width),
-	.dqo_running = 0,
-	.dqo_running_size = 0,
-	.dqo_suspend_cnt = 0,
-	.dqo_suspend_cnt_size = 0,
-	.dqo_target_queue = offsetof(struct dispatch_queue_s, do_targetq),
-	.dqo_target_queue_size = sizeof(((dispatch_queue_t)NULL)->do_targetq),
-	.dqo_priority = 0,
-	.dqo_priority_size = 0,
-};
-
-#if TARGET_OS_MAC
-const struct dispatch_allocator_layout_s dispatch_allocator_layout = {
-	.dal_version = 1,
-#if DISPATCH_ALLOCATOR
-	.dal_allocator_zone = &_dispatch_main_heap,
-	.dal_deferred_free_isa = &_dispatch_main_heap,
-	.dal_allocation_size = DISPATCH_CONTINUATION_SIZE,
-	.dal_magazine_size = BYTES_PER_MAGAZINE,
-#if PACK_FIRST_PAGE_WITH_CONTINUATIONS
-	.dal_first_allocation_offset =
-			offsetof(struct dispatch_magazine_s, fp_conts),
-#else
-	.dal_first_allocation_offset =
-			offsetof(struct dispatch_magazine_s, conts),
-#endif
-	.dal_allocation_isa_offset =
-			offsetof(struct dispatch_continuation_s, dc_flags),
-	.dal_enumerator = &_dispatch_allocator_enumerate,
-#endif // DISPATCH_ALLOCATOR
-};
-#endif
-
-#if DISPATCH_USE_DIRECT_TSD
-const struct dispatch_tsd_indexes_s dispatch_tsd_indexes = {
-	.dti_version = 3,
-	.dti_queue_index = dispatch_queue_key,
-	.dti_voucher_index = dispatch_voucher_key,
-	.dti_qos_class_index = dispatch_priority_key,
-	.dti_continuation_cache_index = dispatch_cache_key,
-};
-#endif // DISPATCH_USE_DIRECT_TSD
-
-// 6618342 Contact the team that owns the Instrument DTrace probe before
-//         renaming this symbol
-struct dispatch_queue_static_s _dispatch_main_q = {
-	DISPATCH_GLOBAL_OBJECT_HEADER(queue_main),
-#if !DISPATCH_USE_RESOLVERS
-	.do_targetq = _dispatch_get_default_queue(true),
-#endif
-	.dq_state = DISPATCH_QUEUE_STATE_INIT_VALUE(1) |
-			DISPATCH_QUEUE_ROLE_BASE_ANON,
-	.dq_label = "com.apple.main-thread",
-	.dq_atomic_flags = DQF_THREAD_BOUND | DQF_WIDTH(1),
-	.dq_serialnum = 1,
-};
-
-#if DISPATCH_USE_MGR_THREAD && DISPATCH_USE_PTHREAD_ROOT_QUEUES
-static struct dispatch_pthread_root_queue_context_s
-_dispatch_mgr_root_queue_pthread_context;
-
-struct dispatch_queue_global_s _dispatch_mgr_root_queue = {
-	DISPATCH_GLOBAL_OBJECT_HEADER(queue_global),
-	.dq_state = DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE,
-	.do_ctxt = &_dispatch_mgr_root_queue_pthread_context,
-	.dq_label = "com.apple.root.libdispatch-manager",
-	.dq_atomic_flags = DQF_WIDTH(DISPATCH_QUEUE_WIDTH_POOL),
-	.dq_priority = DISPATCH_PRIORITY_FLAG_MANAGER |
-			DISPATCH_PRIORITY_SATURATED_OVERRIDE,
-	.dq_serialnum = 3,
-	.dgq_thread_pool_size = 1,
-};
-#else
-#define _dispatch_mgr_root_queue _dispatch_root_queues[\
-		DISPATCH_ROOT_QUEUE_IDX_USER_INTERACTIVE_QOS_OVERCOMMIT]
-#endif
-
-// 6618342 Contact the team that owns the Instrument DTrace probe before
-//         renaming this symbol
-struct dispatch_queue_static_s _dispatch_mgr_q = {
-	DISPATCH_GLOBAL_OBJECT_HEADER(queue_mgr),
-	.dq_state = DISPATCH_QUEUE_STATE_INIT_VALUE(1) |
-			DISPATCH_QUEUE_ROLE_BASE_ANON,
-	.do_ctxt = (void *)-1,
-	.do_targetq = _dispatch_mgr_root_queue._as_dq,
-	.dq_label = "com.apple.libdispatch-manager",
-	.dq_atomic_flags = DQF_WIDTH(1),
-	.dq_priority = DISPATCH_PRIORITY_FLAG_MANAGER |
-			DISPATCH_PRIORITY_SATURATED_OVERRIDE,
-	.dq_serialnum = 2,
-};
-
-#if DISPATCH_USE_INTERNAL_WORKQUEUE
-static struct dispatch_pthread_root_queue_context_s
-		_dispatch_pthread_root_queue_contexts[DISPATCH_ROOT_QUEUE_COUNT];
-#define _dispatch_root_queue_ctxt(n) &_dispatch_pthread_root_queue_contexts[n]
-#else
-#define _dispatch_root_queue_ctxt(n) NULL
-#endif // DISPATCH_USE_INTERNAL_WORKQUEUE
-
-// 6618342 Contact the team that owns the Instrument DTrace probe before
-//         renaming this symbol
-struct dispatch_queue_global_s _dispatch_root_queues[] = {
-#define _DISPATCH_ROOT_QUEUE_IDX(n, flags) \
-		((flags & DISPATCH_PRIORITY_FLAG_OVERCOMMIT) ? \
-		DISPATCH_ROOT_QUEUE_IDX_##n##_QOS_OVERCOMMIT : \
-		DISPATCH_ROOT_QUEUE_IDX_##n##_QOS)
-#define _DISPATCH_ROOT_QUEUE_ENTRY(n, flags, ...) \
-	[_DISPATCH_ROOT_QUEUE_IDX(n, flags)] = { \
-		DISPATCH_GLOBAL_OBJECT_HEADER(queue_global), \
-		.dq_state = DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE, \
-		.do_ctxt = _dispatch_root_queue_ctxt(_DISPATCH_ROOT_QUEUE_IDX(n, flags)), \
-		.dq_atomic_flags = DQF_WIDTH(DISPATCH_QUEUE_WIDTH_POOL), \
-		.dq_priority = flags | ((flags & DISPATCH_PRIORITY_FLAG_FALLBACK) ? \
-				_dispatch_priority_make_fallback(DISPATCH_QOS_##n) : \
-				_dispatch_priority_make(DISPATCH_QOS_##n, 0)), \
-		__VA_ARGS__ \
-	}
-	_DISPATCH_ROOT_QUEUE_ENTRY(MAINTENANCE, 0,
-		.dq_label = "com.apple.root.maintenance-qos",
-		.dq_serialnum = 4,
-	),
-	_DISPATCH_ROOT_QUEUE_ENTRY(MAINTENANCE, DISPATCH_PRIORITY_FLAG_OVERCOMMIT,
-		.dq_label = "com.apple.root.maintenance-qos.overcommit",
-		.dq_serialnum = 5,
-	),
-	_DISPATCH_ROOT_QUEUE_ENTRY(BACKGROUND, 0,
-		.dq_label = "com.apple.root.background-qos",
-		.dq_serialnum = 6,
-	),
-	_DISPATCH_ROOT_QUEUE_ENTRY(BACKGROUND, DISPATCH_PRIORITY_FLAG_OVERCOMMIT,
-		.dq_label = "com.apple.root.background-qos.overcommit",
-		.dq_serialnum = 7,
-	),
-	_DISPATCH_ROOT_QUEUE_ENTRY(UTILITY, 0,
-		.dq_label = "com.apple.root.utility-qos",
-		.dq_serialnum = 8,
-	),
-	_DISPATCH_ROOT_QUEUE_ENTRY(UTILITY, DISPATCH_PRIORITY_FLAG_OVERCOMMIT,
-		.dq_label = "com.apple.root.utility-qos.overcommit",
-		.dq_serialnum = 9,
-	),
-	_DISPATCH_ROOT_QUEUE_ENTRY(DEFAULT, DISPATCH_PRIORITY_FLAG_FALLBACK,
-		.dq_label = "com.apple.root.default-qos",
-		.dq_serialnum = 10,
-	),
-	_DISPATCH_ROOT_QUEUE_ENTRY(DEFAULT,
-			DISPATCH_PRIORITY_FLAG_FALLBACK | DISPATCH_PRIORITY_FLAG_OVERCOMMIT,
-		.dq_label = "com.apple.root.default-qos.overcommit",
-		.dq_serialnum = 11,
-	),
-	_DISPATCH_ROOT_QUEUE_ENTRY(USER_INITIATED, 0,
-		.dq_label = "com.apple.root.user-initiated-qos",
-		.dq_serialnum = 12,
-	),
-	_DISPATCH_ROOT_QUEUE_ENTRY(USER_INITIATED, DISPATCH_PRIORITY_FLAG_OVERCOMMIT,
-		.dq_label = "com.apple.root.user-initiated-qos.overcommit",
-		.dq_serialnum = 13,
-	),
-	_DISPATCH_ROOT_QUEUE_ENTRY(USER_INTERACTIVE, 0,
-		.dq_label = "com.apple.root.user-interactive-qos",
-		.dq_serialnum = 14,
-	),
-	_DISPATCH_ROOT_QUEUE_ENTRY(USER_INTERACTIVE, DISPATCH_PRIORITY_FLAG_OVERCOMMIT,
-		.dq_label = "com.apple.root.user-interactive-qos.overcommit",
-		.dq_serialnum = 15,
-	),
-};
-
-unsigned long volatile _dispatch_queue_serial_numbers =
-		DISPATCH_QUEUE_SERIAL_NUMBER_INIT;
-
-
-dispatch_queue_global_t
-dispatch_get_global_queue(intptr_t priority, uintptr_t flags)
-{
-	dispatch_assert(countof(_dispatch_root_queues) ==
-			DISPATCH_ROOT_QUEUE_COUNT);
-
-	if (flags & ~(unsigned long)DISPATCH_QUEUE_OVERCOMMIT) {
-		return DISPATCH_BAD_INPUT;
-	}
-	dispatch_qos_t qos = _dispatch_qos_from_queue_priority(priority);
-#if !HAVE_PTHREAD_WORKQUEUE_QOS
-	if (qos == QOS_CLASS_MAINTENANCE) {
-		qos = DISPATCH_QOS_BACKGROUND;
-	} else if (qos == QOS_CLASS_USER_INTERACTIVE) {
-		qos = DISPATCH_QOS_USER_INITIATED;
-	}
-#endif
-	if (qos == DISPATCH_QOS_UNSPECIFIED) {
-		return DISPATCH_BAD_INPUT;
-	}
-	return _dispatch_get_root_queue(qos, flags & DISPATCH_QUEUE_OVERCOMMIT);
-}
-
-dispatch_queue_t
-dispatch_get_current_queue(void)
-{
-	return _dispatch_queue_get_current_or_default();
-}
-
-#pragma mark -
-#pragma mark dispatch_queue_attr_t
-
-// DISPATCH_QUEUE_CONCURRENT resp. _dispatch_queue_attr_concurrent is aliased
-// to array member [0] and their properties must match!
-const struct dispatch_queue_attr_s _dispatch_queue_attrs[] = {
-	[0 ... DISPATCH_QUEUE_ATTR_COUNT - 1] = {
-		DISPATCH_GLOBAL_OBJECT_HEADER(queue_attr),
-	},
-};
-
-#if DISPATCH_VARIANT_STATIC
-// <rdar://problem/16778703>
-struct dispatch_queue_attr_s _dispatch_queue_attr_concurrent = {
-	DISPATCH_GLOBAL_OBJECT_HEADER(queue_attr),
-};
-#endif // DISPATCH_VARIANT_STATIC
-
-// _dispatch_queue_attr_concurrent is aliased using libdispatch.aliases
-// and the -alias_list linker option on Darwin but needs to be done manually
-// for other platforms.
-#ifndef __APPLE__
-extern struct dispatch_queue_attr_s _dispatch_queue_attr_concurrent
-	__attribute__((__alias__("_dispatch_queue_attrs")));
-#endif
-
-dispatch_queue_attr_info_t
-_dispatch_queue_attr_to_info(dispatch_queue_attr_t dqa)
-{
-	dispatch_queue_attr_info_t dqai = { };
-
-	if (!dqa) return dqai;
-
-#if DISPATCH_VARIANT_STATIC
-	if (dqa == &_dispatch_queue_attr_concurrent) {
-		dqai.dqai_concurrent = true;
-		return dqai;
-	}
-#endif
-
-	if (dqa < _dispatch_queue_attrs ||
-			dqa >= &_dispatch_queue_attrs[DISPATCH_QUEUE_ATTR_COUNT]) {
-#ifndef __APPLE__
-		if (memcmp(dqa, &_dispatch_queue_attrs[0],
-				sizeof(struct dispatch_queue_attr_s)) == 0) {
-			dqa = (dispatch_queue_attr_t)&_dispatch_queue_attrs[0];
-		} else
-#endif // __APPLE__
-		DISPATCH_CLIENT_CRASH(dqa->do_vtable, "Invalid queue attribute");
-	}
-
-	size_t idx = (size_t)(dqa - _dispatch_queue_attrs);
-
-	dqai.dqai_inactive = (idx % DISPATCH_QUEUE_ATTR_INACTIVE_COUNT);
-	idx /= DISPATCH_QUEUE_ATTR_INACTIVE_COUNT;
-
-	dqai.dqai_concurrent = !(idx % DISPATCH_QUEUE_ATTR_CONCURRENCY_COUNT);
-	idx /= DISPATCH_QUEUE_ATTR_CONCURRENCY_COUNT;
-
-	dqai.dqai_relpri = -(int)(idx % DISPATCH_QUEUE_ATTR_PRIO_COUNT);
-	idx /= DISPATCH_QUEUE_ATTR_PRIO_COUNT;
-
-	dqai.dqai_qos = idx % DISPATCH_QUEUE_ATTR_QOS_COUNT;
-	idx /= DISPATCH_QUEUE_ATTR_QOS_COUNT;
-
-	dqai.dqai_autorelease_frequency =
-			idx % DISPATCH_QUEUE_ATTR_AUTORELEASE_FREQUENCY_COUNT;
-	idx /= DISPATCH_QUEUE_ATTR_AUTORELEASE_FREQUENCY_COUNT;
-
-	dqai.dqai_overcommit = idx % DISPATCH_QUEUE_ATTR_OVERCOMMIT_COUNT;
-	idx /= DISPATCH_QUEUE_ATTR_OVERCOMMIT_COUNT;
-
-	return dqai;
-}
-
-static dispatch_queue_attr_t
-_dispatch_queue_attr_from_info(dispatch_queue_attr_info_t dqai)
-{
-	size_t idx = 0;
-
-	idx *= DISPATCH_QUEUE_ATTR_OVERCOMMIT_COUNT;
-	idx += dqai.dqai_overcommit;
-
-	idx *= DISPATCH_QUEUE_ATTR_AUTORELEASE_FREQUENCY_COUNT;
-	idx += dqai.dqai_autorelease_frequency;
-
-	idx *= DISPATCH_QUEUE_ATTR_QOS_COUNT;
-	idx += dqai.dqai_qos;
-
-	idx *= DISPATCH_QUEUE_ATTR_PRIO_COUNT;
-	idx += (size_t)(-dqai.dqai_relpri);
-
-	idx *= DISPATCH_QUEUE_ATTR_CONCURRENCY_COUNT;
-	idx += !dqai.dqai_concurrent;
-
-	idx *= DISPATCH_QUEUE_ATTR_INACTIVE_COUNT;
-	idx += dqai.dqai_inactive;
-
-	return (dispatch_queue_attr_t)&_dispatch_queue_attrs[idx];
-}
-
-dispatch_queue_attr_t
-dispatch_queue_attr_make_with_qos_class(dispatch_queue_attr_t dqa,
-		dispatch_qos_class_t qos_class, int relpri)
-{
-	if (!_dispatch_qos_class_valid(qos_class, relpri)) {
-		return (dispatch_queue_attr_t)dqa;
-	}
-	dispatch_queue_attr_info_t dqai = _dispatch_queue_attr_to_info(dqa);
-	dqai.dqai_qos = _dispatch_qos_from_qos_class(qos_class);
-	dqai.dqai_relpri = relpri;
-	return _dispatch_queue_attr_from_info(dqai);
-}
-
-dispatch_queue_attr_t
-dispatch_queue_attr_make_initially_inactive(dispatch_queue_attr_t dqa)
-{
-	dispatch_queue_attr_info_t dqai = _dispatch_queue_attr_to_info(dqa);
-	dqai.dqai_inactive = true;
-	return _dispatch_queue_attr_from_info(dqai);
-}
-
-dispatch_queue_attr_t
-dispatch_queue_attr_make_with_overcommit(dispatch_queue_attr_t dqa,
-		bool overcommit)
-{
-	dispatch_queue_attr_info_t dqai = _dispatch_queue_attr_to_info(dqa);
-	if (overcommit) {
-		dqai.dqai_overcommit = _dispatch_queue_attr_overcommit_enabled;
-	} else {
-		dqai.dqai_overcommit = _dispatch_queue_attr_overcommit_disabled;
-	}
-	return _dispatch_queue_attr_from_info(dqai);
-}
-
-dispatch_queue_attr_t
-dispatch_queue_attr_make_with_autorelease_frequency(dispatch_queue_attr_t dqa,
-		dispatch_autorelease_frequency_t frequency)
-{
-	switch (frequency) {
-	case DISPATCH_AUTORELEASE_FREQUENCY_INHERIT:
-	case DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM:
-	case DISPATCH_AUTORELEASE_FREQUENCY_NEVER:
-		break;
-	}
-	dispatch_queue_attr_info_t dqai = _dispatch_queue_attr_to_info(dqa);
-	dqai.dqai_autorelease_frequency = (uint16_t)frequency;
-	return _dispatch_queue_attr_from_info(dqai);
-}
-
-#pragma mark -
-#pragma mark dispatch_vtables
-
-DISPATCH_NOINLINE
-static void
-_dispatch_object_no_dispose(dispatch_object_t dou,
-		DISPATCH_UNUSED bool *allow_free)
-{
-	DISPATCH_INTERNAL_CRASH(dx_type(dou._do), "do_dispose called");
-}
-
-DISPATCH_NOINLINE
-static size_t
-_dispatch_object_missing_debug(DISPATCH_UNUSED dispatch_object_t dou,
-		char *buf, size_t bufsiz)
-{
-	return strlcpy(buf, "missing do_debug vtable slot: ", bufsiz);
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_object_no_invoke(dispatch_object_t dou,
-		DISPATCH_UNUSED dispatch_invoke_context_t dic,
-		DISPATCH_UNUSED dispatch_invoke_flags_t flags)
-{
-	DISPATCH_INTERNAL_CRASH(dx_type(dou._do), "do_invoke called");
-}
-
-/*
- * Dispatch object cluster
- */
-
-DISPATCH_VTABLE_INSTANCE(semaphore,
-	.do_type        = DISPATCH_SEMAPHORE_TYPE,
-	.do_dispose     = _dispatch_semaphore_dispose,
-	.do_debug       = _dispatch_semaphore_debug,
-	.do_invoke      = _dispatch_object_no_invoke,
-);
-
-DISPATCH_VTABLE_INSTANCE(group,
-	.do_type        = DISPATCH_GROUP_TYPE,
-	.do_dispose     = _dispatch_group_dispose,
-	.do_debug       = _dispatch_group_debug,
-	.do_invoke      = _dispatch_object_no_invoke,
-);
-
-#if !DISPATCH_DATA_IS_BRIDGED_TO_NSDATA
-DISPATCH_VTABLE_INSTANCE(data,
-	.do_type        = DISPATCH_DATA_TYPE,
-	.do_dispose     = _dispatch_data_dispose,
-	.do_debug       = _dispatch_data_debug,
-	.do_invoke      = _dispatch_object_no_invoke,
-);
-#endif
-
-DISPATCH_VTABLE_INSTANCE(queue_attr,
-	.do_type        = DISPATCH_QUEUE_ATTR_TYPE,
-	.do_dispose     = _dispatch_object_no_dispose,
-	.do_debug       = _dispatch_object_missing_debug,
-	.do_invoke      = _dispatch_object_no_invoke,
-);
-
-#if HAVE_MACH
-DISPATCH_VTABLE_INSTANCE(mach_msg,
-	.do_type        = DISPATCH_MACH_MSG_TYPE,
-	.do_dispose     = _dispatch_mach_msg_dispose,
-	.do_debug       = _dispatch_mach_msg_debug,
-	.do_invoke      = _dispatch_mach_msg_invoke,
-);
-#endif // HAVE_MACH
-
-DISPATCH_VTABLE_INSTANCE(io,
-	.do_type        = DISPATCH_IO_TYPE,
-	.do_dispose     = _dispatch_io_dispose,
-	.do_debug       = _dispatch_io_debug,
-	.do_invoke      = _dispatch_object_no_invoke,
-);
-
-DISPATCH_VTABLE_INSTANCE(operation,
-	.do_type        = DISPATCH_OPERATION_TYPE,
-	.do_dispose     = _dispatch_operation_dispose,
-	.do_debug       = _dispatch_operation_debug,
-	.do_invoke      = _dispatch_object_no_invoke,
-);
-
-DISPATCH_VTABLE_INSTANCE(disk,
-	.do_type        = DISPATCH_DISK_TYPE,
-	.do_dispose     = _dispatch_disk_dispose,
-	.do_debug       = _dispatch_object_missing_debug,
-	.do_invoke      = _dispatch_object_no_invoke,
-);
-
-/*
- * Dispatch queue cluster
- */
-
-DISPATCH_NOINLINE
-static void
-_dispatch_queue_no_activate(dispatch_queue_class_t dqu,
-		DISPATCH_UNUSED bool *allow_resume)
-{
-	DISPATCH_INTERNAL_CRASH(dx_type(dqu._dq), "dq_activate called");
-}
-
-DISPATCH_VTABLE_INSTANCE(queue,
-	// This is the base class for queues, no objects of this type are made
-	.do_type        = _DISPATCH_QUEUE_CLUSTER,
-	.do_dispose     = _dispatch_object_no_dispose,
-	.do_debug       = _dispatch_queue_debug,
-	.do_invoke      = _dispatch_object_no_invoke,
-
-	.dq_activate    = _dispatch_queue_no_activate,
-);
-
-DISPATCH_VTABLE_INSTANCE(workloop,
-	.do_type        = DISPATCH_WORKLOOP_TYPE,
-	.do_dispose     = _dispatch_workloop_dispose,
-	.do_debug       = _dispatch_queue_debug,
-	.do_invoke      = _dispatch_workloop_invoke,
-
-	.dq_activate    = _dispatch_queue_no_activate,
-	.dq_wakeup      = _dispatch_workloop_wakeup,
-	.dq_push        = _dispatch_workloop_push,
-);
-
-DISPATCH_VTABLE_SUBCLASS_INSTANCE(queue_serial, lane,
-	.do_type        = DISPATCH_QUEUE_SERIAL_TYPE,
-	.do_dispose     = _dispatch_lane_dispose,
-	.do_debug       = _dispatch_queue_debug,
-	.do_invoke      = _dispatch_lane_invoke,
-
-	.dq_activate    = _dispatch_lane_activate,
-	.dq_wakeup      = _dispatch_lane_wakeup,
-	.dq_push        = _dispatch_lane_push,
-);
-
-DISPATCH_VTABLE_SUBCLASS_INSTANCE(queue_concurrent, lane,
-	.do_type        = DISPATCH_QUEUE_CONCURRENT_TYPE,
-	.do_dispose     = _dispatch_lane_dispose,
-	.do_debug       = _dispatch_queue_debug,
-	.do_invoke      = _dispatch_lane_invoke,
-
-	.dq_activate    = _dispatch_lane_activate,
-	.dq_wakeup      = _dispatch_lane_wakeup,
-	.dq_push        = _dispatch_lane_concurrent_push,
-);
-
-DISPATCH_VTABLE_SUBCLASS_INSTANCE(queue_global, lane,
-	.do_type        = DISPATCH_QUEUE_GLOBAL_ROOT_TYPE,
-	.do_dispose     = _dispatch_object_no_dispose,
-	.do_debug       = _dispatch_queue_debug,
-	.do_invoke      = _dispatch_object_no_invoke,
-
-	.dq_activate    = _dispatch_queue_no_activate,
-	.dq_wakeup      = _dispatch_root_queue_wakeup,
-	.dq_push        = _dispatch_root_queue_push,
-);
-
-#if DISPATCH_USE_PTHREAD_ROOT_QUEUES
-DISPATCH_VTABLE_SUBCLASS_INSTANCE(queue_pthread_root, lane,
-	.do_type        = DISPATCH_QUEUE_PTHREAD_ROOT_TYPE,
-	.do_dispose     = _dispatch_pthread_root_queue_dispose,
-	.do_debug       = _dispatch_queue_debug,
-	.do_invoke      = _dispatch_object_no_invoke,
-
-	.dq_activate    = _dispatch_queue_no_activate,
-	.dq_wakeup      = _dispatch_root_queue_wakeup,
-	.dq_push        = _dispatch_root_queue_push,
-);
-#endif // DISPATCH_USE_PTHREAD_ROOT_QUEUES
-
-DISPATCH_VTABLE_SUBCLASS_INSTANCE(queue_mgr, lane,
-	.do_type        = DISPATCH_QUEUE_MGR_TYPE,
-	.do_dispose     = _dispatch_object_no_dispose,
-	.do_debug       = _dispatch_queue_debug,
-#if DISPATCH_USE_MGR_THREAD
-	.do_invoke      = _dispatch_mgr_thread,
-#else
-	.do_invoke      = _dispatch_object_no_invoke,
-#endif
-
-	.dq_activate    = _dispatch_queue_no_activate,
-	.dq_wakeup      = _dispatch_mgr_queue_wakeup,
-	.dq_push        = _dispatch_mgr_queue_push,
-);
-
-DISPATCH_VTABLE_SUBCLASS_INSTANCE(queue_main, lane,
-	.do_type        = DISPATCH_QUEUE_MAIN_TYPE,
-	.do_dispose     = _dispatch_lane_dispose,
-	.do_debug       = _dispatch_queue_debug,
-	.do_invoke      = _dispatch_lane_invoke,
-
-	.dq_activate    = _dispatch_queue_no_activate,
-	.dq_wakeup      = _dispatch_main_queue_wakeup,
-	.dq_push        = _dispatch_main_queue_push,
-);
-
-#if DISPATCH_COCOA_COMPAT
-DISPATCH_VTABLE_SUBCLASS_INSTANCE(queue_runloop, lane,
-	.do_type        = DISPATCH_QUEUE_RUNLOOP_TYPE,
-	.do_dispose     = _dispatch_runloop_queue_dispose,
-	.do_debug       = _dispatch_queue_debug,
-	.do_invoke      = _dispatch_lane_invoke,
-
-	.dq_activate    = _dispatch_queue_no_activate,
-	.dq_wakeup      = _dispatch_runloop_queue_wakeup,
-	.dq_push        = _dispatch_lane_push,
-);
-#endif
-
-DISPATCH_VTABLE_INSTANCE(source,
-	.do_type        = DISPATCH_SOURCE_KEVENT_TYPE,
-	.do_dispose     = _dispatch_source_dispose,
-	.do_debug       = _dispatch_source_debug,
-	.do_invoke      = _dispatch_source_invoke,
-
-	.dq_activate    = _dispatch_source_activate,
-	.dq_wakeup      = _dispatch_source_wakeup,
-	.dq_push        = _dispatch_lane_push,
-);
-
-#if HAVE_MACH
-DISPATCH_VTABLE_INSTANCE(mach,
-	.do_type        = DISPATCH_MACH_CHANNEL_TYPE,
-	.do_dispose     = _dispatch_mach_dispose,
-	.do_debug       = _dispatch_mach_debug,
-	.do_invoke      = _dispatch_mach_invoke,
-
-	.dq_activate    = _dispatch_mach_activate,
-	.dq_wakeup      = _dispatch_mach_wakeup,
-	.dq_push        = _dispatch_lane_push,
-);
-#endif // HAVE_MACH
-
-void
-_dispatch_vtable_init(void)
-{
-#if OS_OBJECT_HAVE_OBJC2
-	// ObjC classes and dispatch vtables are co-located via linker order and
-	// alias files, verify correct layout during initialization rdar://10640168
-	dispatch_assert((char*)&DISPATCH_CONCAT(_,DISPATCH_CLASS(semaphore_vtable))
-			- (char*)DISPATCH_VTABLE(semaphore) ==
-			offsetof(struct dispatch_semaphore_vtable_s, _os_obj_vtable));
-#endif // USE_OBJC
-}
-
-#pragma mark -
-#pragma mark dispatch_data globals
-
-const dispatch_block_t _dispatch_data_destructor_free = ^{
-	DISPATCH_INTERNAL_CRASH(0, "free destructor called");
-};
-
-const dispatch_block_t _dispatch_data_destructor_none = ^{
-	DISPATCH_INTERNAL_CRASH(0, "none destructor called");
-};
-
-#if !HAVE_MACH
-const dispatch_block_t _dispatch_data_destructor_munmap = ^{
-	DISPATCH_INTERNAL_CRASH(0, "munmap destructor called");
-};
-#else
-// _dispatch_data_destructor_munmap is a linker alias to the following
-const dispatch_block_t _dispatch_data_destructor_vm_deallocate = ^{
-	DISPATCH_INTERNAL_CRASH(0, "vmdeallocate destructor called");
-};
-#endif
-
-const dispatch_block_t _dispatch_data_destructor_inline = ^{
-	DISPATCH_INTERNAL_CRASH(0, "inline destructor called");
-};
-
-struct dispatch_data_s _dispatch_data_empty = {
-#if DISPATCH_DATA_IS_BRIDGED_TO_NSDATA
-	.do_vtable = DISPATCH_DATA_EMPTY_CLASS,
-#else
-	DISPATCH_GLOBAL_OBJECT_HEADER(data),
-	.do_next = DISPATCH_OBJECT_LISTLESS,
-#endif
-};
-
-#pragma mark -
-#pragma mark dispatch_bug
-
-static char _dispatch_build[16];
-
-static void
-_dispatch_build_init(void *context DISPATCH_UNUSED)
-{
-#ifdef __APPLE__
-	int mib[] = { CTL_KERN, KERN_OSVERSION };
-	size_t bufsz = sizeof(_dispatch_build);
-
-	sysctl(mib, 2, _dispatch_build, &bufsz, NULL, 0);
-#if TARGET_OS_SIMULATOR
-	char *sim_version = getenv("SIMULATOR_RUNTIME_BUILD_VERSION");
-	if (sim_version) {
-		(void)strlcat(_dispatch_build, " ", sizeof(_dispatch_build));
-		(void)strlcat(_dispatch_build, sim_version, sizeof(_dispatch_build));
-	}
-#endif // TARGET_OS_SIMULATOR
-
-#else
-	/*
-	 * XXXRW: What to do here for !Mac OS X?
-	 */
-	memset(_dispatch_build, 0, sizeof(_dispatch_build));
-#endif // __APPLE__
-}
-
-static dispatch_once_t _dispatch_build_pred;
-
-bool
-_dispatch_parse_bool(const char *v)
-{
-	return strcasecmp(v, "YES") == 0 || strcasecmp(v, "Y") == 0 ||
-			strcasecmp(v, "TRUE") == 0 || atoi(v);
-}
-
-DISPATCH_NOINLINE
-bool
-_dispatch_getenv_bool(const char *env, bool default_v)
-{
-	const char *v = getenv(env);
-
-	return v ? _dispatch_parse_bool(v) : default_v;
-}
-
-char*
-_dispatch_get_build(void)
-{
-	dispatch_once_f(&_dispatch_build_pred, NULL, _dispatch_build_init);
-	return _dispatch_build;
-}
-
-#define _dispatch_bug_log_is_repeated() ({ \
-		static void *last_seen; \
-		void *previous = last_seen; \
-		last_seen =__builtin_return_address(0); \
-		last_seen == previous; \
-	})
-
-#if HAVE_OS_FAULT_WITH_PAYLOAD
-__attribute__((__format__(__printf__,2,3)))
-static void
-_dispatch_fault(const char *reason, const char *fmt, ...)
-{
-	char buf[1024];
-	va_list ap;
-
-	va_start(ap, fmt);
-	vsnprintf(buf, sizeof(buf), fmt, ap);
-	va_end(ap);
-
-	if (_dispatch_mode & DISPATCH_MODE_STRICT) {
-#if TARGET_OS_IPHONE && !TARGET_OS_SIMULATOR
-	} else if (!(_dispatch_mode & DISPATCH_MODE_NO_FAULTS)) {
-		os_fault_with_payload(OS_REASON_LIBSYSTEM,
-				OS_REASON_LIBSYSTEM_CODE_FAULT,
-				buf, (uint32_t)strlen(buf) + 1, reason, 0);
-#else
-		(void)reason;
-#endif
-	}
-}
-#else
-#define _dispatch_fault(reason, fmt, ...)
-#endif // HAVE_OS_FAULT_WITH_PAYLOAD
-
-#define _dispatch_log_fault(reason, fmt, ...)  ({ \
-		if (!_dispatch_bug_log_is_repeated()) { \
-			_dispatch_log(fmt, ##__VA_ARGS__); \
-			_dispatch_fault(reason, fmt, ##__VA_ARGS__); \
-			if (_dispatch_mode & DISPATCH_MODE_STRICT) { \
-				DISPATCH_CLIENT_CRASH(0, reason); \
-			} \
-		} \
-	})
-
-void
-_dispatch_bug(size_t line, long val)
-{
-	dispatch_once_f(&_dispatch_build_pred, NULL, _dispatch_build_init);
-
-	if (_dispatch_bug_log_is_repeated()) return;
-
-	_dispatch_log("BUG in libdispatch: %s - %lu - 0x%lx",
-			_dispatch_build, (unsigned long)line, val);
-}
-
-#if HAVE_MACH
-void
-_dispatch_bug_mach_client(const char *msg, mach_msg_return_t kr)
-{
-	_dispatch_log_fault("LIBDISPATCH_STRICT: _dispatch_bug_mach_client",
-			"BUG in libdispatch client: %s %s - 0x%x", msg,
-			mach_error_string(kr), kr);
-}
-#endif
-
-void *
-_dispatch_continuation_get_function_symbol(dispatch_continuation_t dc)
-{
-	if (dc->dc_flags & DC_FLAG_BLOCK_WITH_PRIVATE_DATA) {
-		dispatch_block_private_data_t dpbd = _dispatch_block_get_data(dc->dc_ctxt);
-		return _dispatch_Block_invoke(dpbd->dbpd_block);
-	}
-	if (dc->dc_flags & DC_FLAG_BLOCK) {
-		return _dispatch_Block_invoke(dc->dc_ctxt);
-	}
-	return dc->dc_func;
-}
-
-#if HAVE_MACH
-void
-_dispatch_bug_kevent_client(const char *msg, const char *filter,
-		const char *operation, int err, uint64_t ident, uint64_t udata,
-		dispatch_unote_t du)
-{
-	dispatch_continuation_t dc;
-	dispatch_object_t dou;
-	void *func = NULL;
-
-	if (du._du) {
-		dou._do = _dispatch_wref2ptr(du._du->du_owner_wref);
-		switch (dx_type(dou._do)) {
-		case DISPATCH_SOURCE_KEVENT_TYPE:
-			dc = du._dr->ds_handler[DS_EVENT_HANDLER];
-			if (dc) func = _dispatch_continuation_get_function_symbol(dc);
-			break;
-#if HAVE_MACH
-		case DISPATCH_MACH_CHANNEL_TYPE:
-			func = du._dmrr->dmrr_handler_func;
-			break;
-#endif // HAVE_MACH
-		}
-		filter = dux_type(du._du)->dst_kind;
-	}
-
-	if (operation && err) {
-		_dispatch_log_fault("LIBDISPATCH_STRICT: _dispatch_bug_kevent_client",
-				"BUG in libdispatch client: %s %s: \"%s\" - 0x%x "
-				"{ 0x%"PRIx64"[%s], ident: %"PRId64" / 0x%"PRIx64", handler: %p }",
-				msg, operation, strerror(err), err,
-				udata, filter, ident, ident, func);
-	} else if (operation) {
-		_dispatch_log_fault("LIBDISPATCH_STRICT: _dispatch_bug_kevent_client",
-				"BUG in libdispatch client: %s %s"
-				"{ 0x%"PRIx64"[%s], ident: %"PRId64" / 0x%"PRIx64", handler: %p }",
-				msg, operation, udata, filter, ident, ident, func);
-	} else {
-		_dispatch_log_fault("LIBDISPATCH_STRICT: _dispatch_bug_kevent_client",
-				"BUG in libdispatch: %s: \"%s\" - 0x%x"
-				"{ 0x%"PRIx64"[%s], ident: %"PRId64" / 0x%"PRIx64", handler: %p }",
-				msg, strerror(err), err, udata, filter, ident, ident, func);
-	}
-}
-#endif // HAVE_MACH
-
-#if RDAR_49023449
-
-// The clang compiler on Ubuntu18.04 crashes when compiling the full version of
-// this function. This reduced version avoids the crash but logs less useful
-// information.
-void
-_dispatch_bug_kevent_vanished(dispatch_unote_t du)
-{
-	_dispatch_log_fault("LIBDISPATCH_STRICT: _dispatch_bug_kevent_vanished",
-			"BUG in libdispatch client: %s, monitored resource vanished before "
-			"the source cancel handler was invoked",
-			dux_type(du._du)->dst_kind);
-}
-
-#else // RDAR_49023449
-
-void
-_dispatch_bug_kevent_vanished(dispatch_unote_t du)
-{
-	dispatch_continuation_t dc;
-	dispatch_object_t dou;
-	void *func = NULL;
-
-	dou._do = _dispatch_wref2ptr(du._du->du_owner_wref);
-	switch (dx_type(dou._do)) {
-	case DISPATCH_SOURCE_KEVENT_TYPE:
-		dc = du._dr->ds_handler[DS_EVENT_HANDLER];
-		if (dc) func = _dispatch_continuation_get_function_symbol(dc);
-		break;
-#if HAVE_MACH
-	case DISPATCH_MACH_CHANNEL_TYPE:
-		func = du._dmrr->dmrr_handler_func;
-		break;
-#endif // MACH
-	}
-	_dispatch_log_fault("LIBDISPATCH_STRICT: _dispatch_bug_kevent_vanished",
-			"BUG in libdispatch client: %s, monitored resource vanished before "
-			"the source cancel handler was invoked "
-			"{ %p[%s], ident: %" PRIdPTR " / 0x%" PRIxPTR ", handler: %p }",
-			dux_type(du._du)->dst_kind, dou._dq,
-			dou._dq->dq_label ? dou._dq->dq_label : "<unknown>",
-			du._du->du_ident, du._du->du_ident, func);
-}
-
-#endif // RDAR_49023449
-
-DISPATCH_NOINLINE DISPATCH_WEAK
-void
-_dispatch_bug_deprecated(const char *msg)
-{
-	_dispatch_log_fault("LIBDISPATCH_STRICT: _dispatch_bug_deprecated",
-			"DEPRECATED USE in libdispatch client: %s; "
-			"set a breakpoint on _dispatch_bug_deprecated to debug", msg);
-}
-
-void
-_dispatch_abort(size_t line, long val)
-{
-	_dispatch_bug(line, val);
-	abort();
-}
-
-#if !DISPATCH_USE_OS_DEBUG_LOG
-
-#pragma mark -
-#pragma mark dispatch_log
-
-static int dispatch_logfile = -1;
-static bool dispatch_log_disabled;
-#if DISPATCH_DEBUG
-static uint64_t dispatch_log_basetime;
-#endif
-static dispatch_once_t _dispatch_logv_pred;
-
-static void
-_dispatch_logv_init(void *context DISPATCH_UNUSED)
-{
-#if DISPATCH_DEBUG
-	bool log_to_file = true;
-#else
-	bool log_to_file = false;
-#endif
-	char *e = getenv("LIBDISPATCH_LOG");
-	if (e) {
-		if (strcmp(e, "YES") == 0) {
-			// default
-		} else if (strcmp(e, "NO") == 0) {
-			dispatch_log_disabled = true;
-		} else if (strcmp(e, "syslog") == 0) {
-			log_to_file = false;
-		} else if (strcmp(e, "file") == 0) {
-			log_to_file = true;
-		} else if (strcmp(e, "stderr") == 0) {
-			log_to_file = true;
-#if defined(_WIN32)
-			dispatch_logfile = _fileno(stderr);
-#else
-			dispatch_logfile = STDERR_FILENO;
-#endif
-		}
-	}
-	if (!dispatch_log_disabled) {
-		if (log_to_file && dispatch_logfile == -1) {
-#if defined(_WIN32)
-			char path[MAX_PATH + 1] = {0};
-			DWORD dwLength = GetTempPathA(MAX_PATH, path);
-			dispatch_assert(dwLength <= MAX_PATH + 1);
-			snprintf(&path[dwLength], MAX_PATH - dwLength, "libdispatch.%lu.log",
-					GetCurrentProcessId());
-			dispatch_logfile = _open(path, O_WRONLY | O_APPEND | O_CREAT, 0666);
-#else
-			char path[PATH_MAX];
-			snprintf(path, sizeof(path), "/var/tmp/libdispatch.%d.log",
-					getpid());
-			dispatch_logfile = open(path, O_WRONLY | O_APPEND | O_CREAT |
-					O_NOFOLLOW | O_CLOEXEC, 0666);
-#endif
-		}
-		if (dispatch_logfile != -1) {
-			struct timeval tv;
-#if defined(_WIN32)
-			DWORD dwTime = GetTickCount();
-			tv.tv_sec = dwTime / 1000;
-			tv.tv_usec = 1000 * (dwTime % 1000);
-#else
-			gettimeofday(&tv, NULL);
-#endif
-#if DISPATCH_DEBUG
-			dispatch_log_basetime = _dispatch_uptime();
-#endif
-#if defined(_WIN32)
-			char szProgramName[MAX_PATH + 1] = {0};
-			GetModuleFileNameA(NULL, szProgramName, MAX_PATH);
-
-			char szMessage[512];
-			int len = snprintf(szMessage, sizeof(szMessage),
-					"=== log file opened for %s[%lu] at %ld.%06u ===",
-					szProgramName, GetCurrentProcessId(), tv.tv_sec,
-					(int)tv.tv_usec);
-			if (len > 0) {
-				len = MIN(len, sizeof(szMessage) - 1);
-				_write(dispatch_logfile, szMessage, len);
-				_write(dispatch_logfile, "\n", 1);
-			}
-#else
-			dprintf(dispatch_logfile, "=== log file opened for %s[%u] at "
-					"%ld.%06u ===\n", getprogname() ?: "", getpid(),
-					tv.tv_sec, (int)tv.tv_usec);
-#endif
-		}
-	}
-}
-
-static inline void
-_dispatch_log_file(char *buf, size_t len)
-{
-	ssize_t r;
-
-	buf[len++] = '\n';
-retry:
-#if defined(_WIN32)
-	dispatch_assert(len <= UINT_MAX);
-	r = _write(dispatch_logfile, buf, (unsigned int)len);
-#else
-	r = write(dispatch_logfile, buf, len);
-#endif
-	if (unlikely(r == -1) && errno == EINTR) {
-		goto retry;
-	}
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_logv_file(const char *msg, va_list ap)
-{
-	char buf[2048];
-	size_t bufsiz = sizeof(buf), offset = 0;
-	int r;
-
-#if DISPATCH_DEBUG
-	offset += dsnprintf(&buf[offset], bufsiz - offset, "%llu\t",
-			(unsigned long long)_dispatch_uptime() - dispatch_log_basetime);
-#endif
-	r = vsnprintf(&buf[offset], bufsiz - offset, msg, ap);
-	if (r < 0) return;
-	offset += (size_t)r;
-	if (offset > bufsiz - 1) {
-		offset = bufsiz - 1;
-	}
-	_dispatch_log_file(buf, offset);
-}
-
-#if DISPATCH_USE_SIMPLE_ASL
-static inline void
-_dispatch_syslog(const char *msg)
-{
-	_simple_asl_log(ASL_LEVEL_NOTICE, "com.apple.libsystem.libdispatch", msg);
-}
-
-static inline void
-_dispatch_vsyslog(const char *msg, va_list ap)
-{
-	char *str;
-	vasprintf(&str, msg, ap);
-	if (str) {
-		_dispatch_syslog(str);
-		free(str);
-	}
-}
-#elif defined(_WIN32)
-static inline void
-_dispatch_syslog(const char *msg)
-{
-  OutputDebugStringA(msg);
-}
-
-static inline void
-_dispatch_vsyslog(const char *msg, va_list ap)
-{
-  va_list argp;
-
-  va_copy(argp, ap);
-
-  int length = _vscprintf(msg, ap);
-  if (length == -1)
-    return;
-
-  char *buffer = malloc((size_t)length + 1);
-  if (buffer == NULL)
-    return;
-
-  _vsnprintf(buffer, (size_t)length + 1, msg, argp);
-
-  va_end(argp);
-
-  _dispatch_syslog(buffer);
-
-  free(buffer);
-}
-#else // DISPATCH_USE_SIMPLE_ASL
-static inline void
-_dispatch_syslog(const char *msg)
-{
-	syslog(LOG_NOTICE, "%s", msg);
-}
-
-static inline void
-_dispatch_vsyslog(const char *msg, va_list ap)
-{
-	vsyslog(LOG_NOTICE, msg, ap);
-}
-#endif // DISPATCH_USE_SIMPLE_ASL
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_logv(const char *msg, size_t len, va_list *ap_ptr)
-{
-	dispatch_once_f(&_dispatch_logv_pred, NULL, _dispatch_logv_init);
-	if (unlikely(dispatch_log_disabled)) {
-		return;
-	}
-	if (unlikely(dispatch_logfile != -1)) {
-		if (!ap_ptr) {
-			return _dispatch_log_file((char*)msg, len);
-		}
-		return _dispatch_logv_file(msg, *ap_ptr);
-	}
-	if (!ap_ptr) {
-		return _dispatch_syslog(msg);
-	}
-	return _dispatch_vsyslog(msg, *ap_ptr);
-}
-
-DISPATCH_NOINLINE
-void
-_dispatch_log(const char *msg, ...)
-{
-	va_list ap;
-
-	va_start(ap, msg);
-	_dispatch_logv(msg, 0, &ap);
-	va_end(ap);
-}
-
-#endif // DISPATCH_USE_OS_DEBUG_LOG
-
-#pragma mark -
-#pragma mark dispatch_debug
-
-static size_t
-_dispatch_object_debug2(dispatch_object_t dou, char* buf, size_t bufsiz)
-{
-	DISPATCH_OBJECT_TFB(_dispatch_objc_debug, dou, buf, bufsiz);
-	return dx_debug(dou._do, buf, bufsiz);
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_debugv(dispatch_object_t dou, const char *msg, va_list ap)
-{
-	char buf[2048];
-	size_t bufsiz = sizeof(buf), offset = 0;
-	int r;
-#if DISPATCH_DEBUG && !DISPATCH_USE_OS_DEBUG_LOG
-	offset += dsnprintf(&buf[offset], bufsiz - offset, "%llu\t\t%p\t",
-			(unsigned long long)_dispatch_uptime() - dispatch_log_basetime,
-			(void *)_dispatch_thread_self());
-#endif
-	if (dou._do) {
-		offset += _dispatch_object_debug2(dou, &buf[offset], bufsiz - offset);
-		dispatch_assert(offset + 2 < bufsiz);
-		buf[offset++] = ':';
-		buf[offset++] = ' ';
-		buf[offset]   = '\0';
-	} else {
-		offset += strlcpy(&buf[offset], "NULL: ", bufsiz - offset);
-	}
-	r = vsnprintf(&buf[offset], bufsiz - offset, msg, ap);
-#if !DISPATCH_USE_OS_DEBUG_LOG
-	size_t len = offset + (r < 0 ? 0 : (size_t)r);
-	if (len > bufsiz - 1) {
-		len = bufsiz - 1;
-	}
-	_dispatch_logv(buf, len, NULL);
-#else
-	_dispatch_log("%s", buf);
-#endif
-}
-
-DISPATCH_NOINLINE
-void
-dispatch_debugv(dispatch_object_t dou, const char *msg, va_list ap)
-{
-	_dispatch_debugv(dou, msg, ap);
-}
-
-DISPATCH_NOINLINE
-void
-dispatch_debug(dispatch_object_t dou, const char *msg, ...)
-{
-	va_list ap;
-
-	va_start(ap, msg);
-	_dispatch_debugv(dou, msg, ap);
-	va_end(ap);
-}
-
-#if DISPATCH_DEBUG
-DISPATCH_NOINLINE
-void
-_dispatch_object_debug(dispatch_object_t dou, const char *msg, ...)
-{
-	va_list ap;
-
-	va_start(ap, msg);
-	_dispatch_debugv(dou._do, msg, ap);
-	va_end(ap);
-}
-#endif
-
-#pragma mark -
-#pragma mark dispatch_calloc
-
-DISPATCH_NOINLINE
-void
-_dispatch_temporary_resource_shortage(void)
-{
-	sleep(1);
-	__asm__ __volatile__("");  // prevent tailcall
-}
-
-void *
-_dispatch_calloc(size_t num_items, size_t size)
-{
-	void *buf;
-	while (unlikely(!(buf = calloc(num_items, size)))) {
-		_dispatch_temporary_resource_shortage();
-	}
-	return buf;
-}
-
-/**
- * If the source string is mutable, allocates memory and copies the contents.
- * Otherwise returns the source string.
- */
-const char *
-_dispatch_strdup_if_mutable(const char *str)
-{
-#if HAVE_DYLD_IS_MEMORY_IMMUTABLE
-	size_t size = strlen(str) + 1;
-	if (unlikely(!_dyld_is_memory_immutable(str, size))) {
-		char *clone = (char *) malloc(size);
-		if (dispatch_assume(clone)) {
-			memcpy(clone, str, size);
-		}
-		return clone;
-	}
-	return str;
-#else
-	return strdup(str);
-#endif
-}
-
-#pragma mark -
-#pragma mark dispatch_block_t
-
-#ifdef __BLOCKS__
-
-void *
-(_dispatch_Block_copy)(void *db)
-{
-	dispatch_block_t rval;
-
-	if (likely(db)) {
-		while (unlikely(!(rval = Block_copy(db)))) {
-			_dispatch_temporary_resource_shortage();
-		}
-		return rval;
-	}
-	DISPATCH_CLIENT_CRASH(0, "NULL was passed where a block should have been");
-}
-
-void
-_dispatch_call_block_and_release(void *block)
-{
-	void (^b)(void) = block;
-	b();
-	Block_release(b);
-}
-
-#endif // __BLOCKS__
-
-#pragma mark -
-#pragma mark dispatch_client_callout
-
-// Abort on uncaught exceptions thrown from client callouts rdar://8577499
-#if DISPATCH_USE_CLIENT_CALLOUT && (__USING_SJLJ_EXCEPTIONS__ || !USE_OBJC || \
-		OS_OBJECT_HAVE_OBJC1)
-// On platforms with SjLj exceptions, avoid the SjLj overhead on every callout
-// by clearing the unwinder's TSD pointer to the handler stack around callouts
-
-#define _dispatch_get_tsd_base()
-#define _dispatch_get_unwind_tsd() (NULL)
-#define _dispatch_set_unwind_tsd(u) do {(void)(u);} while (0)
-#define _dispatch_free_unwind_tsd()
-
-#undef _dispatch_client_callout
-DISPATCH_NOINLINE
-void
-_dispatch_client_callout(void *ctxt, dispatch_function_t f)
-{
-	_dispatch_get_tsd_base();
-	void *u = _dispatch_get_unwind_tsd();
-	if (likely(!u)) return f(ctxt);
-	_dispatch_set_unwind_tsd(NULL);
-	f(ctxt);
-	_dispatch_free_unwind_tsd();
-	_dispatch_set_unwind_tsd(u);
-}
-
-#undef _dispatch_client_callout2
-DISPATCH_NOINLINE
-void
-_dispatch_client_callout2(void *ctxt, size_t i, void (*f)(void *, size_t))
-{
-	_dispatch_get_tsd_base();
-	void *u = _dispatch_get_unwind_tsd();
-	if (likely(!u)) return f(ctxt, i);
-	_dispatch_set_unwind_tsd(NULL);
-	f(ctxt, i);
-	_dispatch_free_unwind_tsd();
-	_dispatch_set_unwind_tsd(u);
-}
-
-#if HAVE_MACH
-
-#undef _dispatch_client_callout3
-DISPATCH_NOINLINE
-void
-_dispatch_client_callout3(void *ctxt, dispatch_mach_reason_t reason,
-		dispatch_mach_msg_t dmsg, dispatch_mach_async_reply_callback_t f)
-{
-	_dispatch_get_tsd_base();
-	void *u = _dispatch_get_unwind_tsd();
-	if (likely(!u)) return f(ctxt, reason, dmsg);
-	_dispatch_set_unwind_tsd(NULL);
-	f(ctxt, reason, dmsg);
-	_dispatch_free_unwind_tsd();
-	_dispatch_set_unwind_tsd(u);
-}
-
-#undef _dispatch_client_callout4
-void
-_dispatch_client_callout4(void *ctxt, dispatch_mach_reason_t reason,
-		dispatch_mach_msg_t dmsg, mach_error_t error,
-		dispatch_mach_handler_function_t f)
-{
-	_dispatch_get_tsd_base();
-	void *u = _dispatch_get_unwind_tsd();
-	if (likely(!u)) return f(ctxt, reason, dmsg, error);
-	_dispatch_set_unwind_tsd(NULL);
-	f(ctxt, reason, dmsg, error);
-	_dispatch_free_unwind_tsd();
-	_dispatch_set_unwind_tsd(u);
-}
-#endif // HAVE_MACH
-
-#endif // DISPATCH_USE_CLIENT_CALLOUT
-
-#pragma mark -
-#pragma mark _os_object_t no_objc
-
-#if !USE_OBJC
-
-static const _os_object_vtable_s _os_object_vtable;
-
-void
-_os_object_init(void)
-{
-	return;
-}
-
-inline _os_object_t
-_os_object_alloc_realized(const void *cls, size_t size)
-{
-	_os_object_t obj;
-	dispatch_assert(size >= sizeof(struct _os_object_s));
-	while (unlikely(!(obj = calloc(1u, size)))) {
-		_dispatch_temporary_resource_shortage();
-	}
-	obj->os_obj_isa = cls;
-	return obj;
-}
-
-_os_object_t
-_os_object_alloc(const void *cls, size_t size)
-{
-	if (!cls) cls = &_os_object_vtable;
-	return _os_object_alloc_realized(cls, size);
-}
-
-void
-_os_object_dealloc(_os_object_t obj)
-{
-	*((void *volatile*)&obj->os_obj_isa) = (void *)0x200;
-	return free(obj);
-}
-
-void
-_os_object_xref_dispose(_os_object_t obj)
-{
-	_os_object_xrefcnt_dispose_barrier(obj);
-	if (likely(obj->os_obj_isa->_os_obj_xref_dispose)) {
-		return obj->os_obj_isa->_os_obj_xref_dispose(obj);
-	}
-	return _os_object_release_internal(obj);
-}
-
-void
-_os_object_dispose(_os_object_t obj)
-{
-	_os_object_refcnt_dispose_barrier(obj);
-	if (likely(obj->os_obj_isa->_os_obj_dispose)) {
-		return obj->os_obj_isa->_os_obj_dispose(obj);
-	}
-	return _os_object_dealloc(obj);
-}
-
-void*
-os_retain(void *obj)
-{
-	if (likely(obj)) {
-		return _os_object_retain(obj);
-	}
-	return obj;
-}
-
-#undef os_release
-void
-os_release(void *obj)
-{
-	if (likely(obj)) {
-		return _os_object_release(obj);
-	}
-}
-
-void
-_os_object_atfork_prepare(void)
-{
-	return;
-}
-
-void
-_os_object_atfork_parent(void)
-{
-	return;
-}
-
-void
-_os_object_atfork_child(void)
-{
-	return;
-}
-
-#pragma mark -
-#pragma mark dispatch_autorelease_pool no_objc
-
-#if DISPATCH_COCOA_COMPAT
-
-void*
-_dispatch_autorelease_pool_push(void)
-{
-	void *pool = NULL;
-	if (_dispatch_begin_NSAutoReleasePool) {
-		pool = _dispatch_begin_NSAutoReleasePool();
-	}
-	return pool;
-}
-
-void
-_dispatch_autorelease_pool_pop(void *pool)
-{
-	if (_dispatch_end_NSAutoReleasePool) {
-		_dispatch_end_NSAutoReleasePool(pool);
-	}
-}
-
-void
-_dispatch_last_resort_autorelease_pool_push(dispatch_invoke_context_t dic)
-{
-	dic->dic_autorelease_pool = _dispatch_autorelease_pool_push();
-}
-
-void
-_dispatch_last_resort_autorelease_pool_pop(dispatch_invoke_context_t dic)
-{
-	_dispatch_autorelease_pool_pop(dic->dic_autorelease_pool);
-	dic->dic_autorelease_pool = NULL;
-}
-
-#endif // DISPATCH_COCOA_COMPAT
-#endif // !USE_OBJC
-
-#pragma mark -
-#pragma mark dispatch_mig
-#if HAVE_MACH
-
-void *
-dispatch_mach_msg_get_context(mach_msg_header_t *msg)
-{
-	mach_msg_context_trailer_t *tp;
-	void *context = NULL;
-
-	tp = (mach_msg_context_trailer_t *)((uint8_t *)msg +
-			round_msg(msg->msgh_size));
-	if (tp->msgh_trailer_size >=
-			(mach_msg_size_t)sizeof(mach_msg_context_trailer_t)) {
-		context = (void *)(uintptr_t)tp->msgh_context;
-	}
-	return context;
-}
-
-kern_return_t
-_dispatch_wakeup_runloop_thread(mach_port_t mp DISPATCH_UNUSED)
-{
-	// dummy function just to pop a runloop thread out of mach_msg()
-	return 0;
-}
-
-kern_return_t
-_dispatch_consume_send_once_right(mach_port_t mp DISPATCH_UNUSED)
-{
-	// dummy function to consume a send-once right
-	return 0;
-}
-
-kern_return_t
-_dispatch_mach_notify_port_destroyed(mach_port_t notify DISPATCH_UNUSED,
-		mach_port_t name)
-{
-	DISPATCH_INTERNAL_CRASH(name, "unexpected receipt of port-destroyed");
-	return KERN_FAILURE;
-}
-
-kern_return_t
-_dispatch_mach_notify_no_senders(mach_port_t notify DISPATCH_UNUSED,
-		mach_port_mscount_t mscnt)
-{
-	DISPATCH_INTERNAL_CRASH(mscnt, "unexpected receipt of no-more-senders");
-	return KERN_FAILURE;
-}
-
-kern_return_t
-_dispatch_mach_notify_send_once(mach_port_t notify DISPATCH_UNUSED)
-{
-	// we only register for dead-name notifications
-	// some code deallocated our send-once right without consuming it
-#if DISPATCH_DEBUG
-	_dispatch_log("Corruption: An app/library deleted a libdispatch "
-			"dead-name notification");
-#endif
-	return KERN_SUCCESS;
-}
-
-#endif // HAVE_MACH
-#pragma mark -
-#pragma mark dispatch to XPC callbacks
-#if HAVE_MACH
-
-// Default dmxh_direct_message_handler callback that does not handle
-// messages inline.
-static bool
-_dispatch_mach_xpc_no_handle_message(
-		void *_Nullable context DISPATCH_UNUSED,
-		dispatch_mach_reason_t reason DISPATCH_UNUSED,
-		dispatch_mach_msg_t message DISPATCH_UNUSED,
-		mach_error_t error DISPATCH_UNUSED)
-{
-	return false;
-}
-
-// Default dmxh_msg_context_reply_queue callback that returns a NULL queue.
-static dispatch_queue_t
-_dispatch_mach_msg_context_no_async_reply_queue(
-		void *_Nonnull msg_context DISPATCH_UNUSED)
-{
-	return NULL;
-}
-
-// Default dmxh_async_reply_handler callback that crashes when called.
-DISPATCH_NORETURN
-static void
-_dispatch_mach_default_async_reply_handler(void *context DISPATCH_UNUSED,
-		dispatch_mach_reason_t reason DISPATCH_UNUSED,
-		dispatch_mach_msg_t message DISPATCH_UNUSED)
-{
-	DISPATCH_CLIENT_CRASH(_dispatch_mach_xpc_hooks,
-			"_dispatch_mach_default_async_reply_handler called");
-}
-
-// Default dmxh_enable_sigterm_notification callback that enables delivery of
-// SIGTERM notifications (for backwards compatibility).
-static bool
-_dispatch_mach_enable_sigterm(void *_Nullable context DISPATCH_UNUSED)
-{
-	return true;
-}
-
-// Callbacks from dispatch to XPC. The default is to not support any callbacks.
-const struct dispatch_mach_xpc_hooks_s _dispatch_mach_xpc_hooks_default = {
-	.version = DISPATCH_MACH_XPC_HOOKS_VERSION,
-	.dmxh_direct_message_handler = &_dispatch_mach_xpc_no_handle_message,
-	.dmxh_msg_context_reply_queue =
-			&_dispatch_mach_msg_context_no_async_reply_queue,
-	.dmxh_async_reply_handler = &_dispatch_mach_default_async_reply_handler,
-	.dmxh_enable_sigterm_notification = &_dispatch_mach_enable_sigterm,
-};
-
-dispatch_mach_xpc_hooks_t _dispatch_mach_xpc_hooks =
-		&_dispatch_mach_xpc_hooks_default;
-
-#endif // HAVE_MACH
--- a/Telegram/ThirdParty/dispatch/src/inline_internal.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/inline_internal.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,2616 +0,0 @@
-/*
- * Copyright (c) 2008-2013 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-/*
- * IMPORTANT: This header file describes INTERNAL interfaces to libdispatch
- * which are subject to change in future releases of Mac OS X. Any applications
- * relying on these interfaces WILL break.
- */
-
-#ifndef __DISPATCH_INLINE_INTERNAL__
-#define __DISPATCH_INLINE_INTERNAL__
-
-#ifndef __DISPATCH_INDIRECT__
-#error "Please #include <dispatch/dispatch.h> instead of this file directly."
-#include <dispatch/base.h> // for HeaderDoc
-#endif
-
-#if DISPATCH_USE_CLIENT_CALLOUT
-
-DISPATCH_NOTHROW void
-_dispatch_client_callout(void *ctxt, dispatch_function_t f);
-DISPATCH_NOTHROW void
-_dispatch_client_callout2(void *ctxt, size_t i, void (*f)(void *, size_t));
-#if HAVE_MACH
-DISPATCH_NOTHROW void
-_dispatch_client_callout3(void *ctxt, dispatch_mach_reason_t reason,
-		dispatch_mach_msg_t dmsg, dispatch_mach_async_reply_callback_t f);
-DISPATCH_NOTHROW void
-_dispatch_client_callout4(void *ctxt, dispatch_mach_reason_t reason,
-		dispatch_mach_msg_t dmsg, mach_error_t error,
-		dispatch_mach_handler_function_t f);
-#endif // HAVE_MACH
-
-#else // !DISPATCH_USE_CLIENT_CALLOUT
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_client_callout(void *ctxt, dispatch_function_t f)
-{
-	return f(ctxt);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_client_callout2(void *ctxt, size_t i, void (*f)(void *, size_t))
-{
-	return f(ctxt, i);
-}
-
-#if HAVE_MACH
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_client_callout3(void *ctxt, dispatch_mach_reason_t reason,
-		dispatch_mach_msg_t dmsg, dispatch_mach_async_reply_callback_t f)
-{
-	return f(ctxt, reason, dmsg);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_client_callout4(void *ctxt, dispatch_mach_reason_t reason,
-		dispatch_mach_msg_t dmsg, mach_error_t error,
-		dispatch_mach_handler_function_t f)
-{
-	return f(ctxt, reason, dmsg, error);
-}
-#endif // HAVE_MACH
-
-#endif // !DISPATCH_USE_CLIENT_CALLOUT
-
-#pragma mark -
-#pragma mark _os_object_t & dispatch_object_t
-#if DISPATCH_PURE_C
-
-DISPATCH_ALWAYS_INLINE
-static inline const char *
-_dispatch_object_class_name(dispatch_object_t dou)
-{
-#if USE_OBJC
-	return object_getClassName((id)dou._do) + strlen("OS_dispatch_");
-#else
-	return dx_vtable(dou._do)->do_kind;
-#endif
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dispatch_object_is_global(dispatch_object_t dou)
-{
-	return dou._do->do_ref_cnt == DISPATCH_OBJECT_GLOBAL_REFCNT;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dispatch_object_is_root_or_base_queue(dispatch_object_t dou)
-{
-	return dx_hastypeflag(dou._do, QUEUE_ROOT) ||
-			dx_hastypeflag(dou._do, QUEUE_BASE);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dispatch_object_has_vtable(dispatch_object_t dou)
-{
-	// vtables are pointers far away from the low page in memory
-	return dou._dc->dc_flags > 0xffful;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dispatch_object_is_queue(dispatch_object_t dou)
-{
-	return _dispatch_object_has_vtable(dou) && dx_vtable(dou._dq)->dq_push;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dispatch_object_is_continuation(dispatch_object_t dou)
-{
-	if (_dispatch_object_has_vtable(dou)) {
-		return dx_metatype(dou._do) == _DISPATCH_CONTINUATION_TYPE;
-	}
-	return true;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dispatch_object_has_type(dispatch_object_t dou, unsigned long type)
-{
-	return _dispatch_object_has_vtable(dou) && dx_type(dou._do) == type;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dispatch_object_is_redirection(dispatch_object_t dou)
-{
-	return _dispatch_object_has_type(dou,
-			DISPATCH_CONTINUATION_TYPE(ASYNC_REDIRECT));
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dispatch_object_is_barrier(dispatch_object_t dou)
-{
-	dispatch_queue_flags_t dq_flags;
-
-	if (!_dispatch_object_has_vtable(dou)) {
-		return (dou._dc->dc_flags & DC_FLAG_BARRIER);
-	}
-	if (dx_cluster(dou._do) != _DISPATCH_QUEUE_CLUSTER) {
-		return false;
-	}
-	dq_flags = os_atomic_load2o(dou._dq, dq_atomic_flags, relaxed);
-	return dq_flags & DQF_BARRIER_BIT;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dispatch_object_is_waiter(dispatch_object_t dou)
-{
-	if (_dispatch_object_has_vtable(dou)) {
-		return false;
-	}
-	return (dou._dc->dc_flags & (DC_FLAG_SYNC_WAITER | DC_FLAG_ASYNC_AND_WAIT));
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dispatch_object_is_sync_waiter(dispatch_object_t dou)
-{
-	if (_dispatch_object_has_vtable(dou)) {
-		return false;
-	}
-	return (dou._dc->dc_flags & DC_FLAG_SYNC_WAITER);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dispatch_object_is_sync_waiter_non_barrier(dispatch_object_t dou)
-{
-	if (_dispatch_object_has_vtable(dou)) {
-		return false;
-	}
-	return ((dou._dc->dc_flags & (DC_FLAG_BARRIER | DC_FLAG_SYNC_WAITER)) ==
-				(DC_FLAG_SYNC_WAITER));
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline _os_object_t
-_os_object_retain_internal_n_inline(_os_object_t obj, int n)
-{
-	int ref_cnt = _os_object_refcnt_add_orig(obj, n);
-	if (unlikely(ref_cnt < 0)) {
-		_OS_OBJECT_CLIENT_CRASH("Resurrection of an object");
-	}
-	return obj;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_os_object_release_internal_n_no_dispose_inline(_os_object_t obj, int n)
-{
-	int ref_cnt = _os_object_refcnt_sub(obj, n);
-	if (likely(ref_cnt >= 0)) {
-		return;
-	}
-	_OS_OBJECT_CLIENT_CRASH("Over-release of an object");
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_os_object_release_internal_n_inline(_os_object_t obj, int n)
-{
-	int ref_cnt = _os_object_refcnt_sub(obj, n);
-	if (likely(ref_cnt >= 0)) {
-		return;
-	}
-	if (unlikely(ref_cnt < -1)) {
-		_OS_OBJECT_CLIENT_CRASH("Over-release of an object");
-	}
-#if DISPATCH_DEBUG
-	int xref_cnt = obj->os_obj_xref_cnt;
-	if (unlikely(xref_cnt >= 0)) {
-		DISPATCH_INTERNAL_CRASH(xref_cnt,
-				"Release while external references exist");
-	}
-#endif
-	// _os_object_refcnt_dispose_barrier() is in _os_object_dispose()
-	return _os_object_dispose(obj);
-}
-
-DISPATCH_ALWAYS_INLINE_NDEBUG
-static inline void
-_dispatch_retain(dispatch_object_t dou)
-{
-	(void)_os_object_retain_internal_n_inline(dou._os_obj, 1);
-}
-
-DISPATCH_ALWAYS_INLINE_NDEBUG
-static inline void
-_dispatch_retain_2(dispatch_object_t dou)
-{
-	(void)_os_object_retain_internal_n_inline(dou._os_obj, 2);
-}
-
-DISPATCH_ALWAYS_INLINE_NDEBUG
-static inline void
-_dispatch_retain_n(dispatch_object_t dou, int n)
-{
-	(void)_os_object_retain_internal_n_inline(dou._os_obj, n);
-}
-
-DISPATCH_ALWAYS_INLINE_NDEBUG
-static inline void
-_dispatch_retain_n_unsafe(dispatch_object_t dou, int n)
-{
-	// _dispatch_retain_*_unsafe assumes:
-	// - the object is not global
-	// - there's no refcount management bug
-	//
-	// This is meant to be used only when called between the update_tail and
-	// update_prev os_mpsc methods, so that the assembly of that critical window
-	// is as terse as possible (this window is a possible dequeuer starvation).
-	//
-	// Other code should use the safe variants at all times.
-	os_atomic_add2o(dou._os_obj, os_obj_ref_cnt, n, relaxed);
-}
-
-DISPATCH_ALWAYS_INLINE_NDEBUG
-static inline void
-_dispatch_retain_2_unsafe(dispatch_object_t dou)
-{
-	_dispatch_retain_n_unsafe(dou, 2);
-}
-
-DISPATCH_ALWAYS_INLINE_NDEBUG
-static inline void
-_dispatch_release(dispatch_object_t dou)
-{
-	_os_object_release_internal_n_inline(dou._os_obj, 1);
-}
-
-DISPATCH_ALWAYS_INLINE_NDEBUG
-static inline void
-_dispatch_release_2(dispatch_object_t dou)
-{
-	_os_object_release_internal_n_inline(dou._os_obj, 2);
-}
-
-DISPATCH_ALWAYS_INLINE_NDEBUG
-static inline void
-_dispatch_release_n(dispatch_object_t dou, int n)
-{
-	_os_object_release_internal_n_inline(dou._os_obj, n);
-}
-
-DISPATCH_ALWAYS_INLINE_NDEBUG
-static inline void
-_dispatch_release_no_dispose(dispatch_object_t dou)
-{
-	_os_object_release_internal_n_no_dispose_inline(dou._os_obj, 1);
-}
-
-DISPATCH_ALWAYS_INLINE_NDEBUG
-static inline void
-_dispatch_release_2_no_dispose(dispatch_object_t dou)
-{
-	_os_object_release_internal_n_no_dispose_inline(dou._os_obj, 2);
-}
-
-DISPATCH_ALWAYS_INLINE_NDEBUG
-static inline void
-_dispatch_release_tailcall(dispatch_object_t dou)
-{
-	_os_object_release_internal(dou._os_obj);
-}
-
-DISPATCH_ALWAYS_INLINE_NDEBUG
-static inline void
-_dispatch_release_2_tailcall(dispatch_object_t dou)
-{
-	_os_object_release_internal_n(dou._os_obj, 2);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_retain_unote_owner(dispatch_unote_t du)
-{
-	_dispatch_retain_2(_dispatch_wref2ptr(du._du->du_owner_wref));
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_release_unote_owner_tailcall(dispatch_unote_t du)
-{
-	_dispatch_release_2_tailcall(_dispatch_wref2ptr(du._du->du_owner_wref));
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_queue_retain_storage(dispatch_queue_class_t dqu)
-{
-	int ref_cnt = os_atomic_inc2o(dqu._dq, dq_sref_cnt, relaxed);
-	if (unlikely(ref_cnt <= 0)) {
-		_OS_OBJECT_CLIENT_CRASH("Resurrection of an object");
-	}
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_queue_release_storage(dispatch_queue_class_t dqu)
-{
-	// this refcount only delays the _dispatch_object_dealloc() and there's no
-	// need for visibility wrt to the allocation, the internal refcount already
-	// gives us that, and the object becomes immutable after the last internal
-	// refcount release.
-	int ref_cnt = os_atomic_dec2o(dqu._dq, dq_sref_cnt, relaxed);
-	if (unlikely(ref_cnt >= 0)) {
-		return;
-	}
-	if (unlikely(ref_cnt < -1)) {
-		_OS_OBJECT_CLIENT_CRASH("Over-release of an object");
-	}
-	dqu._dq->dq_state = 0xdead000000000000;
-	_dispatch_object_dealloc(dqu._dq);
-}
-
-DISPATCH_ALWAYS_INLINE DISPATCH_NONNULL_ALL
-static inline void
-_dispatch_object_set_target_queue_inline(dispatch_object_t dou,
-		dispatch_queue_t tq)
-{
-	_dispatch_retain(tq);
-	tq = os_atomic_xchg2o(dou._do, do_targetq, tq, release);
-	if (tq) _dispatch_release(tq);
-}
-
-#endif // DISPATCH_PURE_C
-#pragma mark -
-#pragma mark dispatch_thread
-#if DISPATCH_PURE_C
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_thread_context_t
-_dispatch_thread_context_find(const void *key)
-{
-	dispatch_thread_context_t dtc =
-			_dispatch_thread_getspecific(dispatch_context_key);
-	while (dtc) {
-		if (dtc->dtc_key == key) {
-			return dtc;
-		}
-		dtc = dtc->dtc_prev;
-	}
-	return NULL;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_thread_context_push(dispatch_thread_context_t ctxt)
-{
-	ctxt->dtc_prev = _dispatch_thread_getspecific(dispatch_context_key);
-	_dispatch_thread_setspecific(dispatch_context_key, ctxt);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_thread_context_pop(dispatch_thread_context_t ctxt)
-{
-	dispatch_assert(_dispatch_thread_getspecific(dispatch_context_key) == ctxt);
-	_dispatch_thread_setspecific(dispatch_context_key, ctxt->dtc_prev);
-}
-
-typedef struct dispatch_thread_frame_iterator_s {
-	dispatch_queue_t dtfi_queue;
-	dispatch_thread_frame_t dtfi_frame;
-} *dispatch_thread_frame_iterator_t;
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_thread_frame_iterate_start(dispatch_thread_frame_iterator_t it)
-{
-	_dispatch_thread_getspecific_pair(
-			dispatch_queue_key, (void **)&it->dtfi_queue,
-			dispatch_frame_key, (void **)&it->dtfi_frame);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_thread_frame_iterate_next(dispatch_thread_frame_iterator_t it)
-{
-	dispatch_thread_frame_t dtf = it->dtfi_frame;
-	dispatch_queue_t dq = it->dtfi_queue;
-
-	if (dtf) {
-		dispatch_queue_t tq = dq->do_targetq;
-		if (tq) {
-			// redirections or dispatch_sync may skip frames,
-			// so we need to simulate seeing the missing links
-			it->dtfi_queue = tq;
-			if (dq == dtf->dtf_queue) {
-				it->dtfi_frame = dtf->dtf_prev;
-			}
-		} else {
-			it->dtfi_queue = dtf->dtf_queue;
-			it->dtfi_frame = dtf->dtf_prev;
-		}
-	} else if (dq) {
-		it->dtfi_queue = dq->do_targetq;
-	}
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dispatch_thread_frame_find_queue(dispatch_queue_t dq)
-{
-	struct dispatch_thread_frame_iterator_s it;
-
-	_dispatch_thread_frame_iterate_start(&it);
-	while (it.dtfi_queue) {
-		if (it.dtfi_queue == dq) {
-			return true;
-		}
-		_dispatch_thread_frame_iterate_next(&it);
-	}
-	return false;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_thread_frame_t
-_dispatch_thread_frame_get_current(void)
-{
-	return _dispatch_thread_getspecific(dispatch_frame_key);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_thread_frame_save_state(dispatch_thread_frame_t dtf)
-{
-	_dispatch_thread_getspecific_packed_pair(
-			dispatch_queue_key, dispatch_frame_key, dtf->dtf_pair);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_thread_frame_push(dispatch_thread_frame_t dtf,
-		dispatch_queue_class_t dqu)
-{
-	_dispatch_thread_frame_save_state(dtf);
-	_dispatch_thread_setspecific_pair(dispatch_queue_key, dqu._dq,
-			dispatch_frame_key, dtf);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_thread_frame_push_and_rebase(dispatch_thread_frame_t dtf,
-		dispatch_queue_class_t dqu, dispatch_thread_frame_t new_base)
-{
-	_dispatch_thread_frame_save_state(dtf);
-	_dispatch_thread_setspecific_pair(dispatch_queue_key, dqu._dq,
-			dispatch_frame_key, new_base);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_thread_frame_pop(dispatch_thread_frame_t dtf)
-{
-	_dispatch_thread_setspecific_packed_pair(
-			dispatch_queue_key, dispatch_frame_key, dtf->dtf_pair);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_queue_t
-_dispatch_thread_frame_stash(dispatch_thread_frame_t dtf)
-{
-	_dispatch_thread_getspecific_pair(
-			dispatch_queue_key, &dtf->dtf_pair[0],
-			dispatch_frame_key, &dtf->dtf_pair[1]);
-	_dispatch_thread_frame_pop(dtf->dtf_prev);
-	return dtf->dtf_queue;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_thread_frame_unstash(dispatch_thread_frame_t dtf)
-{
-	_dispatch_thread_frame_pop(dtf);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline int
-_dispatch_wqthread_override_start_check_owner(mach_port_t thread,
-		dispatch_qos_t qos, mach_port_t *ulock_addr)
-{
-#if HAVE_PTHREAD_WORKQUEUE_QOS
-	if (!_dispatch_set_qos_class_enabled) return 0;
-	return _pthread_workqueue_override_start_direct_check_owner(thread,
-			_dispatch_qos_to_pp(qos), ulock_addr);
-#else
-	(void)thread; (void)qos; (void)ulock_addr;
-	return 0;
-#endif
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_wqthread_override_start(mach_port_t thread, dispatch_qos_t qos)
-{
-#if HAVE_PTHREAD_WORKQUEUE_QOS
-	if (!_dispatch_set_qos_class_enabled) return;
-	(void)_pthread_workqueue_override_start_direct(thread,
-			_dispatch_qos_to_pp(qos));
-#else
-	(void)thread; (void)qos;
-#endif
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_wqthread_override_reset(void)
-{
-#if HAVE_PTHREAD_WORKQUEUE_QOS
-	if (!_dispatch_set_qos_class_enabled) return;
-	(void)_pthread_workqueue_override_reset();
-#endif
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_thread_override_start(mach_port_t thread, pthread_priority_t pp,
-		void *resource)
-{
-#if HAVE_PTHREAD_WORKQUEUE_QOS
-	if (!_dispatch_set_qos_class_enabled) return;
-	(void)_pthread_qos_override_start_direct(thread, pp, resource);
-#else
-	(void)thread; (void)pp; (void)resource;
-#endif
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_thread_override_end(mach_port_t thread, void *resource)
-{
-#if HAVE_PTHREAD_WORKQUEUE_QOS
-	if (!_dispatch_set_qos_class_enabled) return;
-	(void)_pthread_qos_override_end_direct(thread, resource);
-#else
-	(void)thread; (void)resource;
-#endif
-}
-
-#endif // DISPATCH_PURE_C
-#pragma mark -
-#pragma mark dispatch_queue_t state accessors
-#if DISPATCH_PURE_C
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_queue_flags_t
-_dispatch_queue_atomic_flags(dispatch_queue_class_t dqu)
-{
-	return os_atomic_load2o(dqu._dq, dq_atomic_flags, relaxed);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_queue_flags_t
-_dispatch_queue_atomic_flags_set(dispatch_queue_class_t dqu,
-		dispatch_queue_flags_t bits)
-{
-	return os_atomic_or2o(dqu._dq, dq_atomic_flags, bits, relaxed);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_queue_flags_t
-_dispatch_queue_atomic_flags_set_and_clear_orig(dispatch_queue_class_t dqu,
-		dispatch_queue_flags_t add_bits, dispatch_queue_flags_t clr_bits)
-{
-	dispatch_queue_flags_t oflags, nflags;
-	os_atomic_rmw_loop2o(dqu._dq, dq_atomic_flags, oflags, nflags, relaxed, {
-		nflags = (oflags | add_bits) & ~clr_bits;
-		if (nflags == oflags) os_atomic_rmw_loop_give_up(return oflags);
-	});
-	return oflags;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_queue_flags_t
-_dispatch_queue_atomic_flags_set_and_clear(dispatch_queue_class_t dqu,
-		dispatch_queue_flags_t add_bits, dispatch_queue_flags_t clr_bits)
-{
-	dispatch_queue_flags_t oflags, nflags;
-	os_atomic_rmw_loop2o(dqu._dq, dq_atomic_flags, oflags, nflags, relaxed, {
-		nflags = (oflags | add_bits) & ~clr_bits;
-		if (nflags == oflags) os_atomic_rmw_loop_give_up(return oflags);
-	});
-	return nflags;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_queue_flags_t
-_dispatch_queue_atomic_flags_set_orig(dispatch_queue_class_t dqu,
-		dispatch_queue_flags_t bits)
-{
-	return os_atomic_or_orig2o(dqu._dq, dq_atomic_flags, bits, relaxed);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_queue_flags_t
-_dispatch_queue_atomic_flags_clear(dispatch_queue_class_t dqu,
-		dispatch_queue_flags_t bits)
-{
-	return os_atomic_and2o(dqu._dq, dq_atomic_flags, ~bits, relaxed);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dispatch_queue_is_thread_bound(dispatch_queue_class_t dqu)
-{
-	return _dispatch_queue_atomic_flags(dqu) & DQF_THREAD_BOUND;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dispatch_queue_label_needs_free(dispatch_queue_class_t dqu)
-{
-	return _dispatch_queue_atomic_flags(dqu) & DQF_LABEL_NEEDS_FREE;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_invoke_flags_t
-_dispatch_queue_autorelease_frequency(dispatch_queue_class_t dqu)
-{
-	const unsigned long factor =
-			DISPATCH_INVOKE_AUTORELEASE_ALWAYS / DQF_AUTORELEASE_ALWAYS;
-	dispatch_assert(factor > 0);
-
-	dispatch_queue_flags_t qaf = _dispatch_queue_atomic_flags(dqu);
-
-	qaf &= (dispatch_queue_flags_t)_DQF_AUTORELEASE_MASK;
-	return (dispatch_invoke_flags_t)qaf * factor;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_invoke_flags_t
-_dispatch_queue_merge_autorelease_frequency(dispatch_queue_class_t dqu,
-		dispatch_invoke_flags_t flags)
-{
-	dispatch_invoke_flags_t qaf = _dispatch_queue_autorelease_frequency(dqu);
-
-	if (qaf) {
-		flags &= ~_DISPATCH_INVOKE_AUTORELEASE_MASK;
-		flags |= qaf;
-	}
-	return flags;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dispatch_queue_is_mutable(dispatch_queue_class_t dqu)
-{
-	return _dispatch_queue_atomic_flags(dqu) & DQF_MUTABLE;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_wlh_retain(dispatch_wlh_t wlh)
-{
-	if (wlh && wlh != DISPATCH_WLH_ANON) {
-		_dispatch_queue_retain_storage((dispatch_queue_t)wlh);
-	}
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_wlh_release(dispatch_wlh_t wlh)
-{
-	if (wlh && wlh != DISPATCH_WLH_ANON) {
-		_dispatch_queue_release_storage((dispatch_queue_t)wlh);
-	}
-}
-
-#define DISPATCH_WLH_STORAGE_REF 1ul
-
-DISPATCH_ALWAYS_INLINE DISPATCH_PURE
-static inline dispatch_wlh_t
-_dispatch_get_wlh(void)
-{
-	return _dispatch_thread_getspecific(dispatch_wlh_key);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_workloop_t
-_dispatch_wlh_to_workloop(dispatch_wlh_t wlh)
-{
-	if (wlh == DISPATCH_WLH_ANON) {
-		return NULL;
-	}
-	if (dx_metatype((dispatch_workloop_t)wlh) == _DISPATCH_WORKLOOP_TYPE) {
-		return (dispatch_workloop_t)wlh;
-	}
-	return NULL;
-}
-
-DISPATCH_ALWAYS_INLINE DISPATCH_PURE
-static inline dispatch_wlh_t
-_dispatch_get_event_wlh(void)
-{
-	dispatch_deferred_items_t ddi = _dispatch_deferred_items_get();
-	if (ddi) {
-		DISPATCH_COMPILER_CAN_ASSUME(ddi->ddi_wlh != DISPATCH_WLH_ANON);
-		return ddi->ddi_wlh;
-	}
-	return DISPATCH_WLH_ANON;
-}
-
-DISPATCH_ALWAYS_INLINE DISPATCH_PURE
-static inline dispatch_wlh_t
-_dispatch_get_wlh_reference(void)
-{
-	dispatch_wlh_t wlh = _dispatch_get_wlh();
-	return (dispatch_wlh_t)((uintptr_t)wlh & ~DISPATCH_WLH_STORAGE_REF);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dispatch_adopt_wlh_anon_recurse(void)
-{
-	dispatch_wlh_t cur_wlh = _dispatch_get_wlh_reference();
-	if (cur_wlh == DISPATCH_WLH_ANON) return false;
-	_dispatch_debug("wlh[anon]: set current (releasing %p)", cur_wlh);
-	_dispatch_wlh_release(cur_wlh);
-	_dispatch_thread_setspecific(dispatch_wlh_key, (void *)DISPATCH_WLH_ANON);
-	return true;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_adopt_wlh_anon(void)
-{
-	if (unlikely(!_dispatch_adopt_wlh_anon_recurse())) {
-		DISPATCH_INTERNAL_CRASH(0, "Lingering DISPATCH_WLH_ANON");
-	}
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_adopt_wlh(dispatch_wlh_t wlh)
-{
-	dispatch_wlh_t cur_wlh = _dispatch_get_wlh_reference();
-	_dispatch_debug("wlh[%p]: adopt current (releasing %p)", wlh, cur_wlh);
-	if (cur_wlh == DISPATCH_WLH_ANON) {
-		DISPATCH_INTERNAL_CRASH(0, "Lingering DISPATCH_WLH_ANON");
-	}
-	if (cur_wlh != wlh) {
-		dispatch_assert(wlh);
-		_dispatch_wlh_release(cur_wlh);
-		_dispatch_wlh_retain(wlh);
-	}
-	_dispatch_thread_setspecific(dispatch_wlh_key, (void *)wlh);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_preserve_wlh_storage_reference(dispatch_wlh_t wlh)
-{
-	dispatch_assert(wlh != DISPATCH_WLH_ANON);
-	dispatch_assert(wlh == _dispatch_get_wlh());
-	_dispatch_thread_setspecific(dispatch_wlh_key,
-			(void *)((uintptr_t)wlh | DISPATCH_WLH_STORAGE_REF));
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_reset_wlh(void)
-{
-	dispatch_assert(_dispatch_get_wlh() == DISPATCH_WLH_ANON);
-	_dispatch_debug("wlh[anon]: clear current");
-	_dispatch_thread_setspecific(dispatch_wlh_key, NULL);
-	_dispatch_clear_return_to_kernel();
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dispatch_wlh_should_poll_unote(dispatch_unote_t du)
-{
-	dispatch_deferred_items_t ddi = _dispatch_deferred_items_get();
-	return _dispatch_needs_to_return_to_kernel() && ddi &&
-			ddi->ddi_wlh != DISPATCH_WLH_ANON &&
-			_dispatch_unote_wlh(du) == ddi->ddi_wlh;
-}
-
-#endif // DISPATCH_PURE_C
-#ifndef __cplusplus
-
-DISPATCH_ALWAYS_INLINE
-static inline uint32_t
-_dq_state_suspend_cnt(uint64_t dq_state)
-{
-	return (uint32_t)(dq_state / DISPATCH_QUEUE_SUSPEND_INTERVAL);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dq_state_has_side_suspend_cnt(uint64_t dq_state)
-{
-	return dq_state & DISPATCH_QUEUE_HAS_SIDE_SUSPEND_CNT;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline int32_t
-_dq_state_extract_width_bits(uint64_t dq_state)
-{
-	dq_state &= DISPATCH_QUEUE_WIDTH_MASK;
-	return (int32_t)(dq_state >> DISPATCH_QUEUE_WIDTH_SHIFT);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline int32_t
-_dq_state_available_width(uint64_t dq_state)
-{
-	int32_t full = DISPATCH_QUEUE_WIDTH_FULL;
-	if (likely(!(dq_state & DISPATCH_QUEUE_WIDTH_FULL_BIT))) {
-		return full - _dq_state_extract_width_bits(dq_state);
-	}
-	return 0;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline int32_t
-_dq_state_used_width(uint64_t dq_state, uint16_t dq_width)
-{
-	int32_t full = DISPATCH_QUEUE_WIDTH_FULL;
-	int32_t width = _dq_state_extract_width_bits(dq_state);
-
-	if (dq_state & DISPATCH_QUEUE_PENDING_BARRIER) {
-		// DISPATCH_QUEUE_PENDING_BARRIER means (dq_width - 1) of the used width
-		// is pre-reservation that we want to ignore
-		return width - (full - dq_width) - (dq_width - 1);
-	}
-	return width - (full - dq_width);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dq_state_is_suspended(uint64_t dq_state)
-{
-	return dq_state >= DISPATCH_QUEUE_NEEDS_ACTIVATION;
-}
-#define DISPATCH_QUEUE_IS_SUSPENDED(x) \
-		_dq_state_is_suspended(os_atomic_load2o(x, dq_state, relaxed))
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dq_state_is_inactive(uint64_t dq_state)
-{
-	return dq_state & DISPATCH_QUEUE_INACTIVE;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dq_state_needs_activation(uint64_t dq_state)
-{
-	return dq_state & DISPATCH_QUEUE_NEEDS_ACTIVATION;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dq_state_is_in_barrier(uint64_t dq_state)
-{
-	return dq_state & DISPATCH_QUEUE_IN_BARRIER;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dq_state_has_available_width(uint64_t dq_state)
-{
-	return !(dq_state & DISPATCH_QUEUE_WIDTH_FULL_BIT);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dq_state_has_pending_barrier(uint64_t dq_state)
-{
-	return dq_state & DISPATCH_QUEUE_PENDING_BARRIER;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dq_state_is_dirty(uint64_t dq_state)
-{
-	return dq_state & DISPATCH_QUEUE_DIRTY;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dq_state_is_base_wlh(uint64_t dq_state)
-{
-	return dq_state & DISPATCH_QUEUE_ROLE_BASE_WLH;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dq_state_is_base_anon(uint64_t dq_state)
-{
-	return dq_state & DISPATCH_QUEUE_ROLE_BASE_ANON;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dq_state_is_inner_queue(uint64_t dq_state)
-{
-	return (dq_state & DISPATCH_QUEUE_ROLE_MASK) == DISPATCH_QUEUE_ROLE_INNER;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dq_state_is_enqueued(uint64_t dq_state)
-{
-	return dq_state & (DISPATCH_QUEUE_ENQUEUED|DISPATCH_QUEUE_ENQUEUED_ON_MGR);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dq_state_is_enqueued_on_target(uint64_t dq_state)
-{
-	return dq_state & DISPATCH_QUEUE_ENQUEUED;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dq_state_is_enqueued_on_manager(uint64_t dq_state)
-{
-	return dq_state & DISPATCH_QUEUE_ENQUEUED_ON_MGR;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dq_state_in_sync_transfer(uint64_t dq_state)
-{
-	return dq_state & DISPATCH_QUEUE_SYNC_TRANSFER;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dq_state_received_override(uint64_t dq_state)
-{
-	return _dq_state_is_base_anon(dq_state) &&
-			(dq_state & DISPATCH_QUEUE_RECEIVED_OVERRIDE);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dq_state_received_sync_wait(uint64_t dq_state)
-{
-	return _dq_state_is_base_wlh(dq_state) &&
-			(dq_state & DISPATCH_QUEUE_RECEIVED_SYNC_WAIT);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_qos_t
-_dq_state_max_qos(uint64_t dq_state)
-{
-	dq_state &= DISPATCH_QUEUE_MAX_QOS_MASK;
-	return (dispatch_qos_t)(dq_state >> DISPATCH_QUEUE_MAX_QOS_SHIFT);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline uint64_t
-_dq_state_from_qos(dispatch_qos_t qos)
-{
-	return (uint64_t)(qos) << DISPATCH_QUEUE_MAX_QOS_SHIFT;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline uint64_t
-_dq_state_merge_qos(uint64_t dq_state, dispatch_qos_t qos)
-{
-	uint64_t qos_bits = _dq_state_from_qos(qos);
-	if ((dq_state & DISPATCH_QUEUE_MAX_QOS_MASK) < qos_bits) {
-		dq_state &= ~DISPATCH_QUEUE_MAX_QOS_MASK;
-		dq_state |= qos_bits;
-		if (unlikely(_dq_state_is_base_anon(dq_state))) {
-			dq_state |= DISPATCH_QUEUE_RECEIVED_OVERRIDE;
-		}
-	}
-	return dq_state;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_tid
-_dq_state_drain_owner(uint64_t dq_state)
-{
-	return _dispatch_lock_owner((dispatch_lock)dq_state);
-}
-#define DISPATCH_QUEUE_DRAIN_OWNER(dq) \
-	_dq_state_drain_owner(os_atomic_load2o(dq, dq_state, relaxed))
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dq_state_drain_locked_by(uint64_t dq_state, dispatch_tid tid)
-{
-	return _dispatch_lock_is_locked_by((dispatch_lock)dq_state, tid);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dq_state_drain_locked_by_self(uint64_t dq_state)
-{
-	return _dispatch_lock_is_locked_by_self((dispatch_lock)dq_state);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dq_state_drain_locked(uint64_t dq_state)
-{
-	return _dispatch_lock_is_locked((dispatch_lock)dq_state);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dq_state_is_sync_runnable(uint64_t dq_state)
-{
-	return dq_state < DISPATCH_QUEUE_IN_BARRIER;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dq_state_is_runnable(uint64_t dq_state)
-{
-	return dq_state < DISPATCH_QUEUE_WIDTH_FULL_BIT;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dq_state_should_override(uint64_t dq_state)
-{
-	if (_dq_state_is_suspended(dq_state) ||
-			_dq_state_is_enqueued_on_manager(dq_state)) {
-		return false;
-	}
-	if (_dq_state_is_enqueued_on_target(dq_state)) {
-		return true;
-	}
-	if (_dq_state_is_base_wlh(dq_state)) {
-		return false;
-	}
-	return _dq_state_drain_locked(dq_state);
-}
-
-
-#endif // __cplusplus
-#pragma mark -
-#pragma mark dispatch_queue_t state machine
-
-static inline pthread_priority_t _dispatch_get_priority(void);
-static inline dispatch_priority_t _dispatch_get_basepri(void);
-static inline dispatch_qos_t _dispatch_get_basepri_override_qos_floor(void);
-static inline void _dispatch_set_basepri_override_qos(dispatch_qos_t qos);
-static inline void _dispatch_reset_basepri(dispatch_priority_t dbp);
-static inline dispatch_priority_t _dispatch_set_basepri(dispatch_priority_t dbp);
-
-#if DISPATCH_PURE_C
-
-// Note to later developers: ensure that any initialization changes are
-// made for statically allocated queues (i.e. _dispatch_main_q).
-static inline dispatch_queue_class_t
-_dispatch_queue_init(dispatch_queue_class_t dqu, dispatch_queue_flags_t dqf,
-		uint16_t width, uint64_t initial_state_bits)
-{
-	uint64_t dq_state = DISPATCH_QUEUE_STATE_INIT_VALUE(width);
-	dispatch_queue_t dq = dqu._dq;
-
-	dispatch_assert((initial_state_bits & ~(DISPATCH_QUEUE_ROLE_MASK |
-			DISPATCH_QUEUE_INACTIVE)) == 0);
-
-	if (initial_state_bits & DISPATCH_QUEUE_INACTIVE) {
-		dq_state |= DISPATCH_QUEUE_INACTIVE + DISPATCH_QUEUE_NEEDS_ACTIVATION;
-		dq->do_ref_cnt += 2; // rdar://8181908 see _dispatch_lane_resume
-		if (dx_metatype(dq) == _DISPATCH_SOURCE_TYPE) {
-			dq->do_ref_cnt++; // released when DSF_DELETED is set
-		}
-	}
-
-	dq_state |= (initial_state_bits & DISPATCH_QUEUE_ROLE_MASK);
-	dq->do_next = DISPATCH_OBJECT_LISTLESS;
-	dqf |= DQF_WIDTH(width);
-	os_atomic_store2o(dq, dq_atomic_flags, dqf, relaxed);
-	dq->dq_state = dq_state;
-	dq->dq_serialnum =
-			os_atomic_inc_orig(&_dispatch_queue_serial_numbers, relaxed);
-	return dqu;
-}
-#define _dispatch_queue_alloc(name, dqf, w, initial_state_bits) \
-		_dispatch_queue_init(_dispatch_object_alloc(DISPATCH_VTABLE(name),\
-				sizeof(struct dispatch_##name##_s)), dqf, w, initial_state_bits)
-
-/* Used by:
- * - _dispatch_lane_set_target_queue
- * - changing dispatch source handlers
- *
- * Tries to prevent concurrent wakeup of an inactive queue by suspending it.
- */
-DISPATCH_ALWAYS_INLINE DISPATCH_WARN_RESULT
-static inline bool
-_dispatch_lane_try_inactive_suspend(dispatch_lane_class_t dqu)
-{
-	uint64_t old_state, new_state;
-
-	(void)os_atomic_rmw_loop2o(dqu._dl, dq_state, old_state, new_state, relaxed, {
-		if (unlikely(!_dq_state_is_inactive(old_state))) {
-			os_atomic_rmw_loop_give_up(return false);
-		}
-		new_state = old_state + DISPATCH_QUEUE_SUSPEND_INTERVAL;
-	});
-	if (unlikely(!_dq_state_is_suspended(old_state) ||
-			_dq_state_has_side_suspend_cnt(old_state))) {
-		// Crashing here means that 128+ dispatch_suspend() calls have been
-		// made on an inactive object and then dispatch_set_target_queue() or
-		// dispatch_set_*_handler() has been called.
-		//
-		// We don't want to handle the side suspend count in a codepath that
-		// needs to be fast.
-		DISPATCH_CLIENT_CRASH(0, "Too many calls to dispatch_suspend() "
-				"prior to calling dispatch_set_target_queue() "
-				"or dispatch_set_*_handler()");
-	}
-	return true;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dq_state_needs_lock_override(uint64_t dq_state, dispatch_qos_t qos)
-{
-	return _dq_state_is_base_anon(dq_state) &&
-			qos < _dq_state_max_qos(dq_state);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_qos_t
-_dispatch_queue_override_self(uint64_t dq_state)
-{
-	dispatch_qos_t qos = _dq_state_max_qos(dq_state);
-	_dispatch_wqthread_override_start(_dispatch_tid_self(), qos);
-	// ensure that the root queue sees
-	// that this thread was overridden.
-	_dispatch_set_basepri_override_qos(qos);
-	return qos;
-}
-
-DISPATCH_ALWAYS_INLINE DISPATCH_WARN_RESULT
-static inline uint64_t
-_dispatch_queue_drain_try_lock(dispatch_queue_t dq,
-		dispatch_invoke_flags_t flags)
-{
-	uint64_t pending_barrier_width =
-			(dq->dq_width - 1) * DISPATCH_QUEUE_WIDTH_INTERVAL;
-	uint64_t set_owner_and_set_full_width =
-			_dispatch_lock_value_for_self() | DISPATCH_QUEUE_WIDTH_FULL_BIT;
-	uint64_t lock_fail_mask, old_state, new_state, dequeue_mask;
-
-	// same as !_dq_state_is_runnable()
-	lock_fail_mask  = ~(DISPATCH_QUEUE_WIDTH_FULL_BIT - 1);
-	// same as _dq_state_drain_locked()
-	lock_fail_mask |= DISPATCH_QUEUE_DRAIN_OWNER_MASK;
-
-	if (flags & DISPATCH_INVOKE_STEALING) {
-		lock_fail_mask |= DISPATCH_QUEUE_ENQUEUED_ON_MGR;
-		dequeue_mask = 0;
-	} else if (flags & DISPATCH_INVOKE_MANAGER_DRAIN) {
-		dequeue_mask = DISPATCH_QUEUE_ENQUEUED_ON_MGR;
-	} else {
-		lock_fail_mask |= DISPATCH_QUEUE_ENQUEUED_ON_MGR;
-		dequeue_mask = DISPATCH_QUEUE_ENQUEUED;
-	}
-	dispatch_assert(!(flags & DISPATCH_INVOKE_WLH));
-
-	dispatch_qos_t oq_floor = _dispatch_get_basepri_override_qos_floor();
-retry:
-	os_atomic_rmw_loop2o(dq, dq_state, old_state, new_state, acquire, {
-		new_state = old_state;
-		if (likely(!(old_state & lock_fail_mask))) {
-			if (unlikely(_dq_state_needs_lock_override(old_state, oq_floor))) {
-				os_atomic_rmw_loop_give_up({
-					oq_floor = _dispatch_queue_override_self(old_state);
-					goto retry;
-				});
-			}
-			//
-			// Only keep the HAS_WAITER, MAX_QOS and ENQUEUED bits
-			// In particular acquiring the drain lock clears the DIRTY and
-			// RECEIVED_OVERRIDE bits.
-			//
-			new_state &= DISPATCH_QUEUE_DRAIN_PRESERVED_BITS_MASK;
-			new_state |= set_owner_and_set_full_width;
-			if (_dq_state_has_pending_barrier(old_state) ||
-					old_state + pending_barrier_width <
-					DISPATCH_QUEUE_WIDTH_FULL_BIT) {
-				new_state |= DISPATCH_QUEUE_IN_BARRIER;
-			}
-		} else if (dequeue_mask) {
-			// dequeue_mask is in a register, xor yields better assembly
-			new_state ^= dequeue_mask;
-		} else {
-			os_atomic_rmw_loop_give_up(break);
-		}
-	});
-
-	dispatch_assert((old_state & dequeue_mask) == dequeue_mask);
-	if (likely(!(old_state & lock_fail_mask))) {
-		new_state &= DISPATCH_QUEUE_IN_BARRIER | DISPATCH_QUEUE_WIDTH_FULL_BIT |
-				dequeue_mask;
-		old_state &= DISPATCH_QUEUE_WIDTH_MASK;
-		return new_state - old_state;
-	}
-	return 0;
-}
-
-DISPATCH_ALWAYS_INLINE DISPATCH_WARN_RESULT
-static inline bool
-_dispatch_queue_drain_try_lock_wlh(dispatch_queue_t dq, uint64_t *dq_state)
-{
-	uint64_t old_state, new_state;
-	uint64_t lock_bits = _dispatch_lock_value_for_self() |
-			DISPATCH_QUEUE_WIDTH_FULL_BIT | DISPATCH_QUEUE_IN_BARRIER;
-
-	os_atomic_rmw_loop2o(dq, dq_state, old_state, new_state, acquire, {
-		new_state = old_state;
-		if (unlikely(_dq_state_is_suspended(old_state))) {
-			new_state &= ~DISPATCH_QUEUE_ENQUEUED;
-		} else if (unlikely(_dq_state_drain_locked(old_state))) {
-			os_atomic_rmw_loop_give_up(break);
-		} else {
-			new_state &= DISPATCH_QUEUE_DRAIN_PRESERVED_BITS_MASK;
-			new_state |= lock_bits;
-		}
-	});
-	if (unlikely(!_dq_state_is_base_wlh(old_state) ||
-			!_dq_state_is_enqueued_on_target(old_state) ||
-			_dq_state_is_enqueued_on_manager(old_state))) {
-#if DISPATCH_SIZEOF_PTR == 4
-		old_state >>= 32;
-#endif
-		DISPATCH_INTERNAL_CRASH(old_state, "Invalid wlh state");
-	}
-
-	if (dq_state) *dq_state = new_state;
-	return !_dq_state_is_suspended(old_state) &&
-			!_dq_state_drain_locked(old_state);
-}
-
-/* Used by _dispatch_barrier_{try,}sync
- *
- * Note, this fails if any of e:1 or dl!=0, but that allows this code to be a
- * simple cmpxchg which is significantly faster on Intel, and makes a
- * significant difference on the uncontended codepath.
- *
- * See discussion for DISPATCH_QUEUE_DIRTY in queue_internal.h
- *
- * Initial state must be `completely idle`
- * Final state forces { ib:1, qf:1, w:0 }
- */
-DISPATCH_ALWAYS_INLINE DISPATCH_WARN_RESULT
-static inline bool
-_dispatch_queue_try_acquire_barrier_sync_and_suspend(dispatch_lane_t dq,
-		uint32_t tid, uint64_t suspend_count)
-{
-	uint64_t init  = DISPATCH_QUEUE_STATE_INIT_VALUE(dq->dq_width);
-	uint64_t value = DISPATCH_QUEUE_WIDTH_FULL_BIT | DISPATCH_QUEUE_IN_BARRIER |
-			_dispatch_lock_value_from_tid(tid) |
-			(suspend_count * DISPATCH_QUEUE_SUSPEND_INTERVAL);
-	uint64_t old_state, new_state;
-
-	return os_atomic_rmw_loop2o(dq, dq_state, old_state, new_state, acquire, {
-		uint64_t role = old_state & DISPATCH_QUEUE_ROLE_MASK;
-		if (old_state != (init | role)) {
-			os_atomic_rmw_loop_give_up(break);
-		}
-		new_state = value | role;
-	});
-}
-
-DISPATCH_ALWAYS_INLINE DISPATCH_WARN_RESULT
-static inline bool
-_dispatch_queue_try_acquire_barrier_sync(dispatch_queue_class_t dq, uint32_t tid)
-{
-	return _dispatch_queue_try_acquire_barrier_sync_and_suspend(dq._dl, tid, 0);
-}
-
-/* Used by _dispatch_sync for root queues and some drain codepaths
- *
- * Root queues have no strict orderning and dispatch_sync() always goes through.
- * Drain is the sole setter of `dl` hence can use this non failing version of
- * _dispatch_queue_try_acquire_sync().
- *
- * Final state: { w += 1 }
- */
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_queue_reserve_sync_width(dispatch_lane_t dq)
-{
-	os_atomic_add2o(dq, dq_state, DISPATCH_QUEUE_WIDTH_INTERVAL, relaxed);
-}
-
-/* Used by _dispatch_sync on non-serial queues
- *
- * Initial state must be { sc:0, ib:0, pb:0, d:0 }
- * Final state: { w += 1 }
- */
-DISPATCH_ALWAYS_INLINE DISPATCH_WARN_RESULT
-static inline bool
-_dispatch_queue_try_reserve_sync_width(dispatch_lane_t dq)
-{
-	uint64_t old_state, new_state;
-
-	// <rdar://problem/24738102&24743140> reserving non barrier width
-	// doesn't fail if only the ENQUEUED bit is set (unlike its barrier width
-	// equivalent), so we have to check that this thread hasn't enqueued
-	// anything ahead of this call or we can break ordering
-	if (unlikely(dq->dq_items_tail)) {
-		return false;
-	}
-
-	return os_atomic_rmw_loop2o(dq, dq_state, old_state, new_state, relaxed, {
-		if (unlikely(!_dq_state_is_sync_runnable(old_state)) ||
-				_dq_state_is_dirty(old_state) ||
-				_dq_state_has_pending_barrier(old_state)) {
-			os_atomic_rmw_loop_give_up(return false);
-		}
-		new_state = old_state + DISPATCH_QUEUE_WIDTH_INTERVAL;
-	});
-}
-
-/* Used by target-queue recursing code
- *
- * Initial state must be { sc:0, ib:0, qf:0, pb:0, d:0 }
- * Final state: { w += 1 }
- */
-DISPATCH_ALWAYS_INLINE DISPATCH_WARN_RESULT
-static inline bool
-_dispatch_queue_try_acquire_async(dispatch_lane_t dq)
-{
-	uint64_t old_state, new_state;
-
-	return os_atomic_rmw_loop2o(dq, dq_state, old_state, new_state, acquire, {
-		if (unlikely(!_dq_state_is_runnable(old_state) ||
-				_dq_state_is_dirty(old_state) ||
-				_dq_state_has_pending_barrier(old_state))) {
-			os_atomic_rmw_loop_give_up(return false);
-		}
-		new_state = old_state + DISPATCH_QUEUE_WIDTH_INTERVAL;
-	});
-}
-
-/* Used by concurrent drain
- *
- * Either acquires the full barrier width, in which case the Final state is:
- *   { ib:1 qf:1 pb:0 d:0 }
- * Or if there isn't enough width prepare the queue with the PENDING_BARRIER bit
- *   { ib:0 pb:1 d:0}
- *
- * This always clears the dirty bit as we know for sure we shouldn't reevaluate
- * the state machine here
- */
-DISPATCH_ALWAYS_INLINE DISPATCH_WARN_RESULT
-static inline bool
-_dispatch_queue_try_upgrade_full_width(dispatch_lane_t dq, uint64_t owned)
-{
-	uint64_t old_state, new_state;
-	uint64_t pending_barrier_width = DISPATCH_QUEUE_PENDING_BARRIER +
-			(dq->dq_width - 1) * DISPATCH_QUEUE_WIDTH_INTERVAL;
-
-	os_atomic_rmw_loop2o(dq, dq_state, old_state, new_state, acquire, {
-		new_state = old_state - owned;
-		if (likely(!_dq_state_has_pending_barrier(old_state))) {
-			new_state += pending_barrier_width;
-		}
-		if (likely(_dq_state_is_runnable(new_state))) {
-			new_state += DISPATCH_QUEUE_WIDTH_INTERVAL;
-			new_state += DISPATCH_QUEUE_IN_BARRIER;
-			new_state -= DISPATCH_QUEUE_PENDING_BARRIER;
-		}
-		new_state &= ~DISPATCH_QUEUE_DIRTY;
-	});
-	return new_state & DISPATCH_QUEUE_IN_BARRIER;
-}
-
-/* Used at the end of Drainers
- *
- * This adjusts the `owned` width when the next continuation is already known
- * to account for its barrierness.
- */
-DISPATCH_ALWAYS_INLINE
-static inline uint64_t
-_dispatch_queue_adjust_owned(dispatch_queue_class_t dq, uint64_t owned,
-		struct dispatch_object_s *next_dc)
-{
-	uint16_t dq_width = dq._dq->dq_width;
-	uint64_t reservation;
-
-	if (unlikely(dq_width > 1)) {
-		if (next_dc && _dispatch_object_is_barrier(next_dc)) {
-			reservation  = DISPATCH_QUEUE_PENDING_BARRIER;
-			reservation += (dq_width - 1) * DISPATCH_QUEUE_WIDTH_INTERVAL;
-			owned -= reservation;
-		}
-	}
-	return owned;
-}
-
-/* Used at the end of Drainers
- *
- * Unlocking fails if the DIRTY bit is seen (and the queue is not suspended).
- * In that case, only the DIRTY bit is cleared. The DIRTY bit is therefore used
- * as a signal to renew the drain lock instead of releasing it.
- *
- * Successful unlock forces { dl:0, d:!done, qo:0 } and gives back `owned`
- */
-DISPATCH_ALWAYS_INLINE DISPATCH_WARN_RESULT
-static inline bool
-_dispatch_queue_drain_try_unlock(dispatch_queue_t dq, uint64_t owned, bool done)
-{
-	uint64_t old_state, new_state;
-
-	os_atomic_rmw_loop2o(dq, dq_state, old_state, new_state, release, {
-		new_state  = old_state - owned;
-		new_state &= ~DISPATCH_QUEUE_DRAIN_UNLOCK_MASK;
-		if (unlikely(_dq_state_is_suspended(old_state))) {
-			// nothing to do
-		} else if (unlikely(_dq_state_is_dirty(old_state))) {
-			os_atomic_rmw_loop_give_up({
-				// just renew the drain lock with an acquire barrier, to see
-				// what the enqueuer that set DIRTY has done.
-				// the xor generates better assembly as DISPATCH_QUEUE_DIRTY
-				// is already in a register
-				os_atomic_xor2o(dq, dq_state, DISPATCH_QUEUE_DIRTY, acquire);
-				return false;
-			});
-		} else if (likely(done)) {
-			new_state &= ~DISPATCH_QUEUE_MAX_QOS_MASK;
-		} else {
-			new_state |= DISPATCH_QUEUE_DIRTY;
-		}
-	});
-
-	if (_dq_state_received_override(old_state)) {
-		// Ensure that the root queue sees that this thread was overridden.
-		_dispatch_set_basepri_override_qos(_dq_state_max_qos(old_state));
-	}
-	return true;
-}
-
-#pragma mark -
-#pragma mark os_mpsc_queue
-
-#define _os_mpsc_head(q, _ns, ...)   &(q)->_ns##_head ##__VA_ARGS__
-#define _os_mpsc_tail(q, _ns, ...)   &(q)->_ns##_tail ##__VA_ARGS__
-
-#define os_mpsc(q, _ns, ...)   (q, _ns, __VA_ARGS__)
-
-#define os_mpsc_node_type(Q) _os_atomic_basetypeof(_os_mpsc_head Q)
-
-//
-// Multi Producer calls, can be used safely concurrently
-//
-
-// Returns true when the queue was empty and the head must be set
-#define os_mpsc_push_update_tail(Q, tail, _o_next)  ({ \
-		os_mpsc_node_type(Q) _tl = (tail); \
-		os_atomic_store2o(_tl, _o_next, NULL, relaxed); \
-		os_atomic_xchg(_os_mpsc_tail Q, _tl, release); \
-	})
-
-#define os_mpsc_push_was_empty(prev) ((prev) == NULL)
-
-#define os_mpsc_push_update_prev(Q, prev, head, _o_next)  ({ \
-		os_mpsc_node_type(Q) _prev = (prev); \
-		if (likely(_prev)) { \
-			(void)os_atomic_store2o(_prev, _o_next, (head), relaxed); \
-		} else { \
-			(void)os_atomic_store(_os_mpsc_head Q, (head), relaxed); \
-		} \
-	})
-
-#define os_mpsc_push_list(Q, head, tail, _o_next)  ({ \
-		os_mpsc_node_type(Q) _token; \
-		_token = os_mpsc_push_update_tail(Q, tail, _o_next); \
-		os_mpsc_push_update_prev(Q, _token, head, _o_next); \
-		os_mpsc_push_was_empty(_token); \
-	})
-
-// Returns true when the queue was empty and the head must be set
-#define os_mpsc_push_item(Q, tail, _o_next)  ({ \
-		os_mpsc_node_type(Q) _tail = (tail); \
-		os_mpsc_push_list(Q, _tail, _tail, _o_next); \
-	})
-
-//
-// Single Consumer calls, can NOT be used safely concurrently
-//
-
-#define os_mpsc_looks_empty(Q) \
-		(os_atomic_load(_os_mpsc_tail Q, relaxed) == NULL)
-
-#define os_mpsc_get_head(Q)  ({ \
-		__typeof__(_os_mpsc_head Q) __n = _os_mpsc_head Q; \
-		os_mpsc_node_type(Q) _node; \
-		_node = os_atomic_load(__n, dependency); \
-		if (unlikely(_node == NULL)) { \
-			_node = _dispatch_wait_for_enqueuer((void **)__n); \
-		} \
-		_node; \
-	})
-
-#define os_mpsc_get_next(_n, _o_next)  ({ \
-		__typeof__(_n) __n = (_n); \
-		_os_atomic_basetypeof(&__n->_o_next) _node; \
-		_node = os_atomic_load(&__n->_o_next, dependency); \
-		if (unlikely(_node == NULL)) { \
-			_node = _dispatch_wait_for_enqueuer((void **)&__n->_o_next); \
-		} \
-		_node; \
-	})
-
-#define os_mpsc_pop_head(Q, head, _o_next)  ({ \
-		os_mpsc_node_type(Q) _head = (head), _n; \
-		_n = os_atomic_load2o(_head, _o_next, dependency); \
-		os_atomic_store(_os_mpsc_head Q, _n, relaxed); \
-		/* 22708742: set tail to NULL with release, so that NULL write */ \
-		/* to head above doesn't clobber head from concurrent enqueuer */ \
-		if (unlikely(!_n && \
-				!os_atomic_cmpxchg(_os_mpsc_tail Q, _head, NULL, release))) { \
-			_n = os_mpsc_get_next(_head, _o_next); \
-			os_atomic_store(_os_mpsc_head Q, _n, relaxed); \
-		} \
-		_n; \
-	})
-
-#define os_mpsc_undo_pop_list(Q, head, tail, next, _o_next)  ({ \
-		os_mpsc_node_type(Q) _hd = (head), _tl = (tail), _n = (next); \
-		os_atomic_store2o(_tl, _o_next, _n, relaxed); \
-		if (unlikely(!_n && \
-				!os_atomic_cmpxchg(_os_mpsc_tail Q, NULL, _tl, release))) { \
-			_n = os_mpsc_get_head(Q); \
-			os_atomic_store2o(_tl, _o_next, _n, relaxed); \
-		} \
-		os_atomic_store(_os_mpsc_head Q, _hd, relaxed); \
-	})
-
-#define os_mpsc_undo_pop_head(Q, head, next, _o_next) ({ \
-		os_mpsc_node_type(Q) _head = (head); \
-		os_mpsc_undo_pop_list(Q, _head, _head, next, _o_next); \
-	})
-
-#define os_mpsc_capture_snapshot(Q, tail)  ({ \
-		os_mpsc_node_type(Q) _head = os_mpsc_get_head(Q); \
-		os_atomic_store(_os_mpsc_head Q, NULL, relaxed); \
-		/* 22708742: set tail to NULL with release, so that NULL write */ \
-		/* to head above doesn't clobber head from concurrent enqueuer */ \
-		*(tail) = os_atomic_xchg(_os_mpsc_tail Q, NULL, release); \
-		_head; \
-	})
-
-#define os_mpsc_pop_snapshot_head(head, tail, _o_next) ({ \
-		__typeof__(head) _head = (head), _tail = (tail), _n = NULL; \
-		if (_head != _tail) _n = os_mpsc_get_next(_head, _o_next); \
-		_n; \
-	})
-
-#define os_mpsc_prepend(Q, head, tail, _o_next)  ({ \
-		os_mpsc_node_type(Q) _n = os_atomic_load(_os_mpsc_head Q, relaxed); \
-		os_mpsc_undo_pop_list(Q, head, tail, _n, _o_next); \
-	})
-
-#pragma mark -
-#pragma mark dispatch_queue_t tq lock
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dispatch_queue_sidelock_trylock(dispatch_lane_t dq, dispatch_qos_t qos)
-{
-	dispatch_tid owner;
-	if (_dispatch_unfair_lock_trylock(&dq->dq_sidelock, &owner)) {
-		return true;
-	}
-	_dispatch_wqthread_override_start_check_owner(owner, qos,
-			&dq->dq_sidelock.dul_lock);
-	return false;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_queue_sidelock_lock(dispatch_lane_t dq)
-{
-	return _dispatch_unfair_lock_lock(&dq->dq_sidelock);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dispatch_queue_sidelock_tryunlock(dispatch_lane_t dq)
-{
-	if (_dispatch_unfair_lock_tryunlock(&dq->dq_sidelock)) {
-		return true;
-	}
-	// Ensure that the root queue sees that this thread was overridden.
-	// Since we don't know which override QoS was used, use MAINTENANCE
-	// as a marker for _dispatch_reset_basepri_override()
-	_dispatch_set_basepri_override_qos(DISPATCH_QOS_MAINTENANCE);
-	return false;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_queue_sidelock_unlock(dispatch_lane_t dq)
-{
-	if (_dispatch_unfair_lock_unlock_had_failed_trylock(&dq->dq_sidelock)) {
-		// Ensure that the root queue sees that this thread was overridden.
-		// Since we don't know which override QoS was used, use MAINTENANCE
-		// as a marker for _dispatch_reset_basepri_override()
-		_dispatch_set_basepri_override_qos(DISPATCH_QOS_MAINTENANCE);
-	}
-}
-
-#pragma mark -
-#pragma mark dispatch_queue_t misc
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_queue_t
-_dispatch_queue_get_current(void)
-{
-	return (dispatch_queue_t)_dispatch_thread_getspecific(dispatch_queue_key);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_queue_t
-_dispatch_queue_get_current_or_default(void)
-{
-	int idx = DISPATCH_ROOT_QUEUE_IDX_DEFAULT_QOS_OVERCOMMIT;
-	return _dispatch_queue_get_current() ?: _dispatch_root_queues[idx]._as_dq;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_queue_set_current(dispatch_queue_class_t dqu)
-{
-	_dispatch_thread_setspecific(dispatch_queue_key, dqu._dq);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline struct dispatch_object_s*
-_dispatch_queue_get_head(dispatch_lane_class_t dq)
-{
-	return os_mpsc_get_head(os_mpsc(dq._dl, dq_items));
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline struct dispatch_object_s*
-_dispatch_queue_pop_head(dispatch_lane_class_t dq, struct dispatch_object_s *dc)
-{
-	return os_mpsc_pop_head(os_mpsc(dq._dl, dq_items), dc, do_next);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dispatch_queue_push_item(dispatch_lane_class_t dqu, dispatch_object_t dou)
-{
-	return os_mpsc_push_item(os_mpsc(dqu._dl, dq_items), dou._do, do_next);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_root_queue_push_inline(dispatch_queue_global_t dq,
-		dispatch_object_t _head, dispatch_object_t _tail, int n)
-{
-	struct dispatch_object_s *hd = _head._do, *tl = _tail._do;
-	if (unlikely(os_mpsc_push_list(os_mpsc(dq, dq_items), hd, tl, do_next))) {
-		return _dispatch_root_queue_poke(dq, n, 0);
-	}
-}
-
-#include "trace.h"
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_queue_push_queue(dispatch_queue_t tq, dispatch_queue_class_t dq,
-		uint64_t dq_state)
-{
-#if DISPATCH_USE_KEVENT_WORKLOOP
-	if (likely(_dq_state_is_base_wlh(dq_state))) {
-		_dispatch_trace_runtime_event(worker_request, dq._dq, 1);
-		return _dispatch_event_loop_poke((dispatch_wlh_t)dq._dq, dq_state,
-				DISPATCH_EVENT_LOOP_CONSUME_2);
-	}
-#endif // DISPATCH_USE_KEVENT_WORKLOOP
-	_dispatch_trace_item_push(tq, dq);
-	return dx_push(tq, dq, _dq_state_max_qos(dq_state));
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_priority_t
-_dispatch_root_queue_identity_assume(dispatch_queue_global_t assumed_rq)
-{
-	dispatch_priority_t old_dbp = _dispatch_get_basepri();
-	dispatch_assert(dx_hastypeflag(assumed_rq, QUEUE_ROOT));
-	_dispatch_reset_basepri(assumed_rq->dq_priority);
-	_dispatch_queue_set_current(assumed_rq);
-	return old_dbp;
-}
-
-typedef dispatch_queue_wakeup_target_t
-_dispatch_queue_class_invoke_handler_t(dispatch_queue_class_t,
-		dispatch_invoke_context_t dic, dispatch_invoke_flags_t,
-		uint64_t *owned);
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_queue_class_invoke(dispatch_queue_class_t dqu,
-		dispatch_invoke_context_t dic, dispatch_invoke_flags_t flags,
-		dispatch_invoke_flags_t const_restrict_flags,
-		_dispatch_queue_class_invoke_handler_t invoke)
-{
-	dispatch_queue_t dq = dqu._dq;
-	dispatch_queue_wakeup_target_t tq = DISPATCH_QUEUE_WAKEUP_NONE;
-	bool owning = !(flags & DISPATCH_INVOKE_STEALING);
-	uint64_t owned = 0;
-
-	// When called from a plain _dispatch_queue_drain:
-	//   overriding = false
-	//   owning = true
-	//
-	// When called from an override continuation:
-	//   overriding = true
-	//   owning depends on whether the override embedded the queue or steals
-
-	if (!(flags & (DISPATCH_INVOKE_STEALING | DISPATCH_INVOKE_WLH))) {
-		dq->do_next = DISPATCH_OBJECT_LISTLESS;
-		_dispatch_trace_item_pop(_dispatch_queue_get_current(), dq);
-	}
-	flags |= const_restrict_flags;
-	if (likely(flags & DISPATCH_INVOKE_WLH)) {
-		owned = DISPATCH_QUEUE_SERIAL_DRAIN_OWNED | DISPATCH_QUEUE_ENQUEUED;
-	} else {
-		owned = _dispatch_queue_drain_try_lock(dq, flags);
-	}
-	if (likely(owned)) {
-		dispatch_priority_t old_dbp;
-		if (!(flags & DISPATCH_INVOKE_MANAGER_DRAIN)) {
-			old_dbp = _dispatch_set_basepri(dq->dq_priority);
-		} else {
-			old_dbp = 0;
-		}
-		if (flags & DISPATCH_INVOKE_WORKLOOP_DRAIN) {
-			if (unlikely(_dispatch_queue_atomic_flags(dqu) & DQF_MUTABLE)) {
-				_dispatch_queue_atomic_flags_clear(dqu, DQF_MUTABLE);
-			}
-		}
-
-		flags = _dispatch_queue_merge_autorelease_frequency(dq, flags);
-attempt_running_slow_head:
-#if DISPATCH_COCOA_COMPAT
-		if ((flags & DISPATCH_INVOKE_WLH) &&
-				!(flags & DISPATCH_INVOKE_AUTORELEASE_ALWAYS)) {
-			_dispatch_last_resort_autorelease_pool_push(dic);
-		}
-#endif // DISPATCH_COCOA_COMPAT
-		tq = invoke(dq, dic, flags, &owned);
-#if DISPATCH_COCOA_COMPAT
-		if ((flags & DISPATCH_INVOKE_WLH) &&
-				!(flags & DISPATCH_INVOKE_AUTORELEASE_ALWAYS)) {
-			dispatch_thread_frame_s dtf;
-			_dispatch_thread_frame_push(&dtf, dq);
-			_dispatch_last_resort_autorelease_pool_pop(dic);
-			_dispatch_thread_frame_pop(&dtf);
-		}
-#endif // DISPATCH_COCOA_COMPAT
-		dispatch_assert(tq != DISPATCH_QUEUE_WAKEUP_TARGET);
-		if (unlikely(tq != DISPATCH_QUEUE_WAKEUP_NONE &&
-				tq != DISPATCH_QUEUE_WAKEUP_WAIT_FOR_EVENT)) {
-			// Either dc is set, which is a deferred invoke case
-			//
-			// or only tq is and it means a reenqueue is required, because of:
-			// a retarget, a suspension, or a width change.
-			//
-			// In both cases, we want to bypass the check for DIRTY.
-			// That may cause us to leave DIRTY in place but all drain lock
-			// acquirers clear it
-		} else if (!_dispatch_queue_drain_try_unlock(dq, owned,
-				tq == DISPATCH_QUEUE_WAKEUP_NONE)) {
-			tq = _dispatch_queue_get_current();
-			if (dx_hastypeflag(tq, QUEUE_ROOT) || !owning) {
-				goto attempt_running_slow_head;
-			}
-			DISPATCH_COMPILER_CAN_ASSUME(tq != DISPATCH_QUEUE_WAKEUP_NONE);
-		} else {
-			owned = 0;
-			tq = NULL;
-		}
-		if (!(flags & DISPATCH_INVOKE_MANAGER_DRAIN)) {
-			_dispatch_reset_basepri(old_dbp);
-		}
-	}
-	if (likely(owning)) {
-		_dispatch_trace_item_complete(dq);
-	}
-
-	if (tq) {
-		return _dispatch_queue_invoke_finish(dq, dic, tq, owned);
-	}
-
-	return _dispatch_release_2_tailcall(dq);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dispatch_queue_class_probe(dispatch_lane_class_t dqu)
-{
-	struct dispatch_object_s *tail;
-	// seq_cst wrt atomic store to dq_state <rdar://problem/14637483>
-	// seq_cst wrt atomic store to dq_flags <rdar://problem/22623242>
-	tail = os_atomic_load2o(dqu._dl, dq_items_tail, ordered);
-	return unlikely(tail != NULL);
-}
-
-DISPATCH_ALWAYS_INLINE DISPATCH_CONST
-static inline bool
-_dispatch_is_in_root_queues_array(dispatch_queue_class_t dqu)
-{
-	return (dqu._dgq >= _dispatch_root_queues) &&
-			(dqu._dgq < _dispatch_root_queues + _DISPATCH_ROOT_QUEUE_IDX_COUNT);
-}
-
-DISPATCH_ALWAYS_INLINE DISPATCH_CONST
-static inline dispatch_queue_global_t
-_dispatch_get_root_queue(dispatch_qos_t qos, bool overcommit)
-{
-	if (unlikely(qos < DISPATCH_QOS_MIN || qos > DISPATCH_QOS_MAX)) {
-		DISPATCH_CLIENT_CRASH(qos, "Corrupted priority");
-	}
-	return &_dispatch_root_queues[2 * (qos - 1) + overcommit];
-}
-
-#define _dispatch_get_default_queue(overcommit) \
-		_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_DEFAULT_QOS + \
-				!!(overcommit)]._as_dq
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_queue_set_bound_thread(dispatch_queue_class_t dqu)
-{
-	// Tag thread-bound queues with the owning thread
-	dispatch_assert(_dispatch_queue_is_thread_bound(dqu));
-	uint64_t old_state, new_state;
-	os_atomic_rmw_loop2o(dqu._dq, dq_state, old_state, new_state, relaxed, {
-		new_state = old_state;
-		new_state &= ~DISPATCH_QUEUE_DRAIN_OWNER_MASK;
-		new_state |= _dispatch_lock_value_for_self();
-	});
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_queue_clear_bound_thread(dispatch_queue_class_t dqu)
-{
-	dispatch_assert(_dispatch_queue_is_thread_bound(dqu));
-	os_atomic_and2o(dqu._dq, dq_state,
-			~DISPATCH_QUEUE_DRAIN_OWNER_MASK, relaxed);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_pthread_root_queue_observer_hooks_t
-_dispatch_get_pthread_root_queue_observer_hooks(void)
-{
-	return _dispatch_thread_getspecific(
-			dispatch_pthread_root_queue_observer_hooks_key);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_set_pthread_root_queue_observer_hooks(
-		dispatch_pthread_root_queue_observer_hooks_t observer_hooks)
-{
-	_dispatch_thread_setspecific(dispatch_pthread_root_queue_observer_hooks_key,
-			observer_hooks);
-}
-
-#pragma mark -
-#pragma mark dispatch_priority
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_priority_t
-_dispatch_get_basepri(void)
-{
-#if HAVE_PTHREAD_WORKQUEUE_QOS
-	return (dispatch_priority_t)(uintptr_t)_dispatch_thread_getspecific(
-			dispatch_basepri_key);
-#else
-	return 0;
-#endif
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_reset_basepri(dispatch_priority_t dbp)
-{
-#if HAVE_PTHREAD_WORKQUEUE_QOS
-	dispatch_priority_t old_dbp = _dispatch_get_basepri();
-	// If an inner-loop or'd in the override flag to the per-thread priority,
-	// it needs to be propagated up the chain.
-	dbp &= ~DISPATCH_PRIORITY_OVERRIDE_MASK;
-	dbp |= (old_dbp & DISPATCH_PRIORITY_OVERRIDE_MASK);
-	_dispatch_thread_setspecific(dispatch_basepri_key, (void*)(uintptr_t)dbp);
-#else
-	(void)dbp;
-#endif
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_qos_t
-_dispatch_get_basepri_override_qos_floor(void)
-{
-	dispatch_priority_t dbp = _dispatch_get_basepri();
-	dispatch_qos_t qos = _dispatch_priority_qos(dbp);
-	dispatch_qos_t oqos = _dispatch_priority_override_qos(dbp);
-	return MAX(qos, oqos);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_set_basepri_override_qos(dispatch_qos_t qos)
-{
-#if HAVE_PTHREAD_WORKQUEUE_QOS
-	dispatch_priority_t dbp = _dispatch_get_basepri();
-	if (_dispatch_priority_override_qos(dbp) >= qos) return;
-	dbp &= ~DISPATCH_PRIORITY_OVERRIDE_MASK;
-	dbp |= qos << DISPATCH_PRIORITY_OVERRIDE_SHIFT;
-	_dispatch_thread_setspecific(dispatch_basepri_key, (void*)(uintptr_t)dbp);
-#else
-	(void)qos;
-#endif
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dispatch_reset_basepri_override(void)
-{
-#if HAVE_PTHREAD_WORKQUEUE_QOS
-	dispatch_priority_t dbp = _dispatch_get_basepri();
-	dispatch_qos_t oqos = _dispatch_priority_override_qos(dbp);
-	if (oqos) {
-		dbp &= ~DISPATCH_PRIORITY_OVERRIDE_MASK;
-		_dispatch_thread_setspecific(dispatch_basepri_key, (void*)(uintptr_t)dbp);
-		return oqos != DISPATCH_QOS_SATURATED;
-	}
-#endif
-	return false;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_priority_t
-_dispatch_set_basepri(dispatch_priority_t dq_dbp)
-{
-#if HAVE_PTHREAD_WORKQUEUE_QOS
-	dispatch_priority_t old_dbp = _dispatch_get_basepri();
-	dispatch_priority_t dbp = old_dbp;
-
-	if (unlikely(!old_dbp)) {
-		dbp = dq_dbp & ~DISPATCH_PRIORITY_OVERRIDE_MASK;
-	} else if (dq_dbp & DISPATCH_PRIORITY_REQUESTED_MASK) {
-		dbp &= (DISPATCH_PRIORITY_OVERRIDE_MASK |
-				DISPATCH_PRIORITY_FLAG_OVERCOMMIT);
-		dbp |= MAX(old_dbp & DISPATCH_PRIORITY_REQUESTED_MASK,
-				dq_dbp & DISPATCH_PRIORITY_REQUESTED_MASK);
-		if (_dispatch_priority_fallback_qos(dq_dbp) >
-				_dispatch_priority_qos(dbp)) {
-			dq_dbp &= (DISPATCH_PRIORITY_FALLBACK_QOS_MASK |
-					DISPATCH_PRIORITY_FLAG_FALLBACK |
-					DISPATCH_PRIORITY_FLAG_FLOOR);
-		} else {
-			dq_dbp &= DISPATCH_PRIORITY_FLAG_FLOOR;
-		}
-		dbp |= dq_dbp;
-	} else {
-		if (dbp & DISPATCH_PRIORITY_REQUESTED_MASK) {
-			dbp |= DISPATCH_PRIORITY_FLAG_FLOOR;
-		}
-		if (_dispatch_priority_fallback_qos(dq_dbp) >
-				_dispatch_priority_qos(dbp)) {
-			dbp &= ~DISPATCH_PRIORITY_FALLBACK_QOS_MASK;
-			dbp |= (dq_dbp & (DISPATCH_PRIORITY_FALLBACK_QOS_MASK |
-					DISPATCH_PRIORITY_FLAG_FALLBACK));
-		}
-	}
-	_dispatch_thread_setspecific(dispatch_basepri_key, (void*)(uintptr_t)dbp);
-	return old_dbp;
-#else
-	(void)dq_dbp;
-	return 0;
-#endif
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_init_basepri(dispatch_priority_t dbp)
-{
-#if HAVE_PTHREAD_WORKQUEUE_QOS
-	dispatch_assert(!_dispatch_get_basepri());
-	_dispatch_thread_setspecific(dispatch_basepri_key, (void*)(uintptr_t)dbp);
-#else
-	(void)dbp;
-#endif
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_init_basepri_wlh(dispatch_priority_t dbp)
-{
-#if HAVE_PTHREAD_WORKQUEUE_QOS
-	dispatch_assert(!_dispatch_get_basepri());
-	dbp |= _dispatch_priority_make_override(DISPATCH_QOS_SATURATED);
-	_dispatch_thread_setspecific(dispatch_basepri_key, (void*)(uintptr_t)dbp);
-#else
-	(void)dbp;
-#endif
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_clear_basepri(void)
-{
-#if HAVE_PTHREAD_WORKQUEUE_QOS
-	_dispatch_thread_setspecific(dispatch_basepri_key, (void*)(uintptr_t)0);
-#endif
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline pthread_priority_t
-_dispatch_priority_adopt(pthread_priority_t pp, unsigned long flags)
-{
-#if HAVE_PTHREAD_WORKQUEUE_QOS
-	dispatch_priority_t dbp = _dispatch_get_basepri();
-	pthread_priority_t basepp = _dispatch_priority_to_pp_strip_flags(dbp);
-	pthread_priority_t minbasepp = basepp &
-			~(pthread_priority_t)_PTHREAD_PRIORITY_PRIORITY_MASK;
-	bool enforce = (flags & DISPATCH_PRIORITY_ENFORCE) ||
-			(pp & _PTHREAD_PRIORITY_ENFORCE_FLAG);
-	pp &= ~_PTHREAD_PRIORITY_FLAGS_MASK;
-
-	if (unlikely(!pp)) {
-		dispatch_qos_t fallback = _dispatch_priority_fallback_qos(dbp);
-		return fallback ? _dispatch_qos_to_pp(fallback) : basepp;
-	} else if (pp < minbasepp) {
-		return basepp;
-	} else if (enforce || (dbp & (DISPATCH_PRIORITY_FLAG_FLOOR |
-			DISPATCH_PRIORITY_FLAG_FALLBACK))) {
-		return pp;
-	} else {
-		return basepp;
-	}
-#else
-	(void)pp; (void)flags;
-	return 0;
-#endif
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline pthread_priority_t
-_dispatch_get_priority(void)
-{
-#if HAVE_PTHREAD_WORKQUEUE_QOS
-	pthread_priority_t pp = (uintptr_t)
-			_dispatch_thread_getspecific(dispatch_priority_key);
-	return pp;
-#else
-	return 0;
-#endif
-}
-
-#if HAVE_PTHREAD_WORKQUEUE_QOS
-DISPATCH_ALWAYS_INLINE
-static inline pthread_priority_t
-_dispatch_priority_compute_update(pthread_priority_t pp)
-{
-	dispatch_assert(pp != DISPATCH_NO_PRIORITY);
-	if (!_dispatch_set_qos_class_enabled) return 0;
-	// the priority in _dispatch_get_priority() only tracks manager-ness
-	// and overcommit, which is inherited from the current value for each update
-	// however if the priority had the NEEDS_UNBIND flag set we need to clear it
-	// the first chance we get
-	//
-	// the manager bit is invalid input, but we keep it to get meaningful
-	// assertions in _dispatch_set_priority_and_voucher_slow()
-	pp &= _PTHREAD_PRIORITY_EVENT_MANAGER_FLAG | ~_PTHREAD_PRIORITY_FLAGS_MASK;
-	pthread_priority_t cur_priority = _dispatch_get_priority();
-	pthread_priority_t unbind = _PTHREAD_PRIORITY_NEEDS_UNBIND_FLAG;
-	pthread_priority_t overcommit = _PTHREAD_PRIORITY_OVERCOMMIT_FLAG;
-	if (unlikely(cur_priority & unbind)) {
-		// else we always need an update if the NEEDS_UNBIND flag is set
-		// the slow path in _dispatch_set_priority_and_voucher_slow() will
-		// adjust the priority further with the proper overcommitness
-		return pp ? pp : (cur_priority & ~unbind);
-	} else {
-		cur_priority &= ~overcommit;
-	}
-	if (unlikely(pp != cur_priority)) return pp;
-	return 0;
-}
-#endif
-
-DISPATCH_ALWAYS_INLINE DISPATCH_WARN_RESULT
-static inline voucher_t
-_dispatch_set_priority_and_voucher(pthread_priority_t pp,
-		voucher_t v, dispatch_thread_set_self_t flags)
-{
-#if HAVE_PTHREAD_WORKQUEUE_QOS
-	pp = _dispatch_priority_compute_update(pp);
-	if (likely(!pp)) {
-		if (v == DISPATCH_NO_VOUCHER) {
-			return DISPATCH_NO_VOUCHER;
-		}
-		if (likely(v == _voucher_get())) {
-			bool retained = flags & DISPATCH_VOUCHER_CONSUME;
-			if (flags & DISPATCH_VOUCHER_REPLACE) {
-				if (retained && v) _voucher_release_no_dispose(v);
-				v = DISPATCH_NO_VOUCHER;
-			} else {
-				if (!retained && v) _voucher_retain(v);
-			}
-			return v;
-		}
-	}
-	return _dispatch_set_priority_and_voucher_slow(pp, v, flags);
-#else
-	(void)pp; (void)v; (void)flags;
-	return DISPATCH_NO_VOUCHER;
-#endif
-}
-
-DISPATCH_ALWAYS_INLINE DISPATCH_WARN_RESULT
-static inline voucher_t
-_dispatch_adopt_priority_and_set_voucher(pthread_priority_t pp,
-		voucher_t v, dispatch_thread_set_self_t flags)
-{
-	pthread_priority_t p = 0;
-	if (pp != DISPATCH_NO_PRIORITY) {
-		p = _dispatch_priority_adopt(pp, flags);
-	}
-	return _dispatch_set_priority_and_voucher(p, v, flags);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_reset_priority_and_voucher(pthread_priority_t pp, voucher_t v)
-{
-	if (pp == DISPATCH_NO_PRIORITY) pp = 0;
-	(void)_dispatch_set_priority_and_voucher(pp, v,
-			DISPATCH_VOUCHER_CONSUME | DISPATCH_VOUCHER_REPLACE);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_reset_voucher(voucher_t v, dispatch_thread_set_self_t flags)
-{
-	flags |= DISPATCH_VOUCHER_CONSUME | DISPATCH_VOUCHER_REPLACE;
-	(void)_dispatch_set_priority_and_voucher(0, v, flags);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_qos_t
-_dispatch_queue_push_qos(dispatch_queue_class_t dq, dispatch_qos_t qos)
-{
-	if (qos > _dispatch_priority_qos(dq._dl->dq_priority)) {
-		return qos;
-	}
-	return DISPATCH_QOS_UNSPECIFIED;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_qos_t
-_dispatch_queue_wakeup_qos(dispatch_queue_class_t dq, dispatch_qos_t qos)
-{
-	if (!qos) qos = _dispatch_priority_fallback_qos(dq._dl->dq_priority);
-	// for asynchronous workitems, queue priority is the floor for overrides
-	return MAX(qos, _dispatch_priority_qos(dq._dl->dq_priority));
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_qos_t
-_dispatch_queue_max_qos(dispatch_queue_class_t dq)
-{
-	// Note: the non atomic load allows to avoid CAS on 32bit architectures
-	//       which doesn't give us much as the bits we want are in a single byte
-	//       and can't quite be read non atomically. Given that this function is
-	//       called in various critical codepaths (such as _dispatch_lane_push()
-	//       between the tail exchange and updating the `prev` pointer), we care
-	//       deeply about avoiding this.
-	return _dq_state_max_qos((uint64_t)dq._dl->dq_state_bits << 32);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dispatch_queue_need_override(dispatch_queue_class_t dq, dispatch_qos_t qos)
-{
-	dispatch_qos_t max_qos = _dispatch_queue_max_qos(dq);
-	return max_qos == DISPATCH_QOS_UNSPECIFIED || max_qos < qos;
-}
-
-#define DISPATCH_PRIORITY_PROPAGATE_CURRENT 0x1
-#define DISPATCH_PRIORITY_PROPAGATE_FOR_SYNC_IPC 0x2
-
-DISPATCH_ALWAYS_INLINE
-static inline pthread_priority_t
-_dispatch_priority_compute_propagated(pthread_priority_t pp,
-		unsigned int flags)
-{
-#if HAVE_PTHREAD_WORKQUEUE_QOS
-	if (flags & DISPATCH_PRIORITY_PROPAGATE_CURRENT) {
-		pp = _dispatch_get_priority();
-	}
-	pp &= ~_PTHREAD_PRIORITY_FLAGS_MASK;
-	if (!(flags & DISPATCH_PRIORITY_PROPAGATE_FOR_SYNC_IPC) &&
-			pp > _dispatch_qos_to_pp(DISPATCH_QOS_USER_INITIATED)) {
-		// Cap QOS for propagation at user-initiated <rdar://16681262&16998036>
-		return _dispatch_qos_to_pp(DISPATCH_QOS_USER_INITIATED);
-	}
-	return pp;
-#else
-	(void)pp; (void)flags;
-	return 0;
-#endif
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline pthread_priority_t
-_dispatch_priority_propagate(void)
-{
-	return _dispatch_priority_compute_propagated(0,
-			DISPATCH_PRIORITY_PROPAGATE_CURRENT);
-}
-
-// including maintenance
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dispatch_is_background_thread(void)
-{
-#if HAVE_PTHREAD_WORKQUEUE_QOS
-	pthread_priority_t pp = _dispatch_get_priority();
-	return _dispatch_qos_is_background(_dispatch_qos_from_pp(pp));
-#else
-	return false;
-#endif
-}
-
-#pragma mark -
-#pragma mark dispatch_block_t
-
-#ifdef __BLOCKS__
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dispatch_block_has_private_data(const dispatch_block_t block)
-{
-	return (_dispatch_Block_invoke(block) == _dispatch_block_special_invoke);
-}
-
-DISPATCH_ALWAYS_INLINE DISPATCH_WARN_RESULT
-static inline pthread_priority_t
-_dispatch_block_invoke_should_set_priority(dispatch_block_flags_t flags,
-		pthread_priority_t new_pri)
-{
-	pthread_priority_t old_pri, p = 0;  // 0 means do not change priority.
-	if ((flags & DISPATCH_BLOCK_HAS_PRIORITY)
-			&& ((flags & DISPATCH_BLOCK_ENFORCE_QOS_CLASS) ||
-			!(flags & DISPATCH_BLOCK_INHERIT_QOS_CLASS))) {
-		new_pri &= ~_PTHREAD_PRIORITY_FLAGS_MASK;
-		old_pri = _dispatch_get_priority() & ~_PTHREAD_PRIORITY_FLAGS_MASK;
-		if (old_pri && old_pri < new_pri) p = old_pri;
-	}
-	return p;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_block_private_data_t
-_dispatch_block_get_data(const dispatch_block_t db)
-{
-	if (!_dispatch_block_has_private_data(db)) {
-		return NULL;
-	}
-	// Keep in sync with _dispatch_block_create implementation
-	uint8_t *x = (uint8_t *)db;
-	// x points to base of struct Block_layout
-	x += sizeof(struct Block_layout);
-	// x points to base of captured dispatch_block_private_data_s object
-	dispatch_block_private_data_t dbpd = (dispatch_block_private_data_t)x;
-	if (dbpd->dbpd_magic != DISPATCH_BLOCK_PRIVATE_DATA_MAGIC) {
-		DISPATCH_CLIENT_CRASH(dbpd->dbpd_magic,
-				"Corruption of dispatch block object");
-	}
-	return dbpd;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline pthread_priority_t
-_dispatch_block_get_priority(const dispatch_block_t db)
-{
-	dispatch_block_private_data_t dbpd = _dispatch_block_get_data(db);
-	return dbpd ? dbpd->dbpd_priority : 0;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_block_flags_t
-_dispatch_block_get_flags(const dispatch_block_t db)
-{
-	dispatch_block_private_data_t dbpd = _dispatch_block_get_data(db);
-	return dbpd ? dbpd->dbpd_flags : 0;
-}
-
-#endif
-
-#pragma mark -
-#pragma mark dispatch_continuation_t
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_continuation_t
-_dispatch_continuation_alloc_cacheonly(void)
-{
-	dispatch_continuation_t dc = (dispatch_continuation_t)
-			_dispatch_thread_getspecific(dispatch_cache_key);
-	if (likely(dc)) {
-		_dispatch_thread_setspecific(dispatch_cache_key, dc->do_next);
-	}
-	return dc;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_continuation_t
-_dispatch_continuation_alloc(void)
-{
-	dispatch_continuation_t dc =
-			_dispatch_continuation_alloc_cacheonly();
-	if (unlikely(!dc)) {
-		return _dispatch_continuation_alloc_from_heap();
-	}
-	return dc;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_continuation_t
-_dispatch_continuation_free_cacheonly(dispatch_continuation_t dc)
-{
-	dispatch_continuation_t prev_dc = (dispatch_continuation_t)
-			_dispatch_thread_getspecific(dispatch_cache_key);
-	int cnt = prev_dc ? prev_dc->dc_cache_cnt + 1 : 1;
-	// Cap continuation cache
-	if (unlikely(cnt > _dispatch_continuation_cache_limit)) {
-		return dc;
-	}
-	dc->do_next = prev_dc;
-	dc->dc_cache_cnt = cnt;
-#if DISPATCH_ALLOCATOR
-	// This magical value helps memory tools to recognize continuations on
-	// the various free lists that are really free.
-	dc->dc_flags = (uintptr_t)(void *)&_dispatch_main_heap;
-#endif
-	_dispatch_thread_setspecific(dispatch_cache_key, dc);
-	return NULL;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_continuation_free(dispatch_continuation_t dc)
-{
-	dc = _dispatch_continuation_free_cacheonly(dc);
-	if (unlikely(dc)) {
-		_dispatch_continuation_free_to_cache_limit(dc);
-	}
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_continuation_with_group_invoke(dispatch_continuation_t dc)
-{
-	struct dispatch_object_s *dou = dc->dc_data;
-	unsigned long type = dx_type(dou);
-	if (type == DISPATCH_GROUP_TYPE) {
-		_dispatch_client_callout(dc->dc_ctxt, dc->dc_func);
-		_dispatch_trace_item_complete(dc);
-		dispatch_group_leave((dispatch_group_t)dou);
-	} else {
-		DISPATCH_INTERNAL_CRASH(dx_type(dou), "Unexpected object type");
-	}
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_continuation_invoke_inline(dispatch_object_t dou,
-		dispatch_invoke_flags_t flags, dispatch_queue_class_t dqu)
-{
-	dispatch_continuation_t dc = dou._dc, dc1;
-	dispatch_invoke_with_autoreleasepool(flags, {
-		uintptr_t dc_flags = dc->dc_flags;
-		// Add the item back to the cache before calling the function. This
-		// allows the 'hot' continuation to be used for a quick callback.
-		//
-		// The ccache version is per-thread.
-		// Therefore, the object has not been reused yet.
-		// This generates better assembly.
-		_dispatch_continuation_voucher_adopt(dc, dc_flags);
-		if (!(dc_flags & DC_FLAG_NO_INTROSPECTION)) {
-			_dispatch_trace_item_pop(dqu, dou);
-		}
-		if (dc_flags & DC_FLAG_CONSUME) {
-			dc1 = _dispatch_continuation_free_cacheonly(dc);
-		} else {
-			dc1 = NULL;
-		}
-		if (unlikely(dc_flags & DC_FLAG_GROUP_ASYNC)) {
-			_dispatch_continuation_with_group_invoke(dc);
-		} else {
-			_dispatch_client_callout(dc->dc_ctxt, dc->dc_func);
-			_dispatch_trace_item_complete(dc);
-		}
-		if (unlikely(dc1)) {
-			_dispatch_continuation_free_to_cache_limit(dc1);
-		}
-	});
-	_dispatch_perfmon_workitem_inc();
-}
-
-DISPATCH_ALWAYS_INLINE_NDEBUG
-static inline void
-_dispatch_continuation_pop_inline(dispatch_object_t dou,
-		dispatch_invoke_context_t dic, dispatch_invoke_flags_t flags,
-		dispatch_queue_class_t dqu)
-{
-	dispatch_pthread_root_queue_observer_hooks_t observer_hooks =
-			_dispatch_get_pthread_root_queue_observer_hooks();
-	if (observer_hooks) observer_hooks->queue_will_execute(dqu._dq);
-	flags &= _DISPATCH_INVOKE_PROPAGATE_MASK;
-	if (_dispatch_object_has_vtable(dou)) {
-		dx_invoke(dou._dq, dic, flags);
-	} else {
-		_dispatch_continuation_invoke_inline(dou, flags, dqu);
-	}
-	if (observer_hooks) observer_hooks->queue_did_execute(dqu._dq);
-}
-
-// used to forward the do_invoke of a continuation with a vtable to its real
-// implementation.
-#define _dispatch_continuation_pop_forwarded(dc, dc_flags, dq, ...) \
-	({ \
-		dispatch_continuation_t _dc = (dc), _dc1; \
-		uintptr_t _dc_flags = (dc_flags); \
-		_dispatch_continuation_voucher_adopt(_dc, _dc_flags); \
-		if (!(_dc_flags & DC_FLAG_NO_INTROSPECTION)) { \
-			_dispatch_trace_item_pop(dq, dc); \
-		} \
-		if (_dc_flags & DC_FLAG_CONSUME) { \
-			_dc1 = _dispatch_continuation_free_cacheonly(_dc); \
-		} else { \
-			_dc1 = NULL; \
-		} \
-		__VA_ARGS__; \
-		if (!(_dc_flags & DC_FLAG_NO_INTROSPECTION)) { \
-			_dispatch_trace_item_complete(_dc); \
-		} \
-		if (unlikely(_dc1)) { \
-			_dispatch_continuation_free_to_cache_limit(_dc1); \
-		} \
-	})
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_qos_t
-_dispatch_continuation_priority_set(dispatch_continuation_t dc,
-		dispatch_queue_class_t dqu,
-		pthread_priority_t pp, dispatch_block_flags_t flags)
-{
-	dispatch_qos_t qos = DISPATCH_QOS_UNSPECIFIED;
-#if HAVE_PTHREAD_WORKQUEUE_QOS
-	dispatch_queue_t dq = dqu._dq;
-
-	if (likely(pp)) {
-		bool enforce = (flags & DISPATCH_BLOCK_ENFORCE_QOS_CLASS);
-		bool is_floor = (dq->dq_priority & DISPATCH_PRIORITY_FLAG_FLOOR);
-		bool dq_has_qos = (dq->dq_priority & DISPATCH_PRIORITY_REQUESTED_MASK);
-		if (enforce) {
-			pp |= _PTHREAD_PRIORITY_ENFORCE_FLAG;
-			qos = _dispatch_qos_from_pp_unsafe(pp);
-		} else if (!is_floor && dq_has_qos) {
-			pp = 0;
-		} else {
-			qos = _dispatch_qos_from_pp_unsafe(pp);
-		}
-	}
-	dc->dc_priority = pp;
-#else
-	(void)dc; (void)dqu; (void)pp; (void)flags;
-#endif
-	return qos;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_qos_t
-_dispatch_continuation_init_f(dispatch_continuation_t dc,
-		dispatch_queue_class_t dqu, void *ctxt, dispatch_function_t f,
-		dispatch_block_flags_t flags, uintptr_t dc_flags)
-{
-	pthread_priority_t pp = 0;
-	dc->dc_flags = dc_flags | DC_FLAG_ALLOCATED;
-	dc->dc_func = f;
-	dc->dc_ctxt = ctxt;
-	// in this context DISPATCH_BLOCK_HAS_PRIORITY means that the priority
-	// should not be propagated, only taken from the handler if it has one
-	if (!(flags & DISPATCH_BLOCK_HAS_PRIORITY)) {
-		pp = _dispatch_priority_propagate();
-	}
-	_dispatch_continuation_voucher_set(dc, flags);
-	return _dispatch_continuation_priority_set(dc, dqu, pp, flags);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_qos_t
-_dispatch_continuation_init(dispatch_continuation_t dc,
-		dispatch_queue_class_t dqu, dispatch_block_t work,
-		dispatch_block_flags_t flags, uintptr_t dc_flags)
-{
-	void *ctxt = _dispatch_Block_copy(work);
-
-	dc_flags |= DC_FLAG_BLOCK | DC_FLAG_ALLOCATED;
-	if (unlikely(_dispatch_block_has_private_data(work))) {
-		dc->dc_flags = dc_flags;
-		dc->dc_ctxt = ctxt;
-		// will initialize all fields but requires dc_flags & dc_ctxt to be set
-		return _dispatch_continuation_init_slow(dc, dqu, flags);
-	}
-
-	dispatch_function_t func = _dispatch_Block_invoke(work);
-	if (dc_flags & DC_FLAG_CONSUME) {
-		func = _dispatch_call_block_and_release;
-	}
-	return _dispatch_continuation_init_f(dc, dqu, ctxt, func, flags, dc_flags);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_continuation_async(dispatch_queue_class_t dqu,
-		dispatch_continuation_t dc, dispatch_qos_t qos, uintptr_t dc_flags)
-{
-#if DISPATCH_INTROSPECTION
-	if (!(dc_flags & DC_FLAG_NO_INTROSPECTION)) {
-		_dispatch_trace_item_push(dqu, dc);
-	}
-#else
-	(void)dc_flags;
-#endif
-	return dx_push(dqu._dq, dc, qos);
-}
-
-#endif // DISPATCH_PURE_C
-
-#endif /* __DISPATCH_INLINE_INTERNAL__ */
--- a/Telegram/ThirdParty/dispatch/src/internal.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/internal.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,1118 +0,0 @@
-/*
- * Copyright (c) 2008-2013 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-/*
- * IMPORTANT: This header file describes INTERNAL interfaces to libdispatch
- * which are subject to change in future releases of Mac OS X. Any applications
- * relying on these interfaces WILL break.
- */
-
-#ifndef __DISPATCH_INTERNAL__
-#define __DISPATCH_INTERNAL__
-
-#if __has_include(<config/config_ac.h>)
-#include <config/config_ac.h>
-#else
-#include <config/config.h>
-#endif
-
-#define __DISPATCH_BUILDING_DISPATCH__
-#define __DISPATCH_INDIRECT__
-
-#ifdef __APPLE__
-#include <Availability.h>
-#include <os/availability.h>
-#include <TargetConditionals.h>
-#endif // __APPLE__
-
-
-#if !defined(DISPATCH_MACH_SPI) && TARGET_OS_MAC
-#define DISPATCH_MACH_SPI 1
-#endif
-#if !defined(OS_VOUCHER_CREATION_SPI) && TARGET_OS_MAC
-#define OS_VOUCHER_CREATION_SPI 1
-#endif
-#if !defined(OS_VOUCHER_ACTIVITY_SPI) && TARGET_OS_MAC
-#define OS_VOUCHER_ACTIVITY_SPI 1
-#endif
-#if !defined(OS_VOUCHER_ACTIVITY_GENERATE_SWAPS)
-#define OS_VOUCHER_ACTIVITY_GENERATE_SWAPS 0
-#endif
-#if !defined(OS_FIREHOSE_SPI) && TARGET_OS_MAC
-#define OS_FIREHOSE_SPI 1
-#endif
-#if !defined(DISPATCH_LAYOUT_SPI) && TARGET_OS_MAC
-#define DISPATCH_LAYOUT_SPI 1
-#endif
-
-#if __has_include(<mach-o/dyld_priv.h>)
-#include <mach-o/dyld_priv.h>
-#if !defined(HAVE_DYLD_IS_MEMORY_IMMUTABLE)
-#if defined(DYLD_MACOSX_VERSION_10_12) || defined(DYLD_IOS_VERSION_10_0)
-#define HAVE_DYLD_IS_MEMORY_IMMUTABLE 1
-#else
-#define HAVE_DYLD_IS_MEMORY_IMMUTABLE 0
-#endif
-#endif // !defined(HAVE_DYLD_IS_MEMORY_IMMUTABLE)
-#endif // __has_include(<mach-o/dyld_priv.h>)
-
-#if !defined(USE_OBJC) && HAVE_OBJC
-#define USE_OBJC 1
-#endif
-
-#if USE_OBJC
-#define OS_OBJECT_HAVE_OBJC_SUPPORT 1
-#if defined(__OBJC__)
-#define OS_OBJECT_USE_OBJC 1
-// Force internal Objective-C sources to use class-visible headers
-// even when not compiling in Swift.
-#define OS_OBJECT_SWIFT3 1
-#else
-#define OS_OBJECT_USE_OBJC 0
-#endif // __OBJC__
-#else
-#define OS_OBJECT_HAVE_OBJC_SUPPORT 0
-#endif // USE_OBJC
-
-#include <dispatch/dispatch.h>
-#include <dispatch/base.h>
-
-#define __DISPATCH_HIDE_SYMBOL(sym, version) \
-	__asm__(".section __TEXT,__const\n\t" \
-			".globl $ld$hide$os" #version "$_" #sym "\n\t" \
-			"$ld$hide$os" #version "$_" #sym ":\n\t" \
-			"    .byte 0\n\t" \
-			".previous")
-
-
-#ifndef DISPATCH_HIDE_SYMBOL
-#if TARGET_OS_MAC && !TARGET_OS_IPHONE
-#define DISPATCH_HIDE_SYMBOL(sym, osx, ios, tvos, watchos) \
-		__DISPATCH_HIDE_SYMBOL(sym, osx)
-#else
-#define DISPATCH_HIDE_SYMBOL(sym, osx, ios, tvos, watchos)
-#endif
-#endif
-
-#ifndef DISPATCH_STATIC_GLOBAL
-#define DISPATCH_STATIC_GLOBAL(declaration) static declaration
-#endif
-#ifndef DISPATCH_GLOBAL
-#define DISPATCH_GLOBAL(declaration) declaration
-#endif
-#ifndef DISPATCH_GLOBAL_INIT
-#define DISPATCH_GLOBAL_INIT(declaration, ...) 	declaration = __VA_ARGS__
-#endif
-
-#if defined(__OBJC__) || defined(__cplusplus)
-#define DISPATCH_PURE_C 0
-#else
-#define DISPATCH_PURE_C 1
-#endif
-
-#ifdef __OBJC__
-@protocol OS_dispatch_queue;
-#endif
-
-// Lane cluster class: type for all the queues that have a single head/tail pair
-typedef union {
-	struct dispatch_lane_s *_dl;
-	struct dispatch_queue_static_s *_dsq;
-	struct dispatch_queue_global_s *_dgq;
-	struct dispatch_queue_pthread_root_s *_dpq;
-	struct dispatch_source_s *_ds;
-	struct dispatch_mach_s *_dm;
-#ifdef __OBJC__
-	id<OS_dispatch_queue> _objc_dq; // unsafe cast for the sake of object.m
-#endif
-} dispatch_lane_class_t DISPATCH_TRANSPARENT_UNION;
-
-// Dispatch queue cluster class: type for any dispatch_queue_t
-typedef union {
-	struct dispatch_queue_s *_dq;
-	struct dispatch_workloop_s *_dwl;
-	struct dispatch_lane_s *_dl;
-	struct dispatch_queue_static_s *_dsq;
-	struct dispatch_queue_global_s *_dgq;
-	struct dispatch_queue_pthread_root_s *_dpq;
-	struct dispatch_source_s *_ds;
-	struct dispatch_mach_s *_dm;
-	dispatch_lane_class_t _dlu;
-#ifdef __OBJC__
-	id<OS_dispatch_queue> _objc_dq;
-#endif
-} dispatch_queue_class_t DISPATCH_TRANSPARENT_UNION;
-
-#ifndef __OBJC__
-typedef union {
-	struct _os_object_s *_os_obj;
-	struct dispatch_object_s *_do;
-	struct dispatch_queue_s *_dq;
-	struct dispatch_queue_attr_s *_dqa;
-	struct dispatch_group_s *_dg;
-	struct dispatch_source_s *_ds;
-	struct dispatch_mach_s *_dm;
-	struct dispatch_mach_msg_s *_dmsg;
-	struct dispatch_semaphore_s *_dsema;
-	struct dispatch_data_s *_ddata;
-	struct dispatch_io_s *_dchannel;
-
-	struct dispatch_continuation_s *_dc;
-	struct dispatch_sync_context_s *_dsc;
-	struct dispatch_operation_s *_doperation;
-	struct dispatch_disk_s *_ddisk;
-	struct dispatch_workloop_s *_dwl;
-	struct dispatch_lane_s *_dl;
-	struct dispatch_queue_static_s *_dsq;
-	struct dispatch_queue_global_s *_dgq;
-	struct dispatch_queue_pthread_root_s *_dpq;
-	dispatch_queue_class_t _dqu;
-	dispatch_lane_class_t _dlu;
-	uintptr_t _do_value;
-} dispatch_object_t DISPATCH_TRANSPARENT_UNION;
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_object_t
-upcast(dispatch_object_t dou)
-{
-	return dou;
-}
-#endif // __OBJC__
-
-#include <os/object.h>
-#include <dispatch/time.h>
-#include <dispatch/object.h>
-#include <dispatch/queue.h>
-#include <dispatch/block.h>
-#include <dispatch/source.h>
-#include <dispatch/group.h>
-#include <dispatch/semaphore.h>
-#include <dispatch/once.h>
-#include <dispatch/data.h>
-#include <dispatch/io.h>
-
-/* private.h must be included last to avoid picking up installed headers. */
-#if !defined(_WIN32)
-#include <pthread.h>
-#endif
-#include "os/object_private.h"
-#include "queue_private.h"
-#include "workloop_private.h"
-#include "source_private.h"
-#include "mach_private.h"
-#include "data_private.h"
-#include "os/voucher_private.h"
-#include "os/voucher_activity_private.h"
-#include "io_private.h"
-#include "layout_private.h"
-#include "benchmark.h"
-#include "private.h"
-
-#if HAVE_LIBKERN_OSCROSSENDIAN_H
-#include <libkern/OSCrossEndian.h>
-#endif
-#if HAVE_LIBKERN_OSATOMIC_H
-#include <libkern/OSAtomic.h>
-#endif
-#if HAVE_MACH
-#include <mach/boolean.h>
-#include <mach/clock_types.h>
-#include <mach/clock.h>
-#include <mach/exception.h>
-#include <mach/mach.h>
-#include <mach/mach_error.h>
-#include <mach/mach_host.h>
-#include <mach/mach_interface.h>
-#include <mach/mach_time.h>
-#include <mach/mach_traps.h>
-#include <mach/message.h>
-#include <mach/mig_errors.h>
-#include <mach/host_special_ports.h>
-#include <mach/host_info.h>
-#include <mach/notify.h>
-#include <mach/mach_vm.h>
-#include <mach/vm_map.h>
-#if __has_include(<mach/mach_sync_ipc.h>)
-#include <mach/mach_sync_ipc.h>
-#endif
-#endif /* HAVE_MACH */
-#if __has_include(<os/reason_private.h>)
-#define HAVE_OS_FAULT_WITH_PAYLOAD 1
-#include <os/reason_private.h>
-#include <os/variant_private.h>
-#else
-#define HAVE_OS_FAULT_WITH_PAYLOAD 0
-#endif
-#if HAVE_MALLOC_MALLOC_H
-#include <malloc/malloc.h>
-#endif
-
-#include <sys/stat.h>
-
-#if defined(_WIN32)
-#include <time.h>
-#else
-#include <sys/mount.h>
-#ifdef __ANDROID__
-#include <linux/sysctl.h>
-#endif /* __ANDROID__ */
-#if !defined(__linux__)
-#include <sys/sysctl.h>
-#include <sys/queue.h>
-#endif
-#include <sys/socket.h>
-#include <sys/time.h>
-#include <sys/mman.h>
-#include <netinet/in.h>
-#endif
-
-#ifdef __BLOCKS__
-#if __has_include(<Block_private.h>)
-#include <Block_private.h>
-#else
-#include "BlocksRuntime/Block_private.h"
-#endif // __has_include(<Block_private.h>)
-#include <Block.h>
-#endif /* __BLOCKS__ */
-
-#include <assert.h>
-#include <errno.h>
-#if HAVE_FCNTL_H
-#include <fcntl.h>
-#endif
-#include <limits.h>
-#include <search.h>
-#if USE_POSIX_SEM
-#include <semaphore.h>
-#endif
-#include <signal.h>
-#include <stdarg.h>
-#include <stdbool.h>
-#include <stdint.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#if defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))
-#include <unistd.h>
-#endif
-#if defined(_WIN32)
-#include <io.h>
-#include <crtdbg.h>
-#endif
-#include <inttypes.h>
-
-/* More #includes at EOF (dependent on the contents of internal.h) ... */
-
-__BEGIN_DECLS
-
-/* SPI for Libsystem-internal use */
-DISPATCH_EXPORT DISPATCH_NOTHROW void libdispatch_init(void);
-#if !defined(_WIN32)
-DISPATCH_EXPORT DISPATCH_NOTHROW void dispatch_atfork_prepare(void);
-DISPATCH_EXPORT DISPATCH_NOTHROW void dispatch_atfork_parent(void);
-DISPATCH_EXPORT DISPATCH_NOTHROW void dispatch_atfork_child(void);
-#endif
-
-// Abort on uncaught exceptions thrown from client callouts rdar://8577499
-#if !defined(DISPATCH_USE_CLIENT_CALLOUT)
-#define DISPATCH_USE_CLIENT_CALLOUT 1
-#endif
-
-#define DISPATCH_ALLOW_NON_LEAF_RETARGET 1
-
-/* The "_debug" library build */
-#ifndef DISPATCH_DEBUG
-#define DISPATCH_DEBUG 0
-#endif
-
-#ifndef DISPATCH_PROFILE
-#define DISPATCH_PROFILE 0
-#endif
-
-#if (TARGET_OS_OSX || DISPATCH_DEBUG || DISPATCH_PROFILE) && \
-		!defined(DISPATCH_USE_DTRACE)
-#define DISPATCH_USE_DTRACE 1
-#endif
-
-#if DISPATCH_USE_DTRACE && (DISPATCH_INTROSPECTION || DISPATCH_DEBUG || \
-		DISPATCH_PROFILE) && !defined(DISPATCH_USE_DTRACE_INTROSPECTION)
-#define DISPATCH_USE_DTRACE_INTROSPECTION 1
-#endif
-
-#ifndef DISPATCH_DEBUG_QOS
-#define DISPATCH_DEBUG_QOS DISPATCH_DEBUG
-#endif
-
-#if defined(__GNUC__) || defined(__clang__)
-#define DISPATCH_NOINLINE __attribute__((__noinline__))
-#define DISPATCH_USED __attribute__((__used__))
-#define DISPATCH_UNUSED __attribute__((__unused__))
-#define DISPATCH_WEAK __attribute__((__weak__))
-#define DISPATCH_OVERLOADABLE __attribute__((__overloadable__))
-#if DISPATCH_DEBUG
-#define DISPATCH_PACKED __attribute__((__packed__))
-#define DISPATCH_ALWAYS_INLINE_NDEBUG
-#else
-#define DISPATCH_ALWAYS_INLINE_NDEBUG __attribute__((__always_inline__))
-#endif
-#else	/* __GNUC__ */
-#define DISPATCH_NOINLINE
-#define DISPATCH_USED
-#define DISPATCH_UNUSED
-#define DISPATCH_WEAK
-#define DISPATCH_ALWAYS_INLINE_NDEBUG
-#endif	/* __GNUC__ */
-
-#define DISPATCH_CONCAT(x,y) DISPATCH_CONCAT1(x,y)
-#define DISPATCH_CONCAT1(x,y) x ## y
-
-#define DISPATCH_COUNT_ARGS(...) DISPATCH_COUNT_ARGS1(, ## __VA_ARGS__, \
-		_8, _7, _6, _5, _4, _3, _2, _1, _0)
-#define DISPATCH_COUNT_ARGS1(z, a, b, c, d, e, f, g, h, cnt, ...) cnt
-
-#if BYTE_ORDER == LITTLE_ENDIAN
-#define DISPATCH_STRUCT_LE_2(a, b)        struct { a; b; }
-#define DISPATCH_STRUCT_LE_3(a, b, c)     struct { a; b; c; }
-#define DISPATCH_STRUCT_LE_4(a, b, c, d)  struct { a; b; c; d; }
-#else
-#define DISPATCH_STRUCT_LE_2(a, b)        struct { b; a; }
-#define DISPATCH_STRUCT_LE_3(a, b, c)     struct { c; b; a; }
-#define DISPATCH_STRUCT_LE_4(a, b, c, d)  struct { d; c; b; a; }
-#endif
-#if __has_feature(c_startic_assert)
-#define DISPATCH_UNION_ASSERT(alias, st) \
-		_Static_assert(sizeof(struct { alias; }) == sizeof(st), "bogus union");
-#else
-#define DISPATCH_UNION_ASSERT(alias, st)
-#endif
-#define DISPATCH_UNION_LE(alias, ...) \
-		DISPATCH_UNION_ASSERT(alias, DISPATCH_CONCAT(DISPATCH_STRUCT_LE, \
-				DISPATCH_COUNT_ARGS(__VA_ARGS__))(__VA_ARGS__)) \
-		union { alias; DISPATCH_CONCAT(DISPATCH_STRUCT_LE, \
-				DISPATCH_COUNT_ARGS(__VA_ARGS__))(__VA_ARGS__); }
-
-// workaround 6368156
-#ifdef NSEC_PER_SEC
-#undef NSEC_PER_SEC
-#endif
-#ifdef USEC_PER_SEC
-#undef USEC_PER_SEC
-#endif
-#ifdef NSEC_PER_USEC
-#undef NSEC_PER_USEC
-#endif
-#define NSEC_PER_SEC 1000000000ull
-#define USEC_PER_SEC 1000000ull
-#define NSEC_PER_USEC 1000ull
-
-#if __GNUC__
-#define likely(x) __builtin_expect(!!(x), 1)
-#define unlikely(x) __builtin_expect(!!(x), 0)
-#else
-#define likely(x) (!!(x))
-#define unlikely(x) (!!(x))
-#endif // __GNUC__
-
-#define _LIST_IS_ENQUEUED(elm, field) \
-		((elm)->field.le_prev != NULL)
-#define _LIST_MARK_NOT_ENQUEUED(elm, field) \
-		((void)((elm)->field.le_prev = NULL))
-#define _TAILQ_IS_ENQUEUED(elm, field) \
-		((elm)->field.tqe_prev != NULL)
-#define _TAILQ_MARK_NOT_ENQUEUED(elm, field) \
-		((void)((elm)->field.tqe_prev = NULL))
-
-#if DISPATCH_DEBUG
-// sys/queue.h debugging
-#undef TRASHIT
-#define TRASHIT(x) do {(x) = (void *)-1;} while (0)
-#else // DISPATCH_DEBUG
-#ifndef TRASHIT
-#define TRASHIT(x)
-#endif
-#endif // DISPATCH_DEBUG
-#define _LIST_TRASH_ENTRY(elm, field) do { \
-			TRASHIT((elm)->field.le_next); \
-			TRASHIT((elm)->field.le_prev); \
-		} while (0)
-#define _TAILQ_TRASH_ENTRY(elm, field) do { \
-			TRASHIT((elm)->field.tqe_next); \
-			TRASHIT((elm)->field.tqe_prev); \
-		} while (0)
-#define _TAILQ_TRASH_HEAD(head) do { \
-			TRASHIT((head)->tqh_first); \
-			TRASHIT((head)->tqh_last); \
-		} while (0)
-
-#define DISPATCH_MODE_STRICT    (1U << 0)
-#define DISPATCH_MODE_NO_FAULTS (1U << 1)
-extern uint8_t _dispatch_mode;
-
-DISPATCH_EXPORT DISPATCH_NOINLINE DISPATCH_COLD
-void _dispatch_bug(size_t line, long val);
-
-#if HAVE_MACH
-DISPATCH_NOINLINE DISPATCH_COLD
-void _dispatch_bug_mach_client(const char *msg, mach_msg_return_t kr);
-#endif // HAVE_MACH
-
-struct dispatch_unote_class_s;
-
-#if HAVE_MACH
-DISPATCH_NOINLINE DISPATCH_COLD
-void _dispatch_bug_kevent_client(const char *msg, const char *filter,
-		const char *operation, int err, uint64_t ident, uint64_t udata,
-		struct dispatch_unote_class_s *du);
-#endif // HAVE_MACH
-
-DISPATCH_NOINLINE DISPATCH_COLD
-void _dispatch_bug_kevent_vanished(struct dispatch_unote_class_s *du);
-
-DISPATCH_NOINLINE DISPATCH_COLD
-void _dispatch_bug_deprecated(const char *msg);
-
-DISPATCH_NOINLINE DISPATCH_NORETURN DISPATCH_COLD
-void _dispatch_abort(size_t line, long val);
-
-#if !defined(DISPATCH_USE_OS_DEBUG_LOG) && DISPATCH_DEBUG
-#if __has_include(<os/debug_private.h>)
-#define DISPATCH_USE_OS_DEBUG_LOG 1
-#include <os/debug_private.h>
-#endif
-#endif // DISPATCH_USE_OS_DEBUG_LOG
-
-#if !defined(DISPATCH_USE_SIMPLE_ASL) && !DISPATCH_USE_OS_DEBUG_LOG
-#if __has_include(<_simple.h>)
-#define DISPATCH_USE_SIMPLE_ASL 1
-#include <_simple.h>
-#endif
-#endif // DISPATCH_USE_SIMPLE_ASL
-
-#if !DISPATCH_USE_SIMPLE_ASL && !DISPATCH_USE_OS_DEBUG_LOG && !defined(_WIN32)
-#include <syslog.h>
-#endif
-
-#define DISPATCH_BAD_INPUT		((void *_Nonnull)0)
-#define DISPATCH_OUT_OF_MEMORY	((void *_Nonnull)0)
-
-#if __has_attribute(diagnose_if)
-#define DISPATCH_STATIC_ASSERT_IF(e) \
-		__attribute__((diagnose_if(e, "Assertion failed", "error")))
-#else
-#define DISPATCH_STATIC_ASSERT_IF(e)
-#endif // __has_attribute(diagnose_if)
-
-#if DISPATCH_USE_OS_DEBUG_LOG
-#define _dispatch_log(msg, ...) os_debug_log("libdispatch", msg, ## __VA_ARGS__)
-#else
-DISPATCH_EXPORT DISPATCH_NOINLINE DISPATCH_COLD
-__attribute__((__format__(__printf__,1,2)))
-void _dispatch_log(const char *msg, ...);
-#endif // DISPATCH_USE_OS_DEBUG_LOG
-
-#define dsnprintf(buf, siz, ...) \
-		({ size_t _siz = siz; int _r = snprintf(buf, _siz, __VA_ARGS__); \
-		 _r < 0 ? 0u : ((size_t)_r > _siz ? _siz : (size_t)_r); })
-
-#if __has_feature(c_static_assert) || __STDC_VERSION__ >= 201112L
-#define _dispatch_static_assert(e, s, ...) _Static_assert(e, s)
-#else
-#define _dispatch_static_assert(e, s, ...)
-#endif
-#define dispatch_static_assert(e, ...) \
-		_dispatch_static_assert(e, ##__VA_ARGS__, #e)
-
-#define dispatch_assert_aliases(t1, t2, f) \
-		dispatch_static_assert(offsetof(struct t1,f) == offsetof(struct t2,f), \
-				#t1 "::" #f " and " #t2 "::" #f " should alias")
-
-/*
- * For reporting bugs within libdispatch when using the "_debug" version of the
- * library.
- */
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_assert(long e, size_t line) DISPATCH_STATIC_ASSERT_IF(!e)
-{
-	if (unlikely(DISPATCH_DEBUG && !e)) _dispatch_abort(line, e);
-}
-#define dispatch_assert(e) _dispatch_assert((long)(e), __LINE__)
-
-/*
- * A lot of API return zero upon success and not-zero on fail. Let's capture
- * and log the non-zero value
- */
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_assert_zero(long e, size_t line) DISPATCH_STATIC_ASSERT_IF(e)
-{
-	if (unlikely(DISPATCH_DEBUG && e)) _dispatch_abort(line, e);
-}
-#define dispatch_assert_zero(e) _dispatch_assert_zero((long)(e), __LINE__)
-
-/*
- * For reporting bugs or impedance mismatches between libdispatch and external
- * subsystems. These do NOT abort(), and are always compiled into the product.
- *
- * In particular, we wrap all system-calls with assume() macros.
- */
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_assume(long e, size_t line) DISPATCH_STATIC_ASSERT_IF(!e)
-{
-	if (unlikely(!e)) _dispatch_bug(line, e);
-}
-#define dispatch_assume(e) \
-		({ __typeof__(e) _e = (e); _dispatch_assume((long)_e, __LINE__); _e; })
-
-/*
- * A lot of API return zero upon success and not-zero on fail. Let's capture
- * and log the non-zero value
- */
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_assume_zero(long e, size_t line) DISPATCH_STATIC_ASSERT_IF(e)
-{
-	if (unlikely(e)) _dispatch_bug(line, e);
-}
-#define dispatch_assume_zero(e) \
-		({ __typeof__(e) _e = (e); _dispatch_assume_zero((long)_e, __LINE__); _e; })
-
-/* Make sure the debug statments don't get too stale */
-#define _dispatch_debug(x, args...) do { \
-	if (DISPATCH_DEBUG) { \
-		_dispatch_log("%u\t%p\t" x, __LINE__, \
-				(void *)_dispatch_thread_self(), ##args); \
-	} \
-} while (0)
-
-#if DISPATCH_DEBUG
-/* This is the private version of the deprecated dispatch_debug() */
-DISPATCH_NONNULL2 DISPATCH_NOTHROW
-__attribute__((__format__(printf,2,3)))
-void
-_dispatch_object_debug(dispatch_object_t object, const char *message, ...);
-#else
-#define _dispatch_object_debug(object, message, ...)
-#endif // DISPATCH_DEBUG
-
-#ifdef __BLOCKS__
-#define _dispatch_Block_invoke(bb) \
-		((dispatch_function_t)((struct Block_layout *)bb)->invoke)
-
-void *_dispatch_Block_copy(void *block);
-#if __GNUC__
-#define _dispatch_Block_copy(x) ((__typeof__(x))_dispatch_Block_copy(x))
-#endif
-void _dispatch_call_block_and_release(void *block);
-#endif /* __BLOCKS__ */
-
-bool _dispatch_parse_bool(const char *v);
-bool _dispatch_getenv_bool(const char *env, bool default_v);
-void _dispatch_temporary_resource_shortage(void);
-void *_dispatch_calloc(size_t num_items, size_t size);
-const char *_dispatch_strdup_if_mutable(const char *str);
-void _dispatch_vtable_init(void);
-char *_dispatch_get_build(void);
-#if !defined(_WIN32)
-int _dispatch_sigmask(void);
-#endif
-
-uint64_t _dispatch_timeout(dispatch_time_t when);
-uint64_t _dispatch_time_nanoseconds_since_epoch(dispatch_time_t when);
-
-#define _DISPATCH_UNSAFE_FORK_MULTITHREADED  ((uint8_t)1)
-#define _DISPATCH_UNSAFE_FORK_PROHIBIT       ((uint8_t)2)
-extern uint8_t _dispatch_unsafe_fork;
-extern bool _dispatch_child_of_unsafe_fork;
-void _dispatch_fork_becomes_unsafe_slow(void);
-
-#define _dispatch_is_multithreaded_inline() \
-	((_dispatch_unsafe_fork & _DISPATCH_UNSAFE_FORK_MULTITHREADED) != 0)
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_fork_becomes_unsafe(void)
-{
-	if (unlikely(!_dispatch_is_multithreaded_inline())) {
-		_dispatch_fork_becomes_unsafe_slow();
-		DISPATCH_COMPILER_CAN_ASSUME(_dispatch_is_multithreaded_inline());
-	}
-}
-
-#if DISPATCH_INTROSPECTION
-#undef DISPATCH_PERF_MON
-#define DISPATCH_PERF_MON 0
-#endif
-
-/* #includes dependent on internal.h */
-#include "shims.h"
-#include "event/event_internal.h"
-
-// Older Mac OS X and iOS Simulator fallbacks
-
-#ifndef HAVE_PTHREAD_WORKQUEUE_QOS
-#if !DISPATCH_USE_INTERNAL_WORKQUEUE && HAVE__PTHREAD_WORKQUEUE_INIT && \
-		PTHREAD_WORKQUEUE_SPI_VERSION >= 20140213
-#define HAVE_PTHREAD_WORKQUEUE_QOS 1
-#else
-#define HAVE_PTHREAD_WORKQUEUE_QOS 0
-#endif
-#endif // !defined(HAVE_PTHREAD_WORKQUEUE_QOS)
-
-#ifndef HAVE_PTHREAD_WORKQUEUE_KEVENT
-#if !DISPATCH_USE_INTERNAL_WORKQUEUE && HAVE__PTHREAD_WORKQUEUE_INIT && \
-		defined(KEVENT_FLAG_WORKQ) && PTHREAD_WORKQUEUE_SPI_VERSION >= 20150304
-#define HAVE_PTHREAD_WORKQUEUE_KEVENT 1
-#else
-#define HAVE_PTHREAD_WORKQUEUE_KEVENT 0
-#endif
-#endif // !defined(HAVE_PTHREAD_WORKQUEUE_KEVENT)
-
-#ifndef HAVE_PTHREAD_WORKQUEUE_WORKLOOP
-#if HAVE_PTHREAD_WORKQUEUE_KEVENT && defined(WORKQ_FEATURE_WORKLOOP) && \
-		defined(KEVENT_FLAG_WORKLOOP) && \
-		DISPATCH_MIN_REQUIRED_OSX_AT_LEAST(101300)
-#define HAVE_PTHREAD_WORKQUEUE_WORKLOOP 1
-#else
-#define HAVE_PTHREAD_WORKQUEUE_WORKLOOP 0
-#endif
-#endif // !defined(HAVE_PTHREAD_WORKQUEUE_WORKLOOP)
-
-#ifndef DISPATCH_USE_WORKQUEUE_NARROWING
-#if HAVE_PTHREAD_WORKQUEUES && DISPATCH_MIN_REQUIRED_OSX_AT_LEAST(101300)
-#define DISPATCH_USE_WORKQUEUE_NARROWING 1
-#else
-#define DISPATCH_USE_WORKQUEUE_NARROWING 0
-#endif
-#endif // !defined(DISPATCH_USE_WORKQUEUE_NARROWING)
-
-#ifndef DISPATCH_USE_PTHREAD_ROOT_QUEUES
-#if defined(__BLOCKS__) && defined(__APPLE__)
-#define DISPATCH_USE_PTHREAD_ROOT_QUEUES 1 // <rdar://problem/10719357>
-#else
-#define DISPATCH_USE_PTHREAD_ROOT_QUEUES 0
-#endif
-#endif // !defined(DISPATCH_USE_PTHREAD_ROOT_QUEUES)
-
-#ifndef DISPATCH_USE_PTHREAD_POOL
-#if DISPATCH_USE_PTHREAD_ROOT_QUEUES || DISPATCH_USE_INTERNAL_WORKQUEUE
-#define DISPATCH_USE_PTHREAD_POOL 1
-#else
-#define DISPATCH_USE_PTHREAD_POOL 0
-#endif
-#endif // !defined(DISPATCH_USE_PTHREAD_POOL)
-
-#ifndef DISPATCH_USE_KEVENT_WORKQUEUE
-#if HAVE_PTHREAD_WORKQUEUE_KEVENT
-#define DISPATCH_USE_KEVENT_WORKQUEUE 1
-#else
-#define DISPATCH_USE_KEVENT_WORKQUEUE 0
-#endif
-#endif // !defined(DISPATCH_USE_KEVENT_WORKQUEUE)
-
-#if DISPATCH_USE_KEVENT_WORKQUEUE
-#if !HAVE_PTHREAD_WORKQUEUE_QOS || !EV_UDATA_SPECIFIC
-#error Invalid build configuration
-#endif
-#endif // DISPATCH_USE_KEVENT_WORKQUEUE
-
-#ifndef DISPATCH_USE_MGR_THREAD
-#if !DISPATCH_USE_KEVENT_WORKQUEUE || DISPATCH_DEBUG || DISPATCH_PROFILE
-#define DISPATCH_USE_MGR_THREAD 1
-#else
-#define DISPATCH_USE_MGR_THREAD 0
-#endif
-#endif // !defined(DISPATCH_USE_MGR_THREAD)
-
-#ifndef DISPATCH_USE_KEVENT_WORKLOOP
-#if HAVE_PTHREAD_WORKQUEUE_WORKLOOP
-#define DISPATCH_USE_KEVENT_WORKLOOP 1
-#else
-#define DISPATCH_USE_KEVENT_WORKLOOP 0
-#endif
-#endif // !defined(DISPATCH_USE_KEVENT_WORKLOOP)
-
-#ifdef EVFILT_MEMORYSTATUS
-#ifndef DISPATCH_USE_MEMORYSTATUS
-#define DISPATCH_USE_MEMORYSTATUS 1
-#endif
-#endif // EVFILT_MEMORYSTATUS
-
-#if TARGET_OS_SIMULATOR
-#undef DISPATCH_USE_MEMORYPRESSURE_SOURCE
-#define DISPATCH_USE_MEMORYPRESSURE_SOURCE 0
-#endif // TARGET_OS_SIMULATOR
-#if !defined(DISPATCH_USE_MEMORYPRESSURE_SOURCE) && DISPATCH_USE_MEMORYSTATUS
-#define DISPATCH_USE_MEMORYPRESSURE_SOURCE 1
-#endif
-
-#if __has_include(<malloc_private.h>)
-#include <malloc_private.h>
-#else // __has_include(<malloc_private.h)
-extern void malloc_memory_event_handler(unsigned long);
-extern int malloc_engaged_nano(void);
-#endif // __has_include(<malloc_private.h)
-#if DISPATCH_USE_MEMORYPRESSURE_SOURCE
-extern bool _dispatch_memory_warn;
-#endif
-
-#if defined(MACH_SEND_SYNC_OVERRIDE) && defined(MACH_RCV_SYNC_WAIT) && \
-		DISPATCH_MIN_REQUIRED_OSX_AT_LEAST(101300) && \
-		!defined(DISPATCH_USE_MACH_SEND_SYNC_OVERRIDE)
-#define DISPATCH_USE_MACH_SEND_SYNC_OVERRIDE 1
-#endif
-
-#if defined(F_SETNOSIGPIPE) && defined(F_GETNOSIGPIPE)
-#ifndef DISPATCH_USE_SETNOSIGPIPE
-#define DISPATCH_USE_SETNOSIGPIPE 1
-#endif
-#endif // F_SETNOSIGPIPE
-
-#if defined(MACH_SEND_NOIMPORTANCE)
-#ifndef DISPATCH_USE_CHECKIN_NOIMPORTANCE
-#define DISPATCH_USE_CHECKIN_NOIMPORTANCE 1 // rdar://problem/16996737
-#endif
-#ifndef DISPATCH_USE_NOIMPORTANCE_QOS
-#define DISPATCH_USE_NOIMPORTANCE_QOS 1 // rdar://problem/21414476
-#endif
-#endif // MACH_SEND_NOIMPORTANCE
-
-
-#if HAVE_LIBPROC_INTERNAL_H
-#include <libproc.h>
-#include <libproc_internal.h>
-#ifndef DISPATCH_USE_IMPORTANCE_ASSERTION
-#define DISPATCH_USE_IMPORTANCE_ASSERTION 1
-#endif
-#endif // HAVE_LIBPROC_INTERNAL_H
-
-#if HAVE_SYS_GUARDED_H
-#include <sys/guarded.h>
-#ifndef DISPATCH_USE_GUARDED_FD
-#define DISPATCH_USE_GUARDED_FD 1
-#endif
-#endif // HAVE_SYS_GUARDED_H
-
-
-#if DISPATCH_USE_DTRACE || DISPATCH_USE_DTRACE_INTROSPECTION
-typedef struct dispatch_trace_timer_params_s {
-	int64_t deadline, interval, leeway;
-} *dispatch_trace_timer_params_t;
-
-#ifdef __cplusplus
-extern "C++" {
-#endif
-#include "provider.h"
-#ifdef __cplusplus
-}
-#endif
-#endif // DISPATCH_USE_DTRACE || DISPATCH_USE_DTRACE_INTROSPECTION
-
-#if __has_include(<sys/kdebug.h>)
-#include <sys/kdebug.h>
-#ifndef DBG_DISPATCH
-#define DBG_DISPATCH 46
-#endif
-#ifndef KDBG_CODE
-#define KDBG_CODE(...) 0
-#define DBG_FUNC_START 0
-#define DBG_FUNC_END 0
-#endif
-#define DISPATCH_CODE(subclass, code) \
-		KDBG_CODE(DBG_DISPATCH, DISPATCH_TRACE_SUBCLASS_##subclass, code)
-#define DISPATCH_CODE_START(subclass, code) \
-		(DISPATCH_CODE(subclass, code) | DBG_FUNC_START)
-#define DISPATCH_CODE_END(subclass, code) \
-		(DISPATCH_CODE(subclass, code) | DBG_FUNC_END)
-#ifdef ARIADNEDBG_CODE
-#define ARIADNE_ENTER_DISPATCH_MAIN_CODE ARIADNEDBG_CODE(220, 2)
-#else
-#define ARIADNE_ENTER_DISPATCH_MAIN_CODE 0
-#endif
-#if !defined(DISPATCH_USE_VOUCHER_KDEBUG_TRACE) && \
-		(DISPATCH_INTROSPECTION || DISPATCH_PROFILE || DISPATCH_DEBUG)
-#define DISPATCH_USE_VOUCHER_KDEBUG_TRACE 1
-#endif
-
-#define DISPATCH_TRACE_SUBCLASS_DEFAULT 0
-#define DISPATCH_TRACE_SUBCLASS_VOUCHER 1
-#define DISPATCH_TRACE_SUBCLASS_PERF 2
-#define DISPATCH_TRACE_SUBCLASS_MACH_MSG 3
-#define DISPATCH_TRACE_SUBCLASS_PERF_MON 4
-#define DISPATCH_TRACE_SUBCLASS_QOS_TRACE 5
-#define DISPATCH_TRACE_SUBCLASS_FIREHOSE_TRACE 6
-
-#define DISPATCH_PERF_non_leaf_retarget DISPATCH_CODE(PERF, 1)
-#define DISPATCH_PERF_post_activate_retarget DISPATCH_CODE(PERF, 2)
-#define DISPATCH_PERF_post_activate_mutation DISPATCH_CODE(PERF, 3)
-#define DISPATCH_PERF_delayed_registration DISPATCH_CODE(PERF, 4)
-#define DISPATCH_PERF_mutable_target DISPATCH_CODE(PERF, 5)
-#define DISPATCH_PERF_strict_bg_timer DISPATCH_CODE(PERF, 6)
-#define DISPATCH_PERF_suspended_timer_fire DISPATCH_CODE(PERF, 7)
-#define DISPATCH_PERF_handlerless_source_fire DISPATCH_CODE(PERF, 8)
-#define DISPATCH_PERF_source_registration_without_qos DISPATCH_CODE(PERF, 9)
-
-#define DISPATCH_MACH_MSG_hdr_move DISPATCH_CODE(MACH_MSG, 1)
-
-#define DISPATCH_PERF_MON_worker_thread_start DISPATCH_CODE_START(PERF_MON, 1)
-#define DISPATCH_PERF_MON_worker_thread_end DISPATCH_CODE_END(PERF_MON, 1)
-#define DISPATCH_PERF_MON_worker_useless DISPATCH_CODE(PERF_MON, 2)
-
-#define DISPATCH_QOS_TRACE_queue_creation_start  DISPATCH_CODE_START(QOS_TRACE, 1)
-#define DISPATCH_QOS_TRACE_queue_creation_end  DISPATCH_CODE_END(QOS_TRACE, 1)
-#define DISPATCH_QOS_TRACE_queue_dispose DISPATCH_CODE(QOS_TRACE, 2)
-
-#define DISPATCH_QOS_TRACE_private_block_creation DISPATCH_CODE(QOS_TRACE, 3)
-#define DISPATCH_QOS_TRACE_private_block_dispose DISPATCH_CODE(QOS_TRACE, 4)
-
-#define DISPATCH_QOS_TRACE_continuation_push_eb DISPATCH_CODE(QOS_TRACE, 5)
-#define DISPATCH_QOS_TRACE_continuation_push_ab DISPATCH_CODE(QOS_TRACE, 6)
-#define DISPATCH_QOS_TRACE_continuation_push_f DISPATCH_CODE(QOS_TRACE, 7)
-#define DISPATCH_QOS_TRACE_source_push DISPATCH_CODE(QOS_TRACE, 8)
-
-#define DISPATCH_QOS_TRACE_continuation_pop DISPATCH_CODE(QOS_TRACE, 9)
-#define DISPATCH_QOS_TRACE_source_pop DISPATCH_CODE(QOS_TRACE, 10)
-
-#define DISPATCH_QOS_TRACE_queue_item_complete DISPATCH_CODE(QOS_TRACE, 11)
-
-#define DISPATCH_QOS_TRACE_src_callout DISPATCH_CODE(QOS_TRACE, 12)
-#define DISPATCH_QOS_TRACE_src_dispose DISPATCH_CODE(QOS_TRACE, 13)
-
-#define DISPATCH_FIREHOSE_TRACE_reserver_gave_up DISPATCH_CODE(FIREHOSE_TRACE, 1)
-#define DISPATCH_FIREHOSE_TRACE_reserver_wait DISPATCH_CODE(FIREHOSE_TRACE, 2)
-#define DISPATCH_FIREHOSE_TRACE_allocator DISPATCH_CODE(FIREHOSE_TRACE, 3)
-#define DISPATCH_FIREHOSE_TRACE_wait_for_logd DISPATCH_CODE(FIREHOSE_TRACE, 4)
-#define DISPATCH_FIREHOSE_TRACE_chunk_install DISPATCH_CODE(FIREHOSE_TRACE, 5)
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_ktrace_impl(uint32_t code, uint64_t a, uint64_t b,
-		uint64_t c, uint64_t d)
-{
-	if (!code) return;
-#ifdef _COMM_PAGE_KDEBUG_ENABLE
-	if (likely(*(volatile uint32_t *)_COMM_PAGE_KDEBUG_ENABLE == 0)) return;
-#endif
-	kdebug_trace(code, a, b, c, d);
-}
-#define _dispatch_cast_to_uint64(e) \
-		__builtin_choose_expr(sizeof(e) > 4, \
-				((uint64_t)(e)), ((uint64_t)(uintptr_t)(e)))
-#define _dispatch_ktrace(code, a, b, c, d)  _dispatch_ktrace_impl(code, \
-		_dispatch_cast_to_uint64(a), _dispatch_cast_to_uint64(b), \
-		_dispatch_cast_to_uint64(c), _dispatch_cast_to_uint64(d))
-
-#else // __has_include(<sys/kdebug.h>)
-#define DISPATCH_CODE(subclass, code) 0
-#define ARIADNE_ENTER_DISPATCH_MAIN_CODE 0
-#define DISPATCH_USE_VOUCHER_KDEBUG_TRACE 0
-#define _dispatch_ktrace(code, a, b, c, d)
-#endif // !__has_include(<sys/kdebug.h>)
-#define _dispatch_ktrace4(code, a, b, c, d) _dispatch_ktrace(code, a, b, c, d)
-#define _dispatch_ktrace3(code, a, b, c)    _dispatch_ktrace(code, a, b, c, 0)
-#define _dispatch_ktrace2(code, a, b)       _dispatch_ktrace(code, a, b, 0, 0)
-#define _dispatch_ktrace1(code, a)          _dispatch_ktrace(code, a, 0, 0, 0)
-#define _dispatch_ktrace0(code)             _dispatch_ktrace(code, 0, 0, 0, 0)
-
-#define BITPACK_UINT32_PAIR(a, b) (((uint64_t) (a) << 32) | (uint64_t) (b))
-
-#ifndef MACH_MSGH_BITS_VOUCHER_MASK
-#define MACH_MSGH_BITS_VOUCHER_MASK	0x001f0000
-#define	MACH_MSGH_BITS_SET_PORTS(remote, local, voucher)	\
-	(((remote) & MACH_MSGH_BITS_REMOTE_MASK) | 		\
-	 (((local) << 8) & MACH_MSGH_BITS_LOCAL_MASK) | 	\
-	 (((voucher) << 16) & MACH_MSGH_BITS_VOUCHER_MASK))
-#define	MACH_MSGH_BITS_VOUCHER(bits)				\
-		(((bits) & MACH_MSGH_BITS_VOUCHER_MASK) >> 16)
-#define MACH_MSGH_BITS_HAS_VOUCHER(bits)			\
-	(MACH_MSGH_BITS_VOUCHER(bits) != MACH_MSGH_BITS_ZERO)
-#define msgh_voucher_port msgh_reserved
-#define mach_voucher_t mach_port_t
-#define MACH_VOUCHER_NULL MACH_PORT_NULL
-#define MACH_SEND_INVALID_VOUCHER 0x10000005
-#endif
-
-#ifndef VOUCHER_USE_MACH_VOUCHER
-#if __has_include(<mach/mach_voucher.h>)
-#define VOUCHER_USE_MACH_VOUCHER 1
-#endif
-#endif // VOUCHER_USE_MACH_VOUCHER
-
-#ifndef VOUCHER_USE_EMPTY_MACH_BASE_VOUCHER
-#if RDAR_24272659 // FIXME: <rdar://problem/24272659>
-#define VOUCHER_USE_EMPTY_MACH_BASE_VOUCHER 1
-#else // RDAR_24272659
-#define VOUCHER_USE_EMPTY_MACH_BASE_VOUCHER 0
-#endif // RDAR_24272659
-#endif
-
-#ifndef VOUCHER_USE_PERSONA
-#if VOUCHER_USE_MACH_VOUCHER && defined(BANK_PERSONA_TOKEN) && \
-		!TARGET_OS_SIMULATOR
-#define VOUCHER_USE_PERSONA 1
-#else
-#define VOUCHER_USE_PERSONA 0
-#endif
-#endif // VOUCHER_USE_PERSONA
-
-#if VOUCHER_USE_MACH_VOUCHER
-#undef DISPATCH_USE_IMPORTANCE_ASSERTION
-#define DISPATCH_USE_IMPORTANCE_ASSERTION 0
-#else
-#undef MACH_RCV_VOUCHER
-#define MACH_RCV_VOUCHER 0
-#define VOUCHER_USE_PERSONA 0
-#endif // VOUCHER_USE_MACH_VOUCHER
-
-#define _dispatch_hardware_crash() \
-		__asm__(""); __builtin_trap() // <rdar://problem/17464981>
-
-#ifdef _WIN32
-#define _dispatch_set_crash_log_cause_and_message(ac, msg) do { \
-		(void)(ac); \
-		_dispatch_set_crash_log_message_dynamic((msg)); \
-	} while (0)
-#define _dispatch_set_crash_log_message(msg) \
-		_dispatch_set_crash_log_message_dynamic((msg))
-#define _dispatch_set_crash_log_message_dynamic(msg) _RPTF0(_CRT_ASSERT, (msg))
-#else  // _WIN32
-#define _dispatch_set_crash_log_cause_and_message(ac, msg) ((void)(ac))
-#define _dispatch_set_crash_log_message(msg)
-#define _dispatch_set_crash_log_message_dynamic(msg)
-#endif // _WIN32
-
-#if HAVE_MACH
-// MIG_REPLY_MISMATCH means either:
-// 1) A signal handler is NOT using async-safe API. See the sigaction(2) man
-//    page for more info.
-// 2) A hand crafted call to mach_msg*() screwed up. Use MIG.
-#define DISPATCH_VERIFY_MIG(x) do { \
-		if ((x) == MIG_REPLY_MISMATCH) { \
-			_dispatch_set_crash_log_cause_and_message((x), \
-					"MIG_REPLY_MISMATCH"); \
-			_dispatch_hardware_crash(); \
-		} \
-	} while (0)
-#endif
-
-#define DISPATCH_INTERNAL_CRASH(c, x) do { \
-		_dispatch_set_crash_log_cause_and_message((c), \
-				"BUG IN LIBDISPATCH: " x); \
-		_dispatch_hardware_crash(); \
-	} while (0)
-
-#define DISPATCH_CLIENT_CRASH(c, x) do { \
-		_dispatch_set_crash_log_cause_and_message((c), \
-				"BUG IN CLIENT OF LIBDISPATCH: " x); \
-		_dispatch_hardware_crash(); \
-	} while (0)
-
-#define _OS_OBJECT_CLIENT_CRASH(x) do { \
-		_dispatch_set_crash_log_message("API MISUSE: " x); \
-		_dispatch_hardware_crash(); \
-	} while (0)
-
-#define DISPATCH_ASSERTION_FAILED_MESSAGE \
-		"BUG IN CLIENT OF LIBDISPATCH: Assertion failed: "
-
-#define _dispatch_assert_crash(msg)  do { \
-		const char *__msg = (msg); \
-		_dispatch_log("%s", __msg); \
-		_dispatch_set_crash_log_message_dynamic(__msg); \
-		_dispatch_hardware_crash(); \
-	} while (0)
-
-#if defined(_WIN32)
-#define _dispatch_client_assert_fail(fmt, ...)  do { \
-		char *_msg = NULL; \
-		int _length = _scprintf("%s" fmt, DISPATCH_ASSERTION_FAILED_MESSAGE, ##__VA_ARGS__); \
-		dispatch_assert(_length != -1); \
-		_msg = (char *)malloc((unsigned)_length + 1); \
-		dispatch_assert(_msg); \
-		(void)snprintf(_msg, (unsigned)_length + 1, "%s" fmt, DISPATCH_ASSERTION_FAILED_MESSAGE, ##__VA_ARGS__); \
-		_dispatch_assert_crash(_msg); \
-		free(_msg); \
-	} while (0)
-#else
-#define _dispatch_client_assert_fail(fmt, ...)  do { \
-		char *_msg = NULL; \
-		(void)asprintf(&_msg, "%s" fmt, DISPATCH_ASSERTION_FAILED_MESSAGE, \
-				##__VA_ARGS__); \
-		_dispatch_assert_crash(_msg); \
-		free(_msg); \
-	} while (0)
-#endif
-
-#define DISPATCH_NO_VOUCHER ((voucher_t)(void*)~0ul)
-#define DISPATCH_NO_PRIORITY ((pthread_priority_t)~0ul)
-DISPATCH_ENUM(dispatch_thread_set_self, unsigned long,
-	DISPATCH_PRIORITY_ENFORCE = 0x1,
-	DISPATCH_VOUCHER_REPLACE = 0x2,
-	DISPATCH_VOUCHER_CONSUME = 0x4,
-	DISPATCH_THREAD_PARK = 0x8,
-);
-DISPATCH_WARN_RESULT
-static inline voucher_t _dispatch_adopt_priority_and_set_voucher(
-		pthread_priority_t priority, voucher_t voucher,
-		dispatch_thread_set_self_t flags);
-#if HAVE_MACH
-mach_port_t _dispatch_get_mach_host_port(void);
-#endif
-
-#if HAVE_PTHREAD_WORKQUEUE_QOS
-#if DISPATCH_DEBUG
-extern bool _dispatch_set_qos_class_enabled;
-#else
-#define _dispatch_set_qos_class_enabled (1)
-#endif
-#endif // HAVE_PTHREAD_WORKQUEUE_QOS
-#if DISPATCH_USE_KEVENT_WORKQUEUE
-#if DISPATCH_USE_MGR_THREAD
-extern bool _dispatch_kevent_workqueue_enabled;
-#else
-#define _dispatch_kevent_workqueue_enabled (1)
-#endif
-#else
-#define _dispatch_kevent_workqueue_enabled (0)
-#endif // DISPATCH_USE_KEVENT_WORKQUEUE
-
-#if DISPATCH_USE_KEVENT_WORKLOOP
-#if !DISPATCH_USE_KEVENT_WORKQUEUE || !DISPATCH_USE_KEVENT_QOS
-#error Invalid build configuration
-#endif
-#endif
-
-/* #includes dependent on internal.h */
-#include "object_internal.h"
-#include "semaphore_internal.h"
-#include "introspection_internal.h"
-#include "queue_internal.h"
-#include "source_internal.h"
-#include "mach_internal.h"
-#include "voucher_internal.h"
-#include "data_internal.h"
-#include "io_internal.h"
-#include "inline_internal.h"
-#include "firehose/firehose_internal.h"
-
-__END_DECLS
-
-#endif /* __DISPATCH_INTERNAL__ */
--- a/Telegram/ThirdParty/dispatch/src/introspection.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/introspection.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,1203 +0,0 @@
-/*
- * Copyright (c) 2012-2013 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-// Contains introspection routines that only exist in the version of the
-// library with introspection support
-
-#if DISPATCH_INTROSPECTION
-
-#include <execinfo.h>
-#include "internal.h"
-#include "dispatch/introspection.h"
-#include "introspection_private.h"
-
-typedef struct dispatch_introspection_thread_s {
-#if !OS_OBJECT_HAVE_OBJC1
-	void *dit_isa;
-#endif
-	LIST_ENTRY(dispatch_introspection_thread_s) dit_list;
-	pthread_t thread;
-#if OS_OBJECT_HAVE_OBJC1
-	void *dit_isa;
-#endif
-	dispatch_queue_t *queue;
-} dispatch_introspection_thread_s;
-dispatch_static_assert(offsetof(struct dispatch_continuation_s, dc_flags) ==
-		offsetof(struct dispatch_introspection_thread_s, dit_isa),
-		"These fields must alias so that leaks instruments work");
-typedef struct dispatch_introspection_thread_s *dispatch_introspection_thread_t;
-
-struct dispatch_introspection_state_s _dispatch_introspection = {
-	.threads = LIST_HEAD_INITIALIZER(_dispatch_introspection.threads),
-	.queues = LIST_HEAD_INITIALIZER(_dispatch_introspection.queues),
-};
-
-static void _dispatch_introspection_thread_remove(void *ctxt);
-
-static void _dispatch_introspection_queue_order_dispose(
-		dispatch_queue_introspection_context_t dqic);
-
-#pragma mark -
-#pragma mark dispatch_introspection_init
-
-void
-_dispatch_introspection_init(void)
-{
-	_dispatch_introspection.debug_queue_inversions =
-			_dispatch_getenv_bool("LIBDISPATCH_DEBUG_QUEUE_INVERSIONS", false);
-
-	// Hack to determine queue TSD offset from start of pthread structure
-	uintptr_t thread = _dispatch_thread_self();
-	thread_identifier_info_data_t tiid;
-	mach_msg_type_number_t cnt = THREAD_IDENTIFIER_INFO_COUNT;
-	kern_return_t kr = thread_info(pthread_mach_thread_np((void*)thread),
-			THREAD_IDENTIFIER_INFO, (thread_info_t)&tiid, &cnt);
-	if (!dispatch_assume_zero(kr)) {
-		_dispatch_introspection.thread_queue_offset =
-				(void*)(uintptr_t)tiid.dispatch_qaddr - (void*)thread;
-	}
-	_dispatch_thread_key_create(&dispatch_introspection_key,
-			_dispatch_introspection_thread_remove);
-	_dispatch_introspection_thread_add(); // add main thread
-
-	for (size_t i = 0; i < DISPATCH_ROOT_QUEUE_COUNT; i++) {
-		_dispatch_trace_queue_create(&_dispatch_root_queues[i]);
-	}
-#if DISPATCH_USE_MGR_THREAD && DISPATCH_USE_PTHREAD_ROOT_QUEUES
-	_dispatch_trace_queue_create(_dispatch_mgr_q.do_targetq);
-#endif
-	_dispatch_trace_queue_create(&_dispatch_main_q);
-	_dispatch_trace_queue_create(&_dispatch_mgr_q);
-}
-
-const struct dispatch_introspection_versions_s
-dispatch_introspection_versions = {
-	.introspection_version = 1,
-	.hooks_version = 2,
-	.hooks_size = sizeof(dispatch_introspection_hooks_s),
-	.queue_item_version = 1,
-	.queue_item_size = sizeof(dispatch_introspection_queue_item_s),
-	.queue_block_version = 1,
-	.queue_block_size = sizeof(dispatch_introspection_queue_block_s),
-	.queue_function_version = 1,
-	.queue_function_size = sizeof(dispatch_introspection_queue_function_s),
-	.queue_thread_version = 1,
-	.queue_thread_size = sizeof(dispatch_introspection_queue_thread_s),
-	.object_version = 1,
-	.object_size = sizeof(dispatch_introspection_object_s),
-	.queue_version = 1,
-	.queue_size = sizeof(dispatch_introspection_queue_s),
-	.source_version = 1,
-	.source_size = sizeof(dispatch_introspection_source_s),
-};
-
-#pragma mark -
-#pragma mark dispatch_introspection_threads
-
-void
-_dispatch_introspection_thread_add(void)
-{
-	if (_dispatch_thread_getspecific(dispatch_introspection_key)) {
-		return;
-	}
-	uintptr_t thread = _dispatch_thread_self();
-	dispatch_introspection_thread_t dit = (void*)_dispatch_continuation_alloc();
-	dit->dit_isa = (void*)0x41;
-	dit->thread = (void*)thread;
-	dit->queue = !_dispatch_introspection.thread_queue_offset ? NULL :
-			(void*)thread + _dispatch_introspection.thread_queue_offset;
-	_dispatch_thread_setspecific(dispatch_introspection_key, dit);
-	_dispatch_unfair_lock_lock(&_dispatch_introspection.threads_lock);
-	LIST_INSERT_HEAD(&_dispatch_introspection.threads, dit, dit_list);
-	_dispatch_unfair_lock_unlock(&_dispatch_introspection.threads_lock);
-}
-
-static DISPATCH_TSD_DTOR_CC void
-_dispatch_introspection_thread_remove(void *ctxt)
-{
-	dispatch_introspection_thread_t dit = ctxt;
-	_dispatch_unfair_lock_lock(&_dispatch_introspection.threads_lock);
-	LIST_REMOVE(dit, dit_list);
-	_dispatch_unfair_lock_unlock(&_dispatch_introspection.threads_lock);
-	_dispatch_continuation_free((void*)dit);
-	_dispatch_thread_setspecific(dispatch_introspection_key, NULL);
-}
-
-#pragma mark -
-#pragma mark dispatch_introspection_info
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_introspection_queue_s
-_dispatch_introspection_lane_get_info(dispatch_lane_class_t dqu)
-{
-	dispatch_lane_t dq = dqu._dl;
-	bool global = _dispatch_object_is_global(dq);
-	uint64_t dq_state = os_atomic_load2o(dq, dq_state, relaxed);
-
-	dispatch_introspection_queue_s diq = {
-		.queue = dq->_as_dq,
-		.target_queue = dq->do_targetq,
-		.label = dq->dq_label,
-		.serialnum = dq->dq_serialnum,
-		.width = dq->dq_width,
-		.suspend_count = _dq_state_suspend_cnt(dq_state) + dq->dq_side_suspend_cnt,
-		.enqueued = _dq_state_is_enqueued(dq_state) && !global,
-		.barrier = _dq_state_is_in_barrier(dq_state) && !global,
-		.draining = (dq->dq_items_head == (void*)~0ul) ||
-				(!dq->dq_items_head && dq->dq_items_tail),
-		.global = global,
-		.main = dx_type(dq) == DISPATCH_QUEUE_MAIN_TYPE,
-	};
-	return diq;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_introspection_queue_s
-_dispatch_introspection_workloop_get_info(dispatch_workloop_t dwl)
-{
-	uint64_t dq_state = os_atomic_load2o(dwl, dq_state, relaxed);
-
-	dispatch_introspection_queue_s diq = {
-		.queue = dwl->_as_dq,
-		.target_queue = dwl->do_targetq,
-		.label = dwl->dq_label,
-		.serialnum = dwl->dq_serialnum,
-		.width = 1,
-		.suspend_count = 0,
-		.enqueued = _dq_state_is_enqueued(dq_state),
-		.barrier = _dq_state_is_in_barrier(dq_state),
-		.draining = 0,
-		.global = 0,
-		.main = 0,
-	};
-	return diq;
-}
-
-DISPATCH_USED inline
-dispatch_introspection_queue_s
-dispatch_introspection_queue_get_info(dispatch_queue_t dq)
-{
-	if (dx_metatype(dq) == _DISPATCH_WORKLOOP_TYPE) {
-		return _dispatch_introspection_workloop_get_info(upcast(dq)._dwl);
-	}
-	return _dispatch_introspection_lane_get_info(upcast(dq)._dl);
-}
-
-static inline void
-_dispatch_introspection_continuation_get_info(dispatch_queue_t dq,
-		dispatch_continuation_t dc, dispatch_introspection_queue_item_t diqi)
-{
-	void *ctxt = dc->dc_ctxt;
-	dispatch_function_t func = dc->dc_func;
-	pthread_t waiter = NULL;
-	bool apply = false;
-	uintptr_t flags = dc->dc_flags;
-
-	if (_dispatch_object_has_vtable(dc)) {
-		flags = 0;
-		switch (dc_type(dc)) {
-#if HAVE_PTHREAD_WORKQUEUE_QOS
-		case DISPATCH_CONTINUATION_TYPE(WORKLOOP_STEALING):
-		case DISPATCH_CONTINUATION_TYPE(OVERRIDE_STEALING):
-		case DISPATCH_CONTINUATION_TYPE(OVERRIDE_OWNING):
-			dc = dc->dc_data;
-			if (!_dispatch_object_is_continuation(dc)) {
-				// these really wrap queues so we should hide the continuation type
-				dq = (dispatch_queue_t)dc;
-				diqi->type = dispatch_introspection_queue_item_type_queue;
-				diqi->queue = dispatch_introspection_queue_get_info(dq);
-				return;
-			}
-			return _dispatch_introspection_continuation_get_info(dq, dc, diqi);
-#endif
-		case DISPATCH_CONTINUATION_TYPE(ASYNC_REDIRECT):
-			DISPATCH_INTERNAL_CRASH(0, "Handled by the caller");
-		case DISPATCH_CONTINUATION_TYPE(MACH_ASYNC_REPLY):
-			break;
-		case DISPATCH_CONTINUATION_TYPE(MACH_SEND_BARRRIER_DRAIN):
-			break;
-		case DISPATCH_CONTINUATION_TYPE(MACH_SEND_BARRIER):
-		case DISPATCH_CONTINUATION_TYPE(MACH_RECV_BARRIER):
-			flags = (uintptr_t)dc->dc_data;
-			dq = dq->do_targetq;
-			break;
-		case DISPATCH_CONTINUATION_TYPE(MACH_IPC_HANDOFF):
-			flags = (uintptr_t)dc->dc_data;
-			break;
-		default:
-			DISPATCH_INTERNAL_CRASH(dc->do_vtable, "Unknown dc vtable type");
-		}
-	} else if (flags & (DC_FLAG_SYNC_WAITER | DC_FLAG_ASYNC_AND_WAIT)) {
-		dispatch_sync_context_t dsc = (dispatch_sync_context_t)dc;
-		waiter = pthread_from_mach_thread_np(dsc->dsc_waiter);
-		ctxt = dsc->dsc_ctxt;
-		func = dsc->dsc_func;
-	} else if (func == _dispatch_apply_invoke ||
-			func == _dispatch_apply_redirect_invoke) {
-		dispatch_apply_t da = ctxt;
-		if (da->da_todo) {
-			dc = da->da_dc;
-			dq = dc->dc_data;
-			ctxt = dc->dc_ctxt;
-			func = dc->dc_func;
-			apply = true;
-		}
-	}
-
-	if (flags & DC_FLAG_BLOCK_WITH_PRIVATE_DATA) {
-		dispatch_block_private_data_t dbpd = _dispatch_block_get_data(ctxt);
-		diqi->type = dispatch_introspection_queue_item_type_block;
-		func = _dispatch_Block_invoke(dbpd->dbpd_block);
-	} else if (flags & DC_FLAG_BLOCK) {
-		diqi->type = dispatch_introspection_queue_item_type_block;
-		func = _dispatch_Block_invoke(ctxt);
-	} else {
-		diqi->type = dispatch_introspection_queue_item_type_function;
-	}
-	diqi->function = (dispatch_introspection_queue_function_s){
-		.continuation = dc,
-		.target_queue = dq,
-		.context = ctxt,
-		.function = func,
-		.waiter = waiter,
-		.barrier = (flags & DC_FLAG_BARRIER) || dq->dq_width == 1,
-		.sync = (bool)(flags & (DC_FLAG_SYNC_WAITER | DC_FLAG_ASYNC_AND_WAIT)),
-		.apply = apply,
-	};
-	if (flags & DC_FLAG_GROUP_ASYNC) {
-		dispatch_group_t group = dc->dc_data;
-		if (dx_type(group) == DISPATCH_GROUP_TYPE) {
-			diqi->function.group = group;
-		}
-	}
-}
-
-static inline
-dispatch_introspection_object_s
-_dispatch_introspection_object_get_info(dispatch_object_t dou)
-{
-	dispatch_introspection_object_s dio = {
-		.object = dou._dc,
-		.target_queue = dou._do->do_targetq,
-		.type = (void*)dou._do->do_vtable,
-		.kind = _dispatch_object_class_name(dou._do),
-	};
-	return dio;
-}
-
-static inline
-dispatch_introspection_source_s
-_dispatch_introspection_source_get_info(dispatch_source_t ds)
-{
-	dispatch_source_refs_t dr = ds->ds_refs;
-	dispatch_continuation_t dc = dr->ds_handler[DS_EVENT_HANDLER];
-	void *ctxt = NULL;
-	dispatch_function_t handler = NULL;
-	bool hdlr_is_block = false;
-	if (dc) {
-		ctxt = dc->dc_ctxt;
-		handler = dc->dc_func;
-		hdlr_is_block = (dc->dc_flags & DC_FLAG_BLOCK);
-	}
-
-	uint64_t dq_state = os_atomic_load2o(ds, dq_state, relaxed);
-	dispatch_introspection_source_s dis = {
-		.source = ds,
-		.target_queue = ds->do_targetq,
-		.context = ctxt,
-		.handler = handler,
-		.suspend_count = _dq_state_suspend_cnt(dq_state) + ds->dq_side_suspend_cnt,
-		.enqueued = _dq_state_is_enqueued(dq_state),
-		.handler_is_block = hdlr_is_block,
-		.timer = dr->du_is_timer,
-		.after = dr->du_is_timer && (dr->du_timer_flags & DISPATCH_TIMER_AFTER),
-		.type = (unsigned long)dr->du_filter,
-		.handle = (unsigned long)dr->du_ident,
-	};
-	return dis;
-}
-
-static inline
-dispatch_introspection_source_s
-_dispatch_introspection_mach_get_info(dispatch_mach_t dm)
-{
-	dispatch_mach_recv_refs_t dmrr = dm->dm_recv_refs;
-	uint64_t dq_state = os_atomic_load2o(dm, dq_state, relaxed);
-
-	dispatch_introspection_source_s dis = {
-		.source = upcast(dm)._ds,
-		.target_queue = dm->do_targetq,
-		.context = dmrr->dmrr_handler_ctxt,
-		.handler = (void *)dmrr->dmrr_handler_func,
-		.suspend_count = _dq_state_suspend_cnt(dq_state) + dm->dq_side_suspend_cnt,
-		.enqueued = _dq_state_is_enqueued(dq_state),
-		.handler_is_block = dmrr->dmrr_handler_is_block,
-		.type = (unsigned long)dmrr->du_filter,
-		.handle = (unsigned long)dmrr->du_ident,
-		.is_xpc = dm->dm_is_xpc,
-	};
-	return dis;
-}
-static inline
-dispatch_introspection_queue_thread_s
-_dispatch_introspection_thread_get_info(dispatch_introspection_thread_t dit)
-{
-	dispatch_introspection_queue_thread_s diqt = {
-		.object = (void*)dit,
-		.thread = dit->thread,
-	};
-	if (dit->queue && *dit->queue) {
-		diqt.queue = dispatch_introspection_queue_get_info(*dit->queue);
-	}
-	return diqt;
-}
-
-DISPATCH_USED inline
-dispatch_introspection_queue_item_s
-dispatch_introspection_queue_item_get_info(dispatch_queue_t dq,
-		dispatch_continuation_t dc)
-{
-	dispatch_introspection_queue_item_s diqi;
-	dispatch_object_t dou;
-
-again:
-	dou._dc = dc;
-	if (_dispatch_object_has_vtable(dou._do)) {
-		unsigned long type = dx_type(dou._do);
-		unsigned long metatype = type & _DISPATCH_META_TYPE_MASK;
-		if (type == DISPATCH_CONTINUATION_TYPE(ASYNC_REDIRECT)) {
-			dq = dc->dc_data;
-			dc = dc->dc_other;
-			goto again;
-		}
-		if (metatype == _DISPATCH_CONTINUATION_TYPE) {
-			_dispatch_introspection_continuation_get_info(dq, dc, &diqi);
-		} else if (metatype == _DISPATCH_LANE_TYPE) {
-			diqi.type = dispatch_introspection_queue_item_type_queue;
-			diqi.queue = _dispatch_introspection_lane_get_info(dou._dl);
-		} else if (metatype == _DISPATCH_WORKLOOP_TYPE) {
-			diqi.type = dispatch_introspection_queue_item_type_queue;
-			diqi.queue = _dispatch_introspection_workloop_get_info(dou._dwl);
-		} else if (type == DISPATCH_SOURCE_KEVENT_TYPE) {
-			diqi.type = dispatch_introspection_queue_item_type_source;
-			diqi.source = _dispatch_introspection_source_get_info(dou._ds);
-		} else if (type == DISPATCH_MACH_CHANNEL_TYPE) {
-			diqi.type = dispatch_introspection_queue_item_type_source;
-			diqi.source = _dispatch_introspection_mach_get_info(dou._dm);
-		} else {
-			diqi.type = dispatch_introspection_queue_item_type_object;
-			diqi.object = _dispatch_introspection_object_get_info(dou._do);
-		}
-	} else {
-		_dispatch_introspection_continuation_get_info(dq, dc, &diqi);
-	}
-	return diqi;
-}
-
-#pragma mark -
-#pragma mark dispatch_introspection_iterators
-
-DISPATCH_USED
-dispatch_queue_t
-dispatch_introspection_get_queues(dispatch_queue_t start, size_t count,
-		dispatch_introspection_queue_t queues)
-{
-	dispatch_queue_introspection_context_t next;
-
-	if (start) {
-		next = start->do_finalizer;
-	} else {
-		next = LIST_FIRST(&_dispatch_introspection.queues);
-	}
-	while (count--) {
-		if (!next) {
-			queues->queue = NULL;
-			return NULL;
-		}
-		*queues++ = dispatch_introspection_queue_get_info(next->dqic_queue._dq);
-		next = LIST_NEXT(next, dqic_list);
-	}
-	return next->dqic_queue._dq;
-}
-
-DISPATCH_USED
-dispatch_continuation_t
-dispatch_introspection_get_queue_threads(dispatch_continuation_t start,
-		size_t count, dispatch_introspection_queue_thread_t threads)
-{
-	dispatch_introspection_thread_t next = start ? (void*)start :
-			LIST_FIRST(&_dispatch_introspection.threads);
-	while (count--) {
-		if (!next) {
-			threads->object = NULL;
-			break;
-		}
-		*threads++ = _dispatch_introspection_thread_get_info(next);
-		next = LIST_NEXT(next, dit_list);
-	}
-	return (void*)next;
-}
-
-DISPATCH_USED
-dispatch_continuation_t
-dispatch_introspection_queue_get_items(dispatch_queue_t _dq,
-		dispatch_continuation_t start, size_t count,
-		dispatch_introspection_queue_item_t items)
-{
-	if (dx_metatype(_dq) != _DISPATCH_LANE_TYPE) return NULL;
-	dispatch_lane_t dq = upcast(_dq)._dl;
-	dispatch_continuation_t next = start ? start :
-			dq->dq_items_head == (void*)~0ul ? NULL : (void*)dq->dq_items_head;
-	while (count--) {
-		if (!next) {
-			items->type = dispatch_introspection_queue_item_type_none;
-			break;
-		}
-		*items++ = dispatch_introspection_queue_item_get_info(_dq, next);
-		next = next->do_next;
-	}
-	return next;
-}
-
-#pragma mark -
-#pragma mark tracing & introspection helpers
-
-struct dispatch_object_s *
-_dispatch_introspection_queue_fake_sync_push_pop(dispatch_queue_t dq,
-		void *ctxt, dispatch_function_t func, uintptr_t dc_flags)
-{
-	// fake just what introspection really needs here: flags, func, ctxt, queue,
-	// dc_priority, and of course waiter
-	struct dispatch_sync_context_s dsc = {
-		.dc_priority = _dispatch_get_priority(),
-		.dc_flags    = DC_FLAG_SYNC_WAITER | dc_flags,
-		.dc_other    = dq,
-		.dsc_func    = func,
-		.dsc_ctxt    = ctxt,
-		.dsc_waiter  = _dispatch_tid_self(),
-	};
-
-	_dispatch_trace_item_push(dq, &dsc);
-	_dispatch_trace_item_pop(dq, &dsc);
-#pragma clang diagnostic push
-#pragma clang diagnostic ignored "-Wreturn-stack-address"
-	return (struct dispatch_object_s *)(uintptr_t)&dsc;
-#pragma clang diagnostic pop
-}
-
-#pragma mark -
-#pragma mark dispatch_introspection_hooks
-
-#define DISPATCH_INTROSPECTION_NO_HOOK ((void*)~0ul)
-
-dispatch_introspection_hooks_s _dispatch_introspection_hooks;
-dispatch_introspection_hooks_s _dispatch_introspection_hook_callouts;
-static const
-dispatch_introspection_hooks_s _dispatch_introspection_hook_callouts_enabled = {
-	.queue_create = DISPATCH_INTROSPECTION_NO_HOOK,
-	.queue_dispose = DISPATCH_INTROSPECTION_NO_HOOK,
-	.queue_item_enqueue = DISPATCH_INTROSPECTION_NO_HOOK,
-	.queue_item_dequeue = DISPATCH_INTROSPECTION_NO_HOOK,
-	.queue_item_complete = DISPATCH_INTROSPECTION_NO_HOOK,
-	.runtime_event = DISPATCH_INTROSPECTION_NO_HOOK,
-};
-
-#define DISPATCH_INTROSPECTION_HOOKS_COUNT (( \
-		sizeof(_dispatch_introspection_hook_callouts_enabled) - \
-		sizeof(_dispatch_introspection_hook_callouts_enabled._reserved)) / \
-		sizeof(dispatch_function_t))
-
-#define DISPATCH_INTROSPECTION_HOOK_ENABLED(h) \
-		unlikely(_dispatch_introspection_hooks.h)
-
-#define DISPATCH_INTROSPECTION_HOOK_CALLOUT(h, ...) ({ \
-		__typeof__(_dispatch_introspection_hooks.h) _h; \
-		_h = _dispatch_introspection_hooks.h; \
-		if (unlikely((void*)(_h) != DISPATCH_INTROSPECTION_NO_HOOK)) { \
-			_h(__VA_ARGS__); \
-		} })
-
-#define DISPATCH_INTROSPECTION_INTERPOSABLE_HOOK(h) \
-		DISPATCH_EXPORT void _dispatch_introspection_hook_##h(void) \
-		__asm__("_dispatch_introspection_hook_" #h); \
-		void _dispatch_introspection_hook_##h(void) {}
-
-#define DISPATCH_INTROSPECTION_INTERPOSABLE_HOOK_CALLOUT(h, ...)\
-		dispatch_introspection_hook_##h(__VA_ARGS__)
-
-DISPATCH_INTROSPECTION_INTERPOSABLE_HOOK(queue_create);
-DISPATCH_INTROSPECTION_INTERPOSABLE_HOOK(queue_destroy);
-DISPATCH_INTROSPECTION_INTERPOSABLE_HOOK(queue_item_enqueue);
-DISPATCH_INTROSPECTION_INTERPOSABLE_HOOK(queue_item_dequeue);
-DISPATCH_INTROSPECTION_INTERPOSABLE_HOOK(queue_item_complete);
-DISPATCH_INTROSPECTION_INTERPOSABLE_HOOK(queue_callout_begin);
-DISPATCH_INTROSPECTION_INTERPOSABLE_HOOK(queue_callout_end);
-
-DISPATCH_USED
-void
-dispatch_introspection_hooks_install(dispatch_introspection_hooks_t hooks)
-{
-	dispatch_introspection_hooks_s old_hooks = _dispatch_introspection_hooks;
-	_dispatch_introspection_hooks = *hooks;
-	dispatch_function_t *e = (void*)&_dispatch_introspection_hook_callouts,
-			*h = (void*)&_dispatch_introspection_hooks, *oh = (void*)&old_hooks;
-	for (size_t i = 0; i < DISPATCH_INTROSPECTION_HOOKS_COUNT; i++) {
-		if (!h[i] && e[i]) {
-			h[i] = DISPATCH_INTROSPECTION_NO_HOOK;
-		}
-		if (oh[i] == DISPATCH_INTROSPECTION_NO_HOOK) {
-			oh[i] = NULL;
-		}
-	}
-	*hooks = old_hooks;
-}
-
-DISPATCH_USED
-void
-dispatch_introspection_hook_callouts_enable(
-		dispatch_introspection_hooks_t enable)
-{
-	_dispatch_introspection_hook_callouts = enable ? *enable :
-			_dispatch_introspection_hook_callouts_enabled;
-	dispatch_function_t *e = (void*)&_dispatch_introspection_hook_callouts,
-			*h = (void*)&_dispatch_introspection_hooks;
-	for (size_t i = 0; i < DISPATCH_INTROSPECTION_HOOKS_COUNT; i++) {
-		if (e[i] && !h[i]) {
-			h[i] = DISPATCH_INTROSPECTION_NO_HOOK;
-		} else if (!e[i] && h[i] == DISPATCH_INTROSPECTION_NO_HOOK) {
-			h[i] = NULL;
-		}
-	}
-}
-
-DISPATCH_NOINLINE
-void
-dispatch_introspection_hook_callout_queue_create(
-		dispatch_introspection_queue_t queue_info)
-{
-	DISPATCH_INTROSPECTION_HOOK_CALLOUT(queue_create, queue_info);
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_introspection_queue_create_hook(dispatch_queue_t dq)
-{
-	dispatch_introspection_queue_s diq;
-	diq = dispatch_introspection_queue_get_info(dq);
-	dispatch_introspection_hook_callout_queue_create(&diq);
-}
-
-dispatch_function_t
-_dispatch_object_finalizer(dispatch_object_t dou)
-{
-	dispatch_queue_introspection_context_t dqic;
-	switch (dx_metatype(dou._do)) {
-	case _DISPATCH_LANE_TYPE:
-	case _DISPATCH_WORKLOOP_TYPE:
-		dqic = dou._dq->do_finalizer;
-		return dqic->dqic_finalizer;
-	default:
-		return dou._do->do_finalizer;
-	}
-}
-
-void
-_dispatch_object_set_finalizer(dispatch_object_t dou,
-		dispatch_function_t finalizer)
-{
-	dispatch_queue_introspection_context_t dqic;
-	switch (dx_metatype(dou._do)) {
-	case _DISPATCH_LANE_TYPE:
-	case _DISPATCH_WORKLOOP_TYPE:
-		dqic = dou._dq->do_finalizer;
-		dqic->dqic_finalizer = finalizer;
-		break;
-	default:
-		dou._do->do_finalizer = finalizer;
-		break;
-	}
-}
-
-dispatch_queue_class_t
-_dispatch_introspection_queue_create(dispatch_queue_t dq)
-{
-	dispatch_queue_introspection_context_t dqic;
-	size_t sz = sizeof(struct dispatch_queue_introspection_context_s);
-
-	if (!_dispatch_introspection.debug_queue_inversions) {
-		sz = offsetof(struct dispatch_queue_introspection_context_s,
-				__dqic_no_queue_inversion);
-	}
-	dqic = _dispatch_calloc(1, sz);
-	dqic->dqic_queue._dq = dq;
-	if (_dispatch_introspection.debug_queue_inversions) {
-		LIST_INIT(&dqic->dqic_order_top_head);
-		LIST_INIT(&dqic->dqic_order_bottom_head);
-	}
-	dq->do_finalizer = dqic;
-
-	_dispatch_unfair_lock_lock(&_dispatch_introspection.queues_lock);
-	LIST_INSERT_HEAD(&_dispatch_introspection.queues, dqic, dqic_list);
-	_dispatch_unfair_lock_unlock(&_dispatch_introspection.queues_lock);
-
-	DISPATCH_INTROSPECTION_INTERPOSABLE_HOOK_CALLOUT(queue_create, dq);
-	if (DISPATCH_INTROSPECTION_HOOK_ENABLED(queue_create)) {
-		_dispatch_introspection_queue_create_hook(dq);
-	}
-	return upcast(dq)._dqu;
-}
-
-DISPATCH_NOINLINE
-void
-dispatch_introspection_hook_callout_queue_dispose(
-		dispatch_introspection_queue_t queue_info)
-{
-	DISPATCH_INTROSPECTION_HOOK_CALLOUT(queue_dispose, queue_info);
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_introspection_queue_dispose_hook(dispatch_queue_t dq)
-{
-	dispatch_introspection_queue_s diq;
-	diq = dispatch_introspection_queue_get_info(dq);
-	dispatch_introspection_hook_callout_queue_dispose(&diq);
-}
-
-void
-_dispatch_introspection_queue_dispose(dispatch_queue_t dq)
-{
-	dispatch_queue_introspection_context_t dqic = dq->do_finalizer;
-
-	DISPATCH_INTROSPECTION_INTERPOSABLE_HOOK_CALLOUT(queue_destroy, dq);
-	if (DISPATCH_INTROSPECTION_HOOK_ENABLED(queue_dispose)) {
-		_dispatch_introspection_queue_dispose_hook(dq);
-	}
-
-	_dispatch_unfair_lock_lock(&_dispatch_introspection.queues_lock);
-	LIST_REMOVE(dqic, dqic_list);
-	if (_dispatch_introspection.debug_queue_inversions) {
-		_dispatch_introspection_queue_order_dispose(dqic);
-	}
-	_dispatch_unfair_lock_unlock(&_dispatch_introspection.queues_lock);
-
-	dq->do_finalizer = dqic->dqic_finalizer; // restore the real finalizer
-	free(dqic);
-}
-
-DISPATCH_NOINLINE
-void
-dispatch_introspection_hook_callout_queue_item_enqueue(dispatch_queue_t queue,
-		dispatch_introspection_queue_item_t item)
-{
-	DISPATCH_INTROSPECTION_HOOK_CALLOUT(queue_item_enqueue, queue, item);
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_introspection_queue_item_enqueue_hook(dispatch_queue_t dq,
-		dispatch_object_t dou)
-{
-	dispatch_introspection_queue_item_s diqi;
-	diqi = dispatch_introspection_queue_item_get_info(dq, dou._dc);
-	dispatch_introspection_hook_callout_queue_item_enqueue(dq, &diqi);
-}
-
-void
-_dispatch_introspection_queue_item_enqueue(dispatch_queue_t dq,
-		dispatch_object_t dou)
-{
-	DISPATCH_INTROSPECTION_INTERPOSABLE_HOOK_CALLOUT(
-			queue_item_enqueue, dq, dou);
-	if (DISPATCH_INTROSPECTION_HOOK_ENABLED(queue_item_enqueue)) {
-		_dispatch_introspection_queue_item_enqueue_hook(dq, dou);
-	}
-}
-
-void
-_dispatch_trace_item_push_internal(dispatch_queue_t dq,
-		dispatch_object_t dou)
-{
-	if (dx_metatype(dq) != _DISPATCH_LANE_TYPE) {
-		return;
-	}
-
-	dispatch_continuation_t dc = dou._dc;
-
-	/* Only track user continuations */
-	if (_dispatch_object_is_continuation(dou) &&
-		_dispatch_object_has_vtable(dou) && dc_type(dc) > 0){
-		return;
-	}
-
-	struct dispatch_introspection_queue_item_s idc;
-	idc = dispatch_introspection_queue_item_get_info(dq, dc);
-
-	switch (idc.type) {
-	case dispatch_introspection_queue_item_type_none:
-		break;
-	case dispatch_introspection_queue_item_type_block:
-	{
-		uintptr_t dc_flags = 0;
-		dc_flags |= (idc.block.barrier ? DC_BARRIER : 0);
-		dc_flags |= (idc.block.sync ? DC_SYNC : 0);
-		dc_flags |= (idc.block.apply ? DC_APPLY : 0);
-
-		if (dc->dc_flags & DC_FLAG_BLOCK_WITH_PRIVATE_DATA) {
-			_dispatch_ktrace4(DISPATCH_QOS_TRACE_continuation_push_eb,
-					dou._do_value,
-					(uintptr_t)idc.block.block, /* Heap allocated block ptr */
-					BITPACK_UINT32_PAIR(dq->dq_serialnum, dc_flags),
-					BITPACK_UINT32_PAIR(_dispatch_get_priority(),
-							dc->dc_priority));
-		} else {
-			_dispatch_ktrace4(DISPATCH_QOS_TRACE_continuation_push_ab,
-					dou._do_value,
-					(uintptr_t)idc.block.block_invoke, /* Function pointer */
-					BITPACK_UINT32_PAIR(dq->dq_serialnum, dc_flags),
-					BITPACK_UINT32_PAIR(_dispatch_get_priority(),
-							dc->dc_priority));
-		}
-
-		break;
-	}
-	case dispatch_introspection_queue_item_type_function:
-	{
-		uintptr_t dc_flags = 0;
-		dc_flags |= (idc.function.barrier ? DC_BARRIER : 0);
-		dc_flags |= (idc.function.sync ? DC_SYNC : 0);
-		dc_flags |= (idc.function.apply ? DC_APPLY : 0);
-
-		_dispatch_ktrace4(DISPATCH_QOS_TRACE_continuation_push_f,
-				dou._do_value,
-				(uintptr_t)idc.function.function, /* Function pointer */
-				BITPACK_UINT32_PAIR(dq->dq_serialnum, dc_flags),
-				BITPACK_UINT32_PAIR(_dispatch_get_priority(), dc->dc_priority));
-		break;
-	}
-	case dispatch_introspection_queue_item_type_object:
-		/* Generic dispatch object - we don't know how to handle this yet */
-		break;
-	case dispatch_introspection_queue_item_type_queue:
-		/* Dispatch queue - we don't know how to handle this yet */
-		break;
-	case dispatch_introspection_queue_item_type_source:
-		/* Dispatch sources */
-		_dispatch_ktrace4(DISPATCH_QOS_TRACE_source_push,
-				dou._do_value,
-				idc.source.type,
-				(uintptr_t)idc.source.handler,
-				dq->dq_serialnum);
-		break;
-	}
-}
-
-
-DISPATCH_NOINLINE
-void
-dispatch_introspection_hook_callout_queue_item_dequeue(dispatch_queue_t queue,
-		dispatch_introspection_queue_item_t item)
-{
-	DISPATCH_INTROSPECTION_HOOK_CALLOUT(queue_item_dequeue, queue, item);
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_introspection_queue_item_dequeue_hook(dispatch_queue_t dq,
-		dispatch_object_t dou)
-{
-	dispatch_introspection_queue_item_s diqi;
-	diqi = dispatch_introspection_queue_item_get_info(dq, dou._dc);
-	dispatch_introspection_hook_callout_queue_item_dequeue(dq, &diqi);
-}
-
-void
-_dispatch_introspection_queue_item_dequeue(dispatch_queue_t dq,
-		dispatch_object_t dou)
-{
-	DISPATCH_INTROSPECTION_INTERPOSABLE_HOOK_CALLOUT(
-			queue_item_dequeue, dq, dou);
-	if (DISPATCH_INTROSPECTION_HOOK_ENABLED(queue_item_dequeue)) {
-		_dispatch_introspection_queue_item_dequeue_hook(dq, dou);
-	}
-}
-
-void
-_dispatch_trace_item_pop_internal(dispatch_queue_t dq,
-		dispatch_object_t dou)
-{
-	if (dx_metatype(dq) != _DISPATCH_LANE_TYPE) {
-		return;
-	}
-
-	dispatch_continuation_t dc = dou._dc;
-
-	/* Only track user continuations */
-	if (_dispatch_object_is_continuation(dou) &&
-		_dispatch_object_has_vtable(dou) && dc_type(dc) > 0){
-		return;
-	}
-
-	struct dispatch_introspection_queue_item_s idc;
-	idc = dispatch_introspection_queue_item_get_info(dq, dc);
-
-	switch (idc.type) {
-	case dispatch_introspection_queue_item_type_none:
-		break;
-	case dispatch_introspection_queue_item_type_block:
-	case dispatch_introspection_queue_item_type_function:
-		_dispatch_ktrace3(DISPATCH_QOS_TRACE_continuation_pop,
-				dou._do_value, _dispatch_get_priority(), dq->dq_serialnum);
-		break;
-	case dispatch_introspection_queue_item_type_object:
-		/* Generic dispatch object - we don't know how to handle this yet */
-		break;
-	case dispatch_introspection_queue_item_type_queue:
-		/* Dispatch queue - we don't know how to handle this yet */
-		break;
-	case dispatch_introspection_queue_item_type_source:
-		/* Dispatch sources */
-		_dispatch_ktrace2(DISPATCH_QOS_TRACE_source_pop,
-				dou._do_value, dq->dq_serialnum);
-		break;
-	}
-}
-
-DISPATCH_NOINLINE
-void
-dispatch_introspection_hook_callout_queue_item_complete(
-		dispatch_continuation_t object)
-{
-	DISPATCH_INTROSPECTION_HOOK_CALLOUT(queue_item_complete, object);
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_introspection_queue_item_complete_hook(dispatch_object_t dou)
-{
-	dispatch_introspection_hook_callout_queue_item_complete(dou._dc);
-}
-
-void
-_dispatch_introspection_queue_item_complete(dispatch_object_t dou)
-{
-	DISPATCH_INTROSPECTION_INTERPOSABLE_HOOK_CALLOUT(queue_item_complete, dou);
-	if (DISPATCH_INTROSPECTION_HOOK_ENABLED(queue_item_complete)) {
-		_dispatch_introspection_queue_item_complete_hook(dou);
-	}
-}
-
-void
-_dispatch_introspection_callout_entry(void *ctxt, dispatch_function_t f)
-{
-	dispatch_queue_t dq = _dispatch_queue_get_current();
-	DISPATCH_INTROSPECTION_INTERPOSABLE_HOOK_CALLOUT(
-			queue_callout_begin, dq, ctxt, f);
-}
-
-void
-_dispatch_trace_source_callout_entry_internal(dispatch_source_t ds, long kind,
-		dispatch_queue_t dq, dispatch_continuation_t dc)
-{
-	if (dx_metatype(dq) != _DISPATCH_LANE_TYPE) {
-		return;
-	}
-
-	_dispatch_ktrace3(DISPATCH_QOS_TRACE_src_callout,
-					(uintptr_t)ds, (uintptr_t)dc, kind);
-
-	_dispatch_trace_item_push_internal(dq, (dispatch_object_t) dc);
-}
-
-void
-_dispatch_introspection_callout_return(void *ctxt, dispatch_function_t f)
-{
-	dispatch_queue_t dq = _dispatch_queue_get_current();
-	DISPATCH_INTROSPECTION_INTERPOSABLE_HOOK_CALLOUT(
-			queue_callout_end, dq, ctxt, f);
-}
-
-void
-_dispatch_introspection_runtime_event(
-		enum dispatch_introspection_runtime_event event,
-		void *ptr, uint64_t value)
-{
-	if (DISPATCH_INTROSPECTION_HOOK_ENABLED(runtime_event)) {
-		DISPATCH_INTROSPECTION_HOOK_CALLOUT(runtime_event, event, ptr, value);
-	}
-}
-
-#pragma mark -
-#pragma mark dispatch introspection deadlock detection
-
-typedef struct dispatch_queue_order_entry_s *dispatch_queue_order_entry_t;
-struct dispatch_queue_order_entry_s {
-	LIST_ENTRY(dispatch_queue_order_entry_s) dqoe_order_top_list;
-	LIST_ENTRY(dispatch_queue_order_entry_s) dqoe_order_bottom_list;
-	const char *dqoe_top_label;
-	const char *dqoe_bottom_label;
-	dispatch_queue_t dqoe_top_tq;
-	dispatch_queue_t dqoe_bottom_tq;
-	int   dqoe_pcs_n;
-	void *dqoe_pcs[];
-};
-
-static void
-_dispatch_introspection_queue_order_dispose(
-		dispatch_queue_introspection_context_t dqic)
-{
-	dispatch_queue_introspection_context_t o_dqic;
-	dispatch_queue_order_entry_t e, te;
-	dispatch_queue_t otherq;
-	LIST_HEAD(, dispatch_queue_order_entry_s) head;
-
-	// this whole thing happens with _dispatch_introspection.queues_lock locked
-
-	_dispatch_unfair_lock_lock(&dqic->dqic_order_top_head_lock);
-	LIST_INIT(&head);
-	LIST_SWAP(&head, &dqic->dqic_order_top_head,
-			dispatch_queue_order_entry_s, dqoe_order_top_list);
-	_dispatch_unfair_lock_unlock(&dqic->dqic_order_top_head_lock);
-
-	LIST_FOREACH_SAFE(e, &head, dqoe_order_top_list, te) {
-		otherq = e->dqoe_bottom_tq;
-		o_dqic = otherq->do_finalizer;
-		_dispatch_unfair_lock_lock(&o_dqic->dqic_order_bottom_head_lock);
-		LIST_REMOVE(e, dqoe_order_bottom_list);
-		_dispatch_unfair_lock_unlock(&o_dqic->dqic_order_bottom_head_lock);
-		free(e);
-	}
-
-	_dispatch_unfair_lock_lock(&dqic->dqic_order_bottom_head_lock);
-	LIST_INIT(&head);
-	LIST_SWAP(&head, &dqic->dqic_order_bottom_head,
-			dispatch_queue_order_entry_s, dqoe_order_top_list);
-	_dispatch_unfair_lock_unlock(&dqic->dqic_order_bottom_head_lock);
-
-	LIST_FOREACH_SAFE(e, &head, dqoe_order_bottom_list, te) {
-		otherq = e->dqoe_top_tq;
-		o_dqic = otherq->do_finalizer;
-		_dispatch_unfair_lock_lock(&o_dqic->dqic_order_top_head_lock);
-		LIST_REMOVE(e, dqoe_order_top_list);
-		_dispatch_unfair_lock_unlock(&o_dqic->dqic_order_top_head_lock);
-		free(e);
-	}
-}
-
-// caller must make sure dq is not a root quueue
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_queue_t
-_dispatch_queue_bottom_target_queue(dispatch_queue_t dq)
-{
-	while (dq->do_targetq->do_targetq) {
-		dq = dq->do_targetq;
-	}
-	return dq;
-}
-
-typedef struct dispatch_order_frame_s *dispatch_order_frame_t;
-struct dispatch_order_frame_s {
-	dispatch_order_frame_t dof_prev;
-	dispatch_queue_order_entry_t dof_e;
-};
-
-DISPATCH_NOINLINE DISPATCH_NORETURN
-static void
-_dispatch_introspection_lock_inversion_fail(dispatch_order_frame_t dof,
-		dispatch_queue_t top_q, dispatch_queue_t bottom_q)
-{
-	_SIMPLE_STRING buf = _simple_salloc();
-	const char *leading_word = "with";
-
-	_simple_sprintf(buf, "%s Lock inversion detected\n"
-			"queue [%s] trying to sync onto queue [%s] conflicts\n",
-			DISPATCH_ASSERTION_FAILED_MESSAGE,
-			bottom_q->dq_label ?: "", top_q->dq_label ?: "");
-
-	while (dof) {
-		dispatch_queue_order_entry_t e = dof->dof_e;
-		char **symbols;
-
-		_simple_sprintf(buf,
-			"%s queue [%s] syncing onto queue [%s] at:\n", leading_word,
-			dof->dof_e->dqoe_bottom_label, dof->dof_e->dqoe_top_label);
-
-		symbols = backtrace_symbols(e->dqoe_pcs, e->dqoe_pcs_n);
-		if (symbols) {
-			for (int i = 0; i < e->dqoe_pcs_n; i++) {
-				_simple_sprintf(buf, "%s\n", symbols[i]);
-			}
-			free(symbols);
-		} else {
-			_simple_sappend(buf, "<missing backtrace>\n");
-		}
-
-		leading_word = "and";
-		dof = dof->dof_prev;
-	}
-
-	// <rdar://problem/25053293> turn off the feature for crash handlers
-	_dispatch_introspection.debug_queue_inversions = false;
-	_dispatch_assert_crash(_simple_string(buf));
-	_simple_sfree(buf);
-}
-
-static void
-_dispatch_introspection_order_check(dispatch_order_frame_t dof_prev,
-		dispatch_queue_t top_q, dispatch_queue_t top_tq,
-		dispatch_queue_t bottom_q, dispatch_queue_t bottom_tq)
-{
-	struct dispatch_order_frame_s dof = { .dof_prev = dof_prev };
-	dispatch_queue_introspection_context_t btqic = bottom_tq->do_finalizer;
-
-	// has anyone above bottom_tq ever sync()ed onto top_tq ?
-	_dispatch_unfair_lock_lock(&btqic->dqic_order_top_head_lock);
-	LIST_FOREACH(dof.dof_e, &btqic->dqic_order_top_head, dqoe_order_top_list) {
-		if (unlikely(dof.dof_e->dqoe_bottom_tq == top_tq)) {
-			_dispatch_introspection_lock_inversion_fail(&dof, top_q, bottom_q);
-		}
-		_dispatch_introspection_order_check(&dof, top_q, top_tq,
-				bottom_q, dof.dof_e->dqoe_bottom_tq);
-	}
-	_dispatch_unfair_lock_unlock(&btqic->dqic_order_top_head_lock);
-}
-
-void
-_dispatch_introspection_order_record(dispatch_queue_t top_q)
-{
-	dispatch_queue_t bottom_q = _dispatch_queue_get_current();
-	dispatch_queue_order_entry_t e, it;
-	const int pcs_skip = 1, pcs_n_max = 128;
-	void *pcs[pcs_n_max];
-	int pcs_n;
-
-	if (!bottom_q || !bottom_q->do_targetq || !top_q->do_targetq) {
-		return;
-	}
-
-	dispatch_queue_t top_tq = _dispatch_queue_bottom_target_queue(top_q);
-	dispatch_queue_t bottom_tq = _dispatch_queue_bottom_target_queue(bottom_q);
-	dispatch_queue_introspection_context_t ttqic = top_tq->do_finalizer;
-	dispatch_queue_introspection_context_t btqic = bottom_tq->do_finalizer;
-
-	_dispatch_unfair_lock_lock(&ttqic->dqic_order_top_head_lock);
-	LIST_FOREACH(it, &ttqic->dqic_order_top_head, dqoe_order_top_list) {
-		if (it->dqoe_bottom_tq == bottom_tq) {
-			// that dispatch_sync() is known and validated
-			// move on
-			_dispatch_unfair_lock_unlock(&ttqic->dqic_order_top_head_lock);
-			return;
-		}
-	}
-	_dispatch_unfair_lock_unlock(&ttqic->dqic_order_top_head_lock);
-
-	_dispatch_introspection_order_check(NULL, top_q, top_tq, bottom_q, bottom_tq);
-	pcs_n = MAX(backtrace(pcs, pcs_n_max) - pcs_skip, 0);
-
-	bool copy_top_label = false, copy_bottom_label = false;
-	size_t size = sizeof(struct dispatch_queue_order_entry_s)
-			+ (size_t)pcs_n * sizeof(void *);
-
-	if (_dispatch_queue_label_needs_free(top_q)) {
-		size += strlen(top_q->dq_label) + 1;
-		copy_top_label = true;
-	}
-	if (_dispatch_queue_label_needs_free(bottom_q)) {
-		size += strlen(bottom_q->dq_label) + 1;
-		copy_bottom_label = true;
-	}
-
-	e = _dispatch_calloc(1, size);
-	e->dqoe_top_tq = top_tq;
-	e->dqoe_bottom_tq = bottom_tq;
-	e->dqoe_pcs_n = pcs_n;
-	memcpy(e->dqoe_pcs, pcs + pcs_skip, (size_t)pcs_n * sizeof(void *));
-	// and then lay out the names of the queues at the end
-	char *p = (char *)(e->dqoe_pcs + pcs_n);
-	if (copy_top_label) {
-		e->dqoe_top_label = strcpy(p, top_q->dq_label);
-		p += strlen(p) + 1;
-	} else {
-		e->dqoe_top_label = top_q->dq_label ?: "";
-	}
-	if (copy_bottom_label) {
-		e->dqoe_bottom_label = strcpy(p, bottom_q->dq_label);
-	} else {
-		e->dqoe_bottom_label = bottom_q->dq_label ?: "";
-	}
-
-	_dispatch_unfair_lock_lock(&ttqic->dqic_order_top_head_lock);
-	LIST_FOREACH(it, &ttqic->dqic_order_top_head, dqoe_order_top_list) {
-		if (unlikely(it->dqoe_bottom_tq == bottom_tq)) {
-			// someone else validated it at the same time
-			// go away quickly
-			_dispatch_unfair_lock_unlock(&ttqic->dqic_order_top_head_lock);
-			free(e);
-			return;
-		}
-	}
-	LIST_INSERT_HEAD(&ttqic->dqic_order_top_head, e, dqoe_order_top_list);
-	_dispatch_unfair_lock_unlock(&ttqic->dqic_order_top_head_lock);
-
-	_dispatch_unfair_lock_lock(&btqic->dqic_order_bottom_head_lock);
-	LIST_INSERT_HEAD(&btqic->dqic_order_bottom_head, e, dqoe_order_bottom_list);
-	_dispatch_unfair_lock_unlock(&btqic->dqic_order_bottom_head_lock);
-}
-
-void
-_dispatch_introspection_target_queue_changed(dispatch_queue_t dq)
-{
-	if (!_dispatch_introspection.debug_queue_inversions) return;
-
-	if (_dispatch_queue_atomic_flags(dq) & DQF_TARGETED) {
-		_dispatch_log(
-				"BUG IN CLIENT OF LIBDISPATCH: queue inversion debugging "
-				"cannot be used with code that changes the target "
-				"of a queue already targeted by other dispatch objects\n"
-				"queue %p[%s] was already targeted by other dispatch objects",
-				dq, dq->dq_label ?: "");
-		_dispatch_introspection.debug_queue_inversions = false;
-		return;
-	}
-
-	static char const * const reasons[] = {
-		[1] = "an initiator",
-		[2] = "a recipient",
-		[3] = "both an initiator and a recipient"
-	};
-	dispatch_queue_introspection_context_t dqic = dq->do_finalizer;
-	bool as_top = !LIST_EMPTY(&dqic->dqic_order_top_head);
-	bool as_bottom = !LIST_EMPTY(&dqic->dqic_order_top_head);
-
-	if (as_top || as_bottom) {
-		_dispatch_log(
-				"BUG IN CLIENT OF LIBDISPATCH: queue inversion debugging "
-				"expects queues to not participate in dispatch_sync() "
-				"before their setup is complete\n"
-				"forgetting that queue 0x%p[%s] participated as %s of "
-				"a dispatch_sync", dq, dq->dq_label ?: "",
-				reasons[(int)as_top + 2 * (int)as_bottom]);
-		_dispatch_unfair_lock_lock(&_dispatch_introspection.queues_lock);
-		_dispatch_introspection_queue_order_dispose(dq->do_finalizer);
-		_dispatch_unfair_lock_unlock(&_dispatch_introspection.queues_lock);
-	}
-}
-
-#endif // DISPATCH_INTROSPECTION
--- a/Telegram/ThirdParty/dispatch/src/introspection_internal.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/introspection_internal.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,236 +0,0 @@
-/*
- * Copyright (c) 2010-2013 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-/*
- * IMPORTANT: This header file describes INTERNAL interfaces to libdispatch
- * which are subject to change in future releases of Mac OS X. Any applications
- * relying on these interfaces WILL break.
- */
-
-#ifndef __DISPATCH_INTROSPECTION_INTERNAL__
-#define __DISPATCH_INTROSPECTION_INTERNAL__
-
-/* keep in sync with introspection_private.h */
-enum dispatch_introspection_runtime_event {
-	dispatch_introspection_runtime_event_worker_event_delivery = 1,
-	dispatch_introspection_runtime_event_worker_unpark = 2,
-	dispatch_introspection_runtime_event_worker_request = 3,
-	dispatch_introspection_runtime_event_worker_park = 4,
-
-	dispatch_introspection_runtime_event_sync_wait = 10,
-	dispatch_introspection_runtime_event_async_sync_handoff = 11,
-	dispatch_introspection_runtime_event_sync_sync_handoff = 12,
-	dispatch_introspection_runtime_event_sync_async_handoff = 13,
-};
-
-#if DISPATCH_INTROSPECTION
-
-#define DC_BARRIER 0x1
-#define DC_SYNC 0x2
-#define DC_APPLY 0x4
-
-typedef struct dispatch_queue_introspection_context_s {
-	dispatch_queue_class_t dqic_queue;
-	dispatch_function_t dqic_finalizer;
-	LIST_ENTRY(dispatch_queue_introspection_context_s) dqic_list;
-
-	char __dqic_no_queue_inversion[0];
-
-	// used for queue inversion debugging only
-	dispatch_unfair_lock_s dqic_order_top_head_lock;
-	dispatch_unfair_lock_s dqic_order_bottom_head_lock;
-	LIST_HEAD(, dispatch_queue_order_entry_s) dqic_order_top_head;
-	LIST_HEAD(, dispatch_queue_order_entry_s) dqic_order_bottom_head;
-} *dispatch_queue_introspection_context_t;
-
-struct dispatch_introspection_state_s {
-	LIST_HEAD(, dispatch_introspection_thread_s) threads;
-	LIST_HEAD(, dispatch_queue_introspection_context_s) queues;
-	dispatch_unfair_lock_s threads_lock;
-	dispatch_unfair_lock_s queues_lock;
-
-	ptrdiff_t thread_queue_offset;
-
-	// dispatch introspection features
-	bool debug_queue_inversions; // DISPATCH_DEBUG_QUEUE_INVERSIONS
-};
-
-extern struct dispatch_introspection_state_s _dispatch_introspection;
-
-void _dispatch_introspection_init(void);
-void _dispatch_introspection_thread_add(void);
-dispatch_function_t _dispatch_object_finalizer(dispatch_object_t dou);
-void _dispatch_object_set_finalizer(dispatch_object_t dou,
-		dispatch_function_t finalizer);
-dispatch_queue_class_t _dispatch_introspection_queue_create(
-		dispatch_queue_class_t dqu);
-void _dispatch_introspection_queue_dispose(dispatch_queue_class_t dqu);
-void _dispatch_introspection_queue_item_enqueue(dispatch_queue_class_t dqu,
-		dispatch_object_t dou);
-void _dispatch_introspection_queue_item_dequeue(dispatch_queue_class_t dqu,
-		dispatch_object_t dou);
-void _dispatch_introspection_queue_item_complete(dispatch_object_t dou);
-void _dispatch_introspection_callout_entry(void *ctxt, dispatch_function_t f);
-void _dispatch_introspection_callout_return(void *ctxt, dispatch_function_t f);
-struct dispatch_object_s *_dispatch_introspection_queue_fake_sync_push_pop(
-		dispatch_queue_t dq, void *ctxt, dispatch_function_t func,
-		uintptr_t dc_flags);
-void _dispatch_introspection_runtime_event(
-		enum dispatch_introspection_runtime_event event,
-		void *ptr, uint64_t value);
-
-#if DISPATCH_PURE_C
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_introspection_queue_push_list(dispatch_queue_class_t dqu,
-		dispatch_object_t head, dispatch_object_t tail) {
-	struct dispatch_object_s *dou = head._do;
-	do {
-		_dispatch_introspection_queue_item_enqueue(dqu, dou);
-	} while (dou != tail._do && (dou = dou->do_next));
-};
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_introspection_queue_push(dispatch_queue_class_t dqu,
-		dispatch_object_t dou)
-{
-	_dispatch_introspection_queue_item_enqueue(dqu, dou);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_introspection_queue_pop(dispatch_queue_class_t dqu,
-		dispatch_object_t dou)
-{
-	_dispatch_introspection_queue_item_dequeue(dqu, dou);
-}
-
-void
-_dispatch_introspection_order_record(dispatch_queue_t top_q);
-
-void
-_dispatch_introspection_target_queue_changed(dispatch_queue_t dq);
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_introspection_sync_begin(dispatch_queue_class_t dq)
-{
-	if (!_dispatch_introspection.debug_queue_inversions) return;
-	_dispatch_introspection_order_record(dq._dq);
-}
-
-#endif // DISPATCH_PURE_C
-
-#else // DISPATCH_INTROSPECTION
-
-#define _dispatch_introspection_init()
-#define _dispatch_introspection_thread_add()
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_queue_class_t
-_dispatch_introspection_queue_create(dispatch_queue_class_t dqu)
-{
-	return dqu;
-}
-
-#if DISPATCH_PURE_C
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_function_t
-_dispatch_object_finalizer(dispatch_object_t dou)
-{
-	return dou._do->do_finalizer;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_object_set_finalizer(dispatch_object_t dou,
-		dispatch_function_t finalizer)
-{
-	dou._do->do_finalizer = finalizer;
-}
-
-#endif // DISPATCH_PURE_C
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_introspection_queue_dispose(
-		dispatch_queue_class_t dqu DISPATCH_UNUSED) {}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_introspection_queue_push_list(
-		dispatch_queue_class_t dqu DISPATCH_UNUSED,
-		dispatch_object_t head DISPATCH_UNUSED,
-		dispatch_object_t tail DISPATCH_UNUSED) {}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_introspection_queue_push(dispatch_queue_class_t dqu DISPATCH_UNUSED,
-		dispatch_object_t dou DISPATCH_UNUSED) {}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_introspection_queue_pop(dispatch_queue_class_t dqu DISPATCH_UNUSED,
-		dispatch_object_t dou DISPATCH_UNUSED) {}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_introspection_queue_item_complete(
-		dispatch_object_t dou DISPATCH_UNUSED) {}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_introspection_callout_entry(void *ctxt DISPATCH_UNUSED,
-		dispatch_function_t f DISPATCH_UNUSED) {}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_introspection_callout_return(void *ctxt DISPATCH_UNUSED,
-		dispatch_function_t f DISPATCH_UNUSED) {}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_introspection_target_queue_changed(
-		dispatch_queue_t dq DISPATCH_UNUSED) {}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_introspection_sync_begin(
-		dispatch_queue_class_t dq DISPATCH_UNUSED) {}
-
-DISPATCH_ALWAYS_INLINE
-static inline struct dispatch_object_s *
-_dispatch_introspection_queue_fake_sync_push_pop(
-		dispatch_queue_t dq DISPATCH_UNUSED,
-		void *ctxt DISPATCH_UNUSED, dispatch_function_t func DISPATCH_UNUSED,
-		uintptr_t dc_flags DISPATCH_UNUSED) { return NULL; }
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_introspection_runtime_event(
-		enum dispatch_introspection_runtime_event event DISPATCH_UNUSED,
-		void *ptr DISPATCH_UNUSED, uint64_t value DISPATCH_UNUSED) {}
-
-#endif // DISPATCH_INTROSPECTION
-
-#endif // __DISPATCH_INTROSPECTION_INTERNAL__
--- a/Telegram/ThirdParty/dispatch/src/io.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/io.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,2776 +0,0 @@
-/*
- * Copyright (c) 2009-2013 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include "internal.h"
-
-#if defined(__FreeBSD__)
-#include <fcntl.h>
-#define F_RDADVISE F_RDAHEAD
-#endif
-
-#ifndef DISPATCH_IO_DEBUG
-#define DISPATCH_IO_DEBUG DISPATCH_DEBUG
-#endif
-
-#ifndef PAGE_SIZE
-#if defined(_WIN32)
-static DWORD
-getpagesize(void)
-{
-	SYSTEM_INFO siInfo;
-	GetSystemInfo(&siInfo);
-	return siInfo.dwPageSize;
-}
-#endif
-#define PAGE_SIZE ((size_t)getpagesize())
-#endif
-
-#if DISPATCH_DATA_IS_BRIDGED_TO_NSDATA
-#define _dispatch_io_data_retain(x) _dispatch_objc_retain(x)
-#define _dispatch_io_data_release(x) _dispatch_objc_release(x)
-#else
-#define _dispatch_io_data_retain(x) dispatch_retain(x)
-#define _dispatch_io_data_release(x) dispatch_release(x)
-#endif
-
-typedef void (^dispatch_fd_entry_init_callback_t)(dispatch_fd_entry_t fd_entry);
-
-DISPATCH_EXPORT DISPATCH_NOTHROW
-void _dispatch_iocntl(uint32_t param, uint64_t value);
-
-static dispatch_operation_t _dispatch_operation_create(
-		dispatch_op_direction_t direction, dispatch_io_t channel, off_t offset,
-		size_t length, dispatch_data_t data, dispatch_queue_t queue,
-		dispatch_io_handler_t handler);
-static void _dispatch_operation_enqueue(dispatch_operation_t op,
-		dispatch_op_direction_t direction, dispatch_data_t data);
-static dispatch_source_t _dispatch_operation_timer(dispatch_queue_t tq,
-		dispatch_operation_t op);
-static inline void _dispatch_fd_entry_retain(dispatch_fd_entry_t fd_entry);
-static inline void _dispatch_fd_entry_release(dispatch_fd_entry_t fd_entry);
-static void _dispatch_fd_entry_init_async(dispatch_fd_t fd,
-		dispatch_fd_entry_init_callback_t completion_callback);
-static dispatch_fd_entry_t _dispatch_fd_entry_create_with_fd(dispatch_fd_t fd,
-		uintptr_t hash);
-static dispatch_fd_entry_t _dispatch_fd_entry_create_with_path(
-		dispatch_io_path_data_t path_data, dev_t dev, mode_t mode);
-static int _dispatch_fd_entry_open(dispatch_fd_entry_t fd_entry,
-		dispatch_io_t channel);
-static void _dispatch_fd_entry_cleanup_operations(dispatch_fd_entry_t fd_entry,
-		dispatch_io_t channel);
-static void _dispatch_stream_init(dispatch_fd_entry_t fd_entry,
-		dispatch_queue_t tq);
-static void _dispatch_stream_dispose(dispatch_fd_entry_t fd_entry,
-		dispatch_op_direction_t direction);
-static void _dispatch_disk_init(dispatch_fd_entry_t fd_entry, dev_t dev);
-static void _dispatch_stream_enqueue_operation(dispatch_stream_t stream,
-		dispatch_operation_t operation, dispatch_data_t data);
-static void _dispatch_disk_enqueue_operation(dispatch_disk_t dsk,
-		dispatch_operation_t operation, dispatch_data_t data);
-static void _dispatch_stream_cleanup_operations(dispatch_stream_t stream,
-		dispatch_io_t channel);
-static void _dispatch_disk_cleanup_inactive_operations(dispatch_disk_t disk,
-		dispatch_io_t channel);
-static void _dispatch_stream_source_handler(void *ctx);
-static void _dispatch_stream_queue_handler(void *ctx);
-static void _dispatch_stream_handler(void *ctx);
-static void _dispatch_disk_handler(void *ctx);
-static void _dispatch_disk_perform(void *ctxt);
-static void _dispatch_operation_advise(dispatch_operation_t op,
-		size_t chunk_size);
-static int _dispatch_operation_perform(dispatch_operation_t op);
-static void _dispatch_operation_deliver_data(dispatch_operation_t op,
-		dispatch_op_flags_t flags);
-
-// Macros to wrap syscalls which return -1 on error, and retry on EINTR
-#define _dispatch_io_syscall_switch_noerr(_err, _syscall, ...) do { \
-		switch (((_err) = (((_syscall) == -1) ? errno : 0))) { \
-		case EINTR: continue; \
-		__VA_ARGS__ \
-		} \
-		break; \
-	} while (1)
-#define _dispatch_io_syscall_switch(__err, __syscall, ...) do { \
-		_dispatch_io_syscall_switch_noerr(__err, __syscall, \
-		case 0: break; \
-		__VA_ARGS__ \
-		); \
-	} while (0)
-#define _dispatch_io_syscall(__syscall) do { int __err; \
-		_dispatch_io_syscall_switch(__err, __syscall); \
-	} while (0)
-
-enum {
-	DISPATCH_OP_COMPLETE = 1,
-	DISPATCH_OP_DELIVER,
-	DISPATCH_OP_DELIVER_AND_COMPLETE,
-	DISPATCH_OP_COMPLETE_RESUME,
-	DISPATCH_OP_RESUME,
-	DISPATCH_OP_ERR,
-	DISPATCH_OP_FD_ERR,
-};
-
-#define _dispatch_io_Block_copy(x) \
-		((__typeof__(x))_dispatch_Block_copy((dispatch_block_t)(x)))
-
-#pragma mark -
-#pragma mark dispatch_io_debug
-
-#if DISPATCH_IO_DEBUG
-#if !DISPATCH_DEBUG
-#define _dispatch_io_log(x, ...) do { \
-			_dispatch_log("%llu\t%p\t" x, _dispatch_uptime(), \
-			(void *)_dispatch_thread_self(), ##__VA_ARGS__); \
-		} while (0)
-#ifdef _dispatch_object_debug
-#undef _dispatch_object_debug
-#define _dispatch_object_debug dispatch_debug
-#pragma clang diagnostic ignored "-Wdeprecated-declarations"
-#endif
-#else
-#define _dispatch_io_log(x, ...) _dispatch_debug(x, ##__VA_ARGS__)
-#endif // DISPATCH_DEBUG
-#else
-#define _dispatch_io_log(x, ...)
-#endif // DISPATCH_IO_DEBUG
-
-#define _dispatch_fd_debug(msg, fd, ...) \
-		_dispatch_io_log("fd[0x%" PRIx64 "]: " msg, fd, ##__VA_ARGS__)
-#define _dispatch_op_debug(msg, op, ...) \
-		_dispatch_io_log("op[%p]: " msg, op, ##__VA_ARGS__)
-#define _dispatch_channel_debug(msg, channel, ...) \
-		_dispatch_io_log("channel[%p]: " msg, channel, ##__VA_ARGS__)
-#define _dispatch_fd_entry_debug(msg, fd_entry, ...) \
-		_dispatch_io_log("fd_entry[%p]: " msg, fd_entry, ##__VA_ARGS__)
-#define _dispatch_disk_debug(msg, disk, ...) \
-		_dispatch_io_log("disk[%p]: " msg, disk, ##__VA_ARGS__)
-
-#pragma mark -
-#pragma mark dispatch_io_hashtables
-
-LIST_HEAD(dispatch_disk_head_s, dispatch_disk_s);
-LIST_HEAD(dispatch_fd_entry_head_s, dispatch_fd_entry_s);
-
-// Global hashtable of dev_t -> disk_s mappings
-DISPATCH_STATIC_GLOBAL(struct dispatch_disk_head_s _dispatch_io_devs[DIO_HASH_SIZE]);
-DISPATCH_STATIC_GLOBAL(dispatch_queue_t _dispatch_io_devs_lockq);
-
-// Global hashtable of fd -> fd_entry_s mappings
-DISPATCH_STATIC_GLOBAL(struct dispatch_fd_entry_head_s _dispatch_io_fds[DIO_HASH_SIZE]);
-DISPATCH_STATIC_GLOBAL(dispatch_queue_t _dispatch_io_fds_lockq);
-
-DISPATCH_STATIC_GLOBAL(dispatch_once_t _dispatch_io_init_pred);
-
-static char const * const _dispatch_io_key = "io";
-
-static void
-_dispatch_io_queues_init(void *context DISPATCH_UNUSED)
-{
-	_dispatch_io_fds_lockq = dispatch_queue_create(
-			"com.apple.libdispatch-io.fd_lockq", NULL);
-	_dispatch_io_devs_lockq = dispatch_queue_create(
-			"com.apple.libdispatch-io.dev_lockq", NULL);
-}
-
-#pragma mark -
-#pragma mark dispatch_io_defaults
-
-enum {
-	DISPATCH_IOCNTL_CHUNK_PAGES = 1,
-	DISPATCH_IOCNTL_LOW_WATER_CHUNKS,
-	DISPATCH_IOCNTL_INITIAL_DELIVERY,
-	DISPATCH_IOCNTL_MAX_PENDING_IO_REQS,
-};
-
-extern struct dispatch_io_defaults_s {
-	size_t chunk_size, low_water_chunks, max_pending_io_reqs;
-	bool initial_delivery;
-} dispatch_io_defaults;
-
-DISPATCH_GLOBAL_INIT(struct dispatch_io_defaults_s dispatch_io_defaults, {
-	.chunk_size = DIO_MAX_CHUNK_SIZE,
-	.low_water_chunks = DIO_DEFAULT_LOW_WATER_CHUNKS,
-	.max_pending_io_reqs = DIO_MAX_PENDING_IO_REQS,
-});
-
-#define _dispatch_iocntl_set_default(p, v) do { \
-		dispatch_io_defaults.p = (__typeof__(dispatch_io_defaults.p))(v); \
-	} while (0)
-
-void
-_dispatch_iocntl(uint32_t param, uint64_t value)
-{
-	switch (param) {
-	case DISPATCH_IOCNTL_CHUNK_PAGES:
-		_dispatch_iocntl_set_default(chunk_size, value * PAGE_SIZE);
-		break;
-	case DISPATCH_IOCNTL_LOW_WATER_CHUNKS:
-		_dispatch_iocntl_set_default(low_water_chunks, value);
-		break;
-	case DISPATCH_IOCNTL_INITIAL_DELIVERY:
-		_dispatch_iocntl_set_default(initial_delivery, value);
-		break;
-	case DISPATCH_IOCNTL_MAX_PENDING_IO_REQS:
-		_dispatch_iocntl_set_default(max_pending_io_reqs, value);
-		break;
-	}
-}
-
-#pragma mark -
-#pragma mark dispatch_io_t
-
-static dispatch_io_t
-_dispatch_io_create(dispatch_io_type_t type)
-{
-	dispatch_io_t channel = _dispatch_object_alloc(DISPATCH_VTABLE(io),
-			sizeof(struct dispatch_io_s));
-	channel->do_next = DISPATCH_OBJECT_LISTLESS;
-	channel->do_targetq = _dispatch_get_default_queue(true);
-	channel->params.type = type;
-	channel->params.high = SIZE_MAX;
-	channel->params.low = dispatch_io_defaults.low_water_chunks *
-			dispatch_io_defaults.chunk_size;
-	channel->queue = dispatch_queue_create("com.apple.libdispatch-io.channelq",
-			NULL);
-	return channel;
-}
-
-static void
-_dispatch_io_init(dispatch_io_t channel, dispatch_fd_entry_t fd_entry,
-		dispatch_queue_t queue, int err, void (^cleanup_handler)(int))
-{
-	// Enqueue the cleanup handler on the suspended close queue
-	if (cleanup_handler) {
-		_dispatch_retain(queue);
-		dispatch_async(!err ? fd_entry->close_queue : channel->queue, ^{
-			dispatch_async(queue, ^{
-				_dispatch_channel_debug("cleanup handler invoke: err %d",
-						channel, err);
-				cleanup_handler(err);
-			});
-			_dispatch_release(queue);
-		});
-	}
-	if (fd_entry) {
-		channel->fd_entry = fd_entry;
-		dispatch_retain(fd_entry->barrier_queue);
-		dispatch_retain(fd_entry->barrier_group);
-		channel->barrier_queue = fd_entry->barrier_queue;
-		channel->barrier_group = fd_entry->barrier_group;
-	} else {
-		// Still need to create a barrier queue, since all operations go
-		// through it
-		channel->barrier_queue = dispatch_queue_create(
-				"com.apple.libdispatch-io.barrierq", NULL);
-		channel->barrier_group = dispatch_group_create();
-	}
-}
-
-void
-_dispatch_io_dispose(dispatch_io_t channel, DISPATCH_UNUSED bool *allow_free)
-{
-	_dispatch_object_debug(channel, "%s", __func__);
-	if (channel->fd_entry &&
-			!(channel->atomic_flags & (DIO_CLOSED|DIO_STOPPED))) {
-		if (channel->fd_entry->path_data) {
-			// This modification is safe since path_data->channel is checked
-			// only on close_queue (which is still suspended at this point)
-			channel->fd_entry->path_data->channel = NULL;
-		}
-		// Cleanup handlers will only run when all channels related to this
-		// fd are complete
-		_dispatch_fd_entry_release(channel->fd_entry);
-	}
-	if (channel->queue) {
-		dispatch_release(channel->queue);
-	}
-	if (channel->barrier_queue) {
-		dispatch_release(channel->barrier_queue);
-	}
-	if (channel->barrier_group) {
-		dispatch_release(channel->barrier_group);
-	}
-}
-
-static int
-_dispatch_io_validate_type(dispatch_io_t channel, mode_t mode)
-{
-	int err = 0;
-	if (S_ISDIR(mode)) {
-		err = EISDIR;
-	} else if (channel->params.type == DISPATCH_IO_RANDOM &&
-			(S_ISFIFO(mode) || S_ISSOCK(mode))) {
-		err = ESPIPE;
-	}
-	return err;
-}
-
-static int
-_dispatch_io_get_error(dispatch_operation_t op, dispatch_io_t channel,
-		bool ignore_closed)
-{
-	// On _any_ queue
-	int err;
-	if (op) {
-		channel = op->channel;
-	}
-	if (channel->atomic_flags & (DIO_CLOSED|DIO_STOPPED)) {
-		if (!ignore_closed || channel->atomic_flags & DIO_STOPPED) {
-			err = ECANCELED;
-		} else {
-			err = 0;
-		}
-	} else {
-		err = op ? op->fd_entry->err : channel->err;
-	}
-	return err;
-}
-
-#pragma mark -
-#pragma mark dispatch_io_channels
-
-dispatch_io_t
-dispatch_io_create(dispatch_io_type_t type, dispatch_fd_t fd,
-		dispatch_queue_t queue, void (^cleanup_handler)(int))
-{
-	if (type != DISPATCH_IO_STREAM && type != DISPATCH_IO_RANDOM) {
-		return DISPATCH_BAD_INPUT;
-	}
-	dispatch_io_t channel = _dispatch_io_create(type);
-	channel->fd = fd;
-	_dispatch_channel_debug("create", channel);
-	channel->fd_actual = fd;
-	dispatch_suspend(channel->queue);
-	_dispatch_retain(queue);
-	_dispatch_retain(channel);
-	_dispatch_fd_entry_init_async(fd, ^(dispatch_fd_entry_t fd_entry) {
-		// On barrier queue
-		int err = fd_entry->err;
-		if (!err) {
-			err = _dispatch_io_validate_type(channel, fd_entry->stat.mode);
-		}
-		if (!err && type == DISPATCH_IO_RANDOM) {
-#if defined(_WIN32)
-			LARGE_INTEGER liPosition;
-			LARGE_INTEGER liDistance = {};
-			if (!SetFilePointerEx((HANDLE)fd_entry->fd, liDistance, &liPosition, FILE_CURRENT)) {
-				err = (int)GetLastError();
-			} else {
-				err = 0;
-				channel->f_ptr = liPosition.QuadPart;
-			}
-#else
-			off_t f_ptr;
-			_dispatch_io_syscall_switch_noerr(err,
-				f_ptr = lseek(fd_entry->fd, 0, SEEK_CUR),
-				case 0: channel->f_ptr = f_ptr; break;
-				default: (void)dispatch_assume_zero(err); break;
-			);
-#endif
-		}
-		channel->err = err;
-		_dispatch_fd_entry_retain(fd_entry);
-		_dispatch_io_init(channel, fd_entry, queue, err, cleanup_handler);
-		dispatch_resume(channel->queue);
-		_dispatch_object_debug(channel, "%s", __func__);
-		_dispatch_release(channel);
-		_dispatch_release(queue);
-	});
-	_dispatch_object_debug(channel, "%s", __func__);
-	return channel;
-}
-
-dispatch_io_t
-dispatch_io_create_f(dispatch_io_type_t type, dispatch_fd_t fd,
-		dispatch_queue_t queue, void *context,
-		void (*cleanup_handler)(void *context, int error))
-{
-	return dispatch_io_create(type, fd, queue, !cleanup_handler ? NULL :
-			^(int error){ cleanup_handler(context, error); });
-}
-
-#if defined(_WIN32)
-#define _is_separator(ch) ((ch) == '/' || (ch) == '\\')
-#else
-#define _is_separator(ch) ((ch) == '/')
-#endif
-
-dispatch_io_t
-dispatch_io_create_with_path(dispatch_io_type_t type, const char *path,
-		int oflag, mode_t mode, dispatch_queue_t queue,
-		void (^cleanup_handler)(int error))
-{
-	if (type != DISPATCH_IO_STREAM && type != DISPATCH_IO_RANDOM) {
-		return DISPATCH_BAD_INPUT;
-	}
-#if defined(_WIN32)
-	if (PathIsRelativeA(path)) {
-		return DISPATCH_BAD_INPUT;
-	}
-#else
-	if (!_is_separator(*path)) {
-		return DISPATCH_BAD_INPUT;
-	}
-#endif
-	size_t pathlen = strlen(path);
-	dispatch_io_path_data_t path_data = malloc(sizeof(*path_data) + pathlen+1);
-	if (!path_data) {
-		return DISPATCH_OUT_OF_MEMORY;
-	}
-	dispatch_io_t channel = _dispatch_io_create(type);
-	channel->fd = -1;
-	_dispatch_channel_debug("create with path %s", channel, path);
-	channel->fd_actual = -1;
-	path_data->channel = channel;
-	path_data->oflag = oflag;
-	path_data->mode = mode;
-	path_data->pathlen = pathlen;
-	memcpy(path_data->path, path, pathlen + 1);
-	_dispatch_retain(queue);
-	_dispatch_retain(channel);
-	dispatch_async(channel->queue, ^{
-		int err = 0;
-		struct stat st;
-		_dispatch_io_syscall_switch_noerr(err,
-#if defined(_WIN32)
-			stat(path_data->path, &st),
-#else
-			(path_data->oflag & O_NOFOLLOW) == O_NOFOLLOW
-#if __APPLE__
-					|| (path_data->oflag & O_SYMLINK) == O_SYMLINK
-#endif
-					? lstat(path_data->path, &st) : stat(path_data->path, &st),
-#endif
-			case 0:
-				err = _dispatch_io_validate_type(channel, st.st_mode);
-				break;
-			default:
-				if ((path_data->oflag & O_CREAT) &&
-						!_is_separator(*(path_data->path + path_data->pathlen - 1))) {
-					// Check parent directory
-					char *c = NULL;
-					for (ssize_t i = (ssize_t)path_data->pathlen - 1; i >= 0; i--) {
-						if (_is_separator(path_data->path[i])) {
-							c = &path_data->path[i];
-							break;
-						}
-					}
-					dispatch_assert(c);
-					*c = 0;
-					int perr;
-					_dispatch_io_syscall_switch_noerr(perr,
-						stat(path_data->path, &st),
-						case 0:
-							// Since the parent directory exists, open() will
-							// create a regular file after the fd_entry has
-							// been filled in
-							st.st_mode = S_IFREG;
-							err = 0;
-							break;
-					);
-#if defined(_WIN32)
-					*c = '\\';
-#else
-					*c = '/';
-#endif
-				}
-				break;
-		);
-		channel->err = err;
-		if (err) {
-			free(path_data);
-			_dispatch_io_init(channel, NULL, queue, err, cleanup_handler);
-			_dispatch_release(channel);
-			_dispatch_release(queue);
-			return;
-		}
-		dispatch_suspend(channel->queue);
-		dispatch_once_f(&_dispatch_io_init_pred, NULL,
-				_dispatch_io_queues_init);
-		dispatch_async(_dispatch_io_devs_lockq, ^{
-			dispatch_fd_entry_t fd_entry = _dispatch_fd_entry_create_with_path(
-					path_data, st.st_dev, st.st_mode);
-			_dispatch_io_init(channel, fd_entry, queue, 0, cleanup_handler);
-			dispatch_resume(channel->queue);
-			_dispatch_object_debug(channel, "%s", __func__);
-			_dispatch_release(channel);
-			_dispatch_release(queue);
-		});
-	});
-	_dispatch_object_debug(channel, "%s", __func__);
-	return channel;
-}
-
-dispatch_io_t
-dispatch_io_create_with_path_f(dispatch_io_type_t type, const char *path,
-		int oflag, mode_t mode, dispatch_queue_t queue, void *context,
-		void (*cleanup_handler)(void *context, int error))
-{
-	return dispatch_io_create_with_path(type, path, oflag, mode, queue,
-			!cleanup_handler ? NULL :
-			^(int error){ cleanup_handler(context, error); });
-}
-
-dispatch_io_t
-dispatch_io_create_with_io(dispatch_io_type_t type, dispatch_io_t in_channel,
-		dispatch_queue_t queue, void (^cleanup_handler)(int error))
-{
-	if (type != DISPATCH_IO_STREAM && type != DISPATCH_IO_RANDOM) {
-		return DISPATCH_BAD_INPUT;
-	}
-	dispatch_io_t channel = _dispatch_io_create(type);
-	_dispatch_channel_debug("create with channel %p", channel, in_channel);
-	dispatch_suspend(channel->queue);
-	_dispatch_retain(queue);
-	_dispatch_retain(channel);
-	_dispatch_retain(in_channel);
-	dispatch_async(in_channel->queue, ^{
-		int err0 = _dispatch_io_get_error(NULL, in_channel, false);
-		if (err0) {
-			channel->err = err0;
-			_dispatch_io_init(channel, NULL, queue, err0, cleanup_handler);
-			dispatch_resume(channel->queue);
-			_dispatch_release(channel);
-			_dispatch_release(in_channel);
-			_dispatch_release(queue);
-			return;
-		}
-		dispatch_async(in_channel->barrier_queue, ^{
-			int err = _dispatch_io_get_error(NULL, in_channel, false);
-			// If there is no error, the fd_entry for the in_channel is valid.
-			// Since we are running on in_channel's queue, the fd_entry has been
-			// fully resolved and will stay valid for the duration of this block
-			if (!err) {
-				err = in_channel->err;
-				if (!err) {
-					err = in_channel->fd_entry->err;
-				}
-			}
-			if (!err) {
-				err = _dispatch_io_validate_type(channel,
-						in_channel->fd_entry->stat.mode);
-			}
-			if (!err && type == DISPATCH_IO_RANDOM && in_channel->fd != -1) {
-#if defined(_WIN32)
-				LARGE_INTEGER liPosition;
-				LARGE_INTEGER liDistance = {};
-				if (!SetFilePointerEx((HANDLE)in_channel->fd_entry->fd, liDistance, &liPosition, FILE_CURRENT)) {
-					err = (int)GetLastError();
-				} else {
-					err = 0;
-					channel->f_ptr = liPosition.QuadPart;
-				}
-#else
-				off_t f_ptr;
-				_dispatch_io_syscall_switch_noerr(err,
-					f_ptr = lseek(in_channel->fd_entry->fd, 0, SEEK_CUR),
-					case 0: channel->f_ptr = f_ptr; break;
-					default: (void)dispatch_assume_zero(err); break;
-				);
-#endif
-			}
-			channel->err = err;
-			if (err) {
-				_dispatch_io_init(channel, NULL, queue, err, cleanup_handler);
-				dispatch_resume(channel->queue);
-				_dispatch_release(channel);
-				_dispatch_release(in_channel);
-				_dispatch_release(queue);
-				return;
-			}
-			if (in_channel->fd == -1) {
-				// in_channel was created from path
-				channel->fd = -1;
-				channel->fd_actual = -1;
-				mode_t mode = in_channel->fd_entry->stat.mode;
-				dev_t dev = in_channel->fd_entry->stat.dev;
-				size_t path_data_len = sizeof(struct dispatch_io_path_data_s) +
-						in_channel->fd_entry->path_data->pathlen + 1;
-				dispatch_io_path_data_t path_data = malloc(path_data_len);
-				memcpy(path_data, in_channel->fd_entry->path_data,
-						path_data_len);
-				path_data->channel = channel;
-				// lockq_io_devs is known to already exist
-				dispatch_async(_dispatch_io_devs_lockq, ^{
-					dispatch_fd_entry_t fd_entry;
-					fd_entry = _dispatch_fd_entry_create_with_path(path_data,
-							dev, mode);
-					_dispatch_io_init(channel, fd_entry, queue, 0,
-							cleanup_handler);
-					dispatch_resume(channel->queue);
-					_dispatch_release(channel);
-					_dispatch_release(queue);
-				});
-			} else {
-				dispatch_fd_entry_t fd_entry = in_channel->fd_entry;
-				channel->fd = in_channel->fd;
-				channel->fd_actual = in_channel->fd_actual;
-				_dispatch_fd_entry_retain(fd_entry);
-				_dispatch_io_init(channel, fd_entry, queue, 0, cleanup_handler);
-				dispatch_resume(channel->queue);
-				_dispatch_release(channel);
-				_dispatch_release(queue);
-			}
-			_dispatch_release(in_channel);
-			_dispatch_object_debug(channel, "%s", __func__);
-		});
-	});
-	_dispatch_object_debug(channel, "%s", __func__);
-	return channel;
-}
-
-dispatch_io_t
-dispatch_io_create_with_io_f(dispatch_io_type_t type, dispatch_io_t in_channel,
-		dispatch_queue_t queue, void *context,
-		void (*cleanup_handler)(void *context, int error))
-{
-	return dispatch_io_create_with_io(type, in_channel, queue,
-			!cleanup_handler ? NULL :
-			^(int error){ cleanup_handler(context, error); });
-}
-
-#pragma mark -
-#pragma mark dispatch_io_accessors
-
-void
-dispatch_io_set_high_water(dispatch_io_t channel, size_t high_water)
-{
-	_dispatch_retain(channel);
-	dispatch_async(channel->queue, ^{
-		_dispatch_channel_debug("set high water: %zu", channel, high_water);
-		if (channel->params.low > high_water) {
-			channel->params.low = high_water;
-		}
-		channel->params.high = high_water ? high_water : 1;
-		_dispatch_release(channel);
-	});
-}
-
-void
-dispatch_io_set_low_water(dispatch_io_t channel, size_t low_water)
-{
-	_dispatch_retain(channel);
-	dispatch_async(channel->queue, ^{
-		_dispatch_channel_debug("set low water: %zu", channel, low_water);
-		if (channel->params.high < low_water) {
-			channel->params.high = low_water ? low_water : 1;
-		}
-		channel->params.low = low_water;
-		_dispatch_release(channel);
-	});
-}
-
-void
-dispatch_io_set_interval(dispatch_io_t channel, uint64_t interval,
-		unsigned long flags)
-{
-	_dispatch_retain(channel);
-	dispatch_async(channel->queue, ^{
-		_dispatch_channel_debug("set interval: %llu", channel,
-		  (unsigned long long)interval);
-		channel->params.interval = interval < INT64_MAX ? interval : INT64_MAX;
-		channel->params.interval_flags = flags;
-		_dispatch_release(channel);
-	});
-}
-
-void
-_dispatch_io_set_target_queue(dispatch_io_t channel, dispatch_queue_t dq)
-{
-	_dispatch_retain(dq);
-	_dispatch_retain(channel);
-	dispatch_async(channel->queue, ^{
-		dispatch_queue_t prev_dq = channel->do_targetq;
-		channel->do_targetq = dq;
-		_dispatch_release(prev_dq);
-		_dispatch_object_debug(channel, "%s", __func__);
-		_dispatch_release(channel);
-	});
-}
-
-dispatch_fd_t
-dispatch_io_get_descriptor(dispatch_io_t channel)
-{
-	if (channel->atomic_flags & (DIO_CLOSED|DIO_STOPPED)) {
-		return -1;
-	}
-	dispatch_fd_t fd = channel->fd_actual;
-	if (fd == -1 && !_dispatch_io_get_error(NULL, channel, false)) {
-		dispatch_thread_context_t ctxt =
-				_dispatch_thread_context_find(_dispatch_io_key);
-		if (ctxt && ctxt->dtc_io_in_barrier == channel) {
-			(void)_dispatch_fd_entry_open(channel->fd_entry, channel);
-		}
-	}
-	return channel->fd_actual;
-}
-
-#pragma mark -
-#pragma mark dispatch_io_operations
-
-static void
-_dispatch_io_stop(dispatch_io_t channel)
-{
-	_dispatch_channel_debug("stop", channel);
-	(void)os_atomic_or2o(channel, atomic_flags, DIO_STOPPED, relaxed);
-	_dispatch_retain(channel);
-	dispatch_async(channel->queue, ^{
-		dispatch_async(channel->barrier_queue, ^{
-			_dispatch_object_debug(channel, "%s", __func__);
-			dispatch_fd_entry_t fd_entry = channel->fd_entry;
-			if (fd_entry) {
-				_dispatch_channel_debug("stop cleanup", channel);
-				_dispatch_fd_entry_cleanup_operations(fd_entry, channel);
-				if (!(channel->atomic_flags & DIO_CLOSED)) {
-					if (fd_entry->path_data) {
-						fd_entry->path_data->channel = NULL;
-					}
-					channel->fd_entry = NULL;
-					_dispatch_fd_entry_release(fd_entry);
-				}
-			} else if (channel->fd != -1) {
-				// Stop after close, need to check if fd_entry still exists
-				_dispatch_retain(channel);
-				dispatch_async(_dispatch_io_fds_lockq, ^{
-					_dispatch_object_debug(channel, "%s", __func__);
-					_dispatch_channel_debug("stop cleanup after close",
-							channel);
-					dispatch_fd_entry_t fdi;
-					uintptr_t hash = DIO_HASH(channel->fd);
-					LIST_FOREACH(fdi, &_dispatch_io_fds[hash], fd_list) {
-						if (fdi->fd == channel->fd) {
-							_dispatch_fd_entry_cleanup_operations(fdi, channel);
-							break;
-						}
-					}
-					_dispatch_release(channel);
-				});
-			}
-			_dispatch_release(channel);
-		});
-	});
-}
-
-void
-dispatch_io_close(dispatch_io_t channel, unsigned long flags)
-{
-	if (flags & DISPATCH_IO_STOP) {
-		// Don't stop an already stopped channel
-		if (channel->atomic_flags & DIO_STOPPED) {
-			return;
-		}
-		return _dispatch_io_stop(channel);
-	}
-	// Don't close an already closed or stopped channel
-	if (channel->atomic_flags & (DIO_CLOSED|DIO_STOPPED)) {
-		return;
-	}
-	_dispatch_retain(channel);
-	dispatch_async(channel->queue, ^{
-		dispatch_async(channel->barrier_queue, ^{
-			_dispatch_object_debug(channel, "%s", __func__);
-			_dispatch_channel_debug("close", channel);
-			if (!(channel->atomic_flags & (DIO_CLOSED|DIO_STOPPED))) {
-				(void)os_atomic_or2o(channel, atomic_flags, DIO_CLOSED,
-						relaxed);
-				dispatch_fd_entry_t fd_entry = channel->fd_entry;
-				if (fd_entry) {
-					if (fd_entry->path_data) {
-						fd_entry->path_data->channel = NULL;
-					}
-					channel->fd_entry = NULL;
-					_dispatch_fd_entry_release(fd_entry);
-				}
-			}
-			_dispatch_release(channel);
-		});
-	});
-}
-
-void
-dispatch_io_barrier(dispatch_io_t channel, dispatch_block_t barrier)
-{
-	_dispatch_retain(channel);
-	dispatch_async(channel->queue, ^{
-		dispatch_queue_t io_q = channel->do_targetq;
-		dispatch_queue_t barrier_queue = channel->barrier_queue;
-		dispatch_group_t barrier_group = channel->barrier_group;
-		dispatch_async(barrier_queue, ^{
-			dispatch_suspend(barrier_queue);
-			dispatch_group_notify(barrier_group, io_q, ^{
-				dispatch_thread_context_s io_ctxt = {
-					.dtc_key = _dispatch_io_key,
-					.dtc_io_in_barrier = channel,
-				};
-
-				_dispatch_object_debug(channel, "%s", __func__);
-				_dispatch_thread_context_push(&io_ctxt);
-				barrier();
-				_dispatch_thread_context_pop(&io_ctxt);
-				dispatch_resume(barrier_queue);
-				_dispatch_release(channel);
-			});
-		});
-	});
-}
-
-void
-dispatch_io_barrier_f(dispatch_io_t channel, void *context,
-		dispatch_function_t barrier)
-{
-	return dispatch_io_barrier(channel, ^{ barrier(context); });
-}
-
-void
-dispatch_io_read(dispatch_io_t channel, off_t offset, size_t length,
-		dispatch_queue_t queue, dispatch_io_handler_t handler)
-{
-	_dispatch_retain(channel);
-	_dispatch_retain(queue);
-	dispatch_async(channel->queue, ^{
-		dispatch_operation_t op;
-		op = _dispatch_operation_create(DOP_DIR_READ, channel, offset,
-				length, dispatch_data_empty, queue, handler);
-		if (op) {
-			dispatch_queue_t barrier_q = channel->barrier_queue;
-			dispatch_async(barrier_q, ^{
-				_dispatch_operation_enqueue(op, DOP_DIR_READ,
-						dispatch_data_empty);
-			});
-		}
-		_dispatch_release(channel);
-		_dispatch_release(queue);
-	});
-}
-
-void
-dispatch_io_read_f(dispatch_io_t channel, off_t offset, size_t length,
-		dispatch_queue_t queue, void *context,
-		dispatch_io_handler_function_t handler)
-{
-	return dispatch_io_read(channel, offset, length, queue,
-			^(bool done, dispatch_data_t d, int error){
-		handler(context, done, d, error);
-	});
-}
-
-void
-dispatch_io_write(dispatch_io_t channel, off_t offset, dispatch_data_t data,
-		dispatch_queue_t queue, dispatch_io_handler_t handler)
-{
-	_dispatch_io_data_retain(data);
-	_dispatch_retain(channel);
-	_dispatch_retain(queue);
-	dispatch_async(channel->queue, ^{
-		dispatch_operation_t op;
-		op = _dispatch_operation_create(DOP_DIR_WRITE, channel, offset,
-				dispatch_data_get_size(data), data, queue, handler);
-		if (op) {
-			dispatch_queue_t barrier_q = channel->barrier_queue;
-			dispatch_async(barrier_q, ^{
-				_dispatch_operation_enqueue(op, DOP_DIR_WRITE, data);
-				_dispatch_io_data_release(data);
-			});
-		} else {
-			_dispatch_io_data_release(data);
-		}
-		_dispatch_release(channel);
-		_dispatch_release(queue);
-	});
-}
-
-void
-dispatch_io_write_f(dispatch_io_t channel, off_t offset, dispatch_data_t data,
-		dispatch_queue_t queue, void *context,
-		dispatch_io_handler_function_t handler)
-{
-	return dispatch_io_write(channel, offset, data, queue,
-			^(bool done, dispatch_data_t d, int error){
-		handler(context, done, d, error);
-	});
-}
-
-void
-dispatch_read(dispatch_fd_t fd, size_t length, dispatch_queue_t queue,
-		void (^handler)(dispatch_data_t, int))
-{
-	_dispatch_retain(queue);
-	_dispatch_fd_entry_init_async(fd, ^(dispatch_fd_entry_t fd_entry) {
-		// On barrier queue
-		if (fd_entry->err) {
-			int err = fd_entry->err;
-			dispatch_async(queue, ^{
-				_dispatch_fd_debug("convenience handler invoke", fd);
-				handler(dispatch_data_empty, err);
-			});
-			_dispatch_release(queue);
-			return;
-		}
-		// Safe to access fd_entry on barrier queue
-		dispatch_io_t channel = fd_entry->convenience_channel;
-		if (!channel) {
-			channel = _dispatch_io_create(DISPATCH_IO_STREAM);
-			channel->fd = fd;
-			channel->fd_actual = fd;
-			channel->fd_entry = fd_entry;
-			dispatch_retain(fd_entry->barrier_queue);
-			dispatch_retain(fd_entry->barrier_group);
-			channel->barrier_queue = fd_entry->barrier_queue;
-			channel->barrier_group = fd_entry->barrier_group;
-			fd_entry->convenience_channel = channel;
-		}
-		__block dispatch_data_t deliver_data = dispatch_data_empty;
-		__block int err = 0;
-		dispatch_async(fd_entry->close_queue, ^{
-			dispatch_async(queue, ^{
-				_dispatch_fd_debug("convenience handler invoke", fd);
-				handler(deliver_data, err);
-				_dispatch_io_data_release(deliver_data);
-			});
-			_dispatch_release(queue);
-		});
-		dispatch_operation_t op =
-			_dispatch_operation_create(DOP_DIR_READ, channel, 0,
-					length, dispatch_data_empty,
-					_dispatch_get_default_queue(false),
-					^(bool done, dispatch_data_t data, int error) {
-				if (data) {
-					data = dispatch_data_create_concat(deliver_data, data);
-					_dispatch_io_data_release(deliver_data);
-					deliver_data = data;
-				}
-				if (done) {
-					err = error;
-				}
-			});
-		if (op) {
-			_dispatch_operation_enqueue(op, DOP_DIR_READ, dispatch_data_empty);
-		}
-	});
-}
-
-void
-dispatch_read_f(dispatch_fd_t fd, size_t length, dispatch_queue_t queue,
-		void *context, void (*handler)(void *, dispatch_data_t, int))
-{
-	return dispatch_read(fd, length, queue, ^(dispatch_data_t d, int error){
-		handler(context, d, error);
-	});
-}
-
-void
-dispatch_write(dispatch_fd_t fd, dispatch_data_t data, dispatch_queue_t queue,
-		void (^handler)(dispatch_data_t, int))
-{
-	_dispatch_io_data_retain(data);
-	_dispatch_retain(queue);
-	_dispatch_fd_entry_init_async(fd, ^(dispatch_fd_entry_t fd_entry) {
-		// On barrier queue
-		if (fd_entry->err) {
-			int err = fd_entry->err;
-			dispatch_async(queue, ^{
-				_dispatch_fd_debug("convenience handler invoke", fd);
-				handler(NULL, err);
-			});
-			_dispatch_release(queue);
-			return;
-		}
-		// Safe to access fd_entry on barrier queue
-		dispatch_io_t channel = fd_entry->convenience_channel;
-		if (!channel) {
-			channel = _dispatch_io_create(DISPATCH_IO_STREAM);
-			channel->fd = fd;
-			channel->fd_actual = fd;
-			channel->fd_entry = fd_entry;
-			dispatch_retain(fd_entry->barrier_queue);
-			dispatch_retain(fd_entry->barrier_group);
-			channel->barrier_queue = fd_entry->barrier_queue;
-			channel->barrier_group = fd_entry->barrier_group;
-			fd_entry->convenience_channel = channel;
-		}
-		__block dispatch_data_t deliver_data = NULL;
-		__block int err = 0;
-		dispatch_async(fd_entry->close_queue, ^{
-			dispatch_async(queue, ^{
-				_dispatch_fd_debug("convenience handler invoke", fd);
-				handler(deliver_data, err);
-				if (deliver_data) {
-					_dispatch_io_data_release(deliver_data);
-				}
-			});
-			_dispatch_release(queue);
-		});
-		dispatch_operation_t op =
-			_dispatch_operation_create(DOP_DIR_WRITE, channel, 0,
-					dispatch_data_get_size(data), data,
-					_dispatch_get_default_queue(false),
-					^(bool done, dispatch_data_t d, int error) {
-				if (done) {
-					if (d) {
-						_dispatch_io_data_retain(d);
-						deliver_data = d;
-					}
-					err = error;
-				}
-			});
-		if (op) {
-			_dispatch_operation_enqueue(op, DOP_DIR_WRITE, data);
-		}
-		_dispatch_io_data_release(data);
-	});
-}
-
-void
-dispatch_write_f(dispatch_fd_t fd, dispatch_data_t data, dispatch_queue_t queue,
-		void *context, void (*handler)(void *, dispatch_data_t, int))
-{
-	return dispatch_write(fd, data, queue, ^(dispatch_data_t d, int error){
-		handler(context, d, error);
-	});
-}
-
-#pragma mark -
-#pragma mark dispatch_operation_t
-
-static dispatch_operation_t
-_dispatch_operation_create(dispatch_op_direction_t direction,
-		dispatch_io_t channel, off_t offset, size_t length,
-		dispatch_data_t data, dispatch_queue_t queue,
-		dispatch_io_handler_t handler)
-{
-	// On channel queue
-	dispatch_assert(direction < DOP_DIR_MAX);
-	// Safe to call _dispatch_io_get_error() with channel->fd_entry since
-	// that can only be NULL if atomic_flags are set rdar://problem/8362514
-	int err = _dispatch_io_get_error(NULL, channel, false);
-	if (err || !length) {
-		_dispatch_io_data_retain(data);
-		_dispatch_retain(queue);
-		_dispatch_retain(channel);
-		dispatch_async(channel->barrier_queue, ^{
-			dispatch_async(queue, ^{
-				dispatch_data_t d = data;
-				if (direction == DOP_DIR_READ && err) {
-					d = NULL;
-				} else if (direction == DOP_DIR_WRITE && !err) {
-					d = NULL;
-				}
-				_dispatch_channel_debug("IO handler invoke: err %d", channel,
-						err);
-				handler(true, d, err);
-				_dispatch_release(channel);
-				_dispatch_io_data_release(data);
-			});
-			_dispatch_release(queue);
-		});
-		return NULL;
-	}
-	dispatch_operation_t op = _dispatch_object_alloc(DISPATCH_VTABLE(operation),
-			sizeof(struct dispatch_operation_s));
-	_dispatch_channel_debug("operation create: %p", channel, op);
-	op->do_next = DISPATCH_OBJECT_LISTLESS;
-	op->do_xref_cnt = -1; // operation object is not exposed externally
-	op->op_q = dispatch_queue_create_with_target("com.apple.libdispatch-io.opq",
-			NULL, queue);
-	op->active = false;
-	op->direction = direction;
-	op->offset = offset + channel->f_ptr;
-	op->length = length;
-	op->handler = _dispatch_io_Block_copy(handler);
-	_dispatch_retain(channel);
-	op->channel = channel;
-	op->params = channel->params;
-	// Take a snapshot of the priority of the channel queue. The actual I/O
-	// for this operation will be performed at this priority
-	dispatch_queue_t targetq = op->channel->do_targetq;
-	while (targetq->do_targetq) {
-		targetq = targetq->do_targetq;
-	}
-	op->do_targetq = targetq;
-	_dispatch_object_debug(op, "%s", __func__);
-	return op;
-}
-
-void
-_dispatch_operation_dispose(dispatch_operation_t op,
-		DISPATCH_UNUSED bool *allow_free)
-{
-	_dispatch_object_debug(op, "%s", __func__);
-	_dispatch_op_debug("dispose", op);
-	// Deliver the data if there's any
-	if (op->fd_entry) {
-		_dispatch_operation_deliver_data(op, DOP_DONE);
-		dispatch_group_leave(op->fd_entry->barrier_group);
-		_dispatch_fd_entry_release(op->fd_entry);
-	}
-	if (op->channel) {
-		_dispatch_release(op->channel);
-	}
-	if (op->timer) {
-		dispatch_release(op->timer);
-	}
-	// For write operations, op->buf is owned by op->buf_data
-	if (op->buf && op->direction == DOP_DIR_READ) {
-#if defined(_WIN32)
-		_aligned_free(op->buf);
-#else
-		free(op->buf);
-#endif
-	}
-	if (op->buf_data) {
-		_dispatch_io_data_release(op->buf_data);
-	}
-	if (op->data) {
-		_dispatch_io_data_release(op->data);
-	}
-	if (op->op_q) {
-		dispatch_release(op->op_q);
-	}
-	Block_release(op->handler);
-	_dispatch_op_debug("disposed", op);
-}
-
-static void
-_dispatch_operation_enqueue(dispatch_operation_t op,
-		dispatch_op_direction_t direction, dispatch_data_t data)
-{
-	// Called from the barrier queue
-	_dispatch_io_data_retain(data);
-	// If channel is closed or stopped, then call the handler immediately
-	int err = _dispatch_io_get_error(NULL, op->channel, false);
-	if (err) {
-		dispatch_io_handler_t handler = op->handler;
-		dispatch_async(op->op_q, ^{
-			dispatch_data_t d = data;
-			if (direction == DOP_DIR_READ && err) {
-				d = NULL;
-			} else if (direction == DOP_DIR_WRITE && !err) {
-				d = NULL;
-			}
-			handler(true, d, err);
-			_dispatch_io_data_release(data);
-		});
-		_dispatch_op_debug("release -> %d, err %d", op, op->do_ref_cnt, err);
-		_dispatch_release(op);
-		return;
-	}
-	// Finish operation init
-	op->fd_entry = op->channel->fd_entry;
-	_dispatch_fd_entry_retain(op->fd_entry);
-	dispatch_group_enter(op->fd_entry->barrier_group);
-	dispatch_disk_t disk = op->fd_entry->disk;
-	if (!disk) {
-		dispatch_stream_t stream = op->fd_entry->streams[direction];
-		dispatch_async(stream->dq, ^{
-			_dispatch_stream_enqueue_operation(stream, op, data);
-			_dispatch_io_data_release(data);
-		});
-	} else {
-		dispatch_async(disk->pick_queue, ^{
-			_dispatch_disk_enqueue_operation(disk, op, data);
-			_dispatch_io_data_release(data);
-		});
-	}
-}
-
-static bool
-_dispatch_operation_should_enqueue(dispatch_operation_t op,
-		dispatch_queue_t tq, dispatch_data_t data)
-{
-	// On stream queue or disk queue
-	_dispatch_op_debug("enqueue", op);
-	_dispatch_io_data_retain(data);
-	op->data = data;
-	int err = _dispatch_io_get_error(op, NULL, true);
-	if (err) {
-		op->err = err;
-		// Final release
-		_dispatch_op_debug("release -> %d, err %d", op, op->do_ref_cnt, err);
-		_dispatch_release(op);
-		return false;
-	}
-	if (op->params.interval) {
-		dispatch_resume(_dispatch_operation_timer(tq, op));
-	}
-	return true;
-}
-
-static dispatch_source_t
-_dispatch_operation_timer(dispatch_queue_t tq, dispatch_operation_t op)
-{
-	// On stream queue or pick queue
-	if (op->timer) {
-		return op->timer;
-	}
-	dispatch_source_t timer = dispatch_source_create(
-			DISPATCH_SOURCE_TYPE_TIMER, 0, 0, tq);
-	dispatch_source_set_timer(timer,
-			dispatch_time(DISPATCH_TIME_NOW, (int64_t)op->params.interval),
-			op->params.interval, 0);
-	dispatch_source_set_event_handler(timer, ^{
-		// On stream queue or pick queue
-		if (dispatch_source_testcancel(timer)) {
-			// Do nothing. The operation has already completed
-			return;
-		}
-		dispatch_op_flags_t flags = DOP_DEFAULT;
-		if (op->params.interval_flags & DISPATCH_IO_STRICT_INTERVAL) {
-			// Deliver even if there is less data than the low-water mark
-			flags |= DOP_DELIVER;
-		}
-		// If the operation is active, dont deliver data
-		if ((op->active) && (flags & DOP_DELIVER)) {
-			op->flags = flags;
-		} else {
-			_dispatch_operation_deliver_data(op, flags);
-		}
-	});
-	op->timer = timer;
-	return op->timer;
-}
-
-#pragma mark -
-#pragma mark dispatch_fd_entry_t
-
-#if DISPATCH_USE_GUARDED_FD_CHANGE_FDGUARD
-static void
-_dispatch_fd_entry_guard(dispatch_fd_entry_t fd_entry)
-{
-	guardid_t guard = fd_entry;
-	const unsigned int guard_flags = GUARD_CLOSE;
-	int err, fd_flags = 0;
-	_dispatch_io_syscall_switch_noerr(err,
-		change_fdguard_np(fd_entry->fd, NULL, 0, &guard, guard_flags,
-				&fd_flags),
-		case 0:
-			fd_entry->guard_flags = guard_flags;
-			fd_entry->orig_fd_flags = fd_flags;
-			break;
-		case EPERM: break;
-		default: (void)dispatch_assume_zero(err); break;
-	);
-}
-
-static void
-_dispatch_fd_entry_unguard(dispatch_fd_entry_t fd_entry)
-{
-	if (!fd_entry->guard_flags) {
-		return;
-	}
-	guardid_t guard = fd_entry;
-	int err, fd_flags = fd_entry->orig_fd_flags;
-	_dispatch_io_syscall_switch(err,
-		change_fdguard_np(fd_entry->fd, &guard, fd_entry->guard_flags, NULL, 0,
-				&fd_flags),
-		default: (void)dispatch_assume_zero(err); break;
-	);
-}
-#else
-#if !defined(_WIN32)
-static inline void
-_dispatch_fd_entry_guard(dispatch_fd_entry_t fd_entry) { (void)fd_entry; }
-#endif
-static inline void
-_dispatch_fd_entry_unguard(dispatch_fd_entry_t fd_entry) { (void)fd_entry; }
-#endif // DISPATCH_USE_GUARDED_FD
-
-static inline dispatch_fd_t
-_dispatch_fd_entry_guarded_open(dispatch_fd_entry_t fd_entry, const char *path,
-		int oflag, mode_t mode) {
-#if DISPATCH_USE_GUARDED_FD
-	guardid_t guard = (uintptr_t)fd_entry;
-	const unsigned int guard_flags = GUARD_CLOSE | GUARD_DUP |
-			GUARD_SOCKET_IPC | GUARD_FILEPORT;
-	int fd = guarded_open_np(path, &guard, guard_flags, oflag | O_CLOEXEC,
-			mode);
-	if (fd != -1) {
-		fd_entry->guard_flags = guard_flags;
-		return fd;
-	}
-	errno = 0;
-#else
-	(void)fd_entry;
-#endif
-#if defined(_WIN32)
-	(void)mode;
-	DWORD dwDesiredAccess = 0;
-	switch (oflag & (_O_RDONLY | _O_WRONLY | _O_RDWR)) {
-		case _O_RDONLY:
-			dwDesiredAccess = GENERIC_READ;
-			break;
-		case _O_WRONLY:
-			dwDesiredAccess = GENERIC_WRITE;
-			break;
-		case _O_RDWR:
-			dwDesiredAccess = GENERIC_READ | GENERIC_WRITE;
-			break;
-	}
-	DWORD dwCreationDisposition = OPEN_EXISTING;
-	if (oflag & _O_CREAT) {
-		dwCreationDisposition = OPEN_ALWAYS;
-		if (oflag & _O_EXCL) {
-			dwCreationDisposition = CREATE_NEW;
-		} else if (oflag & _O_TRUNC) {
-			dwCreationDisposition = CREATE_ALWAYS;
-		}
-	} else if (oflag & _O_TRUNC) {
-		dwCreationDisposition = TRUNCATE_EXISTING;
-	}
-	return (dispatch_fd_t)CreateFile(path, dwDesiredAccess,
-			FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, NULL,
-			dwCreationDisposition, 0, NULL);
-#else
-	return open(path, oflag, mode);
-#endif
-}
-
-static inline int
-_dispatch_fd_entry_guarded_close(dispatch_fd_entry_t fd_entry, dispatch_fd_t fd) {
-#if DISPATCH_USE_GUARDED_FD
-	if (fd_entry->guard_flags) {
-		guardid_t guard = (uintptr_t)fd_entry;
-		return guarded_close_np(fd, &guard);
-	} else
-#else
-	(void)fd_entry;
-#endif
-	{
-#if defined(_WIN32)
-		return CloseHandle((HANDLE)fd);
-#else
-		return close(fd);
-#endif
-	}
-}
-
-static inline void
-_dispatch_fd_entry_retain(dispatch_fd_entry_t fd_entry) {
-	dispatch_suspend(fd_entry->close_queue);
-}
-
-static inline void
-_dispatch_fd_entry_release(dispatch_fd_entry_t fd_entry) {
-	dispatch_resume(fd_entry->close_queue);
-}
-
-static void
-_dispatch_fd_entry_init_async(dispatch_fd_t fd,
-		dispatch_fd_entry_init_callback_t completion_callback)
-{
-	dispatch_once_f(&_dispatch_io_init_pred, NULL,
-			_dispatch_io_queues_init);
-	dispatch_async(_dispatch_io_fds_lockq, ^{
-		dispatch_fd_entry_t fd_entry = NULL;
-		// Check to see if there is an existing entry for the given fd
-		uintptr_t hash = DIO_HASH(fd);
-		LIST_FOREACH(fd_entry, &_dispatch_io_fds[hash], fd_list) {
-			if (fd_entry->fd == fd) {
-				// Retain the fd_entry to ensure it cannot go away until the
-				// stat() has completed
-				_dispatch_fd_entry_retain(fd_entry);
-				break;
-			}
-		}
-		if (!fd_entry) {
-			// If we did not find an existing entry, create one
-			fd_entry = _dispatch_fd_entry_create_with_fd(fd, hash);
-		}
-		_dispatch_fd_entry_debug("init", fd_entry);
-		dispatch_async(fd_entry->barrier_queue, ^{
-			_dispatch_fd_entry_debug("init completion", fd_entry);
-			completion_callback(fd_entry);
-			// stat() is complete, release reference to fd_entry
-			_dispatch_fd_entry_release(fd_entry);
-		});
-	});
-}
-
-static dispatch_fd_entry_t
-_dispatch_fd_entry_create(dispatch_queue_t q)
-{
-	dispatch_fd_entry_t fd_entry;
-	fd_entry = _dispatch_calloc(1ul, sizeof(struct dispatch_fd_entry_s));
-	// Use target queue to ensure that no concurrent lookups are going on when
-	// the close queue is running
-	fd_entry->close_queue = dispatch_queue_create_with_target(
-			"com.apple.libdispatch-io.closeq", NULL, q);
-	// Suspend the cleanup queue until closing
-	_dispatch_fd_entry_retain(fd_entry);
-	return fd_entry;
-}
-
-static dispatch_fd_entry_t
-_dispatch_fd_entry_create_with_fd(dispatch_fd_t fd, uintptr_t hash)
-{
-	// On fds lock queue
-	dispatch_fd_entry_t fd_entry = _dispatch_fd_entry_create(
-			_dispatch_io_fds_lockq);
-	_dispatch_fd_entry_debug("create: fd %" PRId64, fd_entry, fd);
-	fd_entry->fd = fd;
-	LIST_INSERT_HEAD(&_dispatch_io_fds[hash], fd_entry, fd_list);
-	fd_entry->barrier_queue = dispatch_queue_create(
-			"com.apple.libdispatch-io.barrierq", NULL);
-	fd_entry->barrier_group = dispatch_group_create();
-	dispatch_async(fd_entry->barrier_queue, ^{
-#if defined(_WIN32)
-		DWORD dwType = GetFileType((HANDLE)fd);
-		if (dwType == FILE_TYPE_PIPE) {
-			unsigned long value = 1;
-			int result = ioctlsocket((SOCKET)fd, (long)FIONBIO, &value);
-			(void)dispatch_assume_zero(result);
-			_dispatch_stream_init(fd_entry,
-				_dispatch_get_default_queue(false));
-		} else {
-			dispatch_suspend(fd_entry->barrier_queue);
-			dispatch_once_f(&_dispatch_io_init_pred, NULL,
-					_dispatch_io_queues_init);
-			dispatch_async(_dispatch_io_devs_lockq, ^{
-				_dispatch_disk_init(fd_entry, 0);
-				dispatch_resume(fd_entry->barrier_queue);
-			});
-		}
-#else
-		_dispatch_fd_entry_debug("stat", fd_entry);
-		int err, orig_flags, orig_nosigpipe = -1;
-		struct stat st;
-		_dispatch_io_syscall_switch(err,
-			fstat(fd, &st),
-			default: fd_entry->err = err; return;
-		);
-		fd_entry->stat.dev = st.st_dev;
-		fd_entry->stat.mode = st.st_mode;
-		_dispatch_fd_entry_guard(fd_entry);
-		_dispatch_io_syscall_switch(err,
-			orig_flags = fcntl(fd, F_GETFL),
-			default: (void)dispatch_assume_zero(err); break;
-		);
-#if DISPATCH_USE_SETNOSIGPIPE // rdar://problem/4121123
-		if (S_ISFIFO(st.st_mode)) {
-			_dispatch_io_syscall_switch(err,
-				orig_nosigpipe = fcntl(fd, F_GETNOSIGPIPE),
-				default: (void)dispatch_assume_zero(err); break;
-			);
-			if (orig_nosigpipe != -1) {
-				_dispatch_io_syscall_switch(err,
-					orig_nosigpipe = fcntl(fd, F_SETNOSIGPIPE, 1),
-					default:
-						orig_nosigpipe = -1;
-						(void)dispatch_assume_zero(err);
-						break;
-				);
-			}
-		}
-#endif
-		if (S_ISREG(st.st_mode)) {
-			if (orig_flags != -1) {
-				_dispatch_io_syscall_switch(err,
-					fcntl(fd, F_SETFL, orig_flags & ~O_NONBLOCK),
-					default:
-						orig_flags = -1;
-						(void)dispatch_assume_zero(err);
-						break;
-				);
-			}
-			dev_t dev = (dev_t)major(st.st_dev);
-			// We have to get the disk on the global dev queue. The
-			// barrier queue cannot continue until that is complete
-			dispatch_suspend(fd_entry->barrier_queue);
-			dispatch_once_f(&_dispatch_io_init_pred, NULL,
-					_dispatch_io_queues_init);
-			dispatch_async(_dispatch_io_devs_lockq, ^{
-				_dispatch_disk_init(fd_entry, dev);
-				dispatch_resume(fd_entry->barrier_queue);
-			});
-		} else {
-			if (orig_flags != -1) {
-				_dispatch_io_syscall_switch(err,
-					fcntl(fd, F_SETFL, orig_flags | O_NONBLOCK),
-					default:
-						orig_flags = -1;
-						(void)dispatch_assume_zero(err);
-						break;
-				);
-			}
-
-			_dispatch_stream_init(fd_entry,
-					_dispatch_get_default_queue(false));
-		}
-		fd_entry->orig_flags = orig_flags;
-		fd_entry->orig_nosigpipe = orig_nosigpipe;
-#endif
-	});
-	// This is the first item run when the close queue is resumed, indicating
-	// that all channels associated with this entry have been closed and that
-	// all operations associated with this entry have been freed
-	dispatch_async(fd_entry->close_queue, ^{
-		if (!fd_entry->disk) {
-			_dispatch_fd_entry_debug("close queue cleanup", fd_entry);
-			dispatch_op_direction_t dir;
-			for (dir = 0; dir < DOP_DIR_MAX; dir++) {
-				_dispatch_stream_dispose(fd_entry, dir);
-			}
-		} else {
-			dispatch_disk_t disk = fd_entry->disk;
-			dispatch_async(_dispatch_io_devs_lockq, ^{
-				_dispatch_release(disk);
-			});
-		}
-		// Remove this entry from the global fd list
-		LIST_REMOVE(fd_entry, fd_list);
-	});
-	// If there was a source associated with this stream, disposing of the
-	// source cancels it and suspends the close queue. Freeing the fd_entry
-	// structure must happen after the source cancel handler has finished
-	dispatch_async(fd_entry->close_queue, ^{
-		_dispatch_fd_entry_debug("close queue release", fd_entry);
-		dispatch_release(fd_entry->close_queue);
-		_dispatch_fd_entry_debug("barrier queue release", fd_entry);
-		dispatch_release(fd_entry->barrier_queue);
-		_dispatch_fd_entry_debug("barrier group release", fd_entry);
-		dispatch_release(fd_entry->barrier_group);
-#if !defined(_WIN32)
-		if (fd_entry->orig_flags != -1) {
-			_dispatch_io_syscall(
-				fcntl(fd, F_SETFL, fd_entry->orig_flags)
-			);
-		}
-#if DISPATCH_USE_SETNOSIGPIPE // rdar://problem/4121123
-		if (fd_entry->orig_nosigpipe != -1) {
-			_dispatch_io_syscall(
-				fcntl(fd, F_SETNOSIGPIPE, fd_entry->orig_nosigpipe)
-			);
-		}
-#endif
-#endif
-		_dispatch_fd_entry_unguard(fd_entry);
-		if (fd_entry->convenience_channel) {
-			fd_entry->convenience_channel->fd_entry = NULL;
-			dispatch_release(fd_entry->convenience_channel);
-		}
-		free(fd_entry);
-	});
-	return fd_entry;
-}
-
-static dispatch_fd_entry_t
-_dispatch_fd_entry_create_with_path(dispatch_io_path_data_t path_data,
-		dev_t dev, mode_t mode)
-{
-	// On devs lock queue
-	dispatch_fd_entry_t fd_entry = _dispatch_fd_entry_create(
-			path_data->channel->queue);
-	_dispatch_fd_entry_debug("create: path %s", fd_entry, path_data->path);
-	if (S_ISREG(mode)) {
-#if defined(_WIN32)
-		_dispatch_disk_init(fd_entry, 0);
-#else
-		_dispatch_disk_init(fd_entry, (dev_t)major(dev));
-#endif
-	} else {
-			_dispatch_stream_init(fd_entry,
-					_dispatch_get_default_queue(false));
-	}
-	fd_entry->fd = -1;
-	fd_entry->orig_flags = -1;
-	fd_entry->path_data = path_data;
-	fd_entry->stat.dev = dev;
-	fd_entry->stat.mode = mode;
-	fd_entry->barrier_queue = dispatch_queue_create(
-			"com.apple.libdispatch-io.barrierq", NULL);
-	fd_entry->barrier_group = dispatch_group_create();
-	// This is the first item run when the close queue is resumed, indicating
-	// that the channel associated with this entry has been closed and that
-	// all operations associated with this entry have been freed
-	dispatch_async(fd_entry->close_queue, ^{
-		_dispatch_fd_entry_debug("close queue cleanup", fd_entry);
-		if (!fd_entry->disk) {
-			dispatch_op_direction_t dir;
-			for (dir = 0; dir < DOP_DIR_MAX; dir++) {
-				_dispatch_stream_dispose(fd_entry, dir);
-			}
-		}
-		if (fd_entry->fd != -1) {
-			_dispatch_fd_entry_guarded_close(fd_entry, fd_entry->fd);
-		}
-		if (fd_entry->path_data->channel) {
-			// If associated channel has not been released yet, mark it as
-			// no longer having an fd_entry (for stop after close).
-			// It is safe to modify channel since we are on close_queue with
-			// target queue the channel queue
-			fd_entry->path_data->channel->fd_entry = NULL;
-		}
-	});
-	dispatch_async(fd_entry->close_queue, ^{
-		_dispatch_fd_entry_debug("close queue release", fd_entry);
-		dispatch_release(fd_entry->close_queue);
-		dispatch_release(fd_entry->barrier_queue);
-		dispatch_release(fd_entry->barrier_group);
-		free(fd_entry->path_data);
-		free(fd_entry);
-	});
-	return fd_entry;
-}
-
-static int
-_dispatch_fd_entry_open(dispatch_fd_entry_t fd_entry, dispatch_io_t channel)
-{
-	if (!(fd_entry->fd == -1 && fd_entry->path_data)) {
-		return 0;
-	}
-	if (fd_entry->err) {
-		return fd_entry->err;
-	}
-	dispatch_fd_t fd = -1;
-	int oflag = fd_entry->disk ? fd_entry->path_data->oflag & ~O_NONBLOCK :
-			fd_entry->path_data->oflag | O_NONBLOCK;
-open:
-	fd = _dispatch_fd_entry_guarded_open(fd_entry, fd_entry->path_data->path,
-			oflag, fd_entry->path_data->mode);
-	if (fd == -1) {
-		int err = errno;
-		if (err == EINTR) {
-			goto open;
-		}
-		(void)os_atomic_cmpxchg2o(fd_entry, err, 0, err, relaxed);
-		return err;
-	}
-	if (!os_atomic_cmpxchg2o(fd_entry, fd, -1, fd, relaxed)) {
-		// Lost the race with another open
-		_dispatch_fd_entry_guarded_close(fd_entry, fd);
-	} else {
-		channel->fd_actual = fd;
-	}
-	_dispatch_object_debug(channel, "%s", __func__);
-	return 0;
-}
-
-static void
-_dispatch_fd_entry_cleanup_operations(dispatch_fd_entry_t fd_entry,
-		dispatch_io_t channel)
-{
-	if (fd_entry->disk) {
-		if (channel) {
-			_dispatch_retain(channel);
-		}
-		_dispatch_fd_entry_retain(fd_entry);
-		dispatch_async(fd_entry->disk->pick_queue, ^{
-			_dispatch_disk_cleanup_inactive_operations(fd_entry->disk, channel);
-			_dispatch_fd_entry_release(fd_entry);
-			if (channel) {
-				_dispatch_release(channel);
-			}
-		});
-	} else {
-		dispatch_op_direction_t direction;
-		for (direction = 0; direction < DOP_DIR_MAX; direction++) {
-			dispatch_stream_t stream = fd_entry->streams[direction];
-			if (!stream) {
-				continue;
-			}
-			if (channel) {
-				_dispatch_retain(channel);
-			}
-			_dispatch_fd_entry_retain(fd_entry);
-			dispatch_async(stream->dq, ^{
-				_dispatch_stream_cleanup_operations(stream, channel);
-				_dispatch_fd_entry_release(fd_entry);
-				if (channel) {
-					_dispatch_release(channel);
-				}
-			});
-		}
-	}
-}
-
-#pragma mark -
-#pragma mark dispatch_stream_t/dispatch_disk_t
-
-static void
-_dispatch_stream_init(dispatch_fd_entry_t fd_entry, dispatch_queue_t tq)
-{
-	dispatch_op_direction_t direction;
-	for (direction = 0; direction < DOP_DIR_MAX; direction++) {
-		dispatch_stream_t stream;
-		stream = _dispatch_calloc(1ul, sizeof(struct dispatch_stream_s));
-		stream->dq = dispatch_queue_create_with_target(
-				"com.apple.libdispatch-io.streamq", NULL, tq);
-		dispatch_set_context(stream->dq, stream);
-		TAILQ_INIT(&stream->operations[DISPATCH_IO_RANDOM]);
-		TAILQ_INIT(&stream->operations[DISPATCH_IO_STREAM]);
-		fd_entry->streams[direction] = stream;
-	}
-}
-
-static void
-_dispatch_stream_dispose(dispatch_fd_entry_t fd_entry,
-		dispatch_op_direction_t direction)
-{
-	// On close queue
-	dispatch_stream_t stream = fd_entry->streams[direction];
-	if (!stream) {
-		return;
-	}
-	dispatch_assert(TAILQ_EMPTY(&stream->operations[DISPATCH_IO_STREAM]));
-	dispatch_assert(TAILQ_EMPTY(&stream->operations[DISPATCH_IO_RANDOM]));
-	if (stream->source) {
-		// Balanced by source cancel handler:
-		_dispatch_fd_entry_retain(fd_entry);
-		dispatch_source_cancel(stream->source);
-		dispatch_resume(stream->source);
-		dispatch_release(stream->source);
-	}
-	dispatch_set_context(stream->dq, NULL);
-	dispatch_release(stream->dq);
-	free(stream);
-}
-
-static void
-_dispatch_disk_init(dispatch_fd_entry_t fd_entry, dev_t dev)
-{
-	// On devs lock queue
-	dispatch_disk_t disk;
-	// Check to see if there is an existing entry for the given device
-	uintptr_t hash = DIO_HASH(dev);
-	LIST_FOREACH(disk, &_dispatch_io_devs[hash], disk_list) {
-		if (disk->dev == dev) {
-			_dispatch_retain(disk);
-			goto out;
-		}
-	}
-	// Otherwise create a new entry
-	size_t pending_reqs_depth = dispatch_io_defaults.max_pending_io_reqs;
-	disk = _dispatch_object_alloc(DISPATCH_VTABLE(disk),
-			sizeof(struct dispatch_disk_s) +
-			(pending_reqs_depth * sizeof(dispatch_operation_t)));
-	disk->do_next = DISPATCH_OBJECT_LISTLESS;
-	disk->do_xref_cnt = -1;
-	disk->advise_list_depth = pending_reqs_depth;
-	disk->do_targetq = _dispatch_get_default_queue(false);
-	disk->dev = dev;
-	TAILQ_INIT(&disk->operations);
-	disk->cur_rq = TAILQ_FIRST(&disk->operations);
-	char label[45];
-	snprintf(label, sizeof(label), "com.apple.libdispatch-io.deviceq.%d",
-			(int)dev);
-	disk->pick_queue = dispatch_queue_create(label, NULL);
-	LIST_INSERT_HEAD(&_dispatch_io_devs[hash], disk, disk_list);
-out:
-	fd_entry->disk = disk;
-	TAILQ_INIT(&fd_entry->stream_ops);
-}
-
-void
-_dispatch_disk_dispose(dispatch_disk_t disk, DISPATCH_UNUSED bool *allow_free)
-{
-	LIST_REMOVE(disk, disk_list);
-	dispatch_assert(TAILQ_EMPTY(&disk->operations));
-	size_t i;
-	for (i = 0; i < disk->advise_list_depth; ++i) {
-		dispatch_assert(!disk->advise_list[i]);
-	}
-	dispatch_release(disk->pick_queue);
-}
-
-#pragma mark -
-#pragma mark dispatch_stream_operations/dispatch_disk_operations
-
-static inline bool
-_dispatch_stream_operation_avail(dispatch_stream_t stream)
-{
-	return  !(TAILQ_EMPTY(&stream->operations[DISPATCH_IO_RANDOM])) ||
-			!(TAILQ_EMPTY(&stream->operations[DISPATCH_IO_STREAM]));
-}
-
-static void
-_dispatch_stream_enqueue_operation(dispatch_stream_t stream,
-		dispatch_operation_t op, dispatch_data_t data)
-{
-	if (!_dispatch_operation_should_enqueue(op, stream->dq, data)) {
-		return;
-	}
-	_dispatch_object_debug(op, "%s", __func__);
-	bool no_ops = !_dispatch_stream_operation_avail(stream);
-	TAILQ_INSERT_TAIL(&stream->operations[op->params.type], op, operation_list);
-	if (no_ops) {
-		dispatch_async_f(stream->dq, stream->dq,
-				_dispatch_stream_queue_handler);
-	}
-}
-
-static void
-_dispatch_disk_enqueue_operation(dispatch_disk_t disk, dispatch_operation_t op,
-		dispatch_data_t data)
-{
-	if (!_dispatch_operation_should_enqueue(op, disk->pick_queue, data)) {
-		return;
-	}
-	_dispatch_object_debug(op, "%s", __func__);
-	if (op->params.type == DISPATCH_IO_STREAM) {
-		if (TAILQ_EMPTY(&op->fd_entry->stream_ops)) {
-			TAILQ_INSERT_TAIL(&disk->operations, op, operation_list);
-		}
-		TAILQ_INSERT_TAIL(&op->fd_entry->stream_ops, op, stream_list);
-	} else {
-		TAILQ_INSERT_TAIL(&disk->operations, op, operation_list);
-	}
-	_dispatch_disk_handler(disk);
-}
-
-static void
-_dispatch_stream_complete_operation(dispatch_stream_t stream,
-		dispatch_operation_t op)
-{
-	// On stream queue
-	_dispatch_object_debug(op, "%s", __func__);
-	_dispatch_op_debug("complete: stream %p", op, stream);
-	TAILQ_REMOVE(&stream->operations[op->params.type], op, operation_list);
-	if (op == stream->op) {
-		stream->op = NULL;
-	}
-	if (op->timer) {
-		dispatch_source_cancel(op->timer);
-	}
-	// Final release will deliver any pending data
-	_dispatch_op_debug("release -> %d (stream complete)", op, op->do_ref_cnt);
-	_dispatch_release(op);
-}
-
-static void
-_dispatch_disk_complete_operation(dispatch_disk_t disk, dispatch_operation_t op)
-{
-	// On pick queue
-	_dispatch_object_debug(op, "%s", __func__);
-	_dispatch_op_debug("complete: disk %p", op, disk);
-	// Current request is always the last op returned
-	if (disk->cur_rq == op) {
-		disk->cur_rq = TAILQ_PREV(op, dispatch_disk_operations_s,
-				operation_list);
-	}
-	if (op->params.type == DISPATCH_IO_STREAM) {
-		// Check if there are other pending stream operations behind it
-		dispatch_operation_t op_next = TAILQ_NEXT(op, stream_list);
-		TAILQ_REMOVE(&op->fd_entry->stream_ops, op, stream_list);
-		if (op_next) {
-			TAILQ_INSERT_TAIL(&disk->operations, op_next, operation_list);
-		}
-	}
-	TAILQ_REMOVE(&disk->operations, op, operation_list);
-	if (op->timer) {
-		dispatch_source_cancel(op->timer);
-	}
-	// Final release will deliver any pending data
-	_dispatch_op_debug("release -> %d (disk complete)", op, op->do_ref_cnt);
-	_dispatch_release(op);
-}
-
-static dispatch_operation_t
-_dispatch_stream_pick_next_operation(dispatch_stream_t stream,
-		dispatch_operation_t op)
-{
-	// On stream queue
-	if (!op) {
-		// On the first run through, pick the first operation
-		if (!_dispatch_stream_operation_avail(stream)) {
-			return op;
-		}
-		if (!TAILQ_EMPTY(&stream->operations[DISPATCH_IO_STREAM])) {
-			op = TAILQ_FIRST(&stream->operations[DISPATCH_IO_STREAM]);
-		} else if (!TAILQ_EMPTY(&stream->operations[DISPATCH_IO_RANDOM])) {
-			op = TAILQ_FIRST(&stream->operations[DISPATCH_IO_RANDOM]);
-		}
-		return op;
-	}
-	if (op->params.type == DISPATCH_IO_STREAM) {
-		// Stream operations need to be serialized so continue the current
-		// operation until it is finished
-		return op;
-	}
-	// Get the next random operation (round-robin)
-	if (op->params.type == DISPATCH_IO_RANDOM) {
-		op = TAILQ_NEXT(op, operation_list);
-		if (!op) {
-			op = TAILQ_FIRST(&stream->operations[DISPATCH_IO_RANDOM]);
-		}
-		return op;
-	}
-	return NULL;
-}
-
-static dispatch_operation_t
-_dispatch_disk_pick_next_operation(dispatch_disk_t disk)
-{
-	// On pick queue
-	dispatch_operation_t op;
-	if (!TAILQ_EMPTY(&disk->operations)) {
-		if (disk->cur_rq == NULL) {
-			op = TAILQ_FIRST(&disk->operations);
-		} else {
-			op = disk->cur_rq;
-			do {
-				op = TAILQ_NEXT(op, operation_list);
-				if (!op) {
-					op = TAILQ_FIRST(&disk->operations);
-				}
-				// TODO: more involved picking algorithm rdar://problem/8780312
-			} while (op->active && op != disk->cur_rq);
-		}
-		if (!op->active) {
-			disk->cur_rq = op;
-			return op;
-		}
-	}
-	return NULL;
-}
-
-static void
-_dispatch_stream_cleanup_operations(dispatch_stream_t stream,
-		dispatch_io_t channel)
-{
-	// On stream queue
-	dispatch_operation_t op, tmp;
-	__typeof__(*stream->operations) *operations;
-	operations = &stream->operations[DISPATCH_IO_RANDOM];
-	TAILQ_FOREACH_SAFE(op, operations, operation_list, tmp) {
-		if (!channel || op->channel == channel) {
-			_dispatch_stream_complete_operation(stream, op);
-		}
-	}
-	operations = &stream->operations[DISPATCH_IO_STREAM];
-	TAILQ_FOREACH_SAFE(op, operations, operation_list, tmp) {
-		if (!channel || op->channel == channel) {
-			_dispatch_stream_complete_operation(stream, op);
-		}
-	}
-	if (stream->source_running && !_dispatch_stream_operation_avail(stream)) {
-		dispatch_suspend(stream->source);
-		stream->source_running = false;
-	}
-}
-
-static inline void
-_dispatch_disk_cleanup_specified_operations(dispatch_disk_t disk,
-		dispatch_io_t channel, bool inactive_only)
-{
-	// On pick queue
-	dispatch_operation_t op, tmp;
-	TAILQ_FOREACH_SAFE(op, &disk->operations, operation_list, tmp) {
-		if (inactive_only && op->active) continue;
-		if (!channel || op->channel == channel) {
-			_dispatch_op_debug("cleanup: disk %p", op, disk);
-			_dispatch_disk_complete_operation(disk, op);
-		}
-	}
-}
-
-static void
-_dispatch_disk_cleanup_operations(dispatch_disk_t disk, dispatch_io_t channel)
-{
-	_dispatch_disk_cleanup_specified_operations(disk, channel, false);
-}
-
-static void
-_dispatch_disk_cleanup_inactive_operations(dispatch_disk_t disk,
-		dispatch_io_t channel)
-{
-	_dispatch_disk_cleanup_specified_operations(disk, channel, true);
-}
-
-#pragma mark -
-#pragma mark dispatch_stream_handler/dispatch_disk_handler
-
-static dispatch_source_t
-_dispatch_stream_source(dispatch_stream_t stream, dispatch_operation_t op)
-{
-	// On stream queue
-	if (stream->source) {
-		return stream->source;
-	}
-	dispatch_fd_t fd = op->fd_entry->fd;
-	_dispatch_op_debug("stream source create", op);
-	dispatch_source_t source = NULL;
-	if (op->direction == DOP_DIR_READ) {
-		source = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ,
-				(uintptr_t)fd, 0, stream->dq);
-	} else if (op->direction == DOP_DIR_WRITE) {
-		source = dispatch_source_create(DISPATCH_SOURCE_TYPE_WRITE,
-				(uintptr_t)fd, 0, stream->dq);
-	} else {
-		dispatch_assert(op->direction < DOP_DIR_MAX);
-		return NULL;
-	}
-	dispatch_set_context(source, stream);
-	dispatch_source_set_event_handler_f(source,
-			_dispatch_stream_source_handler);
-	// Close queue must not run user cleanup handlers until sources are fully
-	// unregistered
-	dispatch_queue_t close_queue = op->fd_entry->close_queue;
-	dispatch_source_set_mandatory_cancel_handler(source, ^{
-		_dispatch_op_debug("stream source cancel", op);
-		dispatch_resume(close_queue);
-	});
-	stream->source = source;
-	return stream->source;
-}
-
-static void
-_dispatch_stream_source_handler(void *ctx)
-{
-	// On stream queue
-	dispatch_stream_t stream = (dispatch_stream_t)ctx;
-	dispatch_suspend(stream->source);
-	stream->source_running = false;
-	return _dispatch_stream_handler(stream);
-}
-
-static void
-_dispatch_stream_queue_handler(void *ctx)
-{
-	// On stream queue
-	dispatch_stream_t stream = (dispatch_stream_t)dispatch_get_context(ctx);
-	if (!stream) {
-		// _dispatch_stream_dispose has been called
-		return;
-	}
-	return _dispatch_stream_handler(stream);
-}
-
-static void
-_dispatch_stream_handler(void *ctx)
-{
-	// On stream queue
-	dispatch_stream_t stream = (dispatch_stream_t)ctx;
-	dispatch_operation_t op;
-pick:
-	op = _dispatch_stream_pick_next_operation(stream, stream->op);
-	if (!op) {
-		_dispatch_debug("no operation found: stream %p", stream);
-		return;
-	}
-	int err = _dispatch_io_get_error(op, NULL, true);
-	if (err) {
-		op->err = err;
-		_dispatch_stream_complete_operation(stream, op);
-		goto pick;
-	}
-	stream->op = op;
-	_dispatch_op_debug("stream handler", op);
-	dispatch_fd_entry_t fd_entry = op->fd_entry;
-	_dispatch_fd_entry_retain(fd_entry);
-	// For performance analysis
-	if (!op->total && dispatch_io_defaults.initial_delivery) {
-		// Empty delivery to signal the start of the operation
-		_dispatch_op_debug("initial delivery", op);
-		_dispatch_operation_deliver_data(op, DOP_DELIVER);
-	}
-	// TODO: perform on the operation target queue to get correct priority
-	int result = _dispatch_operation_perform(op);
-	dispatch_op_flags_t flags = ~0u;
-	switch (result) {
-	case DISPATCH_OP_DELIVER:
-		flags = DOP_DEFAULT;
-		DISPATCH_FALLTHROUGH;
-	case DISPATCH_OP_DELIVER_AND_COMPLETE:
-		flags = (flags != DOP_DEFAULT) ? DOP_DELIVER | DOP_NO_EMPTY :
-				DOP_DEFAULT;
-		_dispatch_operation_deliver_data(op, flags);
-		DISPATCH_FALLTHROUGH;
-	case DISPATCH_OP_COMPLETE:
-		if (flags != DOP_DEFAULT) {
-			_dispatch_stream_complete_operation(stream, op);
-		}
-		if (_dispatch_stream_operation_avail(stream)) {
-			dispatch_async_f(stream->dq, stream->dq,
-					_dispatch_stream_queue_handler);
-		}
-		break;
-	case DISPATCH_OP_COMPLETE_RESUME:
-		_dispatch_stream_complete_operation(stream, op);
-		DISPATCH_FALLTHROUGH;
-	case DISPATCH_OP_RESUME:
-		if (_dispatch_stream_operation_avail(stream)) {
-			stream->source_running = true;
-			dispatch_resume(_dispatch_stream_source(stream, op));
-		}
-		break;
-	case DISPATCH_OP_ERR:
-		_dispatch_stream_cleanup_operations(stream, op->channel);
-		break;
-	case DISPATCH_OP_FD_ERR:
-		_dispatch_fd_entry_retain(fd_entry);
-		dispatch_async(fd_entry->barrier_queue, ^{
-			_dispatch_fd_entry_cleanup_operations(fd_entry, NULL);
-			_dispatch_fd_entry_release(fd_entry);
-		});
-		break;
-	default:
-		break;
-	}
-	_dispatch_fd_entry_release(fd_entry);
-	return;
-}
-
-static void
-_dispatch_disk_handler(void *ctx)
-{
-	// On pick queue
-	dispatch_disk_t disk = (dispatch_disk_t)ctx;
-	if (disk->io_active) {
-		return;
-	}
-	_dispatch_disk_debug("disk handler", disk);
-	dispatch_operation_t op;
-	size_t i = disk->free_idx, j = disk->req_idx;
-	if (j <= i) {
-		j += disk->advise_list_depth;
-	}
-	while (i <= j) {
-		if ((!disk->advise_list[i%disk->advise_list_depth]) &&
-				(op = _dispatch_disk_pick_next_operation(disk))) {
-			int err = _dispatch_io_get_error(op, NULL, true);
-			if (err) {
-				op->err = err;
-				_dispatch_disk_complete_operation(disk, op);
-				continue;
-			}
-			_dispatch_retain(op);
-			_dispatch_op_debug("retain -> %d", op, op->do_ref_cnt + 1);
-			disk->advise_list[i%disk->advise_list_depth] = op;
-			op->active = true;
-			_dispatch_op_debug("activate: disk %p", op, disk);
-			_dispatch_object_debug(op, "%s", __func__);
-		} else {
-			// No more operations to get
-			break;
-		}
-		i++;
-	}
-	disk->free_idx = (i%disk->advise_list_depth);
-	op = disk->advise_list[disk->req_idx];
-	if (op) {
-		disk->io_active = true;
-		_dispatch_op_debug("async perform: disk %p", op, disk);
-		dispatch_async_f(op->do_targetq, disk, _dispatch_disk_perform);
-	}
-}
-
-static void
-_dispatch_disk_perform(void *ctxt)
-{
-	dispatch_disk_t disk = ctxt;
-	_dispatch_disk_debug("disk perform", disk);
-	size_t chunk_size = dispatch_io_defaults.chunk_size;
-	dispatch_operation_t op;
-	size_t i = disk->advise_idx, j = disk->free_idx;
-	if (j <= i) {
-		j += disk->advise_list_depth;
-	}
-	do {
-		op = disk->advise_list[i%disk->advise_list_depth];
-		if (!op) {
-			// Nothing more to advise, must be at free_idx
-			dispatch_assert(i%disk->advise_list_depth == disk->free_idx);
-			break;
-		}
-		if (op->direction == DOP_DIR_WRITE) {
-			// TODO: preallocate writes ? rdar://problem/9032172
-			continue;
-		}
-		if (op->fd_entry->fd == -1 && _dispatch_fd_entry_open(op->fd_entry,
-				op->channel)) {
-			continue;
-		}
-		// For performance analysis
-		if (!op->total && dispatch_io_defaults.initial_delivery) {
-			// Empty delivery to signal the start of the operation
-			_dispatch_op_debug("initial delivery", op);
-			_dispatch_operation_deliver_data(op, DOP_DELIVER);
-		}
-		// Advise two chunks if the list only has one element and this is the
-		// first advise on the operation
-		if ((j-i) == 1 && !disk->advise_list[disk->free_idx] &&
-				!op->advise_offset) {
-			chunk_size *= 2;
-		}
-		_dispatch_operation_advise(op, chunk_size);
-	} while (++i < j);
-	disk->advise_idx = i%disk->advise_list_depth;
-	op = disk->advise_list[disk->req_idx];
-	int result = _dispatch_operation_perform(op);
-	disk->advise_list[disk->req_idx] = NULL;
-	disk->req_idx = (disk->req_idx + 1) % disk->advise_list_depth;
-	_dispatch_op_debug("async perform completion: disk %p", op, disk);
-	dispatch_async(disk->pick_queue, ^{
-		_dispatch_op_debug("perform completion", op);
-		switch (result) {
-		case DISPATCH_OP_DELIVER:
-			_dispatch_operation_deliver_data(op, DOP_DEFAULT);
-			break;
-		case DISPATCH_OP_COMPLETE:
-			_dispatch_disk_complete_operation(disk, op);
-			break;
-		case DISPATCH_OP_DELIVER_AND_COMPLETE:
-			_dispatch_operation_deliver_data(op, DOP_DELIVER | DOP_NO_EMPTY);
-			_dispatch_disk_complete_operation(disk, op);
-			break;
-		case DISPATCH_OP_ERR:
-			_dispatch_disk_cleanup_operations(disk, op->channel);
-			break;
-		case DISPATCH_OP_FD_ERR:
-			_dispatch_disk_cleanup_operations(disk, NULL);
-			break;
-		default:
-			dispatch_assert(result);
-			break;
-		}
-		_dispatch_op_debug("deactivate: disk %p", op, disk);
-		op->active = false;
-		disk->io_active = false;
-		_dispatch_disk_handler(disk);
-		// Balancing the retain in _dispatch_disk_handler. Note that op must be
-		// released at the very end, since it might hold the last reference to
-		// the disk
-		_dispatch_op_debug("release -> %d (disk perform complete)", op,
-				op->do_ref_cnt);
-		_dispatch_release(op);
-	});
-}
-
-#pragma mark -
-#pragma mark dispatch_operation_perform
-
-static void
-_dispatch_operation_advise(dispatch_operation_t op, size_t chunk_size)
-{
-	_dispatch_op_debug("advise", op);
-#if defined(_WIN32)
-	(void)op;
-	(void)chunk_size;
-#else
-	if (_dispatch_io_get_error(op, NULL, true)) return;
-#if !defined(F_RDADVISE)
-	// Compatibility struct whose values may be passed to posix_fadvise()
-	struct radvisory {
-		off_t ra_offset;
-		int   ra_count;
-	};
-#endif
-	int err;
-	struct radvisory advise;
-	// No point in issuing a read advise for the next chunk if we are already
-	// a chunk ahead from reading the bytes
-	if (op->advise_offset > (off_t)(((size_t)op->offset + op->total) +
-			chunk_size + PAGE_SIZE)) {
-		return;
-	}
-	_dispatch_object_debug(op, "%s", __func__);
-	advise.ra_count = (int)chunk_size;
-	if (!op->advise_offset) {
-		op->advise_offset = op->offset;
-		// If this is the first time through, align the advised range to a
-		// page boundary
-		size_t pg_fraction = ((size_t)op->offset + chunk_size) % PAGE_SIZE;
-		advise.ra_count += (int)(pg_fraction ? PAGE_SIZE - pg_fraction : 0);
-	}
-	advise.ra_offset = op->advise_offset;
-	op->advise_offset += advise.ra_count;
-#if defined(F_RDADVISE)
-	_dispatch_io_syscall_switch(err,
-		fcntl(op->fd_entry->fd, F_RDADVISE, &advise),
-		case EFBIG: break; // advised past the end of the file rdar://10415691
-		case ENOTSUP: break; // not all FS support radvise rdar://13484629
-		// TODO: set disk status on error
-		default: (void)dispatch_assume_zero(err); break;
-	);
-#elif defined(HAVE_POSIX_FADVISE)
-	err = posix_fadvise(op->fd_entry->fd, advise.ra_offset,
-			(off_t)advise.ra_count, POSIX_FADV_WILLNEED);
-	switch (err) {
-		case 0: break;
-		case EINVAL: break; // unsupported advice or file type
-		case ESPIPE: break; // fd refers to a pipe or FIFO
-		default: (void)dispatch_assume_zero(err); break;
-	}
-#else
-#error "_dispatch_operation_advise not implemented on this platform"
-#endif // defined(F_RDADVISE)
-#endif // defined(_WIN32)
-}
-
-static int
-_dispatch_operation_perform(dispatch_operation_t op)
-{
-	_dispatch_op_debug("perform", op);
-	int err = _dispatch_io_get_error(op, NULL, true);
-	if (err) {
-		goto error;
-	}
-	_dispatch_object_debug(op, "%s", __func__);
-	if (!op->buf) {
-		size_t max_buf_siz = op->params.high;
-		size_t chunk_siz = dispatch_io_defaults.chunk_size;
-		if (op->direction == DOP_DIR_READ) {
-			// If necessary, create a buffer for the ongoing operation, large
-			// enough to fit chunk_size but at most high-water
-			size_t data_siz = dispatch_data_get_size(op->data);
-			if (data_siz) {
-				dispatch_assert(data_siz < max_buf_siz);
-				max_buf_siz -= data_siz;
-			}
-			if (max_buf_siz > chunk_siz) {
-				max_buf_siz = chunk_siz;
-			}
-			if (op->length < SIZE_MAX) {
-				op->buf_siz = op->length - op->total;
-				if (op->buf_siz > max_buf_siz) {
-					op->buf_siz = max_buf_siz;
-				}
-			} else {
-				op->buf_siz = max_buf_siz;
-			}
-#if defined(_WIN32)
-			static bool bQueried = false;
-			static SYSTEM_INFO siInfo;
-			if (!bQueried) {
-				GetNativeSystemInfo(&siInfo);
-				bQueried = true;
-			}
-			op->buf = _aligned_malloc(op->buf_siz, siInfo.dwPageSize);
-#else
-			err = posix_memalign(&op->buf, (size_t)PAGE_SIZE, op->buf_siz);
-			if (err != 0) {
-				goto error;
-			}
-#endif
-			_dispatch_op_debug("buffer allocated", op);
-		} else if (op->direction == DOP_DIR_WRITE) {
-			// Always write the first data piece, if that is smaller than a
-			// chunk, accumulate further data pieces until chunk size is reached
-			if (chunk_siz > max_buf_siz) {
-				chunk_siz = max_buf_siz;
-			}
-			op->buf_siz = 0;
-			dispatch_data_apply(op->data,
-					^(dispatch_data_t region DISPATCH_UNUSED,
-					size_t offset DISPATCH_UNUSED,
-					const void* buf DISPATCH_UNUSED, size_t len) {
-				size_t siz = op->buf_siz + len;
-				if (!op->buf_siz || siz <= chunk_siz) {
-					op->buf_siz = siz;
-				}
-				return (bool)(siz < chunk_siz);
-			});
-			if (op->buf_siz > max_buf_siz) {
-				op->buf_siz = max_buf_siz;
-			}
-			dispatch_data_t d;
-			d = dispatch_data_create_subrange(op->data, 0, op->buf_siz);
-			op->buf_data = dispatch_data_create_map(d, (const void**)&op->buf,
-					NULL);
-			_dispatch_io_data_release(d);
-			_dispatch_op_debug("buffer mapped", op);
-		}
-	}
-	if (op->fd_entry->fd == -1) {
-		err = _dispatch_fd_entry_open(op->fd_entry, op->channel);
-		if (err) {
-			goto error;
-		}
-	}
-	void *buf = op->buf + op->buf_len;
-	size_t len = op->buf_siz - op->buf_len;
-#if defined(_WIN32)
-	assert(len <= UINT_MAX && "overflow for read/write");
-	LONGLONG off = (LONGLONG)((size_t)op->offset + op->total);
-#else
-	off_t off = (off_t)((size_t)op->offset + op->total);
-#endif
-#if defined(_WIN32)
-	long processed = -1;
-#else
-	ssize_t processed = -1;
-#endif
-syscall:
-	if (op->direction == DOP_DIR_READ) {
-		if (op->params.type == DISPATCH_IO_STREAM) {
-#if defined(_WIN32)
-			HANDLE hFile = (HANDLE)op->fd_entry->fd;
-			BOOL bSuccess;
-			if (_dispatch_handle_is_socket(hFile)) {
-				processed = recv((SOCKET)hFile, buf, len, 0);
-				if (processed < 0) {
-					bSuccess = FALSE;
-					err = WSAGetLastError();
-					if (err == WSAEWOULDBLOCK) {
-						err = EAGAIN;
-					}
-					goto error;
-				}
-				bSuccess = TRUE;
-			} else if (GetFileType(hFile) == FILE_TYPE_PIPE) {
-				OVERLAPPED ovlOverlapped = {};
-				DWORD dwTotalBytesAvail;
-				bSuccess = PeekNamedPipe(hFile, NULL, 0, NULL,
-						&dwTotalBytesAvail, NULL);
-				if (bSuccess) {
-					if (dwTotalBytesAvail == 0) {
-						err = EAGAIN;
-						goto error;
-					}
-					len = MIN(len, dwTotalBytesAvail);
-					bSuccess = ReadFile(hFile, buf, (DWORD)len,
-							(LPDWORD)&processed, &ovlOverlapped);
-				}
-				if (!bSuccess) {
-					DWORD dwError = GetLastError();
-					if (dwError == ERROR_IO_PENDING) {
-						bSuccess = GetOverlappedResult(hFile, &ovlOverlapped,
-								(LPDWORD)&processed, /* bWait */ TRUE);
-						dwError = GetLastError();
-					}
-					if (dwError == ERROR_BROKEN_PIPE ||
-							dwError == ERROR_NO_DATA) {
-						bSuccess = TRUE;
-						processed = 0;
-					}
-				}
-			} else {
-				bSuccess = ReadFile(hFile, buf, (DWORD)len,
-						(LPDWORD)&processed, NULL);
-			}
-			if (!bSuccess) {
-				err = EIO;
-				goto error;
-			}
-#else
-			processed = read(op->fd_entry->fd, buf, len);
-#endif
-		} else if (op->params.type == DISPATCH_IO_RANDOM) {
-#if defined(_WIN32)
-			OVERLAPPED ovlOverlapped = {};
-			ovlOverlapped.Offset = off & 0xffffffff;
-			ovlOverlapped.OffsetHigh = (off >> 32) & 0xffffffff;
-			ReadFile((HANDLE)op->fd_entry->fd, buf, (DWORD)len,
-					(LPDWORD)&processed, &ovlOverlapped);
-#else
-			processed = pread(op->fd_entry->fd, buf, len, off);
-#endif
-		}
-	} else if (op->direction == DOP_DIR_WRITE) {
-		if (op->params.type == DISPATCH_IO_STREAM) {
-#if defined(_WIN32)
-			HANDLE hFile = (HANDLE)op->fd_entry->fd;
-			BOOL bSuccess;
-			if (_dispatch_handle_is_socket(hFile)) {
-				processed = send((SOCKET)hFile, buf, len, 0);
-				if (processed < 0) {
-					bSuccess = FALSE;
-					err = WSAGetLastError();
-					if (err == WSAEWOULDBLOCK) {
-						err = EAGAIN;
-					}
-					goto error;
-				}
-				bSuccess = TRUE;
-			} else if (GetFileType(hFile) == FILE_TYPE_PIPE) {
-				// Unfortunately there isn't a good way to achieve O_NONBLOCK
-				// semantics when writing to a pipe. SetNamedPipeHandleState()
-				// can allow pipes to be switched into a "no wait" mode, but
-				// that doesn't work on most pipe handles because Windows
-				// doesn't consistently create pipes with FILE_WRITE_ATTRIBUTES
-				// access. The best we can do is to try to query the write quota
-				// and then write as much as we can.
-				IO_STATUS_BLOCK iosb;
-				FILE_PIPE_LOCAL_INFORMATION fpli;
-				NTSTATUS status = _dispatch_NtQueryInformationFile(hFile, &iosb,
-						&fpli, sizeof(fpli), FilePipeLocalInformation);
-				if (NT_SUCCESS(status)) {
-					if (fpli.WriteQuotaAvailable == 0) {
-						err = EAGAIN;
-						goto error;
-					}
-					len = MIN(len, fpli.WriteQuotaAvailable);
-				}
-				OVERLAPPED ovlOverlapped = {};
-				bSuccess = WriteFile(hFile, buf, (DWORD)len,
-						(LPDWORD)&processed, &ovlOverlapped);
-				if (!bSuccess) {
-					DWORD dwError = GetLastError();
-					if (dwError == ERROR_IO_PENDING) {
-						bSuccess = GetOverlappedResult(hFile, &ovlOverlapped,
-								(LPDWORD)&processed, /* bWait */ TRUE);
-						dwError = GetLastError();
-					}
-					if (dwError == ERROR_BROKEN_PIPE ||
-							dwError == ERROR_NO_DATA) {
-						bSuccess = TRUE;
-						processed = 0;
-					}
-				}
-			} else {
-				bSuccess = WriteFile(hFile, buf, (DWORD)len,
-						(LPDWORD)&processed, NULL);
-			}
-			if (!bSuccess) {
-				err = EIO;
-				goto error;
-			}
-#else
-			processed = write(op->fd_entry->fd, buf, len);
-#endif
-		} else if (op->params.type == DISPATCH_IO_RANDOM) {
-#if defined(_WIN32)
-			OVERLAPPED ovlOverlapped = {};
-			ovlOverlapped.Offset = off & 0xffffffff;
-			ovlOverlapped.OffsetHigh = (off >> 32) & 0xffffffff;
-			WriteFile((HANDLE)op->fd_entry->fd, buf, (DWORD)len,
-					(LPDWORD)&processed, &ovlOverlapped);
-#else
-			processed = pwrite(op->fd_entry->fd, buf, len, off);
-#endif
-		}
-	}
-	// Encountered an error on the file descriptor
-	if (processed == -1) {
-		err = errno;
-		if (err == EINTR) {
-			goto syscall;
-		}
-		goto error;
-	}
-	// EOF is indicated by two handler invocations
-	if (processed == 0) {
-		_dispatch_op_debug("performed: EOF", op);
-		return DISPATCH_OP_DELIVER_AND_COMPLETE;
-	}
-	op->buf_len += (size_t)processed;
-	op->total += (size_t)processed;
-	if (op->total == op->length) {
-		// Finished processing all the bytes requested by the operation
-		return DISPATCH_OP_COMPLETE;
-	} else {
-		// Deliver data only if we satisfy the filters
-		return DISPATCH_OP_DELIVER;
-	}
-error:
-	if (err == EAGAIN || err == EWOULDBLOCK) {
-		// For disk based files with blocking I/O we should never get EAGAIN
-		dispatch_assert(!op->fd_entry->disk);
-		_dispatch_op_debug("performed: EAGAIN/EWOULDBLOCK", op);
-		if (op->direction == DOP_DIR_READ && op->total &&
-				op->channel == op->fd_entry->convenience_channel) {
-			// Convenience read with available data completes on EAGAIN
-			return DISPATCH_OP_COMPLETE_RESUME;
-		}
-		return DISPATCH_OP_RESUME;
-	}
-	_dispatch_op_debug("performed: err %d", op, err);
-	op->err = err;
-	switch (err) {
-	case ECANCELED:
-		return DISPATCH_OP_ERR;
-	case EBADF:
-		(void)os_atomic_cmpxchg2o(op->fd_entry, err, 0, err, relaxed);
-		return DISPATCH_OP_FD_ERR;
-	default:
-		return DISPATCH_OP_COMPLETE;
-	}
-}
-
-static void
-_dispatch_operation_deliver_data(dispatch_operation_t op,
-		dispatch_op_flags_t flags)
-{
-	// Either called from stream resp. pick queue or when op is finalized
-	dispatch_data_t data = NULL;
-	int err = 0;
-	size_t undelivered = op->undelivered + op->buf_len;
-	bool deliver = (flags & (DOP_DELIVER|DOP_DONE)) ||
-			(op->flags & DOP_DELIVER);
-	op->flags = DOP_DEFAULT;
-	if (!deliver) {
-		// Don't deliver data until low water mark has been reached
-		if (undelivered >= op->params.low) {
-			deliver = true;
-		} else if (op->buf_len < op->buf_siz) {
-			// Request buffer is not yet used up
-			_dispatch_op_debug("buffer data: undelivered %zu", op, undelivered);
-			return;
-		}
-	} else {
-		err = op->err;
-		if (!err && (op->channel->atomic_flags & DIO_STOPPED)) {
-			err = ECANCELED;
-			op->err = err;
-		}
-	}
-	// Deliver data or buffer used up
-	if (op->direction == DOP_DIR_READ) {
-		if (op->buf_len) {
-			void *buf = op->buf;
-#if defined(_WIN32)
-			// buf is allocated with _aligned_malloc()
-			data = dispatch_data_create(buf, op->buf_len, NULL,
-					^{ _aligned_free(buf); });
-#else
-			data = dispatch_data_create(buf, op->buf_len, NULL,
-					DISPATCH_DATA_DESTRUCTOR_FREE);
-#endif
-			op->buf = NULL;
-			op->buf_len = 0;
-			dispatch_data_t d = dispatch_data_create_concat(op->data, data);
-			_dispatch_io_data_release(op->data);
-			_dispatch_io_data_release(data);
-			data = d;
-		} else {
-			data = op->data;
-		}
-		op->data = deliver ? dispatch_data_empty : data;
-	} else if (op->direction == DOP_DIR_WRITE) {
-		if (deliver) {
-			data = dispatch_data_create_subrange(op->data, op->buf_len,
-					op->length);
-		}
-		if (op->buf_data && op->buf_len == op->buf_siz) {
-			_dispatch_io_data_release(op->buf_data);
-			op->buf_data = NULL;
-			op->buf = NULL;
-			op->buf_len = 0;
-			// Trim newly written buffer from head of unwritten data
-			dispatch_data_t d;
-			if (deliver) {
-				_dispatch_io_data_retain(data);
-				d = data;
-			} else {
-				d = dispatch_data_create_subrange(op->data, op->buf_siz,
-						op->length);
-			}
-			_dispatch_io_data_release(op->data);
-			op->data = d;
-		}
-	} else {
-		dispatch_assert(op->direction < DOP_DIR_MAX);
-		return;
-	}
-	if (!deliver || ((flags & DOP_NO_EMPTY) && !dispatch_data_get_size(data))) {
-		op->undelivered = undelivered;
-		_dispatch_op_debug("buffer data: undelivered %zu", op, undelivered);
-		return;
-	}
-	op->undelivered = 0;
-	_dispatch_object_debug(op, "%s", __func__);
-	_dispatch_op_debug("deliver data", op);
-	dispatch_op_direction_t direction = op->direction;
-	dispatch_io_handler_t handler = op->handler;
-	dispatch_fd_entry_t fd_entry = op->fd_entry;
-	_dispatch_fd_entry_retain(fd_entry);
-	dispatch_io_t channel = op->channel;
-	_dispatch_retain(channel);
-	// Note that data delivery may occur after the operation is freed
-	dispatch_async(op->op_q, ^{
-		bool done = (flags & DOP_DONE);
-		dispatch_data_t d = data;
-		if (done) {
-			if (direction == DOP_DIR_READ && err) {
-				if (dispatch_data_get_size(d)) {
-					_dispatch_op_debug("IO handler invoke", op);
-					handler(false, d, 0);
-				}
-				d = NULL;
-			} else if (direction == DOP_DIR_WRITE && !err) {
-				d = NULL;
-			}
-		}
-		_dispatch_op_debug("IO handler invoke: err %d", op, err);
-		handler(done, d, err);
-		_dispatch_release(channel);
-		_dispatch_fd_entry_release(fd_entry);
-		_dispatch_io_data_release(data);
-	});
-}
-
-#pragma mark -
-#pragma mark dispatch_io_debug
-
-DISPATCH_COLD
-static size_t
-_dispatch_io_debug_attr(dispatch_io_t channel, char* buf, size_t bufsiz)
-{
-	dispatch_queue_t target = channel->do_targetq;
-	return dsnprintf(buf, bufsiz, "type = %s, fd = 0x%" PRIxPTR ", %sfd_entry = %p, "
-			"queue = %p, target = %s[%p], barrier_queue = %p, barrier_group = "
-			"%p, err = 0x%x, low = 0x%zx, high = 0x%zx, interval%s = %llu ",
-			channel->params.type == DISPATCH_IO_STREAM ? "stream" : "random",
-			(intptr_t)channel->fd_actual, channel->atomic_flags & DIO_STOPPED ?
-			"stopped, " : channel->atomic_flags & DIO_CLOSED ? "closed, " : "",
-			channel->fd_entry, channel->queue, target && target->dq_label ?
-			target->dq_label : "", target, channel->barrier_queue,
-			channel->barrier_group, channel->err, channel->params.low,
-			channel->params.high, channel->params.interval_flags &
-			DISPATCH_IO_STRICT_INTERVAL ? "(strict)" : "",
-			(unsigned long long) channel->params.interval);
-}
-
-size_t
-_dispatch_io_debug(dispatch_io_t channel, char* buf, size_t bufsiz)
-{
-	size_t offset = 0;
-	offset += dsnprintf(&buf[offset], bufsiz - offset, "%s[%p] = { ",
-			_dispatch_object_class_name(channel), channel);
-	offset += _dispatch_object_debug_attr(channel, &buf[offset],
-			bufsiz - offset);
-	offset += _dispatch_io_debug_attr(channel, &buf[offset], bufsiz - offset);
-	offset += dsnprintf(&buf[offset], bufsiz - offset, "}");
-	return offset;
-}
-
-DISPATCH_COLD
-static size_t
-_dispatch_operation_debug_attr(dispatch_operation_t op, char* buf,
-		size_t bufsiz)
-{
-	dispatch_queue_t target = op->do_targetq;
-	dispatch_queue_t oqtarget = op->op_q ? op->op_q->do_targetq : NULL;
-	return dsnprintf(buf, bufsiz, "type = %s %s, fd = 0x%" PRIxPTR ", fd_entry = %p, "
-			"channel = %p, queue = %p -> %s[%p], target = %s[%p], "
-			"offset = %lld, length = %zu, done = %zu, undelivered = %zu, "
-			"flags = %u, err = 0x%x, low = 0x%zx, high = 0x%zx, "
-			"interval%s = %llu ", op->params.type == DISPATCH_IO_STREAM ?
-			"stream" : "random", op->direction == DOP_DIR_READ ? "read" :
-			"write", (intptr_t)(op->fd_entry ? op->fd_entry->fd : -1), op->fd_entry,
-			op->channel, op->op_q, oqtarget && oqtarget->dq_label ?
-			oqtarget->dq_label : "", oqtarget, target && target->dq_label ?
-			target->dq_label : "", target, (long long)op->offset, op->length,
-			op->total, op->undelivered + op->buf_len, op->flags, op->err,
-			op->params.low, op->params.high, op->params.interval_flags &
-			DISPATCH_IO_STRICT_INTERVAL ? "(strict)" : "",
-			(unsigned long long)op->params.interval);
-}
-
-size_t
-_dispatch_operation_debug(dispatch_operation_t op, char* buf, size_t bufsiz)
-{
-	size_t offset = 0;
-	offset += dsnprintf(&buf[offset], bufsiz - offset, "%s[%p] = { ",
-			_dispatch_object_class_name(op), op);
-	offset += _dispatch_object_debug_attr(op, &buf[offset], bufsiz - offset);
-	offset += _dispatch_operation_debug_attr(op, &buf[offset], bufsiz - offset);
-	offset += dsnprintf(&buf[offset], bufsiz - offset, "}");
-	return offset;
-}
--- a/Telegram/ThirdParty/dispatch/src/io_internal.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/io_internal.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,198 +0,0 @@
-/*
- * Copyright (c) 2009-2013 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-/*
- * IMPORTANT: This header file describes INTERNAL interfaces to libdispatch
- * which are subject to change in future releases of Mac OS X. Any applications
- * relying on these interfaces WILL break.
- */
-
-#ifndef __DISPATCH_IO_INTERNAL__
-#define __DISPATCH_IO_INTERNAL__
-
-#ifndef __DISPATCH_INDIRECT__
-#error "Please #include <dispatch/dispatch.h> instead of this file directly."
-#include <dispatch/base.h> // for HeaderDoc
-#endif
-
-#define _DISPATCH_IO_LABEL_SIZE 16
-
-#if TARGET_OS_IPHONE // rdar://problem/9032036
-#define DIO_MAX_CHUNK_SIZE				(512u * 1024)
-#define DIO_HASH_SIZE					64u  // must be a power of two
-#else
-#define DIO_MAX_CHUNK_SIZE				(1024u * 1024)
-#define DIO_HASH_SIZE					256u // must be a power of two
-#endif
-
-#define DIO_HASH(x) ((uintptr_t)(x) & (DIO_HASH_SIZE - 1))
-
-#define DIO_DEFAULT_LOW_WATER_CHUNKS	  1u // default low-water mark
-#define DIO_MAX_PENDING_IO_REQS			  6u // Pending I/O read advises
-
-typedef unsigned int dispatch_op_direction_t;
-enum {
-	DOP_DIR_READ = 0,
-	DOP_DIR_WRITE,
-	DOP_DIR_MAX,
-	DOP_DIR_IGNORE = UINT_MAX,
-};
-
-typedef unsigned int dispatch_op_flags_t;
-#define DOP_DEFAULT		0u // check conditions to determine delivery
-#define DOP_DELIVER		1u // always deliver operation
-#define DOP_DONE		2u // operation is done (implies deliver)
-#define DOP_STOP		4u // operation interrupted by chan stop (implies done)
-#define DOP_NO_EMPTY	8u // don't deliver empty data
-
-// dispatch_io_t atomic_flags
-#define DIO_CLOSED		1u // channel has been closed
-#define DIO_STOPPED		2u // channel has been stopped (implies closed)
-
-DISPATCH_INTERNAL_CLASS_DECL(operation, OBJECT);
-DISPATCH_INTERNAL_CLASS_DECL(disk, OBJECT);
-
-struct dispatch_stream_s {
-	dispatch_queue_t dq;
-	dispatch_source_t source;
-	dispatch_operation_t op;
-	bool source_running;
-	TAILQ_HEAD(, dispatch_operation_s) operations[2];
-};
-
-typedef struct dispatch_stream_s *dispatch_stream_t;
-
-struct dispatch_io_path_data_s {
-	dispatch_io_t channel;
-	int oflag;
-	mode_t mode;
-	size_t pathlen;
-	char path[];
-};
-
-typedef struct dispatch_io_path_data_s *dispatch_io_path_data_t;
-
-struct dispatch_stat_s {
-	dev_t dev;
-	mode_t mode;
-};
-
-struct dispatch_disk_s {
-	DISPATCH_OBJECT_HEADER(disk);
-	TAILQ_HEAD(dispatch_disk_operations_s, dispatch_operation_s) operations;
-	dispatch_operation_t cur_rq;
-	dispatch_queue_t pick_queue;
-
-	size_t free_idx;
-	size_t req_idx;
-	size_t advise_idx;
-	dev_t dev;
-	bool io_active;
-	LIST_ENTRY(dispatch_disk_s) disk_list;
-	size_t advise_list_depth;
-	dispatch_operation_t advise_list[];
-};
-
-struct dispatch_fd_entry_s {
-	dispatch_fd_t fd;
-	dispatch_io_path_data_t path_data;
-	int orig_flags, orig_nosigpipe, err;
-#if DISPATCH_USE_GUARDED_FD_CHANGE_FDGUARD
-	int orig_fd_flags;
-#endif
-#if DISPATCH_USE_GUARDED_FD
-	unsigned int guard_flags;
-#endif
-	struct dispatch_stat_s stat;
-	dispatch_stream_t streams[2];
-	dispatch_disk_t disk;
-	dispatch_queue_t close_queue, barrier_queue;
-	dispatch_group_t barrier_group;
-	dispatch_io_t convenience_channel;
-	TAILQ_HEAD(, dispatch_operation_s) stream_ops;
-	LIST_ENTRY(dispatch_fd_entry_s) fd_list;
-};
-
-typedef struct dispatch_fd_entry_s *dispatch_fd_entry_t;
-
-typedef struct dispatch_io_param_s {
-	dispatch_io_type_t type; // STREAM OR RANDOM
-	size_t low;
-	size_t high;
-	uint64_t interval;
-	unsigned long interval_flags;
-} dispatch_io_param_s;
-
-struct dispatch_operation_s {
-	DISPATCH_OBJECT_HEADER(operation);
-	dispatch_queue_t op_q;
-	dispatch_op_direction_t direction; // READ OR WRITE
-	dispatch_io_param_s params;
-#if defined(_WIN32)
-	LONGLONG offset;
-#else
-	off_t offset;
-#endif
-	size_t length;
-	int err;
-	dispatch_io_handler_t handler;
-	dispatch_io_t channel;
-	dispatch_fd_entry_t fd_entry;
-	dispatch_source_t timer;
-	bool active;
-	off_t advise_offset;
-	void* buf;
-	dispatch_op_flags_t flags;
-	size_t buf_siz, buf_len, undelivered, total;
-	dispatch_data_t buf_data, data;
-	TAILQ_ENTRY(dispatch_operation_s) operation_list;
-	// the request list in the fd_entry stream_ops
-	TAILQ_ENTRY(dispatch_operation_s) stream_list;
-};
-
-DISPATCH_CLASS_DECL(io, OBJECT);
-struct dispatch_io_s {
-	DISPATCH_OBJECT_HEADER(io);
-	dispatch_queue_t queue, barrier_queue;
-	dispatch_group_t barrier_group;
-	dispatch_io_param_s params;
-	dispatch_fd_entry_t fd_entry;
-	unsigned int atomic_flags;
-	dispatch_fd_t fd, fd_actual;
-#if defined(_WIN32)
-	LONGLONG f_ptr;
-#else
-	off_t f_ptr;
-#endif
-	int err; // contains creation errors only
-};
-
-void _dispatch_io_set_target_queue(dispatch_io_t channel, dispatch_queue_t dq);
-DISPATCH_COLD
-size_t _dispatch_io_debug(dispatch_io_t channel, char* buf, size_t bufsiz);
-void _dispatch_io_dispose(dispatch_io_t channel, bool *allow_free);
-DISPATCH_COLD
-size_t _dispatch_operation_debug(dispatch_operation_t op, char* buf,
-		size_t bufsiz);
-void _dispatch_operation_dispose(dispatch_operation_t operation,
-		bool *allow_free);
-void _dispatch_disk_dispose(dispatch_disk_t disk, bool *allow_free);
-
-#endif // __DISPATCH_IO_INTERNAL__
--- a/Telegram/ThirdParty/dispatch/src/libdispatch.codes	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/libdispatch.codes	1970-01-01 00:00:00.000000000 -0000
@@ -1,42 +0,0 @@
-0x2bdc0008	DISPATCH_ARIADNE_dispatch_main
-
-0x2e010004	DISPATCH_VOUCHER_dc_push
-0x2e010008	DISPATCH_VOUCHER_dc_pop
-0x2e01000c	DISPATCH_VOUCHER_dmsg_push
-0x2e010010	DISPATCH_VOUCHER_dmsg_pop
-0x2e010018	DISPATCH_VOUCHER_activity_adopt
-
-0x2e020004	DISPATCH_PERF_non_leaf_retarget
-0x2e020008	DISPATCH_PERF_post_activate_retarget
-0x2e02000c	DISPATCH_PERF_post_activate_mutation
-0x2e020010	DISPATCH_PERF_delayed_registration
-0x2e020014	DISPATCH_PERF_mutable_target
-0x2e020018	DISPATCH_PERF_strict_bg_timer
-0x2e02001c	DISPATCH_PERF_suspended_timer_fire
-0x2e020020	DISPATCH_PERF_handlerless_source_fire
-0x2e020024	DISPATCH_PERF_source_registration_without_qos
-
-0x2e030004	DISPATCH_MACH_MSG_hdr_move
-
-0x2e040004	DISPATCH_PERF_MON_worker_thread
-0x2e040008	DISPATCH_PERF_MON_worker_useless
-
-0x2e050004	DISPATCH_QOS_TRACE_queue_creation
-0x2e050008	DISPATCH_QOS_TRACE_queue_dispose
-0x2e05000c	DISPATCH_QOS_TRACE_block_creation
-0x2e050010	DISPATCH_QOS_TRACE_block_dispose
-0x2e050014	DISPATCH_QOS_TRACE_cont_push_eb
-0x2e050018	DISPATCH_QOS_TRACE_cont_push_ab
-0x2e05001c	DISPATCH_QOS_TRACE_cont_push_f
-0x2e050020	DISPATCH_QOS_TRACE_source_push
-0x2e050024	DISPATCH_QOS_TRACE_cont_pop
-0x2e050028	DISPATCH_QOS_TRACE_source_pop
-0x2e05002c	DISPATCH_QOS_TRACE_queue_item_done
-0x2e050030	DISPATCH_QOS_TRACE_source_callout
-0x2e050034	DISPATCH_QOS_TRACE_source_dispose
-
-0x2e060004	DISPATCH_FIREHOSE_TRACE_reserver_gave_up
-0x2e060008	DISPATCH_FIREHOSE_TRACE_reserver_wait
-0x2e06000c	DISPATCH_FIREHOSE_TRACE_allocator
-0x2e060010	DISPATCH_FIREHOSE_TRACE_wait_for_logd
-0x2e060014	DISPATCH_FIREHOSE_TRACE_chunk_install
--- a/Telegram/ThirdParty/dispatch/src/mach.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/mach.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,3250 +0,0 @@
-/*
- * Copyright (c) 2008-2016 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include "internal.h"
-#if HAVE_MACH
-
-#define DISPATCH_MACH_RETURN_IMMEDIATE_SEND_RESULT 0x1
-#define DISPATCH_MACH_REGISTER_FOR_REPLY 0x2
-#define DISPATCH_MACH_WAIT_FOR_REPLY 0x4
-#define DISPATCH_MACH_OPTIONS_MASK 0xffff
-
-#define DM_SEND_STATUS_SUCCESS 0x1
-#define DM_SEND_STATUS_RETURNING_IMMEDIATE_SEND_RESULT 0x2
-
-#define DM_CHECKIN_CANCELED ((dispatch_mach_msg_t)~0ul)
-
-DISPATCH_ENUM(dispatch_mach_send_invoke_flags, uint32_t,
-	DM_SEND_INVOKE_NONE            = 0x0,
-	DM_SEND_INVOKE_MAKE_DIRTY      = 0x1,
-	DM_SEND_INVOKE_NEEDS_BARRIER   = 0x2,
-	DM_SEND_INVOKE_CAN_RUN_BARRIER = 0x4,
-	DM_SEND_INVOKE_IMMEDIATE_SEND  = 0x8,
-);
-#define DM_SEND_INVOKE_IMMEDIATE_SEND_MASK \
-		((dispatch_mach_send_invoke_flags_t)DM_SEND_INVOKE_IMMEDIATE_SEND)
-
-static inline mach_msg_option_t _dispatch_mach_checkin_options(void);
-static mach_port_t _dispatch_mach_msg_get_remote_port(dispatch_object_t dou);
-static mach_port_t _dispatch_mach_msg_get_reply_port(dispatch_object_t dou);
-static void _dispatch_mach_msg_disconnected(dispatch_mach_t dm,
-		mach_port_t local_port, mach_port_t remote_port);
-static inline void _dispatch_mach_msg_reply_received(dispatch_mach_t dm,
-		dispatch_mach_reply_wait_refs_t dwr, mach_port_t local_port);
-static dispatch_mach_msg_t _dispatch_mach_msg_create_reply_disconnected(
-		dispatch_object_t dou, dispatch_mach_reply_refs_t dmr,
-		dispatch_mach_reason_t reason);
-static bool _dispatch_mach_reconnect_invoke(dispatch_mach_t dm,
-		dispatch_object_t dou);
-static inline mach_msg_header_t* _dispatch_mach_msg_get_msg(
-		dispatch_mach_msg_t dmsg);
-static void _dispatch_mach_send_push(dispatch_mach_t dm, dispatch_object_t dou,
-		dispatch_qos_t qos);
-static void _dispatch_mach_push_send_barrier_drain(dispatch_mach_t dm,
-		dispatch_qos_t qos);
-static void _dispatch_mach_handle_or_push_received_msg(dispatch_mach_t dm,
-		dispatch_mach_msg_t dmsg, pthread_priority_t pp);
-static void _dispatch_mach_push_async_reply_msg(dispatch_mach_t dm,
-		dispatch_mach_msg_t dmsg, dispatch_queue_t drq);
-static dispatch_queue_t _dispatch_mach_msg_context_async_reply_queue(
-		void *ctxt);
-static dispatch_continuation_t _dispatch_mach_msg_async_reply_wrap(
-		dispatch_mach_msg_t dmsg, dispatch_mach_t dm);
-static void _dispatch_mach_notification_kevent_unregister(dispatch_mach_t dm);
-static void _dispatch_mach_notification_kevent_register(dispatch_mach_t dm,
-		mach_port_t send);
-
-// For tests only.
-DISPATCH_EXPORT void _dispatch_mach_hooks_install_default(void);
-
-#pragma mark -
-#pragma mark dispatch to XPC callbacks
-
-void
-dispatch_mach_hooks_install_4libxpc(dispatch_mach_xpc_hooks_t hooks)
-{
-	if (hooks->version < DISPATCH_MACH_XPC_MIN_HOOKS_VERSION) {
-		DISPATCH_CLIENT_CRASH(hooks,
-				"trying to install hooks with unsupported version");
-	}
-	if (!os_atomic_cmpxchg(&_dispatch_mach_xpc_hooks,
-			&_dispatch_mach_xpc_hooks_default, hooks, relaxed)) {
-		DISPATCH_CLIENT_CRASH(_dispatch_mach_xpc_hooks,
-				"dispatch_mach_hooks_install_4libxpc called twice");
-	}
-}
-
-void
-_dispatch_mach_hooks_install_default(void)
-{
-	os_atomic_store(&_dispatch_mach_xpc_hooks,
-			&_dispatch_mach_xpc_hooks_default, relaxed);
-}
-
-#pragma mark -
-#pragma mark dispatch_mach_t
-
-static dispatch_mach_t
-_dispatch_mach_create(const char *label, dispatch_queue_t q, void *context,
-		dispatch_mach_handler_function_t handler, bool handler_is_block,
-		bool is_xpc)
-{
-	dispatch_mach_recv_refs_t dmrr;
-	dispatch_mach_send_refs_t dmsr;
-	dispatch_mach_t dm;
-
-	dm = _dispatch_queue_alloc(mach, DQF_MUTABLE, 1,
-			DISPATCH_QUEUE_INACTIVE | DISPATCH_QUEUE_ROLE_INNER)._dm;
-	dm->dq_label = label;
-	dm->dm_is_xpc = is_xpc;
-
-	dmrr = dux_create(&_dispatch_mach_type_recv, 0, 0)._dmrr;
-	dispatch_assert(dmrr->du_is_direct);
-	dmrr->du_owner_wref = _dispatch_ptr2wref(dm);
-	dmrr->dmrr_handler_func = handler;
-	dmrr->dmrr_handler_ctxt = context;
-	dmrr->dmrr_handler_is_block = handler_is_block;
-	dm->dm_recv_refs = dmrr;
-
-	dmsr = dux_create(&_dispatch_mach_type_send, 0,
-			DISPATCH_MACH_SEND_POSSIBLE|DISPATCH_MACH_SEND_DEAD)._dmsr;
-	dmsr->du_owner_wref = _dispatch_ptr2wref(dm);
-	dm->dm_send_refs = dmsr;
-
-	if (unlikely(!q)) {
-		q = _dispatch_get_default_queue(true);
-	} else {
-		_dispatch_retain(q);
-	}
-	dm->do_targetq = q;
-	_dispatch_object_debug(dm, "%s", __func__);
-	return dm;
-}
-
-dispatch_mach_t
-dispatch_mach_create(const char *label, dispatch_queue_t q,
-		dispatch_mach_handler_t handler)
-{
-	dispatch_block_t bb = _dispatch_Block_copy((void*)handler);
-	return _dispatch_mach_create(label, q, bb,
-			(dispatch_mach_handler_function_t)_dispatch_Block_invoke(bb), true,
-			false);
-}
-
-dispatch_mach_t
-dispatch_mach_create_f(const char *label, dispatch_queue_t q, void *context,
-		dispatch_mach_handler_function_t handler)
-{
-	return _dispatch_mach_create(label, q, context, handler, false, false);
-}
-
-dispatch_mach_t
-dispatch_mach_create_4libxpc(const char *label, dispatch_queue_t q,
-		void *context, dispatch_mach_handler_function_t handler)
-{
-	return _dispatch_mach_create(label, q, context, handler, false, true);
-}
-
-void
-_dispatch_mach_dispose(dispatch_mach_t dm, bool *allow_free)
-{
-	_dispatch_object_debug(dm, "%s", __func__);
-	_dispatch_unote_dispose(dm->dm_recv_refs);
-	dm->dm_recv_refs = NULL;
-	_dispatch_unote_dispose(dm->dm_send_refs);
-	dm->dm_send_refs = NULL;
-	if (dm->dm_xpc_term_refs) {
-		_dispatch_unote_dispose(dm->dm_xpc_term_refs);
-		dm->dm_xpc_term_refs = NULL;
-	}
-	_dispatch_lane_class_dispose(dm, allow_free);
-}
-
-void
-dispatch_mach_connect(dispatch_mach_t dm, mach_port_t receive,
-		mach_port_t send, dispatch_mach_msg_t checkin)
-{
-	dispatch_mach_send_refs_t dmsr = dm->dm_send_refs;
-
-	if (MACH_PORT_VALID(receive)) {
-		dm->dm_recv_refs->du_ident = receive;
-	}
-	dmsr->dmsr_send = send;
-	if (MACH_PORT_VALID(send)) {
-		if (checkin) {
-			dispatch_mach_msg_t dmsg = checkin;
-			dispatch_retain(dmsg);
-			dmsg->dmsg_options = _dispatch_mach_checkin_options();
-			dmsr->dmsr_checkin_port = _dispatch_mach_msg_get_remote_port(dmsg);
-		}
-		dmsr->dmsr_checkin = checkin;
-	}
-
-	uint32_t disconnect_cnt = os_atomic_and_orig2o(dmsr, dmsr_disconnect_cnt,
-			~DISPATCH_MACH_NEVER_CONNECTED, relaxed);
-	if (unlikely(!(disconnect_cnt & DISPATCH_MACH_NEVER_CONNECTED))) {
-		DISPATCH_CLIENT_CRASH(disconnect_cnt, "Channel already connected");
-	}
-	_dispatch_object_debug(dm, "%s", __func__);
-	return dispatch_activate(dm);
-}
-
-static inline void
-_dispatch_mach_reply_list_insert(dispatch_mach_send_refs_t dmsr,
-		dispatch_mach_reply_refs_t dmr)
-{
-	_dispatch_unfair_lock_lock(&dmsr->dmsr_replies_lock);
-	dispatch_assert(!_LIST_IS_ENQUEUED(dmr, dmr_list));
-	LIST_INSERT_HEAD(&dmsr->dmsr_replies, dmr, dmr_list);
-	_dispatch_unfair_lock_unlock(&dmsr->dmsr_replies_lock);
-}
-
-static inline void
-_dispatch_mach_reply_list_remove_locked(dispatch_mach_reply_refs_t dmr)
-{
-	dispatch_assert(_LIST_IS_ENQUEUED(dmr, dmr_list));
-	LIST_REMOVE(dmr, dmr_list);
-	_LIST_MARK_NOT_ENQUEUED(dmr, dmr_list);
-}
-
-static inline bool
-_dispatch_mach_reply_list_tryremove(dispatch_mach_send_refs_t dmsr,
-		dispatch_mach_reply_refs_t dmr)
-{
-	bool removed;
-	_dispatch_unfair_lock_lock(&dmsr->dmsr_replies_lock);
-	if ((removed = _LIST_IS_ENQUEUED(dmr, dmr_list))) {
-		_dispatch_mach_reply_list_remove_locked(dmr);
-	}
-	_dispatch_unfair_lock_unlock(&dmsr->dmsr_replies_lock);
-	return removed;
-}
-
-#define DMRU_DELETE_ACK     DUU_DELETE_ACK
-#define DMRU_PROBE          DUU_PROBE
-#define DMRU_MUST_SUCCEED   DUU_MUST_SUCCEED
-#define DMRU_DUU_MASK       0x0f
-#define DMRU_DISCONNECTED   0x10
-#define DMRU_REMOVE         0x20
-#define DMRU_ASYNC_MERGE    0x40
-#define DMRU_CANCEL         0x80
-
-DISPATCH_NOINLINE
-static void
-_dispatch_mach_reply_unregister(dispatch_mach_t dm,
-		dispatch_mach_reply_refs_t dmr, uint32_t options)
-{
-	// - async waiters have a dmr of type &_dispatch_mach_type_reply
-	//   heap-allocated in _dispatch_mach_reply_kevent_register().
-	//
-	// - sync waiters have a dmr of type DISPATCH_MACH_TYPE_WAITER,
-	//   stack-allocated in _dispatch_mach_send_and_wait_for_reply().
-	bool sync_waiter = (dux_type(dmr) == DISPATCH_MACH_TYPE_WAITER);
-	dispatch_mach_send_refs_t dmsr = dm->dm_send_refs;
-	bool disconnected = (options & DMRU_DISCONNECTED);
-	bool wakeup = false;
-
-	_dispatch_debug("machport[0x%08x]: unregistering for%s reply%s, ctxt %p",
-			(mach_port_t)dmr->du_ident, sync_waiter ? " sync" : "",
-			(options & DMRU_CANCEL) ? " (canceled)" :
-			disconnected ? " (disconnected)" : "", dmr->dmr_ctxt);
-
-	if (options & DMRU_REMOVE) {
-		_dispatch_unfair_lock_lock(&dmsr->dmsr_replies_lock);
-		_dispatch_mach_reply_list_remove_locked(dmr);
-		if (LIST_EMPTY(&dmsr->dmsr_replies) && dmsr->dmsr_disconnect_cnt) {
-			wakeup = true;
-		}
-		_dispatch_unfair_lock_unlock(&dmsr->dmsr_replies_lock);
-	}
-
-	if (_dispatch_unote_registered(dmr) &&
-			!_dispatch_unote_unregister(dmr, options & DMRU_DUU_MASK)) {
-		dispatch_assert(!sync_waiter); // sync waiters never use kevent
-		if (options & DMRU_CANCEL) {
-			// when canceling, failed unregistrations are put back in the list
-			// the caller has the lock held
-			LIST_INSERT_HEAD(&dmsr->dmsr_replies, dmr, dmr_list);
-		}
-		return;
-	}
-
-	dispatch_mach_msg_t dmsgr = NULL;
-	dispatch_queue_t drq = NULL;
-	if (disconnected) {
-		if (dm->dm_is_xpc && dmr->dmr_ctxt) {
-			drq = _dispatch_mach_msg_context_async_reply_queue(dmr->dmr_ctxt);
-		}
-		dmsgr = _dispatch_mach_msg_create_reply_disconnected(NULL, dmr,
-				drq ? DISPATCH_MACH_ASYNC_WAITER_DISCONNECTED
-				: DISPATCH_MACH_DISCONNECTED);
-		// _dispatch_mach_msg_create_reply_disconnected() consumes the voucher
-		dispatch_assert(dmr->dmr_voucher == NULL);
-	} else if (dmr->dmr_voucher) {
-		_voucher_release(dmr->dmr_voucher);
-		dmr->dmr_voucher = NULL;
-	}
-	if (!sync_waiter) {
-		_dispatch_unote_dispose(dmr);
-	}
-
-	if (dmsgr) {
-		if (drq) {
-			_dispatch_mach_push_async_reply_msg(dm, dmsgr, drq);
-		} else {
-			_dispatch_mach_handle_or_push_received_msg(dm, dmsgr, 0);
-		}
-	}
-	if (options & DMRU_ASYNC_MERGE) {
-		if (wakeup) {
-			return dx_wakeup(dm, 0,
-					DISPATCH_WAKEUP_CONSUME_2 | DISPATCH_WAKEUP_MAKE_DIRTY);
-		}
-		return _dispatch_release_2_tailcall(dm);
-	}
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_mach_reply_waiter_register(dispatch_mach_t dm,
-		dispatch_mach_reply_wait_refs_t dwr, mach_port_t reply_port,
-		dispatch_mach_msg_t dmsg)
-{
-	dispatch_mach_reply_refs_t dmr = &dwr->dwr_refs;
-	dmr->du_owner_wref = _dispatch_ptr2wref(dm);
-	dmr->du_filter = EVFILT_MACHPORT;
-	dmr->du_ident = reply_port;
-	if (!dmr->dmr_reply_port_owned) {
-		if (dmsg->dmsg_voucher) {
-			dmr->dmr_voucher = _voucher_retain(dmsg->dmsg_voucher);
-		}
-		dmr->dmr_priority = dmsg->dmsg_priority;
-		// make reply context visible to leaks rdar://11777199
-		dmr->dmr_ctxt = dmsg->do_ctxt;
-	}
-
-	_dispatch_debug("machport[0x%08x]: registering for sync reply, ctxt %p",
-			reply_port, dmsg->do_ctxt);
-	_dispatch_mach_reply_list_insert(dm->dm_send_refs, dmr);
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_mach_reply_kevent_register(dispatch_mach_t dm, mach_port_t reply_port,
-		dispatch_mach_msg_t dmsg)
-{
-	dispatch_mach_reply_refs_t dmr;
-	dispatch_priority_t mpri, pri, overcommit;
-	dispatch_qos_t fallback;
-	dispatch_wlh_t wlh;
-
-	dmr = dux_create(&_dispatch_mach_type_reply, reply_port, 0)._dmr;
-	dispatch_assert(dmr->du_is_direct);
-	dmr->du_owner_wref = _dispatch_ptr2wref(dm);
-	if (dmsg->dmsg_voucher) {
-		dmr->dmr_voucher = _voucher_retain(dmsg->dmsg_voucher);
-	}
-	dmr->dmr_priority = dmsg->dmsg_priority;
-	// make reply context visible to leaks rdar://11777199
-	dmr->dmr_ctxt = dmsg->do_ctxt;
-
-	dispatch_queue_t drq = NULL;
-	if (dm->dm_is_xpc && dmsg->do_ctxt) {
-		drq = _dispatch_mach_msg_context_async_reply_queue(dmsg->do_ctxt);
-	}
-	if (unlikely(!drq && _dispatch_unote_wlh(dm->dm_recv_refs))) {
-		wlh = _dispatch_unote_wlh(dm->dm_recv_refs);
-		pri = dm->dq_priority;
-	} else if (dx_hastypeflag(drq, QUEUE_ROOT)) {
-		wlh = DISPATCH_WLH_ANON;
-		if (_dispatch_is_in_root_queues_array(drq)) {
-			pri = drq->dq_priority;
-		} else {
-			pri = DISPATCH_PRIORITY_FLAG_MANAGER;
-		}
-	} else if (!(pri = _dispatch_queue_compute_priority_and_wlh(drq, &wlh))) {
-		wlh = DISPATCH_WLH_ANON;
-		pri = drq->dq_priority;
-	}
-	mpri = _dispatch_priority_from_pp_strip_flags(dmsg->dmsg_priority);
-	overcommit = pri & DISPATCH_PRIORITY_FLAG_OVERCOMMIT;
-	fallback = _dispatch_priority_fallback_qos(pri);
-	if (pri & DISPATCH_PRIORITY_REQUESTED_MASK) {
-		pri &= DISPATCH_PRIORITY_REQUESTED_MASK;
-		if (pri < mpri) pri = mpri;
-		pri |= overcommit;
-	} else if (fallback && mpri) {
-		pri = mpri | overcommit;
-	} else if (fallback && !mpri) {
-		pri = _dispatch_priority_make(fallback, 0) | overcommit;
-	} else {
-		pri = DISPATCH_PRIORITY_FLAG_MANAGER;
-		wlh = DISPATCH_WLH_ANON;
-	}
-
-	_dispatch_debug("machport[0x%08x]: registering for reply, ctxt %p",
-			reply_port, dmsg->do_ctxt);
-	_dispatch_mach_reply_list_insert(dm->dm_send_refs, dmr);
-
-	if (!_dispatch_unote_register(dmr, wlh, pri)) {
-		uint32_t options = DMRU_MUST_SUCCEED | DMRU_REMOVE | DMRU_DISCONNECTED;
-		_dispatch_mach_reply_unregister(dm, dmr, options);
-	}
-}
-
-#pragma mark -
-#pragma mark dispatch_mach_msg
-
-DISPATCH_ALWAYS_INLINE DISPATCH_CONST
-static inline bool
-_dispatch_use_mach_special_reply_port(void)
-{
-#if DISPATCH_USE_MACH_SEND_SYNC_OVERRIDE
-	return true;
-#else
-#define thread_get_special_reply_port() ({__builtin_trap(); MACH_PORT_NULL;})
-	return false;
-#endif
-}
-
-static void
-_dispatch_destruct_reply_port(mach_port_t reply_port,
-		enum thread_destruct_special_reply_port_rights rights)
-{
-	kern_return_t kr = KERN_SUCCESS;
-
-	if (_dispatch_use_mach_special_reply_port()) {
-		kr = thread_destruct_special_reply_port(reply_port, rights);
-	} else if (rights == THREAD_SPECIAL_REPLY_PORT_ALL ||
-			rights == THREAD_SPECIAL_REPLY_PORT_RECEIVE_ONLY) {
-		kr = mach_port_destruct(mach_task_self(), reply_port, 0, 0);
-	}
-	DISPATCH_VERIFY_MIG(kr);
-	dispatch_assume_zero(kr);
-}
-
-static mach_port_t
-_dispatch_get_thread_reply_port(void)
-{
-	mach_port_t reply_port, mrp;
-	if (_dispatch_use_mach_special_reply_port()) {
-		mrp = _dispatch_get_thread_special_reply_port();
-	} else {
-		mrp = _dispatch_get_thread_mig_reply_port();
-	}
-	if (mrp) {
-		reply_port = mrp;
-		_dispatch_debug("machport[0x%08x]: borrowed thread sync reply port",
-				reply_port);
-	} else {
-		if (_dispatch_use_mach_special_reply_port()) {
-			reply_port = thread_get_special_reply_port();
-			_dispatch_set_thread_special_reply_port(reply_port);
-		} else {
-			reply_port = mach_reply_port();
-			_dispatch_set_thread_mig_reply_port(reply_port);
-		}
-		if (unlikely(!MACH_PORT_VALID(reply_port))) {
-			DISPATCH_CLIENT_CRASH(_dispatch_use_mach_special_reply_port(),
-				"Unable to allocate reply port, possible port leak");
-		}
-		_dispatch_debug("machport[0x%08x]: allocated thread sync reply port",
-				reply_port);
-	}
-	_dispatch_debug_machport(reply_port);
-	return reply_port;
-}
-
-static void
-_dispatch_clear_thread_reply_port(mach_port_t reply_port)
-{
-	mach_port_t mrp;
-	if (_dispatch_use_mach_special_reply_port()) {
-		mrp = _dispatch_get_thread_special_reply_port();
-	} else {
-		mrp = _dispatch_get_thread_mig_reply_port();
-	}
-	if (reply_port != mrp) {
-		if (mrp) {
-			_dispatch_debug("machport[0x%08x]: did not clear thread sync reply "
-					"port (found 0x%08x)", reply_port, mrp);
-		}
-		return;
-	}
-	if (_dispatch_use_mach_special_reply_port()) {
-		_dispatch_set_thread_special_reply_port(MACH_PORT_NULL);
-	} else {
-		_dispatch_set_thread_mig_reply_port(MACH_PORT_NULL);
-	}
-	_dispatch_debug_machport(reply_port);
-	_dispatch_debug("machport[0x%08x]: cleared thread sync reply port",
-			reply_port);
-}
-
-static void
-_dispatch_set_thread_reply_port(mach_port_t reply_port)
-{
-	_dispatch_debug_machport(reply_port);
-	mach_port_t mrp;
-	if (_dispatch_use_mach_special_reply_port()) {
-		mrp = _dispatch_get_thread_special_reply_port();
-	} else {
-		mrp = _dispatch_get_thread_mig_reply_port();
-	}
-	if (mrp) {
-		_dispatch_destruct_reply_port(reply_port,
-				THREAD_SPECIAL_REPLY_PORT_ALL);
-		_dispatch_debug("machport[0x%08x]: deallocated sync reply port "
-				"(found 0x%08x)", reply_port, mrp);
-	} else {
-		if (_dispatch_use_mach_special_reply_port()) {
-			_dispatch_set_thread_special_reply_port(reply_port);
-		} else {
-			_dispatch_set_thread_mig_reply_port(reply_port);
-		}
-		_dispatch_debug("machport[0x%08x]: restored thread sync reply port",
-				reply_port);
-	}
-}
-
-static inline mach_port_t
-_dispatch_mach_msg_get_remote_port(dispatch_object_t dou)
-{
-	mach_msg_header_t *hdr = _dispatch_mach_msg_get_msg(dou._dmsg);
-	mach_port_t remote = hdr->msgh_remote_port;
-	return remote;
-}
-
-static inline mach_port_t
-_dispatch_mach_msg_get_reply_port(dispatch_object_t dou)
-{
-	mach_msg_header_t *hdr = _dispatch_mach_msg_get_msg(dou._dmsg);
-	mach_port_t local = hdr->msgh_local_port;
-	if (!MACH_PORT_VALID(local) || MACH_MSGH_BITS_LOCAL(hdr->msgh_bits) !=
-			MACH_MSG_TYPE_MAKE_SEND_ONCE) return MACH_PORT_NULL;
-	return local;
-}
-
-static inline void
-_dispatch_mach_msg_set_reason(dispatch_mach_msg_t dmsg, mach_error_t err,
-		unsigned long reason)
-{
-	dispatch_assert_zero(reason & ~(unsigned long)code_emask);
-	dmsg->dmsg_error = ((err || !reason) ? err :
-			 err_local|err_sub(0x3e0)|(mach_error_t)reason);
-}
-
-static inline unsigned long
-_dispatch_mach_msg_get_reason(dispatch_mach_msg_t dmsg, mach_error_t *err_ptr)
-{
-	mach_error_t err = dmsg->dmsg_error;
-
-	if ((err & system_emask) == err_local && err_get_sub(err) == 0x3e0) {
-		*err_ptr = 0;
-		return err_get_code(err);
-	}
-	*err_ptr = err;
-	return err ? DISPATCH_MACH_MESSAGE_SEND_FAILED : DISPATCH_MACH_MESSAGE_SENT;
-}
-
-static inline dispatch_mach_msg_t
-_dispatch_mach_msg_create_recv(mach_msg_header_t *hdr, mach_msg_size_t siz,
-		dispatch_mach_reply_refs_t dmr, uint32_t flags, pthread_priority_t pp)
-{
-	dispatch_mach_msg_destructor_t destructor;
-	dispatch_mach_msg_t dmsg;
-	voucher_t voucher;
-
-	if (dmr) {
-		_voucher_mach_msg_clear(hdr, false); // deallocate reply message voucher
-		pp = dmr->dmr_priority;
-		voucher = dmr->dmr_voucher;
-		dmr->dmr_voucher = NULL; // transfer reference
-	} else {
-		voucher = voucher_create_with_mach_msg(hdr);
-		pp = _dispatch_priority_compute_propagated(pp, 0);
-	}
-
-	destructor = (flags & DISPATCH_EV_MSG_NEEDS_FREE) ?
-			DISPATCH_MACH_MSG_DESTRUCTOR_FREE :
-			DISPATCH_MACH_MSG_DESTRUCTOR_DEFAULT;
-	dmsg = dispatch_mach_msg_create(hdr, siz, destructor, NULL);
-	if (!(flags & DISPATCH_EV_MSG_NEEDS_FREE)) {
-		_dispatch_ktrace2(DISPATCH_MACH_MSG_hdr_move,
-				(uint64_t)hdr, (uint64_t)dmsg->dmsg_buf);
-	}
-	dmsg->dmsg_voucher = voucher;
-	dmsg->dmsg_priority = pp;
-	dmsg->do_ctxt = dmr ? dmr->dmr_ctxt : NULL;
-	_dispatch_mach_msg_set_reason(dmsg, 0, DISPATCH_MACH_MESSAGE_RECEIVED);
-	_dispatch_voucher_debug("mach-msg[%p] create", voucher, dmsg);
-	_dispatch_voucher_ktrace_dmsg_push(dmsg);
-	return dmsg;
-}
-
-void
-_dispatch_mach_merge_msg(dispatch_unote_t du, uint32_t flags,
-		mach_msg_header_t *hdr, mach_msg_size_t siz,
-		pthread_priority_t msg_pp, pthread_priority_t ovr_pp)
-
-{
-	if (flags & EV_VANISHED) {
-		DISPATCH_CLIENT_CRASH(du._du->du_ident,
-				"Unexpected EV_VANISHED (do not destroy random mach ports)");
-	}
-
-	_dispatch_debug_machport(hdr->msgh_remote_port);
-	_dispatch_debug("machport[0x%08x]: received msg id 0x%x, reply on 0x%08x",
-			hdr->msgh_local_port, hdr->msgh_id, hdr->msgh_remote_port);
-
-	dispatch_mach_t dm = _dispatch_wref2ptr(du._dmrr->du_owner_wref);
-	if (unlikely(_dispatch_queue_atomic_flags(dm) & DSF_CANCELED)) {
-		_dispatch_debug("machport[0x%08x]: drop msg id 0x%x, reply on 0x%08x",
-				hdr->msgh_local_port, hdr->msgh_id, hdr->msgh_remote_port);
-		mach_msg_destroy(hdr);
-		if (flags & DISPATCH_EV_MSG_NEEDS_FREE) {
-			free(hdr);
-		}
-	} else {
-		// Once the mach channel disarming is visible, cancellation will switch
-		// to immediately destroy messages.  If we're preempted here, then the
-		// whole cancellation sequence may be complete by the time we really
-		// enqueue the message.
-		//
-		// _dispatch_mach_msg_invoke_with_mach() is responsible for filtering it
-		// out to keep the promise that DISPATCH_MACH_DISCONNECTED is the last
-		// event sent.
-		dispatch_mach_msg_t dmsg;
-		dmsg = _dispatch_mach_msg_create_recv(hdr, siz, NULL, flags, msg_pp);
-		_dispatch_mach_handle_or_push_received_msg(dm, dmsg, ovr_pp);
-	}
-
-	if (unlikely(_dispatch_unote_needs_delete(du))) {
-		return dx_wakeup(dm, 0, DISPATCH_WAKEUP_EVENT |
-				DISPATCH_WAKEUP_CONSUME_2 | DISPATCH_WAKEUP_MAKE_DIRTY);
-	}
-	return _dispatch_release_2_tailcall(dm);
-}
-
-void
-_dispatch_mach_reply_merge_msg(dispatch_unote_t du, uint32_t flags,
-		mach_msg_header_t *hdr, mach_msg_size_t siz,
-		pthread_priority_t msg_pp, pthread_priority_t ovr_pp)
-{
-	dispatch_mach_reply_refs_t dmr = du._dmr;
-	dispatch_mach_t dm = _dispatch_wref2ptr(dmr->du_owner_wref);
-	bool canceled = (_dispatch_queue_atomic_flags(dm) & DSF_CANCELED);
-	dispatch_mach_msg_t dmsg = NULL;
-
-	_dispatch_debug_machport(hdr->msgh_remote_port);
-	_dispatch_debug("machport[0x%08x]: received msg id 0x%x, reply on 0x%08x",
-			hdr->msgh_local_port, hdr->msgh_id, hdr->msgh_remote_port);
-
-	if (!canceled) {
-		dmsg = _dispatch_mach_msg_create_recv(hdr, siz, dmr, flags, msg_pp);
-	}
-
-	if (dmsg) {
-		dispatch_queue_t drq = NULL;
-		if (dm->dm_is_xpc && dmsg->do_ctxt) {
-			drq = _dispatch_mach_msg_context_async_reply_queue(dmsg->do_ctxt);
-		}
-		if (drq) {
-			_dispatch_mach_push_async_reply_msg(dm, dmsg, drq);
-		} else {
-			_dispatch_mach_handle_or_push_received_msg(dm, dmsg, ovr_pp);
-		}
-	} else {
-		_dispatch_debug("machport[0x%08x]: drop msg id 0x%x, reply on 0x%08x",
-				hdr->msgh_local_port, hdr->msgh_id, hdr->msgh_remote_port);
-		mach_msg_destroy(hdr);
-		if (flags & DISPATCH_EV_MSG_NEEDS_FREE) {
-			free(hdr);
-		}
-	}
-
-	uint32_t options = DMRU_ASYNC_MERGE | DMRU_REMOVE;
-	options |= DMRU_MUST_SUCCEED | DMRU_DELETE_ACK;
-	if (canceled) options |= DMRU_DISCONNECTED;
-	dispatch_assert(_dispatch_unote_needs_delete(dmr));
-	_dispatch_mach_reply_unregister(dm, dmr, options); // consumes the +2
-}
-
-DISPATCH_ALWAYS_INLINE
-static void
-_dispatch_mach_stack_probe(void *addr, size_t size)
-{
-#if TARGET_OS_MAC && DISPATCH_MIN_REQUIRED_OSX_AT_LEAST(101400) && \
-		(defined(__x86_64__) || defined(__arm64__))
-	// <rdar://problem/40708879> there should be a __has_feature() macro test
-	// for this, for now we approximate it, for when the compiler
-	// is generating calls to ____chkstk_darwin on our behalf
-	(void)addr; (void)size;
-#else
-	for (mach_vm_address_t p = mach_vm_trunc_page(addr + vm_page_size);
-			p < (mach_vm_address_t)addr + size; p += vm_page_size) {
-		*(char*)p = 0; // ensure alloca buffer doesn't overlap with stack guard
-	}
-#endif
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_mach_msg_t
-_dispatch_mach_msg_reply_recv(dispatch_mach_t dm,
-		dispatch_mach_reply_wait_refs_t dwr, mach_port_t reply_port,
-		mach_port_t send)
-{
-	if (unlikely(!MACH_PORT_VALID(reply_port))) {
-		DISPATCH_CLIENT_CRASH(reply_port, "Invalid reply port");
-	}
-	void *ctxt = dwr->dwr_refs.dmr_ctxt;
-	mach_msg_header_t *hdr, *hdr2 = NULL;
-	void *hdr_copyout_addr;
-	mach_msg_size_t siz, msgsiz = 0;
-	mach_msg_return_t kr;
-	mach_msg_option_t options;
-	mach_port_t notify = MACH_PORT_NULL;
-	siz = mach_vm_round_page(DISPATCH_MACH_RECEIVE_MAX_INLINE_MESSAGE_SIZE +
-			DISPATCH_MACH_TRAILER_SIZE);
-	hdr = alloca(siz);
-	_dispatch_mach_stack_probe(hdr, siz);
-	options = DISPATCH_MACH_RCV_OPTIONS & (~MACH_RCV_VOUCHER);
-	if (MACH_PORT_VALID(send)) {
-		notify = send;
-		options |= MACH_RCV_SYNC_WAIT;
-	}
-
-retry:
-	_dispatch_debug_machport(reply_port);
-	_dispatch_debug("machport[0x%08x]: MACH_RCV_MSG %s", reply_port,
-			(options & MACH_RCV_TIMEOUT) ? "poll" : "wait");
-	kr = mach_msg(hdr, options, 0, siz, reply_port, MACH_MSG_TIMEOUT_NONE,
-			notify);
-	hdr_copyout_addr = hdr;
-	_dispatch_debug_machport(reply_port);
-	_dispatch_debug("machport[0x%08x]: MACH_RCV_MSG (size %u, opts 0x%x) "
-			"returned: %s - 0x%x", reply_port, siz, options,
-			mach_error_string(kr), kr);
-	switch (kr) {
-	case MACH_RCV_TOO_LARGE:
-		if (unlikely(hdr->msgh_size > UINT_MAX - DISPATCH_MACH_TRAILER_SIZE)) {
-			DISPATCH_CLIENT_CRASH(hdr->msgh_size, "Overlarge message");
-		}
-		if (options & MACH_RCV_LARGE) {
-			msgsiz = hdr->msgh_size + DISPATCH_MACH_TRAILER_SIZE;
-			hdr2 = malloc(msgsiz);
-			if (dispatch_assume(hdr2)) {
-				hdr = hdr2;
-				siz = msgsiz;
-			}
-			options |= MACH_RCV_TIMEOUT;
-			options &= ~MACH_RCV_LARGE;
-			goto retry;
-		}
-		_dispatch_log("BUG in libdispatch client: "
-				"dispatch_mach_send_and_wait_for_reply: dropped message too "
-				"large to fit in memory: id = 0x%x, size = %u", hdr->msgh_id,
-				hdr->msgh_size);
-		break;
-	case MACH_RCV_INVALID_NAME: // rdar://problem/21963848
-	case MACH_RCV_PORT_CHANGED: // rdar://problem/21885327
-	case MACH_RCV_PORT_DIED:
-		// channel was disconnected/canceled and reply port destroyed
-		_dispatch_debug("machport[0x%08x]: sync reply port destroyed, ctxt %p: "
-				"%s - 0x%x", reply_port, ctxt, mach_error_string(kr), kr);
-		if (dwr->dwr_refs.dmr_reply_port_owned) {
-			_dispatch_destruct_reply_port(reply_port,
-					THREAD_SPECIAL_REPLY_PORT_SEND_ONLY);
-		}
-		goto out;
-	case MACH_MSG_SUCCESS:
-		if (hdr->msgh_remote_port) {
-			_dispatch_debug_machport(hdr->msgh_remote_port);
-		}
-		_dispatch_debug("machport[0x%08x]: received msg id 0x%x, size = %u, "
-				"reply on 0x%08x", hdr->msgh_local_port, hdr->msgh_id,
-				hdr->msgh_size, hdr->msgh_remote_port);
-		siz = hdr->msgh_size + DISPATCH_MACH_TRAILER_SIZE;
-		if (hdr2 && siz < msgsiz) {
-			void *shrink = realloc(hdr2, msgsiz);
-			if (shrink) hdr = hdr2 = shrink;
-		}
-		break;
-	case MACH_RCV_INVALID_NOTIFY:
-	default:
-		DISPATCH_INTERNAL_CRASH(kr, "Unexpected error from mach_msg_receive");
-		break;
-	}
-	_dispatch_mach_msg_reply_received(dm, dwr, hdr->msgh_local_port);
-	hdr->msgh_local_port = MACH_PORT_NULL;
-	if (unlikely((dm->dq_atomic_flags & DSF_CANCELED) || kr)) {
-		if (!kr) mach_msg_destroy(hdr);
-		goto out;
-	}
-	dispatch_mach_msg_t dmsg;
-	dispatch_mach_msg_destructor_t destructor = (!hdr2) ?
-			DISPATCH_MACH_MSG_DESTRUCTOR_DEFAULT :
-			DISPATCH_MACH_MSG_DESTRUCTOR_FREE;
-	dmsg = dispatch_mach_msg_create(hdr, siz, destructor, NULL);
-	if (!hdr2 || hdr != hdr_copyout_addr) {
-		_dispatch_ktrace2(DISPATCH_MACH_MSG_hdr_move,
-				(uint64_t)hdr_copyout_addr,
-				(uint64_t)_dispatch_mach_msg_get_msg(dmsg));
-	}
-	dmsg->do_ctxt = ctxt;
-	return dmsg;
-out:
-	free(hdr2);
-	return NULL;
-}
-
-static inline void
-_dispatch_mach_msg_reply_received(dispatch_mach_t dm,
-		dispatch_mach_reply_wait_refs_t dwr, mach_port_t local_port)
-{
-	dispatch_mach_reply_refs_t dmr = &dwr->dwr_refs;
-	bool removed = _dispatch_mach_reply_list_tryremove(dm->dm_send_refs, dmr);
-	mach_port_t reply_port = (mach_port_t)dmr->du_ident;
-
-	if (removed) {
-		_dispatch_debug("machport[0x%08x]: unregistered for sync reply, ctxt %p",
-				reply_port, dmr->dmr_ctxt);
-	}
-
-	if (dmr->dmr_reply_port_owned) {
-		if (local_port != reply_port &&
-				(removed || MACH_PORT_VALID(local_port))) {
-			DISPATCH_CLIENT_CRASH(local_port,
-					"Reply received on unexpected port");
-		}
-		if (removed) {
-			_dispatch_set_thread_reply_port(reply_port);
-		} else {
-			_dispatch_destruct_reply_port(reply_port,
-					THREAD_SPECIAL_REPLY_PORT_SEND_ONLY);
-		}
-		return;
-	}
-
-	if (!MACH_PORT_VALID(local_port) || !removed) {
-		// port moved/destroyed during receive, or reply waiter was never
-		// registered or already removed (disconnected)
-		return;
-	}
-
-	mach_msg_header_t *hdr;
-	dispatch_mach_msg_t dmsg;
-	dmsg = dispatch_mach_msg_create(NULL, sizeof(mach_msg_header_t),
-			DISPATCH_MACH_MSG_DESTRUCTOR_DEFAULT, &hdr);
-	hdr->msgh_local_port = local_port;
-	dmsg->dmsg_voucher = dmr->dmr_voucher;
-	dmr->dmr_voucher = NULL;  // transfer reference
-	dmsg->dmsg_priority = dmr->dmr_priority;
-	dmsg->do_ctxt = dmr->dmr_ctxt;
-	_dispatch_mach_msg_set_reason(dmsg, 0, DISPATCH_MACH_REPLY_RECEIVED);
-	return _dispatch_mach_handle_or_push_received_msg(dm, dmsg, 0);
-}
-
-static inline void
-_dispatch_mach_msg_disconnected(dispatch_mach_t dm, mach_port_t local_port,
-		mach_port_t remote_port)
-{
-	mach_msg_header_t *hdr;
-	dispatch_mach_msg_t dmsg;
-	dmsg = dispatch_mach_msg_create(NULL, sizeof(mach_msg_header_t),
-			DISPATCH_MACH_MSG_DESTRUCTOR_DEFAULT, &hdr);
-	if (local_port) hdr->msgh_local_port = local_port;
-	if (remote_port) hdr->msgh_remote_port = remote_port;
-	_dispatch_mach_msg_set_reason(dmsg, 0, DISPATCH_MACH_DISCONNECTED);
-	_dispatch_debug("machport[0x%08x]: %s right disconnected", local_port ?
-			local_port : remote_port, local_port ? "receive" : "send");
-	return _dispatch_mach_handle_or_push_received_msg(dm, dmsg, 0);
-}
-
-static inline dispatch_mach_msg_t
-_dispatch_mach_msg_create_reply_disconnected(dispatch_object_t dou,
-		dispatch_mach_reply_refs_t dmr, dispatch_mach_reason_t reason)
-{
-	dispatch_mach_msg_t dmsg = dou._dmsg, dmsgr;
-	mach_port_t reply_port = dmsg ? dmsg->dmsg_reply :(mach_port_t)dmr->du_ident;
-
-	if (!reply_port) {
-		if (!dmsg && dmr->dmr_voucher) {
-			_voucher_release(dmr->dmr_voucher);
-			dmr->dmr_voucher = NULL;
-		}
-		return NULL;
-	}
-
-	if (dmr && !_dispatch_unote_registered(dmr) && dmr->dmr_reply_port_owned) {
-		if (dmr->dmr_voucher) {
-			_voucher_release(dmr->dmr_voucher);
-			dmr->dmr_voucher = NULL;
-		}
-		// deallocate owned reply port to break _dispatch_mach_msg_reply_recv
-		// out of waiting in mach_msg(MACH_RCV_MSG).
-		//
-		// after this call, dmr can become invalid
-		_dispatch_destruct_reply_port(reply_port,
-				THREAD_SPECIAL_REPLY_PORT_RECEIVE_ONLY);
-		return NULL;
-	}
-
-	mach_msg_header_t *hdr;
-	dmsgr = dispatch_mach_msg_create(NULL, sizeof(mach_msg_header_t),
-			DISPATCH_MACH_MSG_DESTRUCTOR_DEFAULT, &hdr);
-	hdr->msgh_local_port = reply_port;
-	if (dmsg) {
-		dmsgr->dmsg_priority = dmsg->dmsg_priority;
-		dmsgr->do_ctxt = dmsg->do_ctxt;
-		dmsgr->dmsg_voucher = dmsg->dmsg_voucher;
-		if (dmsgr->dmsg_voucher) _voucher_retain(dmsgr->dmsg_voucher);
-	} else {
-		dmsgr->dmsg_priority = dmr->dmr_priority;
-		dmsgr->do_ctxt = dmr->dmr_ctxt;
-		dmsgr->dmsg_voucher = dmr->dmr_voucher;
-		dmr->dmr_voucher = NULL; // transfer reference
-	}
-	_dispatch_mach_msg_set_reason(dmsgr, 0, reason);
-	_dispatch_debug("machport[0x%08x]: reply disconnected, ctxt %p",
-			hdr->msgh_local_port, dmsgr->do_ctxt);
-	return dmsgr;
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_mach_msg_not_sent(dispatch_mach_t dm, dispatch_object_t dou,
-		dispatch_mach_reply_wait_refs_t dwr)
-{
-	dispatch_mach_msg_t dmsg = dou._dmsg, dmsgr;
-	dispatch_queue_t drq = NULL;
-	mach_msg_header_t *msg = _dispatch_mach_msg_get_msg(dmsg);
-	mach_msg_option_t msg_opts = dmsg->dmsg_options;
-	_dispatch_debug("machport[0x%08x]: not sent msg id 0x%x, ctxt %p, "
-			"msg_opts 0x%x, kvoucher 0x%08x, reply on 0x%08x",
-			msg->msgh_remote_port, msg->msgh_id, dmsg->do_ctxt,
-			msg_opts, msg->msgh_voucher_port, dmsg->dmsg_reply);
-	unsigned long reason = (msg_opts & DISPATCH_MACH_REGISTER_FOR_REPLY) ?
-			0 : DISPATCH_MACH_MESSAGE_NOT_SENT;
-	if (dm->dm_is_xpc && dmsg->do_ctxt) {
-		drq = _dispatch_mach_msg_context_async_reply_queue(dmsg->do_ctxt);
-	}
-	dmsgr = _dispatch_mach_msg_create_reply_disconnected(dmsg,
-			dwr ? &dwr->dwr_refs : NULL,
-			drq ? DISPATCH_MACH_ASYNC_WAITER_DISCONNECTED
-			: DISPATCH_MACH_DISCONNECTED);
-	_dispatch_mach_msg_set_reason(dmsg, 0, reason);
-	_dispatch_mach_handle_or_push_received_msg(dm, dmsg, 0);
-	if (dmsgr) {
-		if (drq) {
-			_dispatch_mach_push_async_reply_msg(dm, dmsgr, drq);
-		} else {
-			_dispatch_mach_handle_or_push_received_msg(dm, dmsgr, 0);
-		}
-	}
-}
-
-DISPATCH_NOINLINE
-static uint32_t
-_dispatch_mach_msg_send(dispatch_mach_t dm, dispatch_object_t dou,
-		dispatch_mach_reply_wait_refs_t dwr, dispatch_qos_t qos,
-		dispatch_mach_send_invoke_flags_t send_flags)
-{
-	dispatch_mach_send_refs_t dsrr = dm->dm_send_refs;
-	dispatch_mach_msg_t dmsg = dou._dmsg, dmsgr = NULL;
-	voucher_t voucher = dmsg->dmsg_voucher;
-	dispatch_queue_t drq = NULL;
-	mach_voucher_t ipc_kvoucher = MACH_VOUCHER_NULL;
-	uint32_t send_status = 0;
-	bool clear_voucher = false, kvoucher_move_send = false;
-	mach_msg_header_t *msg = _dispatch_mach_msg_get_msg(dmsg);
-	bool is_reply = (MACH_MSGH_BITS_REMOTE(msg->msgh_bits) ==
-			MACH_MSG_TYPE_MOVE_SEND_ONCE);
-	mach_port_t reply_port = dmsg->dmsg_reply;
-	if (!is_reply) {
-		dm->dm_needs_mgr = 0;
-		if (unlikely(dsrr->dmsr_checkin && dmsg != dsrr->dmsr_checkin)) {
-			// send initial checkin message
-			if (unlikely(_dispatch_unote_registered(dsrr) &&
-					_dispatch_queue_get_current() != _dispatch_mgr_q._as_dq)) {
-				// send kevent must be uninstalled on the manager queue
-				dm->dm_needs_mgr = true;
-				goto out;
-			}
-			if (unlikely(!_dispatch_mach_msg_send(dm,
-					dsrr->dmsr_checkin, NULL, qos, DM_SEND_INVOKE_NONE))) {
-				goto out;
-			}
-			dsrr->dmsr_checkin = NULL;
-		}
-	}
-	mach_msg_return_t kr = 0;
-	mach_msg_option_t opts = 0, msg_opts = dmsg->dmsg_options;
-	if (!(msg_opts & DISPATCH_MACH_REGISTER_FOR_REPLY)) {
-		mach_msg_priority_t msg_priority = MACH_MSG_PRIORITY_UNSPECIFIED;
-		opts = MACH_SEND_MSG | (msg_opts & ~DISPATCH_MACH_OPTIONS_MASK);
-		if (!is_reply) {
-			if (dmsg != dsrr->dmsr_checkin) {
-				msg->msgh_remote_port = dsrr->dmsr_send;
-			}
-			if (_dispatch_queue_get_current() == _dispatch_mgr_q._as_dq) {
-				if (unlikely(!_dispatch_unote_registered(dsrr))) {
-					_dispatch_mach_notification_kevent_register(dm,
-							msg->msgh_remote_port);
-					dispatch_assert(_dispatch_unote_registered(dsrr));
-				}
-				if (dsrr->dmsr_notification_armed) {
-					goto out;
-				}
-				opts |= MACH_SEND_NOTIFY;
-			}
-			opts |= MACH_SEND_TIMEOUT;
-			if (dmsg->dmsg_priority != _voucher_get_priority(voucher)) {
-				ipc_kvoucher = _voucher_create_mach_voucher_with_priority(
-						voucher, dmsg->dmsg_priority);
-			}
-			_dispatch_voucher_debug("mach-msg[%p] msg_set", voucher, dmsg);
-			if (ipc_kvoucher) {
-				kvoucher_move_send = true;
-				clear_voucher = _voucher_mach_msg_set_mach_voucher(msg,
-						ipc_kvoucher, kvoucher_move_send);
-			} else {
-				clear_voucher = _voucher_mach_msg_set(msg, voucher);
-			}
-			if (qos) {
-				opts |= MACH_SEND_OVERRIDE;
-				msg_priority = (mach_msg_priority_t)
-						_dispatch_priority_compute_propagated(
-						_dispatch_qos_to_pp(qos), 0);
-			}
-		}
-		_dispatch_debug_machport(msg->msgh_remote_port);
-		if (reply_port) _dispatch_debug_machport(reply_port);
-		if (msg_opts & DISPATCH_MACH_WAIT_FOR_REPLY) {
-			if (dwr->dwr_refs.dmr_reply_port_owned) {
-				if (_dispatch_use_mach_special_reply_port()) {
-					opts |= MACH_SEND_SYNC_OVERRIDE;
-				}
-				_dispatch_clear_thread_reply_port(reply_port);
-			}
-			_dispatch_mach_reply_waiter_register(dm, dwr, reply_port, dmsg);
-		}
-		kr = mach_msg(msg, opts, msg->msgh_size, 0, MACH_PORT_NULL, 0,
-				msg_priority);
-		_dispatch_debug("machport[0x%08x]: sent msg id 0x%x, ctxt %p, "
-				"opts 0x%x, msg_opts 0x%x, kvoucher 0x%08x, reply on 0x%08x: "
-				"%s - 0x%x", msg->msgh_remote_port, msg->msgh_id, dmsg->do_ctxt,
-				opts, msg_opts, msg->msgh_voucher_port, reply_port,
-				mach_error_string(kr), kr);
-		if (unlikely(kr && (msg_opts & DISPATCH_MACH_WAIT_FOR_REPLY))) {
-			uint32_t options = DMRU_MUST_SUCCEED | DMRU_REMOVE;
-			dispatch_assert(dwr);
-			_dispatch_mach_reply_unregister(dm, &dwr->dwr_refs, options);
-		}
-		if (clear_voucher) {
-			if (kr == MACH_SEND_INVALID_VOUCHER && msg->msgh_voucher_port) {
-				DISPATCH_CLIENT_CRASH(kr, "Voucher port corruption");
-			}
-			mach_voucher_t kv;
-			kv = _voucher_mach_msg_clear(msg, kvoucher_move_send);
-			if (kvoucher_move_send) ipc_kvoucher = kv;
-		}
-	}
-	if (kr == MACH_SEND_TIMED_OUT && (opts & MACH_SEND_TIMEOUT)) {
-		if (opts & MACH_SEND_NOTIFY) {
-			_dispatch_mach_notification_set_armed(dsrr);
-		} else {
-			// send kevent must be installed on the manager queue
-			dm->dm_needs_mgr = true;
-		}
-		if (ipc_kvoucher) {
-			_dispatch_kvoucher_debug("reuse on re-send", ipc_kvoucher);
-			voucher_t ipc_voucher;
-			ipc_voucher = _voucher_create_with_priority_and_mach_voucher(
-					voucher, dmsg->dmsg_priority, ipc_kvoucher);
-			_dispatch_voucher_debug("mach-msg[%p] replace voucher[%p]",
-					ipc_voucher, dmsg, voucher);
-			if (dmsg->dmsg_voucher) _voucher_release(dmsg->dmsg_voucher);
-			dmsg->dmsg_voucher = ipc_voucher;
-		}
-		goto out;
-	} else if (ipc_kvoucher && (kr || !kvoucher_move_send)) {
-		_voucher_dealloc_mach_voucher(ipc_kvoucher);
-	}
-	dispatch_mach_recv_refs_t dmrr = dm->dm_recv_refs;
-	if (!(msg_opts & DISPATCH_MACH_WAIT_FOR_REPLY) && !kr && reply_port &&
-			!(_dispatch_unote_registered(dmrr) &&
-			dmrr->du_ident == reply_port)) {
-		_dispatch_mach_reply_kevent_register(dm, reply_port, dmsg);
-	}
-	if (unlikely(!is_reply && dmsg == dsrr->dmsr_checkin &&
-			_dispatch_unote_registered(dsrr))) {
-		_dispatch_mach_notification_kevent_unregister(dm);
-	}
-	if (unlikely(kr)) {
-		// Send failed, so reply was never registered <rdar://problem/14309159>
-		if (dm->dm_is_xpc && dmsg->do_ctxt) {
-			drq = _dispatch_mach_msg_context_async_reply_queue(dmsg->do_ctxt);
-		}
-		dmsgr = _dispatch_mach_msg_create_reply_disconnected(dmsg,
-				dwr ? &dwr->dwr_refs : NULL,
-				drq ? DISPATCH_MACH_ASYNC_WAITER_DISCONNECTED
-				: DISPATCH_MACH_DISCONNECTED);
-	}
-	_dispatch_mach_msg_set_reason(dmsg, kr, 0);
-	if ((send_flags & DM_SEND_INVOKE_IMMEDIATE_SEND) &&
-			(msg_opts & DISPATCH_MACH_RETURN_IMMEDIATE_SEND_RESULT)) {
-		// Return sent message synchronously <rdar://problem/25947334>
-		send_status |= DM_SEND_STATUS_RETURNING_IMMEDIATE_SEND_RESULT;
-	} else {
-		_dispatch_mach_handle_or_push_received_msg(dm, dmsg, 0);
-	}
-	if (dmsgr) {
-		if (drq) {
-			_dispatch_mach_push_async_reply_msg(dm, dmsgr, drq);
-		} else {
-			_dispatch_mach_handle_or_push_received_msg(dm, dmsgr, 0);
-		}
-	}
-	send_status |= DM_SEND_STATUS_SUCCESS;
-out:
-	return send_status;
-}
-
-#pragma mark -
-#pragma mark dispatch_mach_send_refs_t
-
-#define _dmsr_state_needs_lock_override(dq_state, qos) \
-		unlikely(qos < _dq_state_max_qos(dq_state))
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_qos_t
-_dmsr_state_max_qos(uint64_t dmsr_state)
-{
-	return _dq_state_max_qos(dmsr_state);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dmsr_state_needs_override(uint64_t dmsr_state, dispatch_qos_t qos)
-{
-	dmsr_state &= DISPATCH_MACH_STATE_MAX_QOS_MASK;
-	return dmsr_state < _dq_state_from_qos(qos);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline uint64_t
-_dmsr_state_merge_override(uint64_t dmsr_state, dispatch_qos_t qos)
-{
-	if (_dmsr_state_needs_override(dmsr_state, qos)) {
-		dmsr_state &= ~DISPATCH_MACH_STATE_MAX_QOS_MASK;
-		dmsr_state |= _dq_state_from_qos(qos);
-		dmsr_state |= DISPATCH_MACH_STATE_DIRTY;
-		dmsr_state |= DISPATCH_MACH_STATE_RECEIVED_OVERRIDE;
-	}
-	return dmsr_state;
-}
-
-#define _dispatch_mach_send_push_update_tail(dmsr, tail) \
-		os_mpsc_push_update_tail(os_mpsc(dmsr, dmsr), tail, do_next)
-#define _dispatch_mach_send_push_update_prev(dmsr, prev, head) \
-		os_mpsc_push_update_prev(os_mpsc(dmsr, dmsr), prev, head, do_next)
-#define _dispatch_mach_send_get_head(dmsr) \
-		os_mpsc_get_head(os_mpsc(dmsr, dmsr))
-#define _dispatch_mach_send_undo_pop_head(dmsr, dc, dc_next) \
-		os_mpsc_undo_pop_head(os_mpsc(dmsr, dmsr), dc, dc_next, do_next)
-#define _dispatch_mach_send_pop_head(dmsr, head) \
-		os_mpsc_pop_head(os_mpsc(dmsr, dmsr), head, do_next)
-
-#define dm_push(dm, dc, qos) \
-		_dispatch_lane_push(dm, dc, qos)
-
-DISPATCH_NOINLINE
-static bool
-_dispatch_mach_send_drain(dispatch_mach_t dm, dispatch_invoke_flags_t flags,
-		dispatch_mach_send_invoke_flags_t send_flags)
-{
-	dispatch_mach_send_refs_t dmsr = dm->dm_send_refs;
-	dispatch_mach_reply_wait_refs_t dwr;
-	dispatch_mach_msg_t dmsg;
-	struct dispatch_object_s *dc = NULL, *next_dc = NULL;
-	dispatch_qos_t qos = _dmsr_state_max_qos(dmsr->dmsr_state);
-	uint64_t old_state, new_state;
-	uint32_t send_status;
-	bool returning_send_result = false;
-	dispatch_wakeup_flags_t wflags = 0;
-
-again:
-	while (dmsr->dmsr_tail) {
-		dc = _dispatch_mach_send_get_head(dmsr);
-		do {
-			dispatch_mach_send_invoke_flags_t sf = send_flags;
-			// Only request immediate send result for the first message
-			send_flags &= ~DM_SEND_INVOKE_IMMEDIATE_SEND_MASK;
-			next_dc = _dispatch_mach_send_pop_head(dmsr, dc);
-			if (_dispatch_object_has_type(dc,
-					DISPATCH_CONTINUATION_TYPE(MACH_SEND_BARRIER))) {
-				if (!(send_flags & DM_SEND_INVOKE_CAN_RUN_BARRIER)) {
-					goto partial_drain;
-				}
-				_dispatch_continuation_pop(dc, NULL, flags, dm);
-				continue;
-			}
-			if (_dispatch_object_is_sync_waiter(dc)) {
-				dmsg = ((dispatch_continuation_t)dc)->dc_data;
-				dwr = ((dispatch_continuation_t)dc)->dc_other;
-			} else if (_dispatch_object_has_vtable(dc)) {
-				dmsg = (dispatch_mach_msg_t)dc;
-				dwr = NULL;
-			} else {
-				if (_dispatch_unote_registered(dmsr) &&
-						(_dispatch_queue_get_current() != _dispatch_mgr_q._as_dq)) {
-					// send kevent must be uninstalled on the manager queue
-					dm->dm_needs_mgr = true;
-					wflags |= DISPATCH_WAKEUP_MAKE_DIRTY;
-					goto partial_drain;
-				}
-				if (unlikely(!_dispatch_mach_reconnect_invoke(dm, dc))) {
-					goto partial_drain;
-				}
-				_dispatch_perfmon_workitem_inc();
-				continue;
-			}
-			_dispatch_voucher_ktrace_dmsg_pop(dmsg);
-			if (unlikely(dmsr->dmsr_disconnect_cnt ||
-					(dm->dq_atomic_flags & DSF_CANCELED))) {
-				_dispatch_mach_msg_not_sent(dm, dmsg, dwr);
-				_dispatch_perfmon_workitem_inc();
-				continue;
-			}
-			send_status = _dispatch_mach_msg_send(dm, dmsg, dwr, qos, sf);
-			if (unlikely(!send_status)) {
-				if (dm->dm_needs_mgr) wflags |= DISPATCH_WAKEUP_MAKE_DIRTY;
-				goto partial_drain;
-			}
-			if (send_status & DM_SEND_STATUS_RETURNING_IMMEDIATE_SEND_RESULT) {
-				returning_send_result = true;
-			}
-			_dispatch_perfmon_workitem_inc();
-		} while ((dc = next_dc));
-	}
-
-	os_atomic_rmw_loop2o(dmsr, dmsr_state, old_state, new_state, release, {
-		if (old_state & DISPATCH_MACH_STATE_DIRTY) {
-			new_state = old_state;
-			new_state &= ~DISPATCH_MACH_STATE_DIRTY;
-			new_state &= ~DISPATCH_MACH_STATE_RECEIVED_OVERRIDE;
-			new_state &= ~DISPATCH_MACH_STATE_PENDING_BARRIER;
-		} else {
-			// unlock
-			new_state = 0;
-		}
-	});
-	goto out;
-
-partial_drain:
-	// if this is not a complete drain, we must undo some things
-	_dispatch_mach_send_undo_pop_head(dmsr, dc, next_dc);
-
-	if (_dispatch_object_has_type(dc,
-			DISPATCH_CONTINUATION_TYPE(MACH_SEND_BARRIER))) {
-		os_atomic_rmw_loop2o(dmsr, dmsr_state, old_state, new_state, release, {
-			new_state = old_state;
-			new_state |= DISPATCH_MACH_STATE_DIRTY;
-			new_state |= DISPATCH_MACH_STATE_PENDING_BARRIER;
-			new_state &= ~DISPATCH_MACH_STATE_UNLOCK_MASK;
-			new_state &= ~DISPATCH_MACH_STATE_RECEIVED_OVERRIDE;
-		});
-	} else {
-		os_atomic_rmw_loop2o(dmsr, dmsr_state, old_state, new_state, release, {
-			new_state = old_state;
-			if (old_state & (DISPATCH_MACH_STATE_DIRTY |
-					DISPATCH_MACH_STATE_RECEIVED_OVERRIDE)) {
-				new_state &= ~DISPATCH_MACH_STATE_DIRTY;
-				new_state &= ~DISPATCH_MACH_STATE_RECEIVED_OVERRIDE;
-				new_state &= ~DISPATCH_MACH_STATE_PENDING_BARRIER;
-			} else {
-				new_state |= DISPATCH_MACH_STATE_DIRTY;
-				new_state &= ~DISPATCH_MACH_STATE_UNLOCK_MASK;
-			}
-		});
-	}
-
-out:
-	if (old_state & DISPATCH_MACH_STATE_RECEIVED_OVERRIDE) {
-		// Ensure that the root queue sees that this thread was overridden.
-		_dispatch_set_basepri_override_qos(_dmsr_state_max_qos(old_state));
-	}
-
-	qos = _dmsr_state_max_qos(new_state);
-	if (unlikely(new_state & DISPATCH_MACH_STATE_UNLOCK_MASK)) {
-		os_atomic_thread_fence(dependency);
-		dmsr = os_atomic_force_dependency_on(dmsr, new_state);
-		goto again;
-	}
-
-	if (new_state & DISPATCH_MACH_STATE_PENDING_BARRIER) {
-		// we don't need to wakeup the mach channel with DISPATCH_WAKEUP_EVENT
-		// because a push on the receive queue always causes a wakeup even
-		// wen DSF_NEEDS_EVENT is set.
-		_dispatch_mach_push_send_barrier_drain(dm, qos);
-		return returning_send_result;
-	}
-
-	if (new_state == 0 && dm->dm_disconnected && !dm->dm_cancel_handler_called){
-		// cancelation waits for the send queue to be empty
-		// so when we know cancelation is pending, and we empty the queue,
-		// force an EVENT wakeup.
-		wflags |= DISPATCH_WAKEUP_EVENT | DISPATCH_WAKEUP_MAKE_DIRTY;
-	}
-	if ((old_state ^ new_state) & DISPATCH_MACH_STATE_ENQUEUED) {
-		if (wflags) {
-			wflags |= DISPATCH_WAKEUP_CONSUME_2;
-		} else {
-			// <rdar://problem/26734097> Note that after this release
-			// the mach channel may be gone.
-			_dispatch_release_2(dm);
-		}
-	}
-	if (wflags) {
-		dx_wakeup(dm, dm->dm_needs_mgr ? qos : 0, wflags);
-	}
-	return returning_send_result;
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_mach_send_invoke(dispatch_mach_t dm, dispatch_invoke_flags_t flags,
-		dispatch_mach_send_invoke_flags_t send_flags)
-{
-	dispatch_mach_send_refs_t dmsr = dm->dm_send_refs;
-	dispatch_lock owner_self = _dispatch_lock_value_for_self();
-	uint64_t old_state, new_state;
-
-	uint64_t canlock_mask = DISPATCH_MACH_STATE_UNLOCK_MASK;
-	uint64_t canlock_state = 0;
-
-	if (send_flags & DM_SEND_INVOKE_NEEDS_BARRIER) {
-		canlock_mask |= DISPATCH_MACH_STATE_PENDING_BARRIER;
-		canlock_state = DISPATCH_MACH_STATE_PENDING_BARRIER;
-	} else if (!(send_flags & DM_SEND_INVOKE_CAN_RUN_BARRIER)) {
-		canlock_mask |= DISPATCH_MACH_STATE_PENDING_BARRIER;
-	}
-
-	dispatch_qos_t oq_floor = _dispatch_get_basepri_override_qos_floor();
-retry:
-	os_atomic_rmw_loop2o(dmsr, dmsr_state, old_state, new_state, acquire, {
-		new_state = old_state;
-		if (unlikely((old_state & canlock_mask) != canlock_state)) {
-			if (!(send_flags & DM_SEND_INVOKE_MAKE_DIRTY)) {
-				os_atomic_rmw_loop_give_up(break);
-			}
-			new_state |= DISPATCH_MACH_STATE_DIRTY;
-		} else {
-			if (_dmsr_state_needs_lock_override(old_state, oq_floor)) {
-				os_atomic_rmw_loop_give_up({
-					oq_floor = _dispatch_queue_override_self(old_state);
-					goto retry;
-				});
-			}
-			new_state |= owner_self;
-			new_state &= ~DISPATCH_MACH_STATE_DIRTY;
-			new_state &= ~DISPATCH_MACH_STATE_RECEIVED_OVERRIDE;
-			new_state &= ~DISPATCH_MACH_STATE_PENDING_BARRIER;
-		}
-	});
-
-	if (unlikely((old_state & canlock_mask) != canlock_state)) {
-		return;
-	}
-	_dispatch_mach_send_drain(dm, flags, send_flags);
-}
-
-DISPATCH_NOINLINE
-void
-_dispatch_mach_send_barrier_drain_invoke(dispatch_continuation_t dc,
-		DISPATCH_UNUSED dispatch_invoke_context_t dic,
-		dispatch_invoke_flags_t flags)
-{
-	dispatch_mach_t dm = upcast(_dispatch_queue_get_current())._dm;
-	uintptr_t dc_flags = DC_FLAG_CONSUME | DC_FLAG_NO_INTROSPECTION;
-	dispatch_thread_frame_s dtf;
-
-	DISPATCH_COMPILER_CAN_ASSUME(dc->dc_priority == DISPATCH_NO_PRIORITY);
-	DISPATCH_COMPILER_CAN_ASSUME(dc->dc_voucher == DISPATCH_NO_VOUCHER);
-	// hide the mach channel (see _dispatch_mach_barrier_invoke comment)
-	_dispatch_thread_frame_stash(&dtf);
-	_dispatch_continuation_pop_forwarded(dc, dc_flags, dm, {
-		_dispatch_mach_send_invoke(dm, flags,
-				DM_SEND_INVOKE_NEEDS_BARRIER | DM_SEND_INVOKE_CAN_RUN_BARRIER);
-	});
-	_dispatch_thread_frame_unstash(&dtf);
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_mach_push_send_barrier_drain(dispatch_mach_t dm, dispatch_qos_t qos)
-{
-	dispatch_continuation_t dc = _dispatch_continuation_alloc();
-
-	dc->do_vtable = DC_VTABLE(MACH_SEND_BARRRIER_DRAIN);
-	dc->dc_func = NULL;
-	dc->dc_ctxt = NULL;
-	dc->dc_voucher = DISPATCH_NO_VOUCHER;
-	dc->dc_priority = DISPATCH_NO_PRIORITY;
-	dm_push(dm, dc, qos);
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_mach_send_push(dispatch_mach_t dm, dispatch_object_t dou,
-		dispatch_qos_t qos)
-{
-	dispatch_mach_send_refs_t dmsr = dm->dm_send_refs;
-	uint64_t old_state, new_state, state_flags = 0;
-	struct dispatch_object_s *prev;
-	dispatch_wakeup_flags_t wflags = 0;
-	bool is_send_barrier = (dou._dc->do_vtable == DC_VTABLE(MACH_SEND_BARRIER));
-	dispatch_tid owner;
-
-	// <rdar://problem/25896179&26266265> the send queue needs to retain
-	// the mach channel if not empty, for the whole duration of this call
-	//
-	// When we may add the ENQUEUED bit, we need to reserve 2 more that we will
-	// transfer to _dispatch_mach_send_drain().
-	prev = _dispatch_mach_send_push_update_tail(dmsr, dou._do);
-	_dispatch_retain_n_unsafe(dm, os_mpsc_push_was_empty(prev) ? 4 : 2);
-	_dispatch_mach_send_push_update_prev(dmsr, prev, dou._do);
-
-	if (unlikely(os_mpsc_push_was_empty(prev))) {
-		state_flags = DISPATCH_MACH_STATE_DIRTY | DISPATCH_MACH_STATE_ENQUEUED;
-		wflags |= DISPATCH_WAKEUP_MAKE_DIRTY;
-		if (is_send_barrier) {
-			state_flags |= DISPATCH_MACH_STATE_PENDING_BARRIER;
-		}
-
-		os_atomic_rmw_loop2o(dmsr, dmsr_state, old_state, new_state, release, {
-			new_state = _dmsr_state_merge_override(old_state, qos);
-			new_state |= state_flags;
-		});
-		if ((old_state ^ new_state) & DISPATCH_MACH_STATE_ENQUEUED) {
-			// +2 transfered to the ENQUEUED state, _dispatch_mach_send_drain
-			// will consume it when clearing the bit.
-		} else {
-			_dispatch_release_2_no_dispose(dm);
-		}
-	} else {
-		os_atomic_rmw_loop2o(dmsr, dmsr_state, old_state, new_state, relaxed, {
-			new_state = _dmsr_state_merge_override(old_state, qos);
-			if (old_state == new_state) {
-				os_atomic_rmw_loop_give_up(break);
-			}
-		});
-	}
-
-
-	qos = _dmsr_state_max_qos(new_state);
-	owner = _dispatch_lock_owner((dispatch_lock)old_state);
-	if (owner) {
-		if (_dmsr_state_needs_override(old_state, qos)) {
-			_dispatch_wqthread_override_start_check_owner(owner, qos,
-					&dmsr->dmsr_state_lock.dul_lock);
-		}
-	} else if (state_flags & DISPATCH_MACH_STATE_PENDING_BARRIER) {
-		_dispatch_mach_push_send_barrier_drain(dm, qos);
-	} else if (wflags || dmsr->dmsr_disconnect_cnt ||
-			(dm->dq_atomic_flags & DSF_CANCELED)) {
-		return dx_wakeup(dm, qos, wflags | DISPATCH_WAKEUP_CONSUME_2);
-	} else if (old_state & DISPATCH_MACH_STATE_PENDING_BARRIER) {
-		return dx_wakeup(dm, qos, DISPATCH_WAKEUP_CONSUME_2);
-	}
-
-	return _dispatch_release_2_tailcall(dm);
-}
-
-DISPATCH_NOINLINE
-static bool
-_dispatch_mach_send_push_and_trydrain(dispatch_mach_t dm,
-		dispatch_object_t dou, dispatch_qos_t qos,
-		dispatch_mach_send_invoke_flags_t send_flags)
-{
-	dispatch_mach_send_refs_t dmsr = dm->dm_send_refs;
-	dispatch_lock owner_self = _dispatch_lock_value_for_self();
-	uint64_t old_state, new_state, canlock_mask, state_flags = 0;
-	dispatch_wakeup_flags_t wflags = 0;
-	dispatch_tid owner;
-	struct dispatch_object_s *prev;
-
-	prev = _dispatch_mach_send_push_update_tail(dmsr, dou._do);
-	if (os_mpsc_push_was_empty(prev)) {
-		// <rdar://problem/25896179&26266265> the send queue needs to retain
-		// the mach channel if not empty.
-		_dispatch_retain_2(dm);
-		state_flags = DISPATCH_MACH_STATE_DIRTY | DISPATCH_MACH_STATE_ENQUEUED;
-		wflags = DISPATCH_WAKEUP_CONSUME_2 | DISPATCH_WAKEUP_MAKE_DIRTY;
-	}
-	_dispatch_mach_send_push_update_prev(dmsr, prev, dou._do);
-
-	if (unlikely(dmsr->dmsr_disconnect_cnt ||
-			(dm->dq_atomic_flags & DSF_CANCELED))) {
-		os_atomic_rmw_loop2o(dmsr, dmsr_state, old_state, new_state, release, {
-			new_state = _dmsr_state_merge_override(old_state, qos);
-			new_state |= state_flags;
-		});
-		if ((old_state ^ new_state) & DISPATCH_MACH_STATE_ENQUEUED) {
-			wflags &= ~(dispatch_wakeup_flags_t)DISPATCH_WAKEUP_CONSUME_2;
-		}
-		dx_wakeup(dm, qos, wflags);
-		return false;
-	}
-
-	canlock_mask = DISPATCH_MACH_STATE_UNLOCK_MASK |
-			DISPATCH_MACH_STATE_PENDING_BARRIER;
-	if (state_flags) {
-		os_atomic_rmw_loop2o(dmsr, dmsr_state, old_state, new_state, seq_cst, {
-			new_state = _dmsr_state_merge_override(old_state, qos);
-			new_state |= state_flags;
-			if (likely((old_state & canlock_mask) == 0)) {
-				new_state |= owner_self;
-				new_state &= ~DISPATCH_MACH_STATE_DIRTY;
-				new_state &= ~DISPATCH_MACH_STATE_RECEIVED_OVERRIDE;
-				new_state &= ~DISPATCH_MACH_STATE_PENDING_BARRIER;
-			}
-		});
-		if ((old_state ^ new_state) & DISPATCH_MACH_STATE_ENQUEUED) {
-			wflags &= ~(dispatch_wakeup_flags_t)DISPATCH_WAKEUP_CONSUME_2;
-		}
-	} else {
-		os_atomic_rmw_loop2o(dmsr, dmsr_state, old_state, new_state, acquire, {
-			new_state = _dmsr_state_merge_override(old_state, qos);
-			if (new_state == old_state) {
-				os_atomic_rmw_loop_give_up(return false);
-			}
-			if (likely((old_state & canlock_mask) == 0)) {
-				new_state |= owner_self;
-				new_state &= ~DISPATCH_MACH_STATE_DIRTY;
-				new_state &= ~DISPATCH_MACH_STATE_RECEIVED_OVERRIDE;
-				new_state &= ~DISPATCH_MACH_STATE_PENDING_BARRIER;
-			}
-		});
-	}
-
-	owner = _dispatch_lock_owner((dispatch_lock)old_state);
-	if (owner) {
-		if (_dmsr_state_needs_override(old_state, qos)) {
-			_dispatch_wqthread_override_start_check_owner(owner, qos,
-					&dmsr->dmsr_state_lock.dul_lock);
-		}
-		if (wflags & DISPATCH_WAKEUP_CONSUME_2) _dispatch_release_2(dm);
-		return false;
-	}
-
-	if (old_state & DISPATCH_MACH_STATE_PENDING_BARRIER) {
-		dx_wakeup(dm, qos, wflags);
-		return false;
-	}
-
-	// Ensure our message is still at the head of the queue and has not already
-	// been dequeued by another thread that raced us to the send queue lock.
-	// A plain load of the head and comparison against our object pointer is
-	// sufficient.
-	if (unlikely(!(wflags && dou._do == dmsr->dmsr_head))) {
-		// Don't request immediate send result for messages we don't own
-		send_flags &= ~DM_SEND_INVOKE_IMMEDIATE_SEND_MASK;
-	}
-	if (wflags & DISPATCH_WAKEUP_CONSUME_2) _dispatch_release_2_no_dispose(dm);
-	return _dispatch_mach_send_drain(dm, DISPATCH_INVOKE_NONE, send_flags);
-}
-
-#pragma mark -
-#pragma mark dispatch_mach
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_mach_notification_kevent_unregister(dispatch_mach_t dm)
-{
-	uint32_t duu_options = DUU_DELETE_ACK | DUU_MUST_SUCCEED;
-	DISPATCH_ASSERT_ON_MANAGER_QUEUE();
-	_dispatch_unote_unregister(dm->dm_send_refs, duu_options);
-	dm->dm_send_refs->du_ident = 0;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_mach_notification_kevent_register(dispatch_mach_t dm,mach_port_t send)
-{
-	DISPATCH_ASSERT_ON_MANAGER_QUEUE();
-	dm->dm_send_refs->du_ident = send;
-	dispatch_assume(_dispatch_unote_register(dm->dm_send_refs,
-			DISPATCH_WLH_ANON, DISPATCH_PRIORITY_FLAG_MANAGER));
-}
-
-void
-_dispatch_mach_notification_merge_evt(dispatch_unote_t du,
-		uint32_t flags DISPATCH_UNUSED, uintptr_t data,
-		pthread_priority_t pp DISPATCH_UNUSED)
-{
-	dispatch_mach_send_refs_t dmsr = du._dmsr;
-	dispatch_mach_t dm = _dispatch_wref2ptr(dmsr->du_owner_wref);
-
-	if (data & dmsr->du_fflags) {
-		_dispatch_mach_send_invoke(dm, DISPATCH_INVOKE_MANAGER_DRAIN,
-				DM_SEND_INVOKE_MAKE_DIRTY);
-	}
-	_dispatch_release_2_tailcall(dm);
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_mach_handle_or_push_received_msg(dispatch_mach_t dm,
-		dispatch_mach_msg_t dmsg, pthread_priority_t pp)
-{
-	mach_error_t error;
-	dispatch_mach_reason_t reason = _dispatch_mach_msg_get_reason(dmsg, &error);
-	dispatch_qos_t qos;
-
-	if (reason == DISPATCH_MACH_MESSAGE_RECEIVED || !dm->dm_is_xpc ||
-			!_dispatch_mach_xpc_hooks->dmxh_direct_message_handler(
-			dm->dm_recv_refs->dmrr_handler_ctxt, reason, dmsg, error)) {
-		// Not XPC client or not a message that XPC can handle inline - push
-		// it onto the channel queue.
-		_dispatch_trace_item_push(dm, dmsg);
-		qos = _dispatch_qos_from_pp(pp);
-		if (!qos) qos = _dispatch_priority_qos(dm->dq_priority);
-		dm_push(dm, dmsg, qos);
-	} else {
-		// XPC handled the message inline. Do the cleanup that would otherwise
-		// have happened in _dispatch_mach_msg_invoke(), leaving out steps that
-		// are not required in this context.
-		dmsg->do_next = DISPATCH_OBJECT_LISTLESS;
-		dispatch_release(dmsg);
-	}
-}
-
-DISPATCH_ALWAYS_INLINE
-static void
-_dispatch_mach_push_async_reply_msg(dispatch_mach_t dm,
-		dispatch_mach_msg_t dmsg, dispatch_queue_t drq)
-{
-	// Push the message onto the given queue. This function is only used for
-	// replies to messages sent by
-	// dispatch_mach_send_with_result_and_async_reply_4libxpc().
-	dispatch_continuation_t dc = _dispatch_mach_msg_async_reply_wrap(dmsg, dm);
-	_dispatch_trace_item_push(drq, dc);
-	dx_push(drq, dc, _dispatch_qos_from_pp(dmsg->dmsg_priority));
-}
-
-#pragma mark -
-#pragma mark dispatch_mach_t
-
-static inline mach_msg_option_t
-_dispatch_mach_checkin_options(void)
-{
-	mach_msg_option_t options = 0;
-#if DISPATCH_USE_CHECKIN_NOIMPORTANCE
-	options = MACH_SEND_NOIMPORTANCE; // <rdar://problem/16996737>
-#endif
-	return options;
-}
-
-
-
-static inline mach_msg_option_t
-_dispatch_mach_send_options(void)
-{
-	mach_msg_option_t options = 0;
-	return options;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline mach_msg_option_t
-_dispatch_mach_send_msg_prepare(dispatch_mach_t dm,
-		dispatch_mach_msg_t dmsg, mach_msg_option_t options)
-{
-#if DISPATCH_DEBUG
-	if (dm->dm_is_xpc && (options & DISPATCH_MACH_WAIT_FOR_REPLY) == 0 &&
-			_dispatch_mach_msg_get_reply_port(dmsg)) {
-		dispatch_assert(
-				_dispatch_mach_msg_context_async_reply_queue(dmsg->do_ctxt));
-	}
-#else
-	(void)dm;
-#endif
-	if (DISPATCH_USE_NOIMPORTANCE_QOS && (options & MACH_SEND_NOIMPORTANCE)) {
-		dmsg->dmsg_priority = 0;
-	} else {
-		unsigned int flags = DISPATCH_PRIORITY_PROPAGATE_CURRENT;
-		if ((options & DISPATCH_MACH_WAIT_FOR_REPLY) &&
-				_dispatch_use_mach_special_reply_port()) {
-			// TODO: remove QoS contribution of sync IPC messages to send queue
-			// rdar://31848737
-			flags |= DISPATCH_PRIORITY_PROPAGATE_FOR_SYNC_IPC;
-		}
-		dmsg->dmsg_priority = _dispatch_priority_compute_propagated(0, flags);
-	}
-	dmsg->dmsg_voucher = _voucher_copy();
-	_dispatch_voucher_debug("mach-msg[%p] set", dmsg->dmsg_voucher, dmsg);
-	options |= _dispatch_mach_send_options();
-	dmsg->dmsg_options = options;
-	return options;
-}
-
-DISPATCH_NOINLINE
-static bool
-_dispatch_mach_send_msg(dispatch_mach_t dm, dispatch_mach_msg_t dmsg,
-		dispatch_continuation_t dc_wait, mach_msg_option_t options)
-{
-	dispatch_mach_send_refs_t dmsr = dm->dm_send_refs;
-	if (unlikely(dmsg->do_next != DISPATCH_OBJECT_LISTLESS)) {
-		DISPATCH_CLIENT_CRASH(dmsg->do_next, "Message already enqueued");
-	}
-	options = _dispatch_mach_send_msg_prepare(dm, dmsg, options);
-	dispatch_retain(dmsg);
-	dispatch_qos_t qos = _dispatch_qos_from_pp(dmsg->dmsg_priority);
-	mach_msg_header_t *msg = _dispatch_mach_msg_get_msg(dmsg);
-	dmsg->dmsg_reply = _dispatch_mach_msg_get_reply_port(dmsg);
-	bool is_reply = (MACH_MSGH_BITS_REMOTE(msg->msgh_bits) ==
-			MACH_MSG_TYPE_MOVE_SEND_ONCE);
-
-	uint32_t send_status;
-	bool returning_send_result = false;
-	dispatch_mach_send_invoke_flags_t send_flags = DM_SEND_INVOKE_NONE;
-	if (options & DISPATCH_MACH_RETURN_IMMEDIATE_SEND_RESULT) {
-		send_flags = DM_SEND_INVOKE_IMMEDIATE_SEND;
-	}
-	if (is_reply && !dmsg->dmsg_reply && !dmsr->dmsr_disconnect_cnt &&
-			!(dm->dq_atomic_flags & DSF_CANCELED)) {
-		// replies are sent to a send-once right and don't need the send queue
-		dispatch_assert(!dc_wait);
-		send_status = _dispatch_mach_msg_send(dm, dmsg, NULL, 0, send_flags);
-		dispatch_assert(send_status);
-		returning_send_result = !!(send_status &
-				DM_SEND_STATUS_RETURNING_IMMEDIATE_SEND_RESULT);
-	} else {
-		_dispatch_voucher_ktrace_dmsg_push(dmsg);
-		dispatch_object_t dou = { ._dmsg = dmsg };
-		if (dc_wait) dou._dc = dc_wait;
-		returning_send_result = _dispatch_mach_send_push_and_trydrain(dm, dou,
-				qos, send_flags);
-	}
-	if (returning_send_result) {
-		_dispatch_voucher_debug("mach-msg[%p] clear", dmsg->dmsg_voucher, dmsg);
-		if (dmsg->dmsg_voucher) _voucher_release(dmsg->dmsg_voucher);
-		dmsg->dmsg_voucher = NULL;
-		dmsg->do_next = DISPATCH_OBJECT_LISTLESS;
-		dispatch_release(dmsg);
-	}
-	return returning_send_result;
-}
-
-DISPATCH_NOINLINE
-void
-dispatch_mach_send(dispatch_mach_t dm, dispatch_mach_msg_t dmsg,
-		mach_msg_option_t options)
-{
-	dispatch_assert_zero(options & DISPATCH_MACH_OPTIONS_MASK);
-	options &= ~DISPATCH_MACH_OPTIONS_MASK;
-	bool returned_send_result = _dispatch_mach_send_msg(dm, dmsg, NULL, options);
-	dispatch_assert(!returned_send_result);
-}
-
-DISPATCH_NOINLINE
-void
-dispatch_mach_send_with_result(dispatch_mach_t dm, dispatch_mach_msg_t dmsg,
-		mach_msg_option_t options, dispatch_mach_send_flags_t send_flags,
-		dispatch_mach_reason_t *send_result, mach_error_t *send_error)
-{
-	if (unlikely(send_flags != DISPATCH_MACH_SEND_DEFAULT)) {
-		DISPATCH_CLIENT_CRASH(send_flags, "Invalid send flags");
-	}
-	dispatch_assert_zero(options & DISPATCH_MACH_OPTIONS_MASK);
-	options &= ~DISPATCH_MACH_OPTIONS_MASK;
-	options |= DISPATCH_MACH_RETURN_IMMEDIATE_SEND_RESULT;
-	bool returned_send_result = _dispatch_mach_send_msg(dm, dmsg, NULL,options);
-	unsigned long reason = DISPATCH_MACH_NEEDS_DEFERRED_SEND;
-	mach_error_t err = 0;
-	if (returned_send_result) {
-		reason = _dispatch_mach_msg_get_reason(dmsg, &err);
-	}
-	*send_result = reason;
-	*send_error = err;
-}
-
-static inline
-dispatch_mach_msg_t
-_dispatch_mach_send_and_wait_for_reply(dispatch_mach_t dm,
-		dispatch_mach_msg_t dmsg, mach_msg_option_t options,
-		bool *returned_send_result)
-{
-	struct dispatch_mach_reply_wait_refs_s dwr_buf = {
-		.dwr_refs = {
-			.du_type = DISPATCH_MACH_TYPE_WAITER,
-			.dmr_ctxt = dmsg->do_ctxt,
-		},
-		.dwr_waiter_tid = _dispatch_tid_self(),
-	};
-	dispatch_mach_reply_wait_refs_t dwr = &dwr_buf;
-	mach_port_t send = MACH_PORT_NULL;
-	mach_port_t reply_port = _dispatch_mach_msg_get_reply_port(dmsg);
-
-	if (likely(!reply_port)) {
-		// use per-thread mach reply port <rdar://24597802>
-		reply_port = _dispatch_get_thread_reply_port();
-		mach_msg_header_t *hdr = _dispatch_mach_msg_get_msg(dmsg);
-		dispatch_assert(MACH_MSGH_BITS_LOCAL(hdr->msgh_bits) ==
-				MACH_MSG_TYPE_MAKE_SEND_ONCE);
-		hdr->msgh_local_port = reply_port;
-		dwr->dwr_refs.dmr_reply_port_owned = true;
-	}
-	options |= DISPATCH_MACH_WAIT_FOR_REPLY;
-
-#if DISPATCH_DEBUG
-	dwr = _dispatch_calloc(1, sizeof(*dwr));
-	*dwr = dwr_buf;
-#endif
-	struct dispatch_continuation_s dc_wait = {
-		.dc_flags = DC_FLAG_SYNC_WAITER,
-		.dc_data = dmsg,
-		.dc_other = &dwr->dwr_refs,
-		.dc_priority = DISPATCH_NO_PRIORITY,
-		.dc_voucher = DISPATCH_NO_VOUCHER,
-	};
-	*returned_send_result = _dispatch_mach_send_msg(dm, dmsg, &dc_wait,options);
-	if (dwr->dwr_refs.dmr_reply_port_owned) {
-		_dispatch_clear_thread_reply_port(reply_port);
-		if (_dispatch_use_mach_special_reply_port()) {
-			// link special reply port to send right for remote receive right
-			// TODO: extend to pre-connect phase <rdar://problem/31823384>
-			send = dm->dm_send_refs->dmsr_send;
-		}
-	}
-	dmsg = _dispatch_mach_msg_reply_recv(dm, dwr, reply_port, send);
-#if DISPATCH_DEBUG
-	free(dwr);
-#endif
-	return dmsg;
-}
-
-DISPATCH_NOINLINE
-dispatch_mach_msg_t
-dispatch_mach_send_and_wait_for_reply(dispatch_mach_t dm,
-		dispatch_mach_msg_t dmsg, mach_msg_option_t options)
-{
-	bool returned_send_result;
-	dispatch_mach_msg_t reply;
-	dispatch_assert_zero(options & DISPATCH_MACH_OPTIONS_MASK);
-	options &= ~DISPATCH_MACH_OPTIONS_MASK;
-	reply = _dispatch_mach_send_and_wait_for_reply(dm, dmsg, options,
-			&returned_send_result);
-	dispatch_assert(!returned_send_result);
-	return reply;
-}
-
-DISPATCH_NOINLINE
-dispatch_mach_msg_t
-dispatch_mach_send_with_result_and_wait_for_reply(dispatch_mach_t dm,
-		dispatch_mach_msg_t dmsg, mach_msg_option_t options,
-		dispatch_mach_send_flags_t send_flags,
-		dispatch_mach_reason_t *send_result, mach_error_t *send_error)
-{
-	if (unlikely(send_flags != DISPATCH_MACH_SEND_DEFAULT)) {
-		DISPATCH_CLIENT_CRASH(send_flags, "Invalid send flags");
-	}
-	bool returned_send_result;
-	dispatch_mach_msg_t reply;
-	dispatch_assert_zero(options & DISPATCH_MACH_OPTIONS_MASK);
-	options &= ~DISPATCH_MACH_OPTIONS_MASK;
-	options |= DISPATCH_MACH_RETURN_IMMEDIATE_SEND_RESULT;
-	reply = _dispatch_mach_send_and_wait_for_reply(dm, dmsg, options,
-			&returned_send_result);
-	unsigned long reason = DISPATCH_MACH_NEEDS_DEFERRED_SEND;
-	mach_error_t err = 0;
-	if (returned_send_result) {
-		reason = _dispatch_mach_msg_get_reason(dmsg, &err);
-	}
-	*send_result = reason;
-	*send_error = err;
-	return reply;
-}
-
-DISPATCH_NOINLINE
-void
-dispatch_mach_send_with_result_and_async_reply_4libxpc(dispatch_mach_t dm,
-		dispatch_mach_msg_t dmsg, mach_msg_option_t options,
-		dispatch_mach_send_flags_t send_flags,
-		dispatch_mach_reason_t *send_result, mach_error_t *send_error)
-{
-	if (unlikely(send_flags != DISPATCH_MACH_SEND_DEFAULT)) {
-		DISPATCH_CLIENT_CRASH(send_flags, "Invalid send flags");
-	}
-	if (unlikely(!dm->dm_is_xpc)) {
-		DISPATCH_CLIENT_CRASH(0,
-			"dispatch_mach_send_with_result_and_wait_for_reply is XPC only");
-	}
-
-	dispatch_assert_zero(options & DISPATCH_MACH_OPTIONS_MASK);
-	options &= ~DISPATCH_MACH_OPTIONS_MASK;
-	options |= DISPATCH_MACH_RETURN_IMMEDIATE_SEND_RESULT;
-	mach_port_t reply_port = _dispatch_mach_msg_get_reply_port(dmsg);
-	if (!reply_port) {
-		DISPATCH_CLIENT_CRASH(0, "Reply port needed for async send with reply");
-	}
-	bool returned_send_result = _dispatch_mach_send_msg(dm, dmsg, NULL,options);
-	unsigned long reason = DISPATCH_MACH_NEEDS_DEFERRED_SEND;
-	mach_error_t err = 0;
-	if (returned_send_result) {
-		reason = _dispatch_mach_msg_get_reason(dmsg, &err);
-	}
-	*send_result = reason;
-	*send_error = err;
-}
-
-DISPATCH_NOINLINE
-static bool
-_dispatch_mach_cancel(dispatch_mach_t dm)
-{
-	bool uninstalled = dm->dm_disconnected;
-	if (dm->dm_send_refs->dmsr_disconnect_cnt) {
-		uninstalled = false; // <rdar://problem/31233110>
-	}
-
-	_dispatch_object_debug(dm, "%s", __func__);
-
-	uint32_t duu_options = DMRU_DELETE_ACK;
-	if (!(_dispatch_queue_atomic_flags(dm) & DSF_NEEDS_EVENT)) {
-		duu_options |= DMRU_PROBE;
-	}
-
-	dispatch_xpc_term_refs_t dxtr = dm->dm_xpc_term_refs;
-	if (dxtr && !_dispatch_unote_unregister(dxtr, duu_options)) {
-		uninstalled = false;
-	}
-
-	dispatch_mach_recv_refs_t dmrr = dm->dm_recv_refs;
-	mach_port_t local_port = (mach_port_t)dmrr->du_ident;
-	if (local_port) {
-		// handle the deferred delete case properly, similar to what
-		// _dispatch_source_invoke2() does
-		if (_dispatch_unote_unregister(dmrr, duu_options)) {
-			_dispatch_mach_msg_disconnected(dm, local_port, MACH_PORT_NULL);
-			dmrr->du_ident = 0;
-		} else {
-			uninstalled = false;
-		}
-	}
-
-	if (uninstalled) {
-		dispatch_queue_flags_t dqf;
-		dqf = _dispatch_queue_atomic_flags_set_and_clear_orig(dm,
-				DSF_DELETED, DSF_NEEDS_EVENT);
-		if (unlikely(dqf & (DSF_DELETED | DSF_CANCEL_WAITER))) {
-			DISPATCH_CLIENT_CRASH(dqf, "Corrupt channel state");
-		}
-		_dispatch_release_no_dispose(dm); // see _dispatch_queue_alloc()
-	} else {
-		_dispatch_queue_atomic_flags_set(dm, DSF_NEEDS_EVENT);
-	}
-	return uninstalled;
-}
-
-DISPATCH_NOINLINE
-static bool
-_dispatch_mach_reconnect_invoke(dispatch_mach_t dm, dispatch_object_t dou)
-{
-	_dispatch_object_debug(dm, "%s", __func__);
-
-	// 1. handle the send-possible notification and checkin message
-
-	dispatch_mach_send_refs_t dmsr = dm->dm_send_refs;
-	if (_dispatch_unote_registered(dmsr)) {
-		_dispatch_mach_notification_kevent_unregister(dm);
-	}
-	if (MACH_PORT_VALID(dmsr->dmsr_send)) {
-		_dispatch_mach_msg_disconnected(dm, MACH_PORT_NULL, dmsr->dmsr_send);
-		dmsr->dmsr_send = MACH_PORT_NULL;
-	}
-	if (dmsr->dmsr_checkin) {
-		_dispatch_mach_msg_not_sent(dm, dmsr->dmsr_checkin, NULL);
-		dmsr->dmsr_checkin = NULL;
-	}
-	dm->dm_needs_mgr = 0;
-
-	// 2. cancel all pending replies and break out synchronous waiters
-
-	dispatch_mach_reply_refs_t dmr, tmp;
-	LIST_HEAD(, dispatch_mach_reply_refs_s) replies =
-			LIST_HEAD_INITIALIZER(replies);
-	bool disconnected;
-
-	// _dispatch_mach_reply_merge_msg is the one passing DMRU_DELETE_ACK
-	uint32_t dmru_options = DMRU_CANCEL | DMRU_DISCONNECTED;
-	if (!(_dispatch_queue_atomic_flags(dm) & DSF_NEEDS_EVENT)) {
-		dmru_options |= DMRU_PROBE;
-	}
-
-	_dispatch_unfair_lock_lock(&dmsr->dmsr_replies_lock);
-	LIST_SWAP(&replies, &dmsr->dmsr_replies,
-			dispatch_mach_reply_refs_s, dmr_list);
-	LIST_FOREACH_SAFE(dmr, &replies, dmr_list, tmp) {
-		_LIST_MARK_NOT_ENQUEUED(dmr, dmr_list);
-		_dispatch_mach_reply_unregister(dm, dmr, dmru_options);
-	}
-	// any unote unregistration that fails is put back on the reply list
-	disconnected = LIST_EMPTY(&dmsr->dmsr_replies);
-	_dispatch_unfair_lock_unlock(&dmsr->dmsr_replies_lock);
-
-	// 3. if no reply is left pending deferred deletion, finish reconnecting
-
-	if (disconnected) {
-		mach_port_t dmsr_send = (mach_port_t)dou._dc->dc_other;
-		dispatch_mach_msg_t dmsr_checkin = dou._dc->dc_data;
-
-		_dispatch_continuation_free(dou._dc);
-		if (dmsr_checkin == DM_CHECKIN_CANCELED) {
-			dm->dm_disconnected = true;
-			dmsr_checkin = NULL;
-		}
-		if (dm->dm_disconnected) {
-			if (MACH_PORT_VALID(dmsr_send)) {
-				_dispatch_mach_msg_disconnected(dm, MACH_PORT_NULL, dmsr_send);
-			}
-			if (dmsr_checkin) {
-				_dispatch_mach_msg_not_sent(dm, dmsr_checkin, NULL);
-			}
-		} else {
-			dmsr->dmsr_send = dmsr_send;
-			dmsr->dmsr_checkin = dmsr_checkin;
-		}
-		(void)os_atomic_dec2o(dmsr, dmsr_disconnect_cnt, relaxed);
-	}
-	return disconnected;
-}
-
-DISPATCH_NOINLINE
-void
-dispatch_mach_reconnect(dispatch_mach_t dm, mach_port_t send,
-		dispatch_mach_msg_t checkin)
-{
-	dispatch_mach_send_refs_t dmsr = dm->dm_send_refs;
-	(void)os_atomic_inc2o(dmsr, dmsr_disconnect_cnt, relaxed);
-	if (MACH_PORT_VALID(send) && checkin) {
-		dispatch_mach_msg_t dmsg = checkin;
-		dispatch_retain(dmsg);
-		dmsg->dmsg_options = _dispatch_mach_checkin_options();
-		dmsr->dmsr_checkin_port = _dispatch_mach_msg_get_remote_port(dmsg);
-	} else {
-		if (checkin != DM_CHECKIN_CANCELED) checkin = NULL;
-		dmsr->dmsr_checkin_port = MACH_PORT_NULL;
-	}
-	dispatch_continuation_t dc = _dispatch_continuation_alloc();
-	dc->dc_flags = DC_FLAG_CONSUME | DC_FLAG_ALLOCATED;
-	// actually called manually in _dispatch_mach_send_drain
-	dc->dc_func = (void*)_dispatch_mach_reconnect_invoke;
-	dc->dc_ctxt = dc;
-	dc->dc_data = checkin;
-	dc->dc_other = (void*)(uintptr_t)send;
-	dc->dc_voucher = DISPATCH_NO_VOUCHER;
-	dc->dc_priority = DISPATCH_NO_PRIORITY;
-	return _dispatch_mach_send_push(dm, dc, 0);
-}
-
-DISPATCH_NOINLINE
-mach_port_t
-dispatch_mach_get_checkin_port(dispatch_mach_t dm)
-{
-	dispatch_mach_send_refs_t dmsr = dm->dm_send_refs;
-	if (unlikely(dm->dq_atomic_flags & DSF_CANCELED)) {
-		return MACH_PORT_DEAD;
-	}
-	return dmsr->dmsr_checkin_port;
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_mach_connect_invoke(dispatch_mach_t dm)
-{
-	dispatch_mach_recv_refs_t dmrr = dm->dm_recv_refs;
-	_dispatch_client_callout4(dmrr->dmrr_handler_ctxt,
-			DISPATCH_MACH_CONNECTED, NULL, 0, dmrr->dmrr_handler_func);
-	dm->dm_connect_handler_called = 1;
-	_dispatch_perfmon_workitem_inc();
-}
-
-typedef struct dispatch_ipc_handoff_s {
-	struct dispatch_continuation_s dih_dc;
-	uint64_t _Atomic dih_wlh;
-	int32_t dih_refcnt;
-} dispatch_ipc_handoff_s, *dispatch_ipc_handoff_t;
-
-typedef struct _dispatch_ipc_handoff_context_s {
-	dispatch_thread_context_s dihc_dtc;
-	dispatch_queue_t dihc_dq;
-	dispatch_qos_t dihc_qos;
-} _dispatch_ipc_handoff_context_s, *_dispatch_ipc_handoff_ctxt_t;
-
-static char const * const
-_dispatch_mach_msg_context_key = "mach_msg";
-
-static _dispatch_ipc_handoff_ctxt_t
-_dispatch_mach_handoff_context(mach_port_t port)
-{
-	dispatch_thread_context_t dtc;
-	_dispatch_ipc_handoff_ctxt_t dihc = NULL;
-	dispatch_ipc_handoff_t dih;
-
-	dtc = _dispatch_thread_context_find(_dispatch_mach_msg_context_key);
-	if (dtc && dtc->dtc_dmsg) {
-		/*
-		 * We need one refcount per async() done,
-		 * and one for the whole chain.
-		 */
-		dihc = (_dispatch_ipc_handoff_ctxt_t)dtc;
-		if (dx_type(dtc->dtc_dmsg) == DISPATCH_MACH_MSG_TYPE) {
-			dtc->dtc_dih = _dispatch_calloc(1, sizeof(dispatch_ipc_handoff_s));
-			dih = dtc->dtc_dih;
-			os_atomic_store(&dih->dih_refcnt, 1, relaxed);
-		} else {
-			dih = dtc->dtc_dih;
-			os_atomic_inc(&dih->dih_refcnt, relaxed);
-		}
-		if (dih->dih_dc.dc_other) {
-			DISPATCH_CLIENT_CRASH(0, "Calling dispatch_mach_handoff_reply "
-					"multiple times from the same context");
-		}
-	} else  {
-		DISPATCH_CLIENT_CRASH(0, "Trying to handoff IPC from non IPC context");
-	}
-
-	dih->dih_dc.dc_other = (void *)(uintptr_t)port;
-	return dihc;
-}
-
-static void
-_dispatch_ipc_handoff_release(dispatch_ipc_handoff_t dih)
-{
-	if (os_atomic_dec_orig(&dih->dih_refcnt, relaxed) == 0) {
-		free(dih);
-	}
-}
-
-static void
-_dispatch_mach_handoff_set_wlh(dispatch_ipc_handoff_t dih, dispatch_queue_t dq)
-{
-	while (likely(dq->do_targetq)) {
-		if (unlikely(_dispatch_queue_is_mutable(dq))) {
-			DISPATCH_CLIENT_CRASH(0,
-					"Trying to handoff IPC onto mutable hierarchy");
-		}
-		if (_dq_state_is_base_wlh(dq->dq_state)) {
-			os_atomic_store(&dih->dih_wlh, (uint64_t)dq, relaxed);
-			return;
-		}
-	}
-
-	/* unsupported hierarchy */
-	os_atomic_store(&dih->dih_wlh, 0, relaxed);
-}
-
-void
-dispatch_mach_handoff_reply_f(dispatch_queue_t dq,
-		mach_port_t port, void *ctxt, dispatch_function_t func)
-{
-	_dispatch_ipc_handoff_ctxt_t dihc = _dispatch_mach_handoff_context(port);
-	dispatch_ipc_handoff_t dih = dihc->dihc_dtc.dtc_dih;
-	dispatch_continuation_t dc = &dih->dih_dc;
-
-	_dispatch_mach_handoff_set_wlh(dih, dq);
-	_dispatch_retain(dq);
-	dihc->dihc_dq = dq;
-	dihc->dihc_qos = _dispatch_continuation_init_f(dc, dq, ctxt, func, 0, 0);
-	dc->dc_data = (void *)dc->dc_flags;
-	dc->do_vtable = DC_VTABLE(MACH_IPC_HANDOFF);
-}
-
-void
-dispatch_mach_handoff_reply(dispatch_queue_t dq,
-		mach_port_t port, dispatch_block_t block)
-{
-	_dispatch_ipc_handoff_ctxt_t dihc = _dispatch_mach_handoff_context(port);
-	dispatch_ipc_handoff_t dih = dihc->dihc_dtc.dtc_dih;
-	dispatch_continuation_t dc = &dih->dih_dc;
-
-	_dispatch_retain(dq);
-	dihc->dihc_dq = dq;
-	dihc->dihc_qos = _dispatch_continuation_init(dc, dq, block, 0, 0);
-	dc->dc_data = (void *)dc->dc_flags;
-	dc->do_vtable = DC_VTABLE(MACH_IPC_HANDOFF);
-}
-
-static void
-_dispatch_mach_ipc_handoff_async(_dispatch_ipc_handoff_ctxt_t dihc)
-{
-	dispatch_ipc_handoff_t dih = dihc->dihc_dtc.dtc_dih;
-	dispatch_continuation_t dc = &dih->dih_dc;
-	mach_port_t port = (mach_port_t)(uintptr_t)dc->dc_other;
-	uint64_t wlh = os_atomic_load(&dih->dih_wlh, relaxed);
-
-	_dispatch_continuation_async(dihc->dihc_dq, dc, dihc->dihc_qos,
-			(uintptr_t)dc->dc_data);
-
-	if (wlh) {
-		_dispatch_sync_ipc_handoff_begin((dispatch_wlh_t)wlh, port,
-				&dih->dih_wlh);
-		os_atomic_cmpxchg(&dih->dih_wlh, wlh, ~wlh, relaxed);
-	}
-
-	_dispatch_ipc_handoff_release(dih);
-	_dispatch_release_tailcall(dihc->dihc_dq);
-}
-
-void
-_dispatch_mach_ipc_handoff_invoke(dispatch_continuation_t dc,
-		dispatch_invoke_context_t dic DISPATCH_UNUSED,
-		dispatch_invoke_flags_t flags)
-{
-	dispatch_ipc_handoff_t dih = (dispatch_ipc_handoff_t)dc;
-	_dispatch_ipc_handoff_context_s dihc = { .dihc_dtc = {
-		.dtc_key = _dispatch_mach_msg_context_key,
-		.dtc_dih = dih,
-	} };
-
-	dispatch_queue_t cq = _dispatch_queue_get_current();
-	uintptr_t dc_flags = (uintptr_t)dc->dc_data;
-	mach_port_t port = (mach_port_t)(uintptr_t)dc->dc_other;
-	uint64_t wlh = os_atomic_xchg(&dih->dih_wlh, 0, relaxed);
-
-	if (wlh == 0) {
-		/* not supported */
-	} else if (wlh & 1) {
-		/* _dispatch_mach_ipc_handoff_async finished its work */
-		wlh = ~wlh;
-	} else {
-		/*
-		 * Because this code may race with _dispatch_mach_ipc_handoff_async,
-		 * Make sure that we have the push.
-		 *
-		 * Then mark the handoff as done, as the client callout below
-		 * may consume the send once, and _dispatch_mach_ipc_handoff_async
-		 * may be about an invalid port now.
-		 */
-		_dispatch_sync_ipc_handoff_begin((dispatch_wlh_t)wlh, port,
-				&dih->dih_wlh);
-	}
-
-	dc->do_next = DISPATCH_OBJECT_LISTLESS;
-	dc->dc_other = NULL;
-
-	_dispatch_thread_context_push(&dihc.dihc_dtc);
-
-	_dispatch_continuation_pop_forwarded(dc, dc_flags, cq, {
-		dispatch_invoke_with_autoreleasepool(flags, {
-			_dispatch_client_callout(dc->dc_ctxt, dc->dc_func);
-			_dispatch_trace_item_complete(dc);
-		});
-	});
-
-	_dispatch_thread_context_pop(&dihc.dihc_dtc);
-
-	if (dihc.dihc_dq) {
-		/* a new handoff was started */
-		_dispatch_mach_ipc_handoff_async(&dihc);
-	} else {
-		/* this was the last handoff in the chain, consume the last ref */
-		_dispatch_ipc_handoff_release(dih);
-	}
-
-	if (wlh) {
-		_dispatch_sync_ipc_handoff_end((dispatch_wlh_t)wlh, port);
-	}
-}
-
-DISPATCH_ALWAYS_INLINE
-static void
-_dispatch_mach_msg_invoke_with_mach(dispatch_mach_msg_t dmsg,
-		dispatch_invoke_flags_t flags, dispatch_mach_t dm)
-{
-	dispatch_mach_recv_refs_t dmrr;
-	mach_error_t err;
-	unsigned long reason = _dispatch_mach_msg_get_reason(dmsg, &err);
-	dispatch_thread_set_self_t adopt_flags = DISPATCH_PRIORITY_ENFORCE|
-			DISPATCH_VOUCHER_CONSUME|DISPATCH_VOUCHER_REPLACE;
-	_dispatch_ipc_handoff_context_s dihc = { .dihc_dtc = {
-		.dtc_key = _dispatch_mach_msg_context_key,
-		.dtc_dmsg = dmsg,
-	} };
-
-	_dispatch_thread_context_push(&dihc.dihc_dtc);
-	_dispatch_trace_item_pop(dm, dmsg);
-
-	dmrr = dm->dm_recv_refs;
-	dmsg->do_next = DISPATCH_OBJECT_LISTLESS;
-	_dispatch_voucher_ktrace_dmsg_pop(dmsg);
-	_dispatch_voucher_debug("mach-msg[%p] adopt", dmsg->dmsg_voucher, dmsg);
-	(void)_dispatch_adopt_priority_and_set_voucher(dmsg->dmsg_priority,
-			dmsg->dmsg_voucher, adopt_flags);
-	dmsg->dmsg_voucher = NULL;
-	dispatch_invoke_with_autoreleasepool(flags, {
-		if (flags & DISPATCH_INVOKE_ASYNC_REPLY) {
-			_dispatch_client_callout3(dmrr->dmrr_handler_ctxt, reason, dmsg,
-					_dispatch_mach_xpc_hooks->dmxh_async_reply_handler);
-		} else {
-			if (unlikely(!dm->dm_connect_handler_called)) {
-				_dispatch_mach_connect_invoke(dm);
-			}
-			if (reason == DISPATCH_MACH_MESSAGE_RECEIVED &&
-					(_dispatch_queue_atomic_flags(dm) & DSF_CANCELED)) {
-				// <rdar://problem/32184699> Do not deliver message received
-				// after cancellation: _dispatch_mach_merge_msg can be preempted
-				// for a long time right after disarming the unote but before
-				// enqueuing the message, allowing for cancellation to complete,
-				// and then the message event to be delivered.
-				//
-				// This makes XPC unhappy because some of these messages are
-				// port-destroyed notifications that can cause it to try to
-				// reconnect on a channel that is almost fully canceled
-				mach_msg_header_t *hdr = _dispatch_mach_msg_get_msg(dmsg);
-				_dispatch_debug("machport[0x%08x]: drop msg id 0x%x, reply on 0x%08x",
-						hdr->msgh_local_port, hdr->msgh_id, hdr->msgh_remote_port);
-				mach_msg_destroy(hdr);
-			} else {
-				_dispatch_client_callout4(dmrr->dmrr_handler_ctxt, reason, dmsg,
-						err, dmrr->dmrr_handler_func);
-			}
-		}
-		_dispatch_perfmon_workitem_inc();
-	});
-	_dispatch_trace_item_complete(dmsg);
-	dispatch_release(dmsg);
-	_dispatch_thread_context_pop(&dihc.dihc_dtc);
-
-	if (dihc.dihc_dq) {
-		_dispatch_mach_ipc_handoff_async(&dihc);
-	}
-}
-
-DISPATCH_NOINLINE
-void
-_dispatch_mach_msg_invoke(dispatch_mach_msg_t dmsg,
-		DISPATCH_UNUSED dispatch_invoke_context_t dic,
-		dispatch_invoke_flags_t flags)
-{
-	dispatch_thread_frame_s dtf;
-
-	// hide mach channel
-	dispatch_mach_t dm = upcast(_dispatch_thread_frame_stash(&dtf))._dm;
-	_dispatch_mach_msg_invoke_with_mach(dmsg, flags, dm);
-	_dispatch_thread_frame_unstash(&dtf);
-}
-
-DISPATCH_NOINLINE
-void
-_dispatch_mach_barrier_invoke(dispatch_continuation_t dc,
-		DISPATCH_UNUSED dispatch_invoke_context_t dic,
-		dispatch_invoke_flags_t flags)
-{
-	dispatch_thread_frame_s dtf;
-	dispatch_mach_t dm = dc->dc_other;
-	dispatch_mach_recv_refs_t dmrr;
-	uintptr_t dc_flags = (uintptr_t)dc->dc_data;
-	unsigned long type = dc_type(dc);
-
-	// hide mach channel from clients
-	if (type == DISPATCH_CONTINUATION_TYPE(MACH_RECV_BARRIER)) {
-		// on the send queue, the mach channel isn't the current queue
-		// its target queue is the current one already
-		_dispatch_thread_frame_stash(&dtf);
-	}
-	dmrr = dm->dm_recv_refs;
-	DISPATCH_COMPILER_CAN_ASSUME(dc_flags & DC_FLAG_CONSUME);
-	if (unlikely(!dm->dm_connect_handler_called)) {
-		dispatch_invoke_with_autoreleasepool(flags, {
-			// do not coalesce with the block below due to continuation reuse
-			_dispatch_mach_connect_invoke(dm);
-		});
-	}
-	_dispatch_continuation_pop_forwarded(dc, dc_flags, dm, {
-		dispatch_invoke_with_autoreleasepool(flags, {
-			_dispatch_client_callout(dc->dc_ctxt, dc->dc_func);
-			_dispatch_client_callout4(dmrr->dmrr_handler_ctxt,
-					DISPATCH_MACH_BARRIER_COMPLETED, NULL, 0,
-					dmrr->dmrr_handler_func);
-		});
-	});
-	if (type == DISPATCH_CONTINUATION_TYPE(MACH_RECV_BARRIER)) {
-		_dispatch_thread_frame_unstash(&dtf);
-	}
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_mach_barrier_set_vtable(dispatch_continuation_t dc,
-		dispatch_mach_t dm, dispatch_continuation_vtable_t vtable)
-{
-	dc->dc_data = (void *)dc->dc_flags;
-	dc->dc_other = dm;
-	dc->do_vtable = vtable; // Must be after dc_flags load, dc_vtable aliases
-}
-
-DISPATCH_NOINLINE
-void
-dispatch_mach_send_barrier_f(dispatch_mach_t dm, void *context,
-		dispatch_function_t func)
-{
-	dispatch_continuation_t dc = _dispatch_continuation_alloc();
-	uintptr_t dc_flags = DC_FLAG_CONSUME;
-	dispatch_qos_t qos;
-
-	_dispatch_continuation_init_f(dc, dm, context, func, 0, dc_flags);
-	_dispatch_mach_barrier_set_vtable(dc, dm, DC_VTABLE(MACH_SEND_BARRIER));
-	_dispatch_trace_item_push(dm, dc);
-	qos = _dispatch_qos_from_pp(dc->dc_priority);
-	return _dispatch_mach_send_push(dm, dc, qos);
-}
-
-DISPATCH_NOINLINE
-void
-dispatch_mach_send_barrier(dispatch_mach_t dm, dispatch_block_t barrier)
-{
-	dispatch_continuation_t dc = _dispatch_continuation_alloc();
-	uintptr_t dc_flags = DC_FLAG_CONSUME;
-	dispatch_qos_t qos;
-
-	_dispatch_continuation_init(dc, dm, barrier, 0, dc_flags);
-	_dispatch_mach_barrier_set_vtable(dc, dm, DC_VTABLE(MACH_SEND_BARRIER));
-	_dispatch_trace_item_push(dm, dc);
-	qos = _dispatch_qos_from_pp(dc->dc_priority);
-	return _dispatch_mach_send_push(dm, dc, qos);
-}
-
-DISPATCH_NOINLINE
-void
-dispatch_mach_receive_barrier_f(dispatch_mach_t dm, void *context,
-		dispatch_function_t func)
-{
-	dispatch_continuation_t dc = _dispatch_continuation_alloc();
-	uintptr_t dc_flags = DC_FLAG_CONSUME;
-	dispatch_qos_t qos;
-
-	qos = _dispatch_continuation_init_f(dc, dm, context, func, 0, dc_flags);
-	_dispatch_mach_barrier_set_vtable(dc, dm, DC_VTABLE(MACH_RECV_BARRIER));
-	return _dispatch_continuation_async(dm, dc, qos, dc_flags);
-}
-
-DISPATCH_NOINLINE
-void
-dispatch_mach_receive_barrier(dispatch_mach_t dm, dispatch_block_t barrier)
-{
-	dispatch_continuation_t dc = _dispatch_continuation_alloc();
-	uintptr_t dc_flags = DC_FLAG_CONSUME;
-	dispatch_qos_t qos;
-
-	qos = _dispatch_continuation_init(dc, dm, barrier, 0, dc_flags);
-	_dispatch_mach_barrier_set_vtable(dc, dm, DC_VTABLE(MACH_RECV_BARRIER));
-	return _dispatch_continuation_async(dm, dc, qos, dc_flags);
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_mach_cancel_invoke(dispatch_mach_t dm, dispatch_invoke_flags_t flags)
-{
-	dispatch_mach_recv_refs_t dmrr = dm->dm_recv_refs;
-
-	dispatch_invoke_with_autoreleasepool(flags, {
-		if (unlikely(!dm->dm_connect_handler_called)) {
-			_dispatch_mach_connect_invoke(dm);
-		}
-		_dispatch_client_callout4(dmrr->dmrr_handler_ctxt,
-				DISPATCH_MACH_CANCELED, NULL, 0, dmrr->dmrr_handler_func);
-		_dispatch_perfmon_workitem_inc();
-	});
-	dm->dm_cancel_handler_called = 1;
-}
-
-DISPATCH_NOINLINE
-void
-dispatch_mach_cancel(dispatch_mach_t dm)
-{
-	dispatch_queue_flags_t dqf;
-
-	_dispatch_object_debug(dm, "%s", __func__);
-	// <rdar://problem/34849210> similar race to dispatch_source_cancel
-	// Once we set the DSF_CANCELED bit, anyone can notice and finish the
-	// unregistration causing use after free in dispatch_mach_reconnect() below.
-	_dispatch_retain(dm);
-	dqf = _dispatch_queue_atomic_flags_set_orig(dm, DSF_CANCELED);
-	if (!(dqf & DSF_CANCELED)) {
-		dispatch_mach_reconnect(dm, MACH_PORT_NULL, DM_CHECKIN_CANCELED);
-	}
-	_dispatch_release_tailcall(dm);
-}
-
-static void
-_dispatch_mach_install(dispatch_mach_t dm, dispatch_wlh_t wlh,
-		dispatch_priority_t pri)
-{
-	bool cancelled = (_dispatch_queue_atomic_flags(dm) & DSF_CANCELED);
-	dispatch_mach_recv_refs_t dmrr = dm->dm_recv_refs;
-
-	dispatch_assert(!dm->ds_is_installed);
-	dm->ds_is_installed = true;
-
-	if (!cancelled && dmrr->du_ident) {
-		(void)_dispatch_unote_register(dmrr, wlh, pri);
-		dispatch_assert(dmrr->du_is_direct);
-	}
-
-	if (!cancelled && dm->dm_is_xpc &&
-			_dispatch_mach_xpc_hooks->dmxh_enable_sigterm_notification(
-			dmrr->dmrr_handler_ctxt)) {
-		dispatch_xpc_term_refs_t _dxtr =
-				dux_create(&_dispatch_xpc_type_sigterm, SIGTERM, 0)._dxtr;
-		_dxtr->du_owner_wref = _dispatch_ptr2wref(dm);
-		dm->dm_xpc_term_refs = _dxtr;
-		_dispatch_unote_register(dm->dm_xpc_term_refs, wlh, pri);
-	}
-	if (!dm->dq_priority) {
-		// _dispatch_mach_reply_kevent_register assumes this has been done
-		// which is unlike regular sources or queues, the FALLBACK flag
-		// is used so that the priority of the channel doesn't act as
-		// a QoS floor for incoming messages (26761457)
-		dm->dq_priority = pri;
-	}
-
-	uint32_t disconnect_cnt = os_atomic_load2o(dm->dm_send_refs,
-			dmsr_disconnect_cnt, relaxed);
-	if (unlikely(disconnect_cnt & DISPATCH_MACH_NEVER_CONNECTED)) {
-		DISPATCH_CLIENT_CRASH(disconnect_cnt, "Channel never connected");
-	}
-}
-
-void
-_dispatch_mach_activate(dispatch_mach_t dm, bool *allow_resume)
-{
-	dispatch_priority_t pri;
-	dispatch_wlh_t wlh;
-
-	// call "super"
-	_dispatch_lane_activate(dm, allow_resume);
-
-	if (!dm->ds_is_installed) {
-		pri = _dispatch_queue_compute_priority_and_wlh(dm, &wlh);
-		if (pri) _dispatch_mach_install(dm, wlh, pri);
-	}
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_mach_handle_wlh_change(dispatch_mach_t dm)
-{
-	dispatch_queue_flags_t dqf;
-
-	dqf = _dispatch_queue_atomic_flags_set_orig(dm, DSF_WLH_CHANGED);
-	if (!(dqf & DQF_MUTABLE)) {
-		if (dm->dm_is_xpc) {
-			DISPATCH_CLIENT_CRASH(0, "Changing target queue "
-					"hierarchy after xpc connection was activated");
-		} else {
-			DISPATCH_CLIENT_CRASH(0, "Changing target queue "
-					"hierarchy after mach channel was connected");
-		}
-	}
-	if (!(dqf & DSF_WLH_CHANGED)) {
-		if (dm->dm_is_xpc) {
-			_dispatch_bug_deprecated("Changing target queue "
-					"hierarchy after xpc connection was activated");
-		} else {
-			_dispatch_bug_deprecated("Changing target queue "
-					"hierarchy after mach channel was connected");
-		}
-	}
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_queue_wakeup_target_t
-_dispatch_mach_invoke2(dispatch_mach_t dm,
-		dispatch_invoke_context_t dic, dispatch_invoke_flags_t flags,
-		uint64_t *owned)
-{
-	dispatch_queue_wakeup_target_t retq = NULL;
-	dispatch_queue_t dq = _dispatch_queue_get_current();
-	dispatch_mach_send_refs_t dmsr = dm->dm_send_refs;
-	dispatch_mach_recv_refs_t dmrr = dm->dm_recv_refs;
-	dispatch_queue_flags_t dqf;
-
-	if (unlikely(!(flags & DISPATCH_INVOKE_MANAGER_DRAIN) && dmrr &&
-			_dispatch_unote_wlh_changed(dmrr, _dispatch_get_event_wlh()))) {
-		_dispatch_mach_handle_wlh_change(dm);
-	}
-
-	// This function performs all mach channel actions. Each action is
-	// responsible for verifying that it takes place on the appropriate queue.
-	// If the current queue is not the correct queue for this action, the
-	// correct queue will be returned and the invoke will be re-driven on that
-	// queue.
-
-	// The order of tests here in invoke and in wakeup should be consistent.
-
-	if (unlikely(!dm->ds_is_installed)) {
-		// The channel needs to be installed on the kevent queue.
-		if (unlikely(flags & DISPATCH_INVOKE_MANAGER_DRAIN)) {
-			return dm->do_targetq;
-		}
-		dispatch_priority_t pri = DISPATCH_PRIORITY_FLAG_MANAGER;
-		if (likely(flags & DISPATCH_INVOKE_WORKER_DRAIN)) {
-			pri = _dispatch_get_basepri();
-		}
-		_dispatch_mach_install(dm, _dispatch_get_event_wlh(), pri);
-		_dispatch_perfmon_workitem_inc();
-	}
-
-	if (_dispatch_queue_class_probe(dm)) {
-		if (dq == dm->do_targetq) {
-drain:
-			retq = _dispatch_lane_serial_drain(dm, dic, flags, owned);
-		} else {
-			retq = dm->do_targetq;
-		}
-	}
-
-	dqf = _dispatch_queue_atomic_flags(dm);
-	if (!retq && !(dqf & DSF_CANCELED) && _dispatch_unote_needs_rearm(dmrr)) {
-		_dispatch_unote_resume(dmrr);
-		if (dq == dm->do_targetq && !dq->do_targetq && !dmsr->dmsr_tail &&
-				(dq->dq_priority & DISPATCH_PRIORITY_FLAG_OVERCOMMIT) &&
-				_dispatch_wlh_should_poll_unote(dmrr)) {
-			// try to redrive the drain from under the lock for channels
-			// targeting an overcommit root queue to avoid parking
-			// when the next message has already fired
-			_dispatch_event_loop_drain(KEVENT_FLAG_IMMEDIATE);
-			if (dm->dq_items_tail) goto drain;
-		}
-		dqf = _dispatch_queue_atomic_flags(dm);
-	}
-
-	if (dmsr->dmsr_tail) {
-		if (!dmsr->dmsr_notification_armed || dmsr->dmsr_disconnect_cnt) {
-			bool requires_mgr = dmsr->dmsr_disconnect_cnt ?
-					_dispatch_unote_registered(dmsr) : dm->dm_needs_mgr;
-			// The channel has pending messages to send.
-			if (unlikely(requires_mgr && dq != _dispatch_mgr_q._as_dq)) {
-				return retq ? retq : _dispatch_mgr_q._as_dq;
-			}
-			dispatch_mach_send_invoke_flags_t send_flags = DM_SEND_INVOKE_NONE;
-			if (dq != _dispatch_mgr_q._as_dq) {
-				send_flags |= DM_SEND_INVOKE_CAN_RUN_BARRIER;
-			}
-			_dispatch_mach_send_invoke(dm, flags, send_flags);
-			if (!retq && dm->dq_items_tail) {
-				retq = dm->do_targetq;
-			}
-		}
-		if (!retq && dmsr->dmsr_tail) {
-			retq = DISPATCH_QUEUE_WAKEUP_WAIT_FOR_EVENT;
-		}
-	}
-
-	if (dqf & DSF_CANCELED) {
-		// The channel has been cancelled and needs to be uninstalled from the
-		// manager queue.
-		if (!(dqf & DSF_DELETED) && !_dispatch_mach_cancel(dm)) {
-			// waiting for the delivery of a deferred delete event
-			return retq ? retq : DISPATCH_QUEUE_WAKEUP_WAIT_FOR_EVENT;
-		}
-
-		// After uninstallation, the cancellation handler needs to be delivered
-		// to the target queue, but not before we drained all messages from the
-		// receive queue.
-		if (!dm->dm_cancel_handler_called) {
-			if (dq != dm->do_targetq) {
-				return retq ? retq : dm->do_targetq;
-			}
-			if (DISPATCH_QUEUE_IS_SUSPENDED(dm)) {
-				return dm->do_targetq;
-			}
-			if (_dispatch_queue_class_probe(dm)) {
-				goto drain;
-			}
-			_dispatch_mach_cancel_invoke(dm, flags);
-		}
-	}
-
-	return retq;
-}
-
-DISPATCH_NOINLINE
-void
-_dispatch_mach_invoke(dispatch_mach_t dm,
-		dispatch_invoke_context_t dic, dispatch_invoke_flags_t flags)
-{
-	_dispatch_queue_class_invoke(dm, dic, flags,
-			DISPATCH_INVOKE_DISALLOW_SYNC_WAITERS, _dispatch_mach_invoke2);
-}
-
-void
-_dispatch_mach_wakeup(dispatch_mach_t dm, dispatch_qos_t qos,
-		dispatch_wakeup_flags_t flags)
-{
-	// This function determines whether the mach channel needs to be invoked.
-	// The order of tests here in probe and in invoke should be consistent.
-
-	dispatch_mach_send_refs_t dmsr = dm->dm_send_refs;
-	dispatch_queue_wakeup_target_t tq = DISPATCH_QUEUE_WAKEUP_NONE;
-	dispatch_queue_flags_t dqf = _dispatch_queue_atomic_flags(dm);
-
-	if (!dm->ds_is_installed) {
-		// The channel needs to be installed on the kevent queue.
-		tq = DISPATCH_QUEUE_WAKEUP_TARGET;
-		goto done;
-	}
-
-	if (_dispatch_queue_class_probe(dm)) {
-		tq = DISPATCH_QUEUE_WAKEUP_TARGET;
-		goto done;
-	}
-
-	if (dmsr->dmsr_tail) {
-		if (_dispatch_lock_is_locked(dmsr->dmsr_state_lock.dul_lock)) {
-			// Sending require the send lock, the channel will be woken up
-			// when the lock is dropped <rdar://15132939&15203957>
-			goto done;
-		}
-
-		if (!dmsr->dmsr_notification_armed || dmsr->dmsr_disconnect_cnt) {
-			bool requires_mgr = dmsr->dmsr_disconnect_cnt ?
-					_dispatch_unote_registered(dmsr) : dm->dm_needs_mgr;
-			if (unlikely(requires_mgr)) {
-				tq = DISPATCH_QUEUE_WAKEUP_MGR;
-			} else {
-				tq = DISPATCH_QUEUE_WAKEUP_TARGET;
-			}
-		}
-	} else if ((dqf & DSF_CANCELED) && (dqf & DSF_NEEDS_EVENT) &&
-			!(flags & DISPATCH_WAKEUP_EVENT)) {
-		// waiting for the delivery of a deferred delete event
-	} else if ((dqf & DSF_CANCELED) && !dm->dm_cancel_handler_called) {
-		// The channel needs to be cancelled and the cancellation handler
-		// needs to be delivered to the target queue.
-		tq = DISPATCH_QUEUE_WAKEUP_TARGET;
-	}
-
-done:
-	if ((tq == DISPATCH_QUEUE_WAKEUP_TARGET) &&
-			dm->do_targetq == _dispatch_mgr_q._as_dq) {
-		tq = DISPATCH_QUEUE_WAKEUP_MGR;
-	}
-
-	return _dispatch_queue_wakeup(dm, qos, flags, tq);
-}
-
-static void
-_dispatch_mach_sigterm_invoke(void *ctx)
-{
-	dispatch_mach_t dm = ctx;
-	uint32_t duu_options = DUU_DELETE_ACK | DUU_MUST_SUCCEED;
-	_dispatch_unote_unregister(dm->dm_xpc_term_refs, duu_options);
-	if (!(_dispatch_queue_atomic_flags(dm) & DSF_CANCELED)) {
-		dispatch_mach_recv_refs_t dmrr = dm->dm_recv_refs;
-		_dispatch_client_callout4(dmrr->dmrr_handler_ctxt,
-				DISPATCH_MACH_SIGTERM_RECEIVED, NULL, 0,
-				dmrr->dmrr_handler_func);
-	}
-}
-
-void
-_dispatch_xpc_sigterm_merge_evt(dispatch_unote_t du,
-		uint32_t flags DISPATCH_UNUSED, uintptr_t data DISPATCH_UNUSED,
-		pthread_priority_t pp)
-{
-	dispatch_mach_t dm = _dispatch_wref2ptr(du._du->du_owner_wref);
-
-	_dispatch_barrier_async_detached_f(dm, dm, _dispatch_mach_sigterm_invoke);
-	dx_wakeup(dm, _dispatch_qos_from_pp(pp), DISPATCH_WAKEUP_EVENT |
-			DISPATCH_WAKEUP_CONSUME_2 | DISPATCH_WAKEUP_MAKE_DIRTY);
-}
-
-#pragma mark -
-#pragma mark dispatch_mach_msg_t
-
-dispatch_mach_msg_t
-dispatch_mach_msg_create(mach_msg_header_t *msg, size_t size,
-		dispatch_mach_msg_destructor_t destructor, mach_msg_header_t **msg_ptr)
-{
-	if (unlikely(size < sizeof(mach_msg_header_t) || (destructor && !msg))) {
-		DISPATCH_CLIENT_CRASH(size, "Empty message");
-	}
-
-	dispatch_mach_msg_t dmsg;
-	size_t msg_size = sizeof(struct dispatch_mach_msg_s);
-	if (!destructor && os_add_overflow(msg_size,
-			  (size - sizeof(dmsg->dmsg_msg)), &msg_size)) {
-		DISPATCH_CLIENT_CRASH(size, "Message size too large");
-	}
-
-	dmsg = _dispatch_object_alloc(DISPATCH_VTABLE(mach_msg), msg_size);
-	if (destructor) {
-		dmsg->dmsg_msg = msg;
-	} else if (msg) {
-		memcpy(dmsg->dmsg_buf, msg, size);
-	}
-	dmsg->do_next = DISPATCH_OBJECT_LISTLESS;
-	dmsg->do_targetq = _dispatch_get_default_queue(false);
-	dmsg->dmsg_destructor = destructor;
-	dmsg->dmsg_size = size;
-	if (msg_ptr) {
-		*msg_ptr = _dispatch_mach_msg_get_msg(dmsg);
-	}
-	return dmsg;
-}
-
-void
-_dispatch_mach_msg_dispose(dispatch_mach_msg_t dmsg,
-		DISPATCH_UNUSED bool *allow_free)
-{
-	if (dmsg->dmsg_voucher) {
-		_voucher_release(dmsg->dmsg_voucher);
-		dmsg->dmsg_voucher = NULL;
-	}
-	switch (dmsg->dmsg_destructor) {
-	case DISPATCH_MACH_MSG_DESTRUCTOR_DEFAULT:
-		break;
-	case DISPATCH_MACH_MSG_DESTRUCTOR_FREE:
-		free(dmsg->dmsg_msg);
-		break;
-	case DISPATCH_MACH_MSG_DESTRUCTOR_VM_DEALLOCATE: {
-		mach_vm_size_t vm_size = dmsg->dmsg_size;
-		mach_vm_address_t vm_addr = (uintptr_t)dmsg->dmsg_msg;
-		(void)dispatch_assume_zero(mach_vm_deallocate(mach_task_self(),
-				vm_addr, vm_size));
-		break;
-	}}
-}
-
-static inline mach_msg_header_t*
-_dispatch_mach_msg_get_msg(dispatch_mach_msg_t dmsg)
-{
-	return dmsg->dmsg_destructor ? dmsg->dmsg_msg :
-			(mach_msg_header_t*)dmsg->dmsg_buf;
-}
-
-mach_msg_header_t*
-dispatch_mach_msg_get_msg(dispatch_mach_msg_t dmsg, size_t *size_ptr)
-{
-	if (size_ptr) {
-		*size_ptr = dmsg->dmsg_size;
-	}
-	return _dispatch_mach_msg_get_msg(dmsg);
-}
-
-size_t
-_dispatch_mach_msg_debug(dispatch_mach_msg_t dmsg, char* buf, size_t bufsiz)
-{
-	size_t offset = 0;
-	offset += dsnprintf(&buf[offset], bufsiz - offset, "%s[%p] = { ",
-			_dispatch_object_class_name(dmsg), dmsg);
-	offset += _dispatch_object_debug_attr(dmsg, buf + offset, bufsiz - offset);
-	offset += dsnprintf(&buf[offset], bufsiz - offset, "opts/err = 0x%x, "
-			"msgh[%p] = { ", dmsg->dmsg_options, dmsg->dmsg_buf);
-	mach_msg_header_t *hdr = _dispatch_mach_msg_get_msg(dmsg);
-	if (hdr->msgh_id) {
-		offset += dsnprintf(&buf[offset], bufsiz - offset, "id 0x%x, ",
-				hdr->msgh_id);
-	}
-	if (hdr->msgh_size) {
-		offset += dsnprintf(&buf[offset], bufsiz - offset, "size %u, ",
-				hdr->msgh_size);
-	}
-	if (hdr->msgh_bits) {
-		offset += dsnprintf(&buf[offset], bufsiz - offset, "bits <l %u, r %u",
-				MACH_MSGH_BITS_LOCAL(hdr->msgh_bits),
-				MACH_MSGH_BITS_REMOTE(hdr->msgh_bits));
-		if (MACH_MSGH_BITS_OTHER(hdr->msgh_bits)) {
-			offset += dsnprintf(&buf[offset], bufsiz - offset, ", o 0x%x",
-					MACH_MSGH_BITS_OTHER(hdr->msgh_bits));
-		}
-		offset += dsnprintf(&buf[offset], bufsiz - offset, ">, ");
-	}
-	if (hdr->msgh_local_port && hdr->msgh_remote_port) {
-		offset += dsnprintf(&buf[offset], bufsiz - offset, "local 0x%x, "
-				"remote 0x%x", hdr->msgh_local_port, hdr->msgh_remote_port);
-	} else if (hdr->msgh_local_port) {
-		offset += dsnprintf(&buf[offset], bufsiz - offset, "local 0x%x",
-				hdr->msgh_local_port);
-	} else if (hdr->msgh_remote_port) {
-		offset += dsnprintf(&buf[offset], bufsiz - offset, "remote 0x%x",
-				hdr->msgh_remote_port);
-	} else {
-		offset += dsnprintf(&buf[offset], bufsiz - offset, "no ports");
-	}
-	offset += dsnprintf(&buf[offset], bufsiz - offset, " } }");
-	return offset;
-}
-
-DISPATCH_ALWAYS_INLINE
-static dispatch_queue_t
-_dispatch_mach_msg_context_async_reply_queue(void *msg_context)
-{
-	return _dispatch_mach_xpc_hooks->dmxh_msg_context_reply_queue(msg_context);
-}
-
-static dispatch_continuation_t
-_dispatch_mach_msg_async_reply_wrap(dispatch_mach_msg_t dmsg,
-		dispatch_mach_t dm)
-{
-	_dispatch_retain(dm); // Released in _dispatch_mach_msg_async_reply_invoke()
-	dispatch_continuation_t dc = _dispatch_continuation_alloc();
-	dc->do_vtable = DC_VTABLE(MACH_ASYNC_REPLY);
-	dc->dc_data = dmsg;
-	dc->dc_other = dm;
-	dc->dc_priority = DISPATCH_NO_PRIORITY;
-	dc->dc_voucher = DISPATCH_NO_VOUCHER;
-	return dc;
-}
-
-DISPATCH_NOINLINE
-void
-_dispatch_mach_msg_async_reply_invoke(dispatch_continuation_t dc,
-		DISPATCH_UNUSED dispatch_invoke_context_t dic,
-		dispatch_invoke_flags_t flags)
-{
-	// _dispatch_mach_msg_invoke_with_mach() releases the reference on dmsg
-	// taken by _dispatch_mach_msg_async_reply_wrap() after handling it.
-	dispatch_mach_msg_t dmsg = dc->dc_data;
-	dispatch_mach_t dm = dc->dc_other;
-	_dispatch_mach_msg_invoke_with_mach(dmsg,
-			flags | DISPATCH_INVOKE_ASYNC_REPLY, dm);
-
-	// Balances _dispatch_mach_msg_async_reply_wrap
-	_dispatch_release(dc->dc_other);
-
-	_dispatch_continuation_free(dc);
-}
-
-#pragma mark -
-#pragma mark dispatch_mig_server
-
-mach_msg_return_t
-dispatch_mig_server(dispatch_source_t ds, size_t maxmsgsz,
-		dispatch_mig_callback_t callback)
-{
-	mach_msg_options_t options = MACH_RCV_MSG | MACH_RCV_TIMEOUT
-		| MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_CTX)
-		| MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0) | MACH_RCV_VOUCHER;
-	mach_msg_options_t tmp_options;
-	mig_reply_error_t *bufTemp, *bufRequest, *bufReply;
-	mach_msg_return_t kr = 0;
-	uint64_t assertion_token = 0;
-	uint32_t cnt = 1000; // do not stall out serial queues
-	boolean_t demux_success;
-	bool received = false;
-	size_t rcv_size = maxmsgsz + MAX_TRAILER_SIZE;
-	dispatch_source_refs_t dr = ds->ds_refs;
-
-	bufRequest = alloca(rcv_size);
-	bufRequest->RetCode = 0;
-	_dispatch_mach_stack_probe(bufRequest, rcv_size);
-
-	bufReply = alloca(rcv_size);
-	bufReply->Head.msgh_size = 0;
-	_dispatch_mach_stack_probe(bufReply, rcv_size);
-
-#if DISPATCH_DEBUG
-	options |= MACH_RCV_LARGE; // rdar://problem/8422992
-#endif
-	tmp_options = options;
-	// XXX FIXME -- change this to not starve out the target queue
-	for (;;) {
-		if (DISPATCH_QUEUE_IS_SUSPENDED(ds) || (--cnt == 0)) {
-			options &= ~MACH_RCV_MSG;
-			tmp_options &= ~MACH_RCV_MSG;
-
-			if (!(tmp_options & MACH_SEND_MSG)) {
-				goto out;
-			}
-		}
-		kr = mach_msg(&bufReply->Head, tmp_options, bufReply->Head.msgh_size,
-				(mach_msg_size_t)rcv_size, (mach_port_t)dr->du_ident, 0, 0);
-
-		tmp_options = options;
-
-		if (unlikely(kr)) {
-			switch (kr) {
-			case MACH_SEND_INVALID_DEST:
-			case MACH_SEND_TIMED_OUT:
-				if (bufReply->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) {
-					mach_msg_destroy(&bufReply->Head);
-				}
-				break;
-			case MACH_RCV_TIMED_OUT:
-				// Don't return an error if a message was sent this time or
-				// a message was successfully received previously
-				// rdar://problems/7363620&7791738
-				if(bufReply->Head.msgh_remote_port || received) {
-					kr = MACH_MSG_SUCCESS;
-				}
-				break;
-			case MACH_RCV_INVALID_NAME:
-				break;
-#if DISPATCH_DEBUG
-			case MACH_RCV_TOO_LARGE:
-				// receive messages that are too large and log their id and size
-				// rdar://problem/8422992
-				tmp_options &= ~MACH_RCV_LARGE;
-				size_t large_size = bufReply->Head.msgh_size + MAX_TRAILER_SIZE;
-				void *large_buf = malloc(large_size);
-				if (large_buf) {
-					rcv_size = large_size;
-					bufReply = large_buf;
-				}
-				if (!mach_msg(&bufReply->Head, tmp_options, 0,
-						(mach_msg_size_t)rcv_size,
-						(mach_port_t)dr->du_ident, 0, 0)) {
-					_dispatch_log("BUG in libdispatch client: "
-							"dispatch_mig_server received message larger than "
-							"requested size %zd: id = 0x%x, size = %d",
-							maxmsgsz, bufReply->Head.msgh_id,
-							bufReply->Head.msgh_size);
-					if (bufReply->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) {
-						mach_msg_destroy(&bufReply->Head);
-					}
-				}
-				if (large_buf) {
-					free(large_buf);
-				}
-				// fall through
-#endif
-			default:
-				_dispatch_bug_mach_client(
-						"dispatch_mig_server: mach_msg() failed", kr);
-				break;
-			}
-			goto out;
-		}
-
-		if (!(tmp_options & MACH_RCV_MSG)) {
-			goto out;
-		}
-
-		if (assertion_token) {
-#if DISPATCH_USE_IMPORTANCE_ASSERTION
-			int r = proc_importance_assertion_complete(assertion_token);
-			(void)dispatch_assume_zero(r);
-#endif
-			assertion_token = 0;
-		}
-		received = true;
-
-		bufTemp = bufRequest;
-		bufRequest = bufReply;
-		bufReply = bufTemp;
-
-#if DISPATCH_USE_IMPORTANCE_ASSERTION
-#pragma clang diagnostic push
-#pragma clang diagnostic ignored "-Wdeprecated-declarations"
-		int r = proc_importance_assertion_begin_with_msg(&bufRequest->Head,
-				NULL, &assertion_token);
-		if (r && r != EIO) {
-			(void)dispatch_assume_zero(r);
-		}
-#pragma clang diagnostic pop
-#endif
-		_voucher_replace(voucher_create_with_mach_msg(&bufRequest->Head));
-		bufReply->Head = (mach_msg_header_t){ };
-		demux_success = callback(&bufRequest->Head, &bufReply->Head);
-
-		if (!demux_success) {
-			// destroy the request - but not the reply port
-			bufRequest->Head.msgh_remote_port = 0;
-			mach_msg_destroy(&bufRequest->Head);
-		} else if (!(bufReply->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX)) {
-			// if MACH_MSGH_BITS_COMPLEX is _not_ set, then bufReply->RetCode
-			// is present
-			if (unlikely(bufReply->RetCode)) {
-				if (bufReply->RetCode == MIG_NO_REPLY) {
-					continue;
-				}
-
-				// destroy the request - but not the reply port
-				bufRequest->Head.msgh_remote_port = 0;
-				mach_msg_destroy(&bufRequest->Head);
-			}
-		}
-
-		if (bufReply->Head.msgh_remote_port) {
-			tmp_options |= MACH_SEND_MSG;
-			if (MACH_MSGH_BITS_REMOTE(bufReply->Head.msgh_bits) !=
-					MACH_MSG_TYPE_MOVE_SEND_ONCE) {
-				tmp_options |= MACH_SEND_TIMEOUT;
-			}
-		}
-	}
-
-out:
-	if (assertion_token) {
-#if DISPATCH_USE_IMPORTANCE_ASSERTION
-		int r = proc_importance_assertion_complete(assertion_token);
-		(void)dispatch_assume_zero(r);
-#endif
-	}
-
-	return kr;
-}
-
-#pragma mark -
-#pragma mark dispatch_mach_mig_demux
-
-static char const * const
-_dispatch_mach_mig_demux_context_key = "mach_mig_demux";
-
-static const mig_routine_descriptor *
-_dispatch_mach_mig_resolve(mach_msg_id_t msgid,
-		const struct mig_subsystem *const subsystems[], size_t count)
-{
-	const mig_routine_descriptor *desc;
-
-	for (size_t i = 0; i < count; i++) {
-		if (subsystems[i]->start <= msgid && msgid < subsystems[i]->end) {
-			desc = &subsystems[i]->routine[msgid - subsystems[i]->start];
-			return desc->stub_routine ? desc : NULL;
-		}
-	}
-	return NULL;
-}
-
-bool
-dispatch_mach_mig_demux(void *context,
-		const struct mig_subsystem *const subsystems[], size_t count,
-		dispatch_mach_msg_t dmsg)
-{
-	dispatch_thread_context_s dmmd_ctx = {
-		.dtc_key = _dispatch_mach_mig_demux_context_key,
-		.dtc_mig_demux_ctx = context,
-	};
-	mach_msg_header_t *hdr = dispatch_mach_msg_get_msg(dmsg, NULL);
-	mach_msg_id_t msgid = hdr->msgh_id;
-	const mig_routine_descriptor *desc;
-	mig_reply_error_t *bufReply;
-	mach_msg_size_t reply_size;
-	kern_return_t kr;
-
-	desc = _dispatch_mach_mig_resolve(msgid, subsystems, count);
-	if (!desc) return false;
-
-	_dispatch_thread_context_push(&dmmd_ctx);
-
-	reply_size = desc->max_reply_msg + MAX_TRAILER_SIZE;
-	bufReply = alloca(reply_size);
-	_dispatch_mach_stack_probe(bufReply, reply_size);
-	bufReply->Head = (mach_msg_header_t){
-		.msgh_bits = MACH_MSGH_BITS(MACH_MSGH_BITS_REMOTE(hdr->msgh_bits), 0),
-		.msgh_remote_port = hdr->msgh_remote_port,
-		.msgh_size = sizeof(mig_reply_error_t),
-		.msgh_id = msgid + 100,
-	};
-
-	desc->stub_routine(hdr, &bufReply->Head);
-
-	// if MACH_MSGH_BITS_COMPLEX is _not_ set, then bufReply->RetCode is present
-	if (unlikely(!(bufReply->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) &&
-			bufReply->RetCode)) {
-		// destroy the request - but not the reply port
-		hdr->msgh_remote_port = 0;
-		if (bufReply->RetCode != MIG_NO_REPLY &&
-				(hdr->msgh_bits & MACH_MSGH_BITS_COMPLEX)) {
-			mach_msg_destroy(hdr);
-		}
-	}
-
-	if (bufReply->Head.msgh_remote_port) {
-		mach_msg_option_t options = MACH_SEND_MSG;
-		if (MACH_MSGH_BITS_REMOTE(bufReply->Head.msgh_bits) !=
-				MACH_MSG_TYPE_MOVE_SEND_ONCE) {
-			options |= MACH_SEND_TIMEOUT;
-		}
-		kr = mach_msg(&bufReply->Head, options, bufReply->Head.msgh_size,
-				0, MACH_PORT_NULL, 0, MACH_PORT_NULL);
-		switch (kr) {
-		case KERN_SUCCESS:
-			break;
-		case MACH_SEND_INVALID_DEST:
-		case MACH_SEND_TIMED_OUT:
-			if (bufReply->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) {
-				mach_msg_destroy(&bufReply->Head);
-			}
-			break;
-		default:
-			DISPATCH_VERIFY_MIG(kr);
-			DISPATCH_CLIENT_CRASH(kr,
-					"dispatch_mach_mig_demux: mach_msg(MACH_SEND_MSG) failed");
-		}
-	}
-
-	_dispatch_thread_context_pop(&dmmd_ctx);
-	return true;
-}
-
-void *
-dispatch_mach_mig_demux_get_context(void)
-{
-	dispatch_thread_context_t dtc;
-	dtc = _dispatch_thread_context_find(_dispatch_mach_mig_demux_context_key);
-	if (unlikely(dtc == NULL)) {
-		DISPATCH_CLIENT_CRASH(0, "dispatch_mach_mig_demux_get_context "
-				"not called from dispatch_mach_mig_demux context");
-	}
-	return dtc->dtc_mig_demux_ctx;
-}
-
-#pragma mark -
-#pragma mark dispatch_mach_debug
-
-DISPATCH_COLD
-static size_t
-_dispatch_mach_debug_attr(dispatch_mach_t dm, char *buf, size_t bufsiz)
-{
-	dispatch_queue_t target = dm->do_targetq;
-	dispatch_mach_send_refs_t dmsr = dm->dm_send_refs;
-	dispatch_mach_recv_refs_t dmrr = dm->dm_recv_refs;
-
-	return dsnprintf(buf, bufsiz, "target = %s[%p], receive = 0x%x, "
-			"send = 0x%x, send-possible = 0x%x%s, checkin = 0x%x%s, "
-			"send state = %016llx, disconnected = %d, canceled = %d ",
-			target && target->dq_label ? target->dq_label : "", target,
-			(mach_port_t)dmrr->du_ident, dmsr->dmsr_send,
-			(mach_port_t)dmsr->du_ident,
-			dmsr->dmsr_notification_armed ? " (armed)" : "",
-			dmsr->dmsr_checkin_port, dmsr->dmsr_checkin ? " (pending)" : "",
-			dmsr->dmsr_state, dmsr->dmsr_disconnect_cnt,
-			(bool)(dm->dq_atomic_flags & DSF_CANCELED));
-}
-
-size_t
-_dispatch_mach_debug(dispatch_mach_t dm, char* buf, size_t bufsiz)
-{
-	size_t offset = 0;
-	offset += dsnprintf(&buf[offset], bufsiz - offset, "%s[%p] = { ",
-			dm->dq_label && !dm->dm_cancel_handler_called ? dm->dq_label :
-			_dispatch_object_class_name(dm), dm);
-	offset += _dispatch_object_debug_attr(dm, &buf[offset], bufsiz - offset);
-	offset += _dispatch_mach_debug_attr(dm, &buf[offset], bufsiz - offset);
-	offset += dsnprintf(&buf[offset], bufsiz - offset, "}");
-	return offset;
-}
-
-#endif /* HAVE_MACH */
--- a/Telegram/ThirdParty/dispatch/src/mach_internal.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/mach_internal.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,133 +0,0 @@
-/*
- * Copyright (c) 2008-2016 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-/*
- * IMPORTANT: This header file describes INTERNAL interfaces to libdispatch
- * which are subject to change in future releases of Mac OS X. Any applications
- * relying on these interfaces WILL break.
- */
-
-#ifndef __DISPATCH_MACH_INTERNAL__
-#define __DISPATCH_MACH_INTERNAL__
-#if HAVE_MACH
-
-#ifndef __DISPATCH_INDIRECT__
-#error "Please #include <dispatch/dispatch.h> instead of this file directly."
-#include <dispatch/base.h> // for HeaderDoc
-#endif
-
-// NOTE: dispatch_source_mach_send_flags_t and dispatch_source_mach_recv_flags_t
-//       bit values must not overlap as they share the same kevent fflags !
-
-/*!
- * @enum dispatch_source_mach_send_flags_t
- *
- * @constant DISPATCH_MACH_SEND_DELETED
- * Port-deleted notification. Disabled for source registration.
- */
-enum {
-	DISPATCH_MACH_SEND_DELETED = 0x4,
-};
-/*!
- * @enum dispatch_source_mach_recv_flags_t
- *
- * @constant DISPATCH_MACH_RECV_MESSAGE
- * Receive right has pending messages
- */
-enum {
-	DISPATCH_MACH_RECV_MESSAGE = 0x2,
-};
-
-DISPATCH_CLASS_DECL(mach, QUEUE);
-DISPATCH_CLASS_DECL(mach_msg, OBJECT);
-
-struct dispatch_mach_s {
-	DISPATCH_SOURCE_CLASS_HEADER(mach);
-	dispatch_mach_send_refs_t dm_send_refs;
-	dispatch_xpc_term_refs_t dm_xpc_term_refs;
-} DISPATCH_ATOMIC64_ALIGN;
-dispatch_assert_valid_lane_type(dispatch_mach_s);
-
-struct dispatch_mach_msg_s {
-	DISPATCH_OBJECT_HEADER(mach_msg);
-	union {
-		mach_msg_option_t dmsg_options;
-		mach_error_t dmsg_error;
-	};
-	mach_port_t dmsg_reply;
-	pthread_priority_t dmsg_priority;
-	voucher_t dmsg_voucher;
-	dispatch_mach_msg_destructor_t dmsg_destructor;
-	size_t dmsg_size;
-	union {
-		mach_msg_header_t *dmsg_msg;
-		char dmsg_buf[0];
-	};
-};
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_mach_xref_dispose(struct dispatch_mach_s *dm)
-{
-	if (dm->dm_is_xpc) {
-		dm->dm_recv_refs->dmrr_handler_ctxt = (void *)0xbadfeed;
-	}
-}
-
-extern dispatch_mach_xpc_hooks_t _dispatch_mach_xpc_hooks;
-extern const struct dispatch_mach_xpc_hooks_s _dispatch_mach_xpc_hooks_default;
-
-void _dispatch_mach_ipc_handoff_invoke(dispatch_continuation_t dc,
-		dispatch_invoke_context_t dic, dispatch_invoke_flags_t flags);
-void _dispatch_mach_msg_async_reply_invoke(dispatch_continuation_t dc,
-		dispatch_invoke_context_t dic, dispatch_invoke_flags_t flags);
-void _dispatch_mach_dispose(dispatch_mach_t dm, bool *allow_free);
-void _dispatch_mach_activate(dispatch_mach_t dm, bool *allow_resume);
-void _dispatch_mach_invoke(dispatch_mach_t dm, dispatch_invoke_context_t dic,
-		dispatch_invoke_flags_t flags);
-void _dispatch_mach_wakeup(dispatch_mach_t dm, dispatch_qos_t qos,
-		dispatch_wakeup_flags_t flags);
-DISPATCH_COLD
-size_t _dispatch_mach_debug(dispatch_mach_t dm, char* buf, size_t bufsiz);
-void _dispatch_mach_notification_merge_evt(dispatch_unote_t du,
-		uint32_t flags, uintptr_t data, pthread_priority_t pp);
-void _dispatch_mach_merge_msg(dispatch_unote_t du, uint32_t flags,
-		mach_msg_header_t *msg, mach_msg_size_t msgsz,
-		pthread_priority_t msg_pp, pthread_priority_t ovr_pp);
-void _dispatch_mach_reply_merge_msg(dispatch_unote_t du, uint32_t flags,
-		mach_msg_header_t *msg, mach_msg_size_t msgsz,
-		pthread_priority_t msg_pp, pthread_priority_t ovr_pp);
-void _dispatch_xpc_sigterm_merge_evt(dispatch_unote_t du, uint32_t flags,
-		uintptr_t data, pthread_priority_t pp);
-
-void _dispatch_mach_msg_dispose(dispatch_mach_msg_t dmsg, bool *allow_free);
-void _dispatch_mach_msg_invoke(dispatch_mach_msg_t dmsg,
-		dispatch_invoke_context_t dic, dispatch_invoke_flags_t flags);
-DISPATCH_COLD
-size_t _dispatch_mach_msg_debug(dispatch_mach_msg_t dmsg, char* buf,
-		size_t bufsiz);
-
-void _dispatch_mach_send_barrier_drain_invoke(dispatch_continuation_t dc,
-		dispatch_invoke_context_t dic, dispatch_invoke_flags_t flags);
-void _dispatch_mach_barrier_invoke(dispatch_continuation_t dc,
-		dispatch_invoke_context_t dic, dispatch_invoke_flags_t flags);
-
-#endif // HAVE_MACH
-#endif /* __DISPATCH_MACH_INTERNAL__ */
--- a/Telegram/ThirdParty/dispatch/src/object.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/object.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,343 +0,0 @@
-/*
- * Copyright (c) 2008-2013 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include "internal.h"
-
-#pragma mark -
-#pragma mark _os_object_t
-
-unsigned long
-_os_object_retain_count(_os_object_t obj)
-{
-	int xref_cnt = obj->os_obj_xref_cnt;
-	if (unlikely(xref_cnt == _OS_OBJECT_GLOBAL_REFCNT)) {
-		return ULONG_MAX; // global object
-	}
-	return (unsigned long)(xref_cnt + 1);
-}
-
-DISPATCH_NOINLINE
-_os_object_t
-_os_object_retain_internal(_os_object_t obj)
-{
-	return _os_object_retain_internal_n_inline(obj, 1);
-}
-
-DISPATCH_NOINLINE
-_os_object_t
-_os_object_retain_internal_n(_os_object_t obj, uint16_t n)
-{
-	return _os_object_retain_internal_n_inline(obj, n);
-}
-
-DISPATCH_NOINLINE
-void
-_os_object_release_internal(_os_object_t obj)
-{
-	return _os_object_release_internal_n_inline(obj, 1);
-}
-
-DISPATCH_NOINLINE
-void
-_os_object_release_internal_n(_os_object_t obj, uint16_t n)
-{
-	return _os_object_release_internal_n_inline(obj, n);
-}
-
-DISPATCH_NOINLINE
-_os_object_t
-_os_object_retain(_os_object_t obj)
-{
-	int xref_cnt = _os_object_xrefcnt_inc_orig(obj);
-	if (unlikely(xref_cnt < 0)) {
-		_OS_OBJECT_CLIENT_CRASH("Resurrection of an object");
-	}
-	return obj;
-}
-
-DISPATCH_NOINLINE
-_os_object_t
-_os_object_retain_with_resurrect(_os_object_t obj)
-{
-	int xref_cnt = _os_object_xrefcnt_inc_orig(obj) + 1;
-	if (unlikely(xref_cnt < 0)) {
-		_OS_OBJECT_CLIENT_CRASH("Resurrection of an over-released object");
-	}
-	if (unlikely(xref_cnt == 0)) {
-		_os_object_retain_internal(obj);
-	}
-	return obj;
-}
-
-DISPATCH_NOINLINE
-void
-_os_object_release(_os_object_t obj)
-{
-	int xref_cnt = _os_object_xrefcnt_dec(obj);
-	if (likely(xref_cnt >= 0)) {
-		return;
-	}
-	if (unlikely(xref_cnt < -1)) {
-		_OS_OBJECT_CLIENT_CRASH("Over-release of an object");
-	}
-	return _os_object_xref_dispose(obj);
-}
-
-bool
-_os_object_retain_weak(_os_object_t obj)
-{
-	int xref_cnt, nxref_cnt;
-	os_atomic_rmw_loop2o(obj, os_obj_xref_cnt, xref_cnt, nxref_cnt, relaxed, {
-		if (unlikely(xref_cnt == _OS_OBJECT_GLOBAL_REFCNT)) {
-			os_atomic_rmw_loop_give_up(return true); // global object
-		}
-		if (unlikely(xref_cnt == -1)) {
-			os_atomic_rmw_loop_give_up(return false);
-		}
-		if (unlikely(xref_cnt < -1)) {
-			os_atomic_rmw_loop_give_up(goto overrelease);
-		}
-		nxref_cnt = xref_cnt + 1;
-	});
-	return true;
-overrelease:
-	_OS_OBJECT_CLIENT_CRASH("Over-release of an object");
-}
-
-bool
-_os_object_allows_weak_reference(_os_object_t obj)
-{
-	int xref_cnt = obj->os_obj_xref_cnt;
-	if (unlikely(xref_cnt == -1)) {
-		return false;
-	}
-	if (unlikely(xref_cnt < -1)) {
-		_OS_OBJECT_CLIENT_CRASH("Over-release of an object");
-	}
-	return true;
-}
-
-#pragma mark -
-#pragma mark dispatch_object_t
-
-void *
-_dispatch_object_alloc(const void *vtable, size_t size)
-{
-#if OS_OBJECT_HAVE_OBJC1
-	const struct dispatch_object_vtable_s *_vtable = vtable;
-	dispatch_object_t dou;
-	dou._os_obj = _os_object_alloc_realized(_vtable->_os_obj_objc_isa, size);
-	dou._do->do_vtable = vtable;
-	return dou._do;
-#else
-	return _os_object_alloc_realized(vtable, size);
-#endif
-}
-
-void
-_dispatch_object_finalize(dispatch_object_t dou)
-{
-#if USE_OBJC
-	objc_destructInstance((id)dou._do);
-#else
-	(void)dou;
-#endif
-}
-
-void
-_dispatch_object_dealloc(dispatch_object_t dou)
-{
-	// so that ddt doesn't pick up bad objects when malloc reuses this memory
-	dou._os_obj->os_obj_isa = NULL;
-#if OS_OBJECT_HAVE_OBJC1
-	dou._do->do_vtable = NULL;
-#endif
-	free(dou._os_obj);
-}
-
-void
-dispatch_retain(dispatch_object_t dou)
-{
-	DISPATCH_OBJECT_TFB(_dispatch_objc_retain, dou);
-	(void)_os_object_retain(dou._os_obj);
-}
-
-void
-dispatch_release(dispatch_object_t dou)
-{
-	DISPATCH_OBJECT_TFB(_dispatch_objc_release, dou);
-	_os_object_release(dou._os_obj);
-}
-
-#if !USE_OBJC
-void
-_dispatch_xref_dispose(dispatch_object_t dou)
-{
-	if (dx_cluster(dou._do) == _DISPATCH_QUEUE_CLUSTER) {
-		_dispatch_queue_xref_dispose(dou._dq);
-	}
-	switch (dx_type(dou._do)) {
-	case DISPATCH_SOURCE_KEVENT_TYPE:
-		_dispatch_source_xref_dispose(dou._ds);
-		break;
-#if HAVE_MACH
-	case DISPATCH_MACH_CHANNEL_TYPE:
-		_dispatch_mach_xref_dispose(dou._dm);
-		break;
-#endif
-#if DISPATCH_COCOA_COMPAT
-	case DISPATCH_QUEUE_RUNLOOP_TYPE:
-		_dispatch_runloop_queue_xref_dispose(dou._dl);
-		break;
-#endif
-	}
-	return _dispatch_release_tailcall(dou._os_obj);
-}
-#endif
-
-void
-_dispatch_dispose(dispatch_object_t dou)
-{
-	dispatch_queue_t tq = dou._do->do_targetq;
-	dispatch_function_t func = _dispatch_object_finalizer(dou);
-	void *ctxt = dou._do->do_ctxt;
-	bool allow_free = true;
-
-	if (unlikely(dou._do->do_next != DISPATCH_OBJECT_LISTLESS)) {
-		DISPATCH_INTERNAL_CRASH(dou._do->do_next, "Release while enqueued");
-	}
-
-	if (unlikely(tq && tq->dq_serialnum == DISPATCH_QUEUE_SERIAL_NUMBER_WLF)) {
-		// the workloop fallback global queue is never serviced, so redirect
-		// the finalizer onto a global queue
-		tq = _dispatch_get_root_queue(DISPATCH_QOS_DEFAULT, false)->_as_dq;
-	}
-
-	dx_dispose(dou._do, &allow_free);
-
-	// Past this point, the only thing left of the object is its memory
-	if (likely(allow_free)) {
-		_dispatch_object_finalize(dou);
-		_dispatch_object_dealloc(dou);
-	}
-	if (func && ctxt) {
-		dispatch_async_f(tq, ctxt, func);
-	}
-	if (tq) _dispatch_release_tailcall(tq);
-}
-
-void *
-dispatch_get_context(dispatch_object_t dou)
-{
-	DISPATCH_OBJECT_TFB(_dispatch_objc_get_context, dou);
-	if (unlikely(dx_hastypeflag(dou._do, NO_CONTEXT))) {
-		return NULL;
-	}
-	return dou._do->do_ctxt;
-}
-
-void
-dispatch_set_context(dispatch_object_t dou, void *context)
-{
-	DISPATCH_OBJECT_TFB(_dispatch_objc_set_context, dou, context);
-	if (unlikely(dx_hastypeflag(dou._do, NO_CONTEXT))) {
-		return;
-	}
-	dou._do->do_ctxt = context;
-}
-
-void
-dispatch_set_finalizer_f(dispatch_object_t dou, dispatch_function_t finalizer)
-{
-	DISPATCH_OBJECT_TFB(_dispatch_objc_set_finalizer_f, dou, finalizer);
-	if (unlikely(dx_hastypeflag(dou._do, NO_CONTEXT))) {
-		return;
-	}
-	_dispatch_object_set_finalizer(dou, finalizer);
-}
-
-void
-dispatch_set_target_queue(dispatch_object_t dou, dispatch_queue_t tq)
-{
-	DISPATCH_OBJECT_TFB(_dispatch_objc_set_target_queue, dou, tq);
-	if (unlikely(_dispatch_object_is_global(dou) ||
-			_dispatch_object_is_root_or_base_queue(dou))) {
-		return;
-	}
-	if (dx_cluster(dou._do) == _DISPATCH_QUEUE_CLUSTER) {
-		return _dispatch_lane_set_target_queue(dou._dl, tq);
-	}
-	if (dx_type(dou._do) == DISPATCH_IO_TYPE) {
-		// <rdar://problem/34417216> FIXME: dispatch IO should be a "source"
-		return _dispatch_io_set_target_queue(dou._dchannel, tq);
-	}
-	if (tq == DISPATCH_TARGET_QUEUE_DEFAULT) {
-		tq = _dispatch_get_default_queue(false);
-	}
-	_dispatch_object_set_target_queue_inline(dou._do, tq);
-}
-
-void
-dispatch_activate(dispatch_object_t dou)
-{
-	DISPATCH_OBJECT_TFB(_dispatch_objc_activate, dou);
-	if (unlikely(_dispatch_object_is_global(dou))) {
-		return;
-	}
-	if (dx_metatype(dou._do) == _DISPATCH_WORKLOOP_TYPE) {
-		return _dispatch_workloop_activate(dou._dwl);
-	}
-	if (dx_cluster(dou._do) == _DISPATCH_QUEUE_CLUSTER) {
-		return _dispatch_lane_resume(dou._dl, true);
-	}
-}
-
-void
-dispatch_suspend(dispatch_object_t dou)
-{
-	DISPATCH_OBJECT_TFB(_dispatch_objc_suspend, dou);
-	if (unlikely(_dispatch_object_is_global(dou) ||
-			_dispatch_object_is_root_or_base_queue(dou))) {
-		return;
-	}
-	if (dx_cluster(dou._do) == _DISPATCH_QUEUE_CLUSTER) {
-		return _dispatch_lane_suspend(dou._dl);
-	}
-}
-
-void
-dispatch_resume(dispatch_object_t dou)
-{
-	DISPATCH_OBJECT_TFB(_dispatch_objc_resume, dou);
-	if (unlikely(_dispatch_object_is_global(dou) ||
-			_dispatch_object_is_root_or_base_queue(dou))) {
-		return;
-	}
-	if (dx_cluster(dou._do) == _DISPATCH_QUEUE_CLUSTER) {
-		_dispatch_lane_resume(dou._dl, false);
-	}
-}
-
-size_t
-_dispatch_object_debug_attr(dispatch_object_t dou, char* buf, size_t bufsiz)
-{
-	return dsnprintf(buf, bufsiz, "xref = %d, ref = %d, ",
-			dou._do->do_xref_cnt + 1, dou._do->do_ref_cnt + 1);
-}
--- a/Telegram/ThirdParty/dispatch/src/object_internal.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/object_internal.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,648 +0,0 @@
-/*
- * Copyright (c) 2008-2013 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-/*
- * IMPORTANT: This header file describes INTERNAL interfaces to libdispatch
- * which are subject to change in future releases of Mac OS X. Any applications
- * relying on these interfaces WILL break.
- */
-
-#ifndef __DISPATCH_OBJECT_INTERNAL__
-#define __DISPATCH_OBJECT_INTERNAL__
-
-#if !OS_OBJECT_USE_OBJC
-#define OS_OBJECT_DECL(name)  DISPATCH_DECL(name)
-#define OS_OBJECT_DECL_SUBCLASS(name, super)  DISPATCH_DECL(name)
-#endif
-
-#if USE_OBJC
-#define OS_OBJECT_EXTRA_VTABLE_SYMBOL(name) _OS_##name##_vtable
-#define DISPATCH_CLASS_SYMBOL(name) OS_dispatch_##name##_class
-#define DISPATCH_CLASS_RAW_SYMBOL_NAME(name) \
-		OS_OBJC_CLASS_RAW_SYMBOL_NAME(DISPATCH_CLASS(name))
-#else
-#define OS_OBJECT_CLASS_SYMBOL(name) _##name##_vtable
-#define OS_OBJC_CLASS_RAW_SYMBOL_NAME(name) \
-		"__" OS_STRINGIFY(name) "_vtable"
-#define DISPATCH_CLASS_SYMBOL(name) _dispatch_##name##_vtable
-#define DISPATCH_CLASS_RAW_SYMBOL_NAME(name) \
-		"__dispatch_" OS_STRINGIFY(name) "_vtable"
-#endif
-
-#define DISPATCH_CLASS(name) OS_dispatch_##name
-#if USE_OBJC
-#define DISPATCH_OBJC_CLASS_DECL(name) \
-		extern void *DISPATCH_CLASS_SYMBOL(name) \
-				__asm__(DISPATCH_CLASS_RAW_SYMBOL_NAME(name))
-#endif
-
-// define a new proper class
-#define OS_OBJECT_CLASS_DECL(name, ...) \
-		struct name##_s; \
-		struct name##_extra_vtable_s { \
-			__VA_ARGS__; \
-		}; \
-		struct name##_vtable_s { \
-			_OS_OBJECT_CLASS_HEADER(); \
-			struct name##_extra_vtable_s _os_obj_vtable; \
-		}; \
-		OS_OBJECT_EXTRA_VTABLE_DECL(name, name) \
-		extern const struct name##_vtable_s OS_OBJECT_CLASS_SYMBOL(name) \
-				__asm__(OS_OBJC_CLASS_RAW_SYMBOL_NAME(OS_OBJECT_CLASS(name)))
-
-#if OS_OBJECT_SWIFT3
-#define OS_OBJECT_INTERNAL_CLASS_DECL(name, super, ...) \
-		OS_OBJECT_OBJC_RUNTIME_VISIBLE \
-		OS_OBJECT_DECL_IMPL_CLASS(name, OS_OBJECT_CLASS(super)); \
-		OS_OBJECT_CLASS_DECL(name, ## __VA_ARGS__)
-#elif OS_OBJECT_USE_OBJC
-#define OS_OBJECT_INTERNAL_CLASS_DECL(name, super, ...) \
-		OS_OBJECT_DECL(name); \
-		OS_OBJECT_CLASS_DECL(name, ## __VA_ARGS__)
-#else
-#define OS_OBJECT_INTERNAL_CLASS_DECL(name, super, ...) \
-		typedef struct name##_s *name##_t; \
-		OS_OBJECT_CLASS_DECL(name, ## __VA_ARGS__)
-#endif
-
-#define DISPATCH_CLASS_DECL_BARE(name, cluster) \
-		OS_OBJECT_CLASS_DECL(dispatch_##name, \
-		DISPATCH_##cluster##_VTABLE_HEADER(dispatch_##name))
-
-#define DISPATCH_CLASS_DECL(name, cluster) \
-		_OS_OBJECT_DECL_PROTOCOL(dispatch_##name, dispatch_object) \
-		_OS_OBJECT_CLASS_IMPLEMENTS_PROTOCOL(dispatch_##name, dispatch_##name) \
-		DISPATCH_CLASS_DECL_BARE(name, cluster)
-
-#define DISPATCH_SUBCLASS_DECL(name, super, ctype) \
-		_OS_OBJECT_DECL_PROTOCOL(dispatch_##name, dispatch_##super); \
-		_OS_OBJECT_CLASS_IMPLEMENTS_PROTOCOL(dispatch_##name, dispatch_##name) \
-		OS_OBJECT_SUBCLASS_DECL(dispatch_##name, dispatch_##ctype)
-
-#define DISPATCH_INTERNAL_CLASS_DECL(name, cluster) \
-		DISPATCH_DECL(dispatch_##name); \
-		DISPATCH_CLASS_DECL(name, cluster)
-
-// define a new subclass used in a cluster
-#define OS_OBJECT_SUBCLASS_DECL(name, ctype) \
-		struct name##_s; \
-		OS_OBJECT_EXTRA_VTABLE_DECL(name, ctype) \
-		extern const struct ctype##_vtable_s OS_OBJECT_CLASS_SYMBOL(name) \
-				__asm__(OS_OBJC_CLASS_RAW_SYMBOL_NAME(OS_OBJECT_CLASS(name)))
-
-#if OS_OBJECT_SWIFT3
-// define a new internal subclass used in a class cluster
-#define OS_OBJECT_INTERNAL_SUBCLASS_DECL(name, super, ctype) \
-		_OS_OBJECT_DECL_PROTOCOL(name, super); \
-		_OS_OBJECT_DECL_SUBCLASS_INTERFACE(name, super) \
-		OS_OBJECT_SUBCLASS_DECL(name, ctype)
-#else
-// define a new internal subclass used in a class cluster
-#define OS_OBJECT_INTERNAL_SUBCLASS_DECL(name, super, ctype) \
-		OS_OBJECT_DECL_SUBCLASS(name, ctype); \
-		_OS_OBJECT_DECL_SUBCLASS_INTERFACE(name, super) \
-		OS_OBJECT_SUBCLASS_DECL(name, ctype)
-#endif
-
-#define DISPATCH_INTERNAL_SUBCLASS_DECL(name, super, ctype) \
-		OS_OBJECT_INTERNAL_SUBCLASS_DECL(dispatch_##name, dispatch_##super, \
-				dispatch_##ctype)
-
-// vtable symbols
-#define OS_OBJECT_VTABLE(name)		(&OS_OBJECT_CLASS_SYMBOL(name))
-#define DISPATCH_OBJC_CLASS(name)	(&DISPATCH_CLASS_SYMBOL(name))
-
-// vtables for subclasses used in a class cluster
-#if USE_OBJC
-// ObjC classes and dispatch vtables are co-located via linker order and alias
-// files rdar://10640168
-#if OS_OBJECT_HAVE_OBJC2
-#define OS_OBJECT_VTABLE_SUBCLASS_INSTANCE(name, ctype, xdispose, dispose, ...) \
-		__attribute__((section("__DATA,__objc_data"), used)) \
-		const struct ctype##_extra_vtable_s \
-		OS_OBJECT_EXTRA_VTABLE_SYMBOL(name) = { __VA_ARGS__ }
-#define OS_OBJECT_EXTRA_VTABLE_DECL(name, ctype)
-#define DISPATCH_VTABLE(name) DISPATCH_OBJC_CLASS(name)
-#else
-#define OS_OBJECT_VTABLE_SUBCLASS_INSTANCE(name, ctype, xdispose, dispose, ...) \
-		const struct ctype##_vtable_s \
-		OS_OBJECT_EXTRA_VTABLE_SYMBOL(name) = { \
-			._os_obj_objc_isa = &OS_OBJECT_CLASS_SYMBOL(name), \
-			._os_obj_vtable = { __VA_ARGS__ }, \
-		}
-#define OS_OBJECT_EXTRA_VTABLE_DECL(name, ctype) \
-		extern const struct ctype##_vtable_s \
-				OS_OBJECT_EXTRA_VTABLE_SYMBOL(name);
-#define DISPATCH_VTABLE(name) &OS_OBJECT_EXTRA_VTABLE_SYMBOL(dispatch_##name)
-#endif // OS_OBJECT_HAVE_OBJC2
-#else
-#define OS_OBJECT_VTABLE_SUBCLASS_INSTANCE(name, ctype, xdispose, dispose, ...) \
-		const struct ctype##_vtable_s OS_OBJECT_CLASS_SYMBOL(name) = { \
-			._os_obj_xref_dispose = xdispose, \
-			._os_obj_dispose = dispose, \
-			._os_obj_vtable = { __VA_ARGS__ }, \
-		}
-#define OS_OBJECT_EXTRA_VTABLE_DECL(name, ctype)
-#define DISPATCH_VTABLE(name) DISPATCH_OBJC_CLASS(name)
-#endif // USE_OBJC
-
-// vtables for proper classes
-#define OS_OBJECT_VTABLE_INSTANCE(name, xdispose, dispose, ...) \
-		OS_OBJECT_VTABLE_SUBCLASS_INSTANCE(name, name, \
-				xdispose, dispose, __VA_ARGS__)
-
-#define DISPATCH_VTABLE_INSTANCE(name, ...) \
-		DISPATCH_VTABLE_SUBCLASS_INSTANCE(name, name, __VA_ARGS__)
-
-#if USE_OBJC
-#define DISPATCH_VTABLE_SUBCLASS_INSTANCE(name, ctype, ...) \
-		OS_OBJECT_VTABLE_SUBCLASS_INSTANCE(dispatch_##name, dispatch_##ctype, \
-				_dispatch_xref_dispose, _dispatch_dispose, __VA_ARGS__)
-
-#define DISPATCH_OBJECT_VTABLE_HEADER(x) \
-	unsigned long const do_type; \
-	void (*const do_dispose)(struct x##_s *, bool *allow_free); \
-	size_t (*const do_debug)(struct x##_s *, char *, size_t); \
-	void (*const do_invoke)(struct x##_s *, dispatch_invoke_context_t, \
-			dispatch_invoke_flags_t)
-#else
-#define DISPATCH_VTABLE_SUBCLASS_INSTANCE(name, ctype, ...) \
-		OS_OBJECT_VTABLE_SUBCLASS_INSTANCE(dispatch_##name, dispatch_##ctype, \
-				_dispatch_xref_dispose, _dispatch_dispose, \
-				.do_kind = #name, __VA_ARGS__)
-
-#define DISPATCH_OBJECT_VTABLE_HEADER(x) \
-	unsigned long const do_type; \
-	const char *const do_kind; \
-	void (*const do_dispose)(struct x##_s *, bool *allow_free); \
-	size_t (*const do_debug)(struct x##_s *, char *, size_t); \
-	void (*const do_invoke)(struct x##_s *, dispatch_invoke_context_t, \
-			dispatch_invoke_flags_t)
-#endif
-
-#define DISPATCH_QUEUE_VTABLE_HEADER(x); \
-	DISPATCH_OBJECT_VTABLE_HEADER(x); \
-	void (*const dq_activate)(dispatch_queue_class_t, bool *allow_resume); \
-	void (*const dq_wakeup)(dispatch_queue_class_t, dispatch_qos_t, \
-			dispatch_wakeup_flags_t); \
-	void (*const dq_push)(dispatch_queue_class_t, dispatch_object_t, \
-			dispatch_qos_t)
-
-#define dx_vtable(x) (&(x)->do_vtable->_os_obj_vtable)
-#define dx_type(x) dx_vtable(x)->do_type
-#define dx_metatype(x) (dx_vtable(x)->do_type & _DISPATCH_META_TYPE_MASK)
-#define dx_cluster(x) (dx_vtable(x)->do_type & _DISPATCH_TYPE_CLUSTER_MASK)
-#define dx_hastypeflag(x, f) (dx_vtable(x)->do_type & _DISPATCH_##f##_TYPEFLAG)
-#define dx_debug(x, y, z) dx_vtable(x)->do_debug((x), (y), (z))
-#define dx_dispose(x, y) dx_vtable(x)->do_dispose(x, y)
-#define dx_invoke(x, y, z) dx_vtable(x)->do_invoke(x, y, z)
-#define dx_push(x, y, z) dx_vtable(x)->dq_push(x, y, z)
-#define dx_wakeup(x, y, z) dx_vtable(x)->dq_wakeup(x, y, z)
-
-#define DISPATCH_OBJECT_GLOBAL_REFCNT		_OS_OBJECT_GLOBAL_REFCNT
-
-#if OS_OBJECT_HAVE_OBJC1
-#define DISPATCH_GLOBAL_OBJECT_HEADER(name) \
-	.do_vtable = DISPATCH_VTABLE(name), \
-	._objc_isa = DISPATCH_OBJC_CLASS(name), \
-	.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT, \
-	.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT
-#else
-#define DISPATCH_GLOBAL_OBJECT_HEADER(name) \
-	.do_vtable = DISPATCH_VTABLE(name), \
-	.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT, \
-	.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT
-#endif
-
-#if DISPATCH_SIZEOF_PTR == 8
-// the bottom nibble must not be zero, the rest of the bits should be random
-// we sign extend the 64-bit version so that a better instruction encoding is
-// generated on Intel
-#define DISPATCH_OBJECT_LISTLESS ((void *)0xffffffff89abcdef)
-#else
-#define DISPATCH_OBJECT_LISTLESS ((void *)0x89abcdef)
-#endif
-
-DISPATCH_ENUM(dispatch_wakeup_flags, uint32_t,
-	// The caller of dx_wakeup owns two internal refcounts on the object being
-	// woken up. Two are needed for WLH wakeups where two threads need
-	// the object to remain valid in a non-coordinated way
-	// - the thread doing the poke for the duration of the poke
-	// - drainers for the duration of their drain
-	DISPATCH_WAKEUP_CONSUME_2               = 0x00000001,
-
-	// Some change to the object needs to be published to drainers.
-	// If the drainer isn't the same thread, some scheme such as the dispatch
-	// queue DIRTY bit must be used and a release barrier likely has to be
-	// involved before dx_wakeup returns
-	DISPATCH_WAKEUP_MAKE_DIRTY              = 0x00000002,
-
-	// This wakeup is made by a sync owner that still holds the drain lock
-	DISPATCH_WAKEUP_BARRIER_COMPLETE        = 0x00000004,
-
-	// This wakeup is caused by a dispatch_block_wait()
-	DISPATCH_WAKEUP_BLOCK_WAIT              = 0x00000008,
-
-	// This wakeup may cause the source to leave its DSF_NEEDS_EVENT state
-	DISPATCH_WAKEUP_EVENT                   = 0x00000010,
-);
-
-typedef struct dispatch_invoke_context_s {
-#if DISPATCH_USE_WORKQUEUE_NARROWING
-	uint64_t dic_next_narrow_check;
-#endif
-	struct dispatch_object_s *dic_barrier_waiter;
-	dispatch_qos_t dic_barrier_waiter_bucket;
-#if DISPATCH_COCOA_COMPAT
-	void *dic_autorelease_pool;
-#endif
-} dispatch_invoke_context_s, *dispatch_invoke_context_t;
-
-#if DISPATCH_USE_WORKQUEUE_NARROWING
-#define DISPATCH_THREAD_IS_NARROWING 1
-
-#define dispatch_with_disabled_narrowing(dic, ...) ({ \
-		uint64_t suspend_narrow_check = dic->dic_next_narrow_check; \
-		dic->dic_next_narrow_check = 0; \
-		__VA_ARGS__; \
-		dic->dic_next_narrow_check = suspend_narrow_check; \
-	})
-#else
-#define dispatch_with_disabled_narrowing(dic, ...) __VA_ARGS__
-#endif
-
-DISPATCH_ENUM(dispatch_invoke_flags, uint32_t,
-	DISPATCH_INVOKE_NONE					= 0x00000000,
-
-	// Invoke modes
-	//
-	// @const DISPATCH_INVOKE_STEALING
-	// This invoke is a stealer, meaning that it doesn't own the
-	// enqueue lock at drain lock time.
-	//
-	// @const DISPATCH_INVOKE_WLH
-	// This invoke is for a bottom WLH
-	//
-	DISPATCH_INVOKE_STEALING				= 0x00000001,
-	DISPATCH_INVOKE_WLH						= 0x00000002,
-
-	// Misc flags
-	//
-	// @const DISPATCH_INVOKE_ASYNC_REPLY
-	// An asynchronous reply to a message is being handled.
-	//
-	// @const DISPATCH_INVOKE_DISALLOW_SYNC_WAITERS
-	// The next serial drain should not allow sync waiters.
-	//
-	DISPATCH_INVOKE_ASYNC_REPLY				= 0x00000004,
-	DISPATCH_INVOKE_DISALLOW_SYNC_WAITERS	= 0x00000008,
-
-	// Below this point flags are propagated to recursive calls to drain(),
-	// continuation pop() or dx_invoke().
-#define _DISPATCH_INVOKE_PROPAGATE_MASK		  0xffff0000u
-
-	// Drain modes
-	//
-	// @const DISPATCH_INVOKE_WORKER_DRAIN
-	// Invoke has been issued by a worker thread (work queue thread, or
-	// pthread root queue) drain. This flag is NOT set when the main queue,
-	// manager queue or runloop queues are drained
-	//
-	// @const DISPATCH_INVOKE_REDIRECTING_DRAIN
-	// Has only been draining concurrent queues so far
-	// Implies DISPATCH_INVOKE_WORKER_DRAIN
-	//
-	// @const DISPATCH_INVOKE_MANAGER_DRAIN
-	// We're draining from a manager context
-	//
-	// @const DISPATCH_INVOKE_THREAD_BOUND
-	// We're draining from the context of a thread-bound queue (main thread)
-	//
-	// @const DISPATCH_INVOKE_WORKER_DRAIN
-	// The queue at the bottom of this drain is a workloop that supports
-	// reordering.
-	//
-	DISPATCH_INVOKE_WORKER_DRAIN			= 0x00010000,
-	DISPATCH_INVOKE_REDIRECTING_DRAIN		= 0x00020000,
-	DISPATCH_INVOKE_MANAGER_DRAIN			= 0x00040000,
-	DISPATCH_INVOKE_THREAD_BOUND			= 0x00080000,
-	DISPATCH_INVOKE_WORKLOOP_DRAIN			= 0x00100000,
-#define _DISPATCH_INVOKE_DRAIN_MODE_MASK	  0x00ff0000u
-
-	// Autoreleasing modes
-	//
-	// @const DISPATCH_INVOKE_AUTORELEASE_ALWAYS
-	// Always use autoreleasepools around callouts
-	//
-	// @const DISPATCH_INVOKE_AUTORELEASE_NEVER
-	// Never use autoreleasepools around callouts
-	//
-	DISPATCH_INVOKE_AUTORELEASE_ALWAYS		= 0x01000000,
-	DISPATCH_INVOKE_AUTORELEASE_NEVER		= 0x02000000,
-#define _DISPATCH_INVOKE_AUTORELEASE_MASK	  0x03000000u
-);
-
-DISPATCH_ENUM(dispatch_object_flags, unsigned long,
-	_DISPATCH_META_TYPE_MASK		= 0x000000ff, // mask for object meta-types
-	_DISPATCH_TYPE_CLUSTER_MASK		= 0x000000f0, // mask for the cluster type
-	_DISPATCH_SUB_TYPE_MASK			= 0x0000ff00, // mask for object sub-types
-	_DISPATCH_TYPEFLAGS_MASK		= 0x00ff0000, // mask for object typeflags
-
-	_DISPATCH_OBJECT_CLUSTER        = 0x00000000, // dispatch object cluster
-	_DISPATCH_CONTINUATION_TYPE		= 0x00000000, // meta-type for continuations
-	_DISPATCH_SEMAPHORE_TYPE		= 0x00000001, // meta-type for semaphores
-	_DISPATCH_NODE_TYPE				= 0x00000002, // meta-type for data node
-	_DISPATCH_IO_TYPE				= 0x00000003, // meta-type for io channels
-	_DISPATCH_OPERATION_TYPE		= 0x00000004, // meta-type for io operations
-	_DISPATCH_DISK_TYPE				= 0x00000005, // meta-type for io disks
-
-	_DISPATCH_QUEUE_CLUSTER         = 0x00000010, // dispatch queue cluster
-	_DISPATCH_LANE_TYPE				= 0x00000011, // meta-type for lanes
-	_DISPATCH_WORKLOOP_TYPE			= 0x00000012, // meta-type for workloops
-	_DISPATCH_SOURCE_TYPE			= 0x00000013, // meta-type for sources
-
-	// QUEUE_ROOT is set on root queues (queues with a NULL do_targetq)
-	// QUEUE_BASE is set on hierarchy bases, these always target a root queue
-	// NO_CONTEXT is set on types not supporting dispatch_{get,set}_context
-	_DISPATCH_QUEUE_ROOT_TYPEFLAG	= 0x00010000,
-	_DISPATCH_QUEUE_BASE_TYPEFLAG	= 0x00020000,
-	_DISPATCH_NO_CONTEXT_TYPEFLAG	= 0x00040000,
-
-#define DISPATCH_OBJECT_SUBTYPE(ty, base) (_DISPATCH_##base##_TYPE | (ty) << 8)
-#define DISPATCH_CONTINUATION_TYPE(name) \
-		DISPATCH_OBJECT_SUBTYPE(DC_##name##_TYPE, CONTINUATION)
-
-	DISPATCH_SEMAPHORE_TYPE				= DISPATCH_OBJECT_SUBTYPE(1, SEMAPHORE),
-	DISPATCH_GROUP_TYPE					= DISPATCH_OBJECT_SUBTYPE(2, SEMAPHORE),
-
-	DISPATCH_DATA_TYPE					= DISPATCH_OBJECT_SUBTYPE(1, NODE),
-	DISPATCH_MACH_MSG_TYPE				= DISPATCH_OBJECT_SUBTYPE(2, NODE),
-	DISPATCH_QUEUE_ATTR_TYPE			= DISPATCH_OBJECT_SUBTYPE(3, NODE),
-
-	DISPATCH_IO_TYPE					= DISPATCH_OBJECT_SUBTYPE(0, IO),
-	DISPATCH_OPERATION_TYPE				= DISPATCH_OBJECT_SUBTYPE(0, OPERATION),
-	DISPATCH_DISK_TYPE					= DISPATCH_OBJECT_SUBTYPE(0, DISK),
-
-	DISPATCH_QUEUE_SERIAL_TYPE			= DISPATCH_OBJECT_SUBTYPE(1, LANE),
-	DISPATCH_QUEUE_CONCURRENT_TYPE		= DISPATCH_OBJECT_SUBTYPE(2, LANE),
-	DISPATCH_QUEUE_GLOBAL_ROOT_TYPE		= DISPATCH_OBJECT_SUBTYPE(3, LANE) |
-			_DISPATCH_QUEUE_ROOT_TYPEFLAG | _DISPATCH_NO_CONTEXT_TYPEFLAG,
-	DISPATCH_QUEUE_PTHREAD_ROOT_TYPE	= DISPATCH_OBJECT_SUBTYPE(4, LANE) |
-			_DISPATCH_QUEUE_ROOT_TYPEFLAG | _DISPATCH_NO_CONTEXT_TYPEFLAG,
-	DISPATCH_QUEUE_MGR_TYPE				= DISPATCH_OBJECT_SUBTYPE(5, LANE) |
-			_DISPATCH_QUEUE_BASE_TYPEFLAG | _DISPATCH_NO_CONTEXT_TYPEFLAG,
-	DISPATCH_QUEUE_MAIN_TYPE			= DISPATCH_OBJECT_SUBTYPE(6, LANE) |
-			_DISPATCH_QUEUE_BASE_TYPEFLAG | _DISPATCH_NO_CONTEXT_TYPEFLAG,
-	DISPATCH_QUEUE_RUNLOOP_TYPE			= DISPATCH_OBJECT_SUBTYPE(7, LANE) |
-			_DISPATCH_QUEUE_BASE_TYPEFLAG | _DISPATCH_NO_CONTEXT_TYPEFLAG,
-	DISPATCH_QUEUE_NETWORK_EVENT_TYPE	= DISPATCH_OBJECT_SUBTYPE(8, LANE) |
-			_DISPATCH_QUEUE_BASE_TYPEFLAG,
-
-	DISPATCH_WORKLOOP_TYPE				= DISPATCH_OBJECT_SUBTYPE(0, WORKLOOP) |
-			_DISPATCH_QUEUE_BASE_TYPEFLAG,
-
-	DISPATCH_SOURCE_KEVENT_TYPE			= DISPATCH_OBJECT_SUBTYPE(1, SOURCE),
-	DISPATCH_MACH_CHANNEL_TYPE			= DISPATCH_OBJECT_SUBTYPE(2, SOURCE),
-);
-
-typedef struct _os_object_vtable_s {
-	_OS_OBJECT_CLASS_HEADER();
-} _os_object_vtable_s;
-
-typedef struct _os_object_s {
-	_OS_OBJECT_HEADER(
-	const _os_object_vtable_s *os_obj_isa,
-	os_obj_ref_cnt,
-	os_obj_xref_cnt);
-} _os_object_s;
-
-#if OS_OBJECT_HAVE_OBJC1
-#define OS_OBJECT_STRUCT_HEADER(x) \
-	_OS_OBJECT_HEADER(\
-	const void *_objc_isa, \
-	do_ref_cnt, \
-	do_xref_cnt); \
-	const struct x##_vtable_s *do_vtable
-#else
-#define OS_OBJECT_STRUCT_HEADER(x) \
-	_OS_OBJECT_HEADER(\
-	const struct x##_vtable_s *do_vtable, \
-	do_ref_cnt, \
-	do_xref_cnt)
-#endif
-
-#define _DISPATCH_OBJECT_HEADER(x) \
-	struct _os_object_s _as_os_obj[0]; \
-	OS_OBJECT_STRUCT_HEADER(dispatch_##x); \
-	struct dispatch_##x##_s *volatile do_next; \
-	struct dispatch_queue_s *do_targetq; \
-	void *do_ctxt; \
-	void *do_finalizer
-
-#define DISPATCH_OBJECT_HEADER(x) \
-	struct dispatch_object_s _as_do[0]; \
-	_DISPATCH_OBJECT_HEADER(x)
-
-// Swift-unavailable -init requires method in each class.
-#define DISPATCH_UNAVAILABLE_INIT() \
-	- (instancetype)init { \
-		DISPATCH_CLIENT_CRASH(0, "-init called directly"); \
-		return [super init]; \
-	}
-
-_OS_OBJECT_DECL_PROTOCOL(dispatch_object, object);
-DISPATCH_CLASS_DECL_BARE(object, OBJECT);
-
-struct dispatch_object_s {
-	_DISPATCH_OBJECT_HEADER(object);
-};
-
-DISPATCH_COLD
-size_t _dispatch_object_debug_attr(dispatch_object_t dou, char* buf,
-		size_t bufsiz);
-void *_dispatch_object_alloc(const void *vtable, size_t size);
-void _dispatch_object_finalize(dispatch_object_t dou);
-void _dispatch_object_dealloc(dispatch_object_t dou);
-#if !USE_OBJC
-void _dispatch_xref_dispose(dispatch_object_t dou);
-#endif
-void _dispatch_dispose(dispatch_object_t dou);
-#if DISPATCH_COCOA_COMPAT
-#if USE_OBJC
-#include <objc/runtime.h>
-#if __has_include(<objc/objc-internal.h>)
-#include <objc/objc-internal.h>
-#else
-extern void *objc_autoreleasePoolPush(void);
-extern void objc_autoreleasePoolPop(void *context);
-#endif // __has_include(<objc/objc-internal.h>)
-#define _dispatch_autorelease_pool_push() \
-		objc_autoreleasePoolPush()
-#define _dispatch_autorelease_pool_pop(context) \
-		objc_autoreleasePoolPop(context)
-#else
-void *_dispatch_autorelease_pool_push(void);
-void _dispatch_autorelease_pool_pop(void *context);
-#endif
-void _dispatch_last_resort_autorelease_pool_push(dispatch_invoke_context_t dic);
-void _dispatch_last_resort_autorelease_pool_pop(dispatch_invoke_context_t dic);
-
-#define dispatch_invoke_with_autoreleasepool(flags, ...)  ({ \
-		void *pool = NULL; \
-		if ((flags) & DISPATCH_INVOKE_AUTORELEASE_ALWAYS) { \
-			pool = _dispatch_autorelease_pool_push(); \
-			DISPATCH_COMPILER_CAN_ASSUME(pool); \
-		}; \
-		__VA_ARGS__; \
-		if (pool) _dispatch_autorelease_pool_pop(pool); \
-	})
-#else
-#define dispatch_invoke_with_autoreleasepool(flags, ...) \
-	do { (void)flags; __VA_ARGS__; } while (0)
-#endif
-
-#if USE_OBJC
-OS_OBJECT_OBJC_CLASS_DECL(object);
-#endif
-
-#if OS_OBJECT_HAVE_OBJC2
-// ObjC toll-free bridging, keep in sync with libdispatch.order file
-//
-// This is required by the dispatch_data_t/NSData bridging, which is not
-// supported on the old runtime.
-#define DISPATCH_OBJECT_TFB(f, o, ...) \
-	if (unlikely(((uintptr_t)((o)._os_obj->os_obj_isa) & 1) || \
-			(Class)((o)._os_obj->os_obj_isa) < \
-					(Class)OS_OBJECT_VTABLE(dispatch_object) || \
-			(Class)((o)._os_obj->os_obj_isa) >= \
-					(Class)OS_OBJECT_VTABLE(object))) { \
-		return f((o), ##__VA_ARGS__); \
-	}
-
-id _dispatch_objc_alloc(Class cls, size_t size);
-void _dispatch_objc_retain(dispatch_object_t dou);
-void _dispatch_objc_release(dispatch_object_t dou);
-void _dispatch_objc_set_context(dispatch_object_t dou, void *context);
-void *_dispatch_objc_get_context(dispatch_object_t dou);
-void _dispatch_objc_set_finalizer_f(dispatch_object_t dou,
-		dispatch_function_t finalizer);
-void _dispatch_objc_set_target_queue(dispatch_object_t dou,
-		dispatch_queue_t queue);
-void _dispatch_objc_suspend(dispatch_object_t dou);
-void _dispatch_objc_resume(dispatch_object_t dou);
-void _dispatch_objc_activate(dispatch_object_t dou);
-DISPATCH_COLD
-size_t _dispatch_objc_debug(dispatch_object_t dou, char* buf, size_t bufsiz);
-
-#if __OBJC2__
-@interface NSObject (DISPATCH_CONCAT(_,DISPATCH_CLASS(object)))
-- (void)_setContext:(void*)context;
-- (void*)_getContext;
-- (void)_setFinalizer:(dispatch_function_t)finalizer;
-- (void)_setTargetQueue:(dispatch_queue_t)queue;
-- (void)_suspend;
-- (void)_resume;
-- (void)_activate;
-@end
-#endif // __OBJC2__
-#else
-#define DISPATCH_OBJECT_TFB(f, o, ...)
-#endif // OS_OBJECT_HAVE_OBJC2
-
-#pragma mark -
-#pragma mark _os_object_s
-
-/*
- * Low level _os_atomic_refcnt_* actions
- *
- * _os_atomic_refcnt_inc2o(o, f):
- *   performs a refcount increment and returns the new refcount value
- *
- * _os_atomic_refcnt_dec2o(o, f):
- *   performs a refcount decrement and returns the new refcount value
- *
- * _os_atomic_refcnt_dispose_barrier2o(o, f):
- *   a barrier to perform prior to tearing down an object when the refcount
- *   reached -1.
- */
-#define _os_atomic_refcnt_perform2o(o, f, op, n, m)   ({ \
-		__typeof__(o) _o = (o); \
-		int _ref_cnt = _o->f; \
-		if (likely(_ref_cnt != _OS_OBJECT_GLOBAL_REFCNT)) { \
-			_ref_cnt = os_atomic_##op##2o(_o, f, n, m); \
-		} \
-		_ref_cnt; \
-	})
-
-#define _os_atomic_refcnt_add_orig2o(o, m, n) \
-		_os_atomic_refcnt_perform2o(o, m, add_orig, n, relaxed)
-
-#define _os_atomic_refcnt_sub2o(o, m, n) \
-		_os_atomic_refcnt_perform2o(o, m, sub, n, release)
-
-#define _os_atomic_refcnt_dispose_barrier2o(o, m) \
-		(void)os_atomic_load2o(o, m, acquire)
-
-
-/*
- * Higher level _os_object_{x,}refcnt_* actions
- *
- * _os_atomic_{x,}refcnt_inc_orig(o):
- *   increment the external (resp. internal) refcount and
- *   returns the old refcount value
- *
- * _os_atomic_{x,}refcnt_dec(o):
- *   decrement the external (resp. internal) refcount and
- *   returns the new refcount value
- *
- * _os_atomic_{x,}refcnt_dispose_barrier(o):
- *   performs the pre-teardown barrier for the external
- *   (resp. internal) refcount
- *
- */
-#define _os_object_xrefcnt_inc_orig(o) \
-		_os_atomic_refcnt_add_orig2o(o, os_obj_xref_cnt, 1)
-
-#define _os_object_xrefcnt_dec(o) \
-		_os_atomic_refcnt_sub2o(o, os_obj_xref_cnt, 1)
-
-#define _os_object_xrefcnt_dispose_barrier(o) \
-		_os_atomic_refcnt_dispose_barrier2o(o, os_obj_xref_cnt)
-
-#define _os_object_refcnt_add_orig(o, n) \
-		_os_atomic_refcnt_add_orig2o(o, os_obj_ref_cnt, n)
-
-#define _os_object_refcnt_sub(o, n) \
-		_os_atomic_refcnt_sub2o(o, os_obj_ref_cnt, n)
-
-#define _os_object_refcnt_dispose_barrier(o) \
-		_os_atomic_refcnt_dispose_barrier2o(o, os_obj_ref_cnt)
-
-void _os_object_atfork_child(void);
-void _os_object_atfork_parent(void);
-void _os_object_atfork_prepare(void);
-void _os_object_init(void);
-unsigned long _os_object_retain_count(_os_object_t obj);
-bool _os_object_retain_weak(_os_object_t obj);
-bool _os_object_allows_weak_reference(_os_object_t obj);
-void _os_object_dispose(_os_object_t obj);
-void _os_object_xref_dispose(_os_object_t obj);
-
-#endif // __DISPATCH_OBJECT_INTERNAL__
--- a/Telegram/ThirdParty/dispatch/src/object.m	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/object.m	1970-01-01 00:00:00.000000000 -0000
@@ -1,537 +0,0 @@
-/*
- * Copyright (c) 2011-2014 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include "internal.h"
-
-#if USE_OBJC
-
-#if _OS_OBJECT_OBJC_ARC
-#error "Cannot build with ARC"
-#endif
-#if defined(__OBJC_GC__)
-#error Objective C GC isn't supported anymore
-#endif
-
-#if __has_include(<objc/objc-internal.h>)
-#include <objc/objc-internal.h>
-#else
-extern id _Nullable objc_retain(id _Nullable obj) __asm__("_objc_retain");
-extern void objc_release(id _Nullable obj) __asm__("_objc_release");
-extern void _objc_init(void);
-extern void _objc_atfork_prepare(void);
-extern void _objc_atfork_parent(void);
-extern void _objc_atfork_child(void);
-#endif // __has_include(<objc/objc-internal.h>)
-#include <objc/objc-exception.h>
-#include <Foundation/NSString.h>
-
-// NOTE: this file must not contain any atomic operations
-
-#pragma mark -
-#pragma mark _os_object_t
-
-static inline id
-_os_objc_alloc(Class cls, size_t size)
-{
-	id obj;
-	size -= sizeof(((struct _os_object_s *)NULL)->os_obj_isa);
-	while (unlikely(!(obj = class_createInstance(cls, size)))) {
-		_dispatch_temporary_resource_shortage();
-	}
-	return obj;
-}
-
-static void*
-_os_objc_destructInstance(id obj)
-{
-	// noop if only Libystem is loaded
-	return obj;
-}
-
-#if DISPATCH_COCOA_COMPAT
-static bool _os_object_debug_missing_pools;
-#endif
-
-void
-_os_object_init(void)
-{
-	_objc_init();
-	Block_callbacks_RR callbacks = {
-		sizeof(Block_callbacks_RR),
-		(void (*)(const void *))&objc_retain,
-		(void (*)(const void *))&objc_release,
-		(void (*)(const void *))&_os_objc_destructInstance
-	};
-	_Block_use_RR2(&callbacks);
-#if DISPATCH_COCOA_COMPAT
-	const char *v = getenv("OBJC_DEBUG_MISSING_POOLS");
-	if (v) _os_object_debug_missing_pools = _dispatch_parse_bool(v);
-	v = getenv("DISPATCH_DEBUG_MISSING_POOLS");
-	if (v) _os_object_debug_missing_pools = _dispatch_parse_bool(v);
-	v = getenv("LIBDISPATCH_DEBUG_MISSING_POOLS");
-	if (v) _os_object_debug_missing_pools = _dispatch_parse_bool(v);
-#endif
-}
-
-_os_object_t
-_os_object_alloc_realized(const void *cls, size_t size)
-{
-	dispatch_assert(size >= sizeof(struct _os_object_s));
-	return _os_objc_alloc(cls, size);
-}
-
-_os_object_t
-_os_object_alloc(const void *_cls, size_t size)
-{
-	dispatch_assert(size >= sizeof(struct _os_object_s));
-	Class cls = _cls ? [(id)_cls class] : [OS_OBJECT_CLASS(object) class];
-	return _os_objc_alloc(cls, size);
-}
-
-void
-_os_object_dealloc(_os_object_t obj)
-{
-	[obj dealloc];
-}
-
-void
-_os_object_xref_dispose(_os_object_t obj)
-{
-	struct _os_object_s *o = (struct _os_object_s *)obj;
-	_os_object_xrefcnt_dispose_barrier(o);
-	[obj _xref_dispose];
-}
-
-void
-_os_object_dispose(_os_object_t obj)
-{
-	struct _os_object_s *o = (struct _os_object_s *)obj;
-	_os_object_refcnt_dispose_barrier(o);
-	[obj _dispose];
-}
-
-#undef os_retain
-void*
-os_retain(void *obj)
-{
-	return objc_retain(obj);
-}
-
-#undef os_release
-void
-os_release(void *obj)
-{
-	return objc_release(obj);
-}
-
-void
-_os_object_atfork_prepare(void)
-{
-	return _objc_atfork_prepare();
-}
-
-void
-_os_object_atfork_parent(void)
-{
-	return _objc_atfork_parent();
-}
-
-void
-_os_object_atfork_child(void)
-{
-	return _objc_atfork_child();
-}
-
-#pragma mark -
-#pragma mark _os_object
-
-@implementation OS_OBJECT_CLASS(object)
-DISPATCH_UNAVAILABLE_INIT()
-
--(id)retain {
-	return _os_object_retain(self);
-}
-
--(oneway void)release {
-	return _os_object_release(self);
-}
-
--(NSUInteger)retainCount {
-	return _os_object_retain_count(self);
-}
-
-#pragma clang diagnostic push
-#pragma clang diagnostic ignored "-Wdeprecated-implementations"
-
--(BOOL)retainWeakReference {
-	return _os_object_retain_weak(self);
-}
-
--(BOOL)allowsWeakReference {
-	return _os_object_allows_weak_reference(self);
-}
-
-#pragma clang diagnostic pop
-
-- (void)_xref_dispose {
-	return _os_object_release_internal(self);
-}
-
-- (void)_dispose {
-	return _os_object_dealloc(self);
-}
-
-@end
-
-#pragma mark -
-#pragma mark _dispatch_objc
-#if OS_OBJECT_HAVE_OBJC2
-
-id
-_dispatch_objc_alloc(Class cls, size_t size)
-{
-	return _os_objc_alloc(cls, size);
-}
-
-void
-_dispatch_objc_retain(dispatch_object_t dou)
-{
-	return (void)os_retain(dou);
-}
-
-void
-_dispatch_objc_release(dispatch_object_t dou)
-{
-	return os_release(dou);
-}
-
-void
-_dispatch_objc_set_context(dispatch_object_t dou, void *context)
-{
-	return [dou _setContext:context];
-}
-
-void *
-_dispatch_objc_get_context(dispatch_object_t dou)
-{
-	return [dou _getContext];
-}
-
-void
-_dispatch_objc_set_finalizer_f(dispatch_object_t dou,
-		dispatch_function_t finalizer)
-{
-	return [dou _setFinalizer:finalizer];
-}
-
-void
-_dispatch_objc_set_target_queue(dispatch_object_t dou, dispatch_queue_t queue)
-{
-	return [dou _setTargetQueue:queue];
-}
-
-void
-_dispatch_objc_suspend(dispatch_object_t dou)
-{
-	return [dou _suspend];
-}
-
-void
-_dispatch_objc_resume(dispatch_object_t dou)
-{
-	return [dou _resume];
-}
-
-void
-_dispatch_objc_activate(dispatch_object_t dou)
-{
-	return [dou _activate];
-}
-
-size_t
-_dispatch_objc_debug(dispatch_object_t dou, char* buf, size_t bufsiz)
-{
-	NSUInteger offset = 0;
-	NSString *desc = [dou debugDescription];
-	[desc getBytes:buf maxLength:bufsiz-1 usedLength:&offset
-			encoding:NSUTF8StringEncoding options:(NSStringEncodingConversionOptions)0
-			range:NSMakeRange(0, [desc length]) remainingRange:NULL];
-	if (offset) buf[offset] = 0;
-	return offset;
-}
-
-#endif
-#pragma mark -
-#pragma mark _dispatch_object
-
-// Force non-lazy class realization rdar://10640168
-#define DISPATCH_OBJC_LOAD() + (void)load {}
-
-@implementation DISPATCH_CLASS(object)
-DISPATCH_UNAVAILABLE_INIT()
-
-- (void)_dispose {
-	return _dispatch_dispose(self); // calls _os_object_dealloc()
-}
-
-- (NSString *)debugDescription {
-	Class nsstring = objc_lookUpClass("NSString");
-	if (!nsstring) return nil;
-	char buf[2048];
-	struct dispatch_object_s *obj = (struct dispatch_object_s *)self;
-	if (dx_vtable(obj)->do_debug) {
-		dx_debug(obj, buf, sizeof(buf));
-	} else {
-		strlcpy(buf, object_getClassName(self), sizeof(buf));
-	}
-	NSString *format = [nsstring stringWithUTF8String:"<%s: %s>"];
-	if (!format) return nil;
-	return [nsstring stringWithFormat:format, object_getClassName(self), buf];
-}
-
-- (void)dealloc DISPATCH_NORETURN {
-	DISPATCH_INTERNAL_CRASH(0, "Calling dealloc on a dispatch object");
-	[super dealloc]; // make clang happy
-}
-
-@end
-
-@implementation DISPATCH_CLASS(queue)
-DISPATCH_OBJC_LOAD()
-DISPATCH_UNAVAILABLE_INIT()
-
-- (NSString *)description {
-	Class nsstring = objc_lookUpClass("NSString");
-	if (!nsstring) return nil;
-	NSString *format = [nsstring stringWithUTF8String:"<%s: %s>"];
-	if (!format) return nil;
-	return [nsstring stringWithFormat:format, object_getClassName(self),
-			dispatch_queue_get_label(self), self];
-}
-
-- (void)_xref_dispose {
-	_dispatch_queue_xref_dispose((struct dispatch_queue_s *)self);
-	[super _xref_dispose];
-}
-
-@end
-
-@implementation DISPATCH_CLASS(source)
-DISPATCH_OBJC_LOAD()
-DISPATCH_UNAVAILABLE_INIT()
-
-- (void)_xref_dispose {
-	_dispatch_queue_xref_dispose((struct dispatch_queue_s *)self);
-	_dispatch_source_xref_dispose(self);
-	[super _xref_dispose];
-}
-
-@end
-
-@implementation DISPATCH_CLASS(mach)
-DISPATCH_OBJC_LOAD()
-DISPATCH_UNAVAILABLE_INIT()
-
-- (void)_xref_dispose {
-	_dispatch_queue_xref_dispose((struct dispatch_queue_s *)self);
-	_dispatch_mach_xref_dispose((struct dispatch_mach_s *)self);
-	[super _xref_dispose];
-}
-
-@end
-
-@implementation DISPATCH_CLASS(queue_runloop)
-DISPATCH_OBJC_LOAD()
-DISPATCH_UNAVAILABLE_INIT()
-
-- (void)_xref_dispose {
-	_dispatch_queue_xref_dispose((struct dispatch_queue_s *)self);
-	_dispatch_runloop_queue_xref_dispose((dispatch_lane_t)self);
-	[super _xref_dispose];
-}
-
-@end
-
-#define DISPATCH_CLASS_IMPL(name) \
-		@implementation DISPATCH_CLASS(name) \
-		DISPATCH_OBJC_LOAD() \
-		DISPATCH_UNAVAILABLE_INIT() \
-		@end
-
-#if !DISPATCH_DATA_IS_BRIDGED_TO_NSDATA
-DISPATCH_CLASS_IMPL(data)
-#endif
-DISPATCH_CLASS_IMPL(semaphore)
-DISPATCH_CLASS_IMPL(group)
-DISPATCH_CLASS_IMPL(workloop)
-DISPATCH_CLASS_IMPL(queue_serial)
-DISPATCH_CLASS_IMPL(queue_concurrent)
-DISPATCH_CLASS_IMPL(queue_main)
-DISPATCH_CLASS_IMPL(queue_global)
-#if DISPATCH_USE_PTHREAD_ROOT_QUEUES
-DISPATCH_CLASS_IMPL(queue_pthread_root)
-#endif
-DISPATCH_CLASS_IMPL(queue_mgr)
-DISPATCH_CLASS_IMPL(queue_attr)
-DISPATCH_CLASS_IMPL(mach_msg)
-DISPATCH_CLASS_IMPL(io)
-DISPATCH_CLASS_IMPL(operation)
-DISPATCH_CLASS_IMPL(disk)
-
-@implementation OS_OBJECT_CLASS(voucher)
-DISPATCH_UNAVAILABLE_INIT()
-DISPATCH_OBJC_LOAD()
-
--(id)retain {
-	return (id)_voucher_retain_inline((struct voucher_s *)self);
-}
-
--(oneway void)release {
-	return _voucher_release_inline((struct voucher_s *)self);
-}
-
-- (void)_xref_dispose {
-	return _voucher_xref_dispose(self); // calls _os_object_release_internal()
-}
-
-- (void)_dispose {
-	return _voucher_dispose(self); // calls _os_object_dealloc()
-}
-
-- (NSString *)debugDescription {
-	Class nsstring = objc_lookUpClass("NSString");
-	if (!nsstring) return nil;
-	char buf[2048];
-	_voucher_debug(self, buf, sizeof(buf));
-	NSString *format = [nsstring stringWithUTF8String:"<%s: %s>"];
-	if (!format) return nil;
-	return [nsstring stringWithFormat:format, object_getClassName(self), buf];
-}
-
-@end
-
-#if VOUCHER_ENABLE_RECIPE_OBJECTS
-@implementation OS_OBJECT_CLASS(voucher_recipe)
-DISPATCH_UNAVAILABLE_INIT()
-DISPATCH_OBJC_LOAD()
-
-- (void)_dispose {
-
-}
-
-- (NSString *)debugDescription {
-	return nil; // TODO: voucher_recipe debugDescription
-}
-
-@end
-#endif
-
-
-#pragma mark -
-#pragma mark dispatch_last_resort_autorelease_pool
-
-#if DISPATCH_COCOA_COMPAT
-
-void
-_dispatch_last_resort_autorelease_pool_push(dispatch_invoke_context_t dic)
-{
-	if (likely(!_os_object_debug_missing_pools)) {
-		dic->dic_autorelease_pool = _dispatch_autorelease_pool_push();
-	}
-}
-
-void
-_dispatch_last_resort_autorelease_pool_pop(dispatch_invoke_context_t dic)
-{
-	if (likely(!_os_object_debug_missing_pools)) {
-		_dispatch_autorelease_pool_pop(dic->dic_autorelease_pool);
-		dic->dic_autorelease_pool = NULL;
-	}
-}
-
-#endif // DISPATCH_COCOA_COMPAT
-
-#pragma mark -
-#pragma mark dispatch_client_callout
-
-// Abort on uncaught exceptions thrown from client callouts rdar://8577499
-#if DISPATCH_USE_CLIENT_CALLOUT && !__USING_SJLJ_EXCEPTIONS__ && \
-		OS_OBJECT_HAVE_OBJC2
-// On platforms with zero-cost exceptions, use a compiler-generated catch-all
-// exception handler.
-
-DISPATCH_NORETURN extern void objc_terminate(void);
-
-#undef _dispatch_client_callout
-void
-_dispatch_client_callout(void *ctxt, dispatch_function_t f)
-{
-	@try {
-		return f(ctxt);
-	}
-	@catch (...) {
-		objc_terminate();
-	}
-}
-
-#undef _dispatch_client_callout2
-void
-_dispatch_client_callout2(void *ctxt, size_t i, void (*f)(void *, size_t))
-{
-	@try {
-		return f(ctxt, i);
-	}
-	@catch (...) {
-		objc_terminate();
-	}
-}
-
-#if HAVE_MACH
-#undef _dispatch_client_callout3
-void
-_dispatch_client_callout3(void *ctxt, dispatch_mach_reason_t reason,
-		dispatch_mach_msg_t dmsg, dispatch_mach_async_reply_callback_t f)
-{
-	@try {
-		return f(ctxt, reason, dmsg);
-	}
-	@catch (...) {
-		objc_terminate();
-	}
-}
-
-#undef _dispatch_client_callout4
-void
-_dispatch_client_callout4(void *ctxt, dispatch_mach_reason_t reason,
-		dispatch_mach_msg_t dmsg, mach_error_t error,
-		dispatch_mach_handler_function_t f)
-{
-	@try {
-		return f(ctxt, reason, dmsg, error);
-	}
-	@catch (...) {
-		objc_terminate();
-	}
-}
-#endif // HAVE_MACH
-
-#endif // DISPATCH_USE_CLIENT_CALLOUT
-
-#endif // USE_OBJC
--- a/Telegram/ThirdParty/dispatch/src/once.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/once.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,71 +0,0 @@
-/*
- * Copyright (c) 2008-2013 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include "internal.h"
-
-#undef dispatch_once
-#undef dispatch_once_f
-
-
-#ifdef __BLOCKS__
-void
-dispatch_once(dispatch_once_t *val, dispatch_block_t block)
-{
-	dispatch_once_f(val, block, _dispatch_Block_invoke(block));
-}
-#endif
-
-#if DISPATCH_ONCE_INLINE_FASTPATH
-#define DISPATCH_ONCE_SLOW_INLINE inline DISPATCH_ALWAYS_INLINE
-#else
-#define DISPATCH_ONCE_SLOW_INLINE DISPATCH_NOINLINE
-#endif // DISPATCH_ONCE_INLINE_FASTPATH
-
-DISPATCH_NOINLINE
-static void
-_dispatch_once_callout(dispatch_once_gate_t l, void *ctxt,
-		dispatch_function_t func)
-{
-	_dispatch_client_callout(ctxt, func);
-	_dispatch_once_gate_broadcast(l);
-}
-
-DISPATCH_NOINLINE
-void
-dispatch_once_f(dispatch_once_t *val, void *ctxt, dispatch_function_t func)
-{
-	dispatch_once_gate_t l = (dispatch_once_gate_t)val;
-
-#if !DISPATCH_ONCE_INLINE_FASTPATH || DISPATCH_ONCE_USE_QUIESCENT_COUNTER
-	uintptr_t v = os_atomic_load(&l->dgo_once, acquire);
-	if (likely(v == DLOCK_ONCE_DONE)) {
-		return;
-	}
-#if DISPATCH_ONCE_USE_QUIESCENT_COUNTER
-	if (likely(DISPATCH_ONCE_IS_GEN(v))) {
-		return _dispatch_once_mark_done_if_quiesced(l, v);
-	}
-#endif
-#endif
-	if (_dispatch_once_gate_tryenter(l)) {
-		return _dispatch_once_callout(l, ctxt, func);
-	}
-	return _dispatch_once_wait(l);
-}
--- a/Telegram/ThirdParty/dispatch/src/protocol.defs	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/protocol.defs	1970-01-01 00:00:00.000000000 -0000
@@ -1,94 +0,0 @@
-/*
- * Copyright (c) 2008-2013 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include <mach/std_types.defs>
-#include <mach/mach_types.defs>
-
-// '64' is used to align with Mach notifications and so that we don't fight
-// with the notify symbols in Libsystem
-subsystem libdispatch_internal_protocol 64;
-
-serverprefix _dispatch_;
-userprefix _dispatch_send_;
-
-skip; /* was MACH_NOTIFY_FIRST: 64 */
-
-/* MACH_NOTIFY_PORT_DELETED: 65 */
-simpleroutine
-mach_notify_port_deleted(
-					_notify	: mach_port_move_send_once_t;
-					_name	: mach_port_name_t
-);
-
-/* MACH_NOTIFY_SEND_POSSIBLE: 66 */
-simpleroutine
-mach_notify_send_possible(
-					_notify	: mach_port_move_send_once_t;
-					_name	: mach_port_name_t
-);
-
-skip;   /* was NOTIFY_OWNERSHIP_RIGHTS: 67 */
-
-skip;   /* was NOTIFY_RECEIVE_RIGHTS: 68 */
-
-/* MACH_NOTIFY_PORT_DESTROYED: 69 */
-simpleroutine
-mach_notify_port_destroyed(
-					_notify	: mach_port_move_send_once_t;
-					_rights	: mach_port_move_receive_t
-);
-
-/* MACH_NOTIFY_NO_SENDERS: 70 */
-simpleroutine
-mach_notify_no_senders(
-					_notify	: mach_port_move_send_once_t;
-					_mscnt	: mach_port_mscount_t
-);
-
-/* MACH_NOTIFY_SEND_ONCE: 71 */
-simpleroutine
-mach_notify_send_once(
-					_notify	: mach_port_move_send_once_t
-);
-
-/* MACH_NOTIFY_DEAD_NAME: 72 */
-simpleroutine
-mach_notify_dead_name(
-					_notify	: mach_port_move_send_once_t;
-					_name	: mach_port_name_t
-);
-
-/* highly unlikely additional Mach notifications */
-skip;
-skip;
-skip;
-skip;
-skip;
-
-simpleroutine
-wakeup_runloop_thread(
-					_port	: mach_port_t;
-	WaitTime _waitTimeout	: natural_t
-);
-
-simpleroutine
-consume_send_once_right(
-					_port	: mach_port_move_send_once_t
-);
--- a/Telegram/ThirdParty/dispatch/src/provider.d	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/provider.d	1970-01-01 00:00:00.000000000 -0000
@@ -1,141 +0,0 @@
-/*
- * Copyright (c) 2010-2013 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-/*
- * DTrace Probes for libdispatch
- *
- * Only available in the introspection version of the library,
- * loaded by running a process with the environment variable
- * DYLD_LIBRARY_PATH=/usr/lib/system/introspection
- */
-
-typedef struct dispatch_object_s *dispatch_object_t;
-typedef struct dispatch_queue_s *dispatch_queue_t;
-typedef struct dispatch_source_s *dispatch_source_t;
-typedef void (*dispatch_function_t)(void *);
-typedef struct dispatch_trace_timer_params_s {
-	int64_t deadline, interval, leeway;
-} *dispatch_trace_timer_params_t;
-
-
-provider dispatch {
-
-/*
- * Probes for dispatch queue push and pop operations
- *
- * dispatch$target:libdispatch*.dylib::queue-push
- * dispatch$target:libdispatch*.dylib::queue-pop
- */
-	probe queue__push(dispatch_queue_t queue, const char *label,
-			dispatch_object_t item, const char *kind,
-			dispatch_function_t function, void *context);
-	probe queue__pop(dispatch_queue_t queue, const char *label,
-			dispatch_object_t item, const char *kind,
-			dispatch_function_t function, void *context);
-
-/*
- * Probes for dispatch callouts to client functions
- *
- * dispatch$target:libdispatch*.dylib::callout-entry
- * dispatch$target:libdispatch*.dylib::callout-return
- */
-	probe callout__entry(dispatch_queue_t queue, const char *label,
-			dispatch_function_t function, void *context);
-	probe callout__return(dispatch_queue_t queue, const char *label,
-			dispatch_function_t function, void *context);
-
-/*
- * Probes for dispatch timer configuration and programming
- *
- * Timer configuration indicates that dispatch_source_set_timer() was called.
- * Timer programming indicates that the dispatch manager is about to sleep
- * for 'deadline' ns (but may wake up earlier if non-timer events occur).
- * Time parameters are in nanoseconds, a value of -1 means "forever".
- *
- * dispatch$target:libdispatch*.dylib::timer-configure
- * dispatch$target:libdispatch*.dylib::timer-program
- */
-	probe timer__configure(dispatch_source_t source,
-			dispatch_function_t handler, dispatch_trace_timer_params_t params);
-	probe timer__program(dispatch_source_t source, dispatch_function_t handler,
-			dispatch_trace_timer_params_t params);
-
-/*
- * Probes for dispatch timer wakes and fires
- *
- * Timer wakes indicate that the dispatch manager woke up due to expiry of the
- * deadline for the specified timer.
- * Timer fires indicate that that the dispatch manager scheduled the event
- * handler of the specified timer for asynchronous execution (may occur without
- * a corresponding timer wake if the manager was awake processing other events
- * when the timer deadline expired).
- *
- * dispatch$target:libdispatch*.dylib::timer-wake
- * dispatch$target:libdispatch*.dylib::timer-fire
- */
-	probe timer__wake(dispatch_source_t source, dispatch_function_t handler);
-	probe timer__fire(dispatch_source_t source, dispatch_function_t handler);
-
-};
-
-
-#pragma D attributes Evolving/Evolving/Common provider dispatch provider
-#pragma D attributes Private/Private/Common provider dispatch module
-#pragma D attributes Private/Private/Common provider dispatch function
-#pragma D attributes Evolving/Evolving/Common provider dispatch name
-#pragma D attributes Evolving/Evolving/Common provider dispatch args
-
-typedef struct voucher_s *voucher_t;
-
-/*
- * Probes for vouchers
- */
-provider voucher {
-
-    /*
-     * Voucher lifetime:
-     *
-     * voucher$target:::create     A new voucher is being created
-     * voucher$target:::dispose    A voucher is being freed
-     * voucher$target:::retain     A voucher is being retained
-     * voucher$target:::release    A voucher is being released
-     */
-    probe create(voucher_t voucher, mach_port_t kv, uint64_t activity_id);
-    probe dispose(voucher_t voucher);
-    probe retain(voucher_t voucher, int resulting_refcnt);
-    probe release(voucher_t voucher, int resulting_refcnt);
-
-    /*
-     * Thread adoption
-     *
-     * voucher$target:::adopt      A voucher is being adopted by the current thread
-     * voucher$target:::orphan     A voucher is being orphanned by the current thread
-     */
-    probe adopt(voucher_t voucher);
-    probe orphan(voucher_t voucher);
-
-};
-
-#pragma D attributes Evolving/Evolving/Common provider voucher provider
-#pragma D attributes Private/Private/Common provider voucher module
-#pragma D attributes Private/Private/Common provider voucher function
-#pragma D attributes Evolving/Evolving/Common provider voucher name
-#pragma D attributes Evolving/Evolving/Common provider voucher args
-
--- a/Telegram/ThirdParty/dispatch/src/queue.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/queue.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,7480 +0,0 @@
-/*
- * Copyright (c) 2008-2013 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include "internal.h"
-#if HAVE_MACH
-#include "protocol.h" // _dispatch_send_wakeup_runloop_thread
-#endif
-
-static inline void _dispatch_root_queues_init(void);
-static void _dispatch_lane_barrier_complete(dispatch_lane_class_t dqu,
-		dispatch_qos_t qos, dispatch_wakeup_flags_t flags);
-static void _dispatch_lane_non_barrier_complete(dispatch_lane_t dq,
-		dispatch_wakeup_flags_t flags);
-#if HAVE_PTHREAD_WORKQUEUE_QOS
-static inline void _dispatch_queue_wakeup_with_override(
-		dispatch_queue_class_t dq, uint64_t dq_state,
-		dispatch_wakeup_flags_t flags);
-#endif
-static void _dispatch_workloop_drain_barrier_waiter(dispatch_workloop_t dwl,
-		struct dispatch_object_s *dc, dispatch_qos_t qos,
-		dispatch_wakeup_flags_t flags, uint64_t owned);
-
-#pragma mark -
-#pragma mark dispatch_assert_queue
-
-DISPATCH_NOINLINE DISPATCH_NORETURN
-static void
-_dispatch_assert_queue_fail(dispatch_queue_t dq, bool expected)
-{
-	_dispatch_client_assert_fail(
-			"Block was %sexpected to execute on queue [%s]",
-			expected ? "" : "not ", dq->dq_label ?: "");
-}
-
-DISPATCH_NOINLINE DISPATCH_NORETURN
-static void
-_dispatch_assert_queue_barrier_fail(dispatch_queue_t dq)
-{
-	_dispatch_client_assert_fail(
-			"Block was expected to act as a barrier on queue [%s]",
-			dq->dq_label ?: "");
-}
-
-void
-dispatch_assert_queue(dispatch_queue_t dq)
-{
-	unsigned long metatype = dx_metatype(dq);
-	if (unlikely(metatype != _DISPATCH_LANE_TYPE &&
-			metatype != _DISPATCH_WORKLOOP_TYPE)) {
-		DISPATCH_CLIENT_CRASH(metatype, "invalid queue passed to "
-				"dispatch_assert_queue()");
-	}
-	uint64_t dq_state = os_atomic_load2o(dq, dq_state, relaxed);
-	if (likely(_dq_state_drain_locked_by_self(dq_state))) {
-		return;
-	}
-	if (likely(_dispatch_thread_frame_find_queue(dq))) {
-		return;
-	}
-	_dispatch_assert_queue_fail(dq, true);
-}
-
-void
-dispatch_assert_queue_not(dispatch_queue_t dq)
-{
-	unsigned long metatype = dx_metatype(dq);
-	if (unlikely(metatype != _DISPATCH_LANE_TYPE &&
-			metatype != _DISPATCH_WORKLOOP_TYPE)) {
-		DISPATCH_CLIENT_CRASH(metatype, "invalid queue passed to "
-				"dispatch_assert_queue_not()");
-	}
-	uint64_t dq_state = os_atomic_load2o(dq, dq_state, relaxed);
-	if (unlikely(_dq_state_drain_locked_by_self(dq_state))) {
-		_dispatch_assert_queue_fail(dq, false);
-	}
-	if (unlikely(_dispatch_thread_frame_find_queue(dq))) {
-		_dispatch_assert_queue_fail(dq, false);
-	}
-}
-
-void
-dispatch_assert_queue_barrier(dispatch_queue_t dq)
-{
-	dispatch_assert_queue(dq);
-
-	if (likely(dq->dq_width == 1)) {
-		return;
-	}
-
-	if (likely(dq->do_targetq)) {
-		uint64_t dq_state = os_atomic_load2o(dq, dq_state, relaxed);
-		if (likely(_dq_state_is_in_barrier(dq_state))) {
-			return;
-		}
-	}
-
-	_dispatch_assert_queue_barrier_fail(dq);
-}
-
-#pragma mark -
-#pragma mark _dispatch_set_priority_and_mach_voucher
-#if HAVE_PTHREAD_WORKQUEUE_QOS
-
-DISPATCH_NOINLINE
-void
-_dispatch_set_priority_and_mach_voucher_slow(pthread_priority_t pp,
-		mach_voucher_t kv)
-{
-	_pthread_set_flags_t pflags = 0;
-	if (pp && _dispatch_set_qos_class_enabled) {
-		pthread_priority_t old_pri = _dispatch_get_priority();
-		if (pp != old_pri) {
-			if (old_pri & _PTHREAD_PRIORITY_NEEDS_UNBIND_FLAG) {
-				pflags |= _PTHREAD_SET_SELF_WQ_KEVENT_UNBIND;
-				// when we unbind, overcomitness can flip, so we need to learn
-				// it from the defaultpri, see _dispatch_priority_compute_update
-				pp |= (_dispatch_get_basepri() &
-						DISPATCH_PRIORITY_FLAG_OVERCOMMIT);
-			} else {
-				// else we need to keep the one that is set in the current pri
-				pp |= (old_pri & _PTHREAD_PRIORITY_OVERCOMMIT_FLAG);
-			}
-			if (likely(old_pri & ~_PTHREAD_PRIORITY_FLAGS_MASK)) {
-				pflags |= _PTHREAD_SET_SELF_QOS_FLAG;
-			}
-			uint64_t mgr_dq_state =
-					os_atomic_load2o(&_dispatch_mgr_q, dq_state, relaxed);
-			if (unlikely(_dq_state_drain_locked_by_self(mgr_dq_state))) {
-				DISPATCH_INTERNAL_CRASH(pp,
-						"Changing the QoS while on the manager queue");
-			}
-			if (unlikely(pp & _PTHREAD_PRIORITY_EVENT_MANAGER_FLAG)) {
-				DISPATCH_INTERNAL_CRASH(pp, "Cannot raise oneself to manager");
-			}
-			if (old_pri & _PTHREAD_PRIORITY_EVENT_MANAGER_FLAG) {
-				DISPATCH_INTERNAL_CRASH(old_pri,
-						"Cannot turn a manager thread into a normal one");
-			}
-		}
-	}
-	if (kv != VOUCHER_NO_MACH_VOUCHER) {
-#if VOUCHER_USE_MACH_VOUCHER
-		pflags |= _PTHREAD_SET_SELF_VOUCHER_FLAG;
-#endif
-	}
-	if (!pflags) return;
-	int r = _pthread_set_properties_self(pflags, pp, kv);
-	if (r == EINVAL) {
-		DISPATCH_INTERNAL_CRASH(pp, "_pthread_set_properties_self failed");
-	}
-	(void)dispatch_assume_zero(r);
-}
-
-DISPATCH_NOINLINE
-voucher_t
-_dispatch_set_priority_and_voucher_slow(pthread_priority_t priority,
-		voucher_t v, dispatch_thread_set_self_t flags)
-{
-	voucher_t ov = DISPATCH_NO_VOUCHER;
-	mach_voucher_t kv = VOUCHER_NO_MACH_VOUCHER;
-	if (v != DISPATCH_NO_VOUCHER) {
-		bool retained = flags & DISPATCH_VOUCHER_CONSUME;
-		ov = _voucher_get();
-		if (ov == v && (flags & DISPATCH_VOUCHER_REPLACE)) {
-			if (retained && v) _voucher_release_no_dispose(v);
-			ov = DISPATCH_NO_VOUCHER;
-		} else {
-			if (!retained && v) _voucher_retain(v);
-			kv = _voucher_swap_and_get_mach_voucher(ov, v);
-		}
-	}
-	if (!(flags & DISPATCH_THREAD_PARK)) {
-		_dispatch_set_priority_and_mach_voucher_slow(priority, kv);
-	}
-	if (ov != DISPATCH_NO_VOUCHER && (flags & DISPATCH_VOUCHER_REPLACE)) {
-		if (ov) _voucher_release(ov);
-		ov = DISPATCH_NO_VOUCHER;
-	}
-	return ov;
-}
-#endif
-#pragma mark -
-#pragma mark dispatch_continuation_t
-
-static void _dispatch_async_redirect_invoke(dispatch_continuation_t dc,
-		dispatch_invoke_context_t dic, dispatch_invoke_flags_t flags);
-#if HAVE_PTHREAD_WORKQUEUE_QOS
-static void _dispatch_queue_override_invoke(dispatch_continuation_t dc,
-		dispatch_invoke_context_t dic, dispatch_invoke_flags_t flags);
-static void _dispatch_workloop_stealer_invoke(dispatch_continuation_t dc,
-		dispatch_invoke_context_t dic, dispatch_invoke_flags_t flags);
-#endif // HAVE_PTHREAD_WORKQUEUE_QOS
-
-const struct dispatch_continuation_vtable_s _dispatch_continuation_vtables[] = {
-	DC_VTABLE_ENTRY(ASYNC_REDIRECT,
-		.do_invoke = _dispatch_async_redirect_invoke),
-#if HAVE_MACH
-	DC_VTABLE_ENTRY(MACH_SEND_BARRRIER_DRAIN,
-		.do_invoke = _dispatch_mach_send_barrier_drain_invoke),
-	DC_VTABLE_ENTRY(MACH_SEND_BARRIER,
-		.do_invoke = _dispatch_mach_barrier_invoke),
-	DC_VTABLE_ENTRY(MACH_RECV_BARRIER,
-		.do_invoke = _dispatch_mach_barrier_invoke),
-	DC_VTABLE_ENTRY(MACH_ASYNC_REPLY,
-		.do_invoke = _dispatch_mach_msg_async_reply_invoke),
-#endif
-#if HAVE_PTHREAD_WORKQUEUE_QOS
-	DC_VTABLE_ENTRY(WORKLOOP_STEALING,
-		.do_invoke = _dispatch_workloop_stealer_invoke),
-	DC_VTABLE_ENTRY(OVERRIDE_STEALING,
-		.do_invoke = _dispatch_queue_override_invoke),
-	DC_VTABLE_ENTRY(OVERRIDE_OWNING,
-		.do_invoke = _dispatch_queue_override_invoke),
-#endif
-#if HAVE_MACH
-	DC_VTABLE_ENTRY(MACH_IPC_HANDOFF,
-		.do_invoke = _dispatch_mach_ipc_handoff_invoke),
-#endif
-};
-
-DISPATCH_NOINLINE
-static void DISPATCH_TSD_DTOR_CC
-_dispatch_cache_cleanup(void *value)
-{
-	dispatch_continuation_t dc, next_dc = value;
-
-	while ((dc = next_dc)) {
-		next_dc = dc->do_next;
-		_dispatch_continuation_free_to_heap(dc);
-	}
-}
-
-static void
-_dispatch_force_cache_cleanup(void)
-{
-	dispatch_continuation_t dc;
-	dc = _dispatch_thread_getspecific(dispatch_cache_key);
-	if (dc) {
-		_dispatch_thread_setspecific(dispatch_cache_key, NULL);
-		_dispatch_cache_cleanup(dc);
-	}
-}
-
-#if DISPATCH_USE_MEMORYPRESSURE_SOURCE
-DISPATCH_NOINLINE
-void
-_dispatch_continuation_free_to_cache_limit(dispatch_continuation_t dc)
-{
-	_dispatch_continuation_free_to_heap(dc);
-	dispatch_continuation_t next_dc;
-	dc = _dispatch_thread_getspecific(dispatch_cache_key);
-	int cnt;
-	if (!dc || (cnt = dc->dc_cache_cnt -
-			_dispatch_continuation_cache_limit) <= 0) {
-		return;
-	}
-	do {
-		next_dc = dc->do_next;
-		_dispatch_continuation_free_to_heap(dc);
-	} while (--cnt && (dc = next_dc));
-	_dispatch_thread_setspecific(dispatch_cache_key, next_dc);
-}
-#endif
-
-DISPATCH_NOINLINE
-void
-_dispatch_continuation_pop(dispatch_object_t dou, dispatch_invoke_context_t dic,
-		dispatch_invoke_flags_t flags, dispatch_queue_class_t dqu)
-{
-	_dispatch_continuation_pop_inline(dou, dic, flags, dqu._dq);
-}
-
-#pragma mark -
-#pragma mark dispatch_block_create
-
-#if __BLOCKS__
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dispatch_block_flags_valid(dispatch_block_flags_t flags)
-{
-	return ((flags & ~DISPATCH_BLOCK_API_MASK) == 0);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_block_flags_t
-_dispatch_block_normalize_flags(dispatch_block_flags_t flags)
-{
-	if (flags & (DISPATCH_BLOCK_NO_QOS_CLASS|DISPATCH_BLOCK_DETACHED)) {
-		flags |= DISPATCH_BLOCK_HAS_PRIORITY;
-	}
-	if (flags & DISPATCH_BLOCK_ENFORCE_QOS_CLASS) {
-		flags &= ~(dispatch_block_flags_t)DISPATCH_BLOCK_INHERIT_QOS_CLASS;
-	}
-	return flags;
-}
-
-static inline dispatch_block_t
-_dispatch_block_create_with_voucher_and_priority(dispatch_block_flags_t flags,
-		voucher_t voucher, pthread_priority_t pri, dispatch_block_t block)
-{
-	dispatch_block_flags_t unmodified_flags = flags;
-	pthread_priority_t unmodified_pri = pri;
-
-	flags = _dispatch_block_normalize_flags(flags);
-	bool assign = (flags & DISPATCH_BLOCK_ASSIGN_CURRENT);
-
-	if (!(flags & DISPATCH_BLOCK_HAS_VOUCHER)) {
-		if (flags & DISPATCH_BLOCK_DETACHED) {
-			voucher = VOUCHER_NULL;
-			flags |= DISPATCH_BLOCK_HAS_VOUCHER;
-		} else if (flags & DISPATCH_BLOCK_NO_VOUCHER) {
-			voucher = DISPATCH_NO_VOUCHER;
-			flags |= DISPATCH_BLOCK_HAS_VOUCHER;
-		} else if (assign) {
-#if OS_VOUCHER_ACTIVITY_SPI
-			voucher = VOUCHER_CURRENT;
-#endif
-			flags |= DISPATCH_BLOCK_HAS_VOUCHER;
-		}
-	}
-#if OS_VOUCHER_ACTIVITY_SPI
-	if (voucher == VOUCHER_CURRENT) {
-		voucher = _voucher_get();
-	}
-#endif
-	if (assign && !(flags & DISPATCH_BLOCK_HAS_PRIORITY)) {
-		pri = _dispatch_priority_propagate();
-		flags |= DISPATCH_BLOCK_HAS_PRIORITY;
-	}
-	dispatch_block_t db = _dispatch_block_create(flags, voucher, pri, block);
-
-#if DISPATCH_DEBUG
-	dispatch_assert(_dispatch_block_get_data(db));
-#endif
-
-	_dispatch_trace_block_create_with_voucher_and_priority(db,
-			_dispatch_Block_invoke(block), unmodified_flags,
-			((unmodified_flags & DISPATCH_BLOCK_HAS_PRIORITY) ? unmodified_pri :
-					(unsigned long)UINT32_MAX),
-			_dispatch_get_priority(), pri);
-	return db;
-}
-
-dispatch_block_t
-dispatch_block_create(dispatch_block_flags_t flags, dispatch_block_t block)
-{
-	if (!_dispatch_block_flags_valid(flags)) return DISPATCH_BAD_INPUT;
-	return _dispatch_block_create_with_voucher_and_priority(flags, NULL, 0,
-			block);
-}
-
-dispatch_block_t
-dispatch_block_create_with_qos_class(dispatch_block_flags_t flags,
-		dispatch_qos_class_t qos_class, int relative_priority,
-		dispatch_block_t block)
-{
-	if (!_dispatch_block_flags_valid(flags) ||
-			!_dispatch_qos_class_valid(qos_class, relative_priority)) {
-		return DISPATCH_BAD_INPUT;
-	}
-	flags |= DISPATCH_BLOCK_HAS_PRIORITY;
-	pthread_priority_t pri = 0;
-#if HAVE_PTHREAD_WORKQUEUE_QOS
-	pri = _pthread_qos_class_encode(qos_class, relative_priority, 0);
-#endif
-	return _dispatch_block_create_with_voucher_and_priority(flags, NULL,
-			pri, block);
-}
-
-dispatch_block_t
-dispatch_block_create_with_voucher(dispatch_block_flags_t flags,
-		voucher_t voucher, dispatch_block_t block)
-{
-	if (!_dispatch_block_flags_valid(flags)) return DISPATCH_BAD_INPUT;
-	flags |= DISPATCH_BLOCK_HAS_VOUCHER;
-	flags &= ~DISPATCH_BLOCK_NO_VOUCHER;
-	return _dispatch_block_create_with_voucher_and_priority(flags, voucher, 0,
-			block);
-}
-
-dispatch_block_t
-dispatch_block_create_with_voucher_and_qos_class(dispatch_block_flags_t flags,
-		voucher_t voucher, dispatch_qos_class_t qos_class,
-		int relative_priority, dispatch_block_t block)
-{
-	if (!_dispatch_block_flags_valid(flags) ||
-			!_dispatch_qos_class_valid(qos_class, relative_priority)) {
-		return DISPATCH_BAD_INPUT;
-	}
-	flags |= (DISPATCH_BLOCK_HAS_VOUCHER|DISPATCH_BLOCK_HAS_PRIORITY);
-	flags &= ~(DISPATCH_BLOCK_NO_VOUCHER|DISPATCH_BLOCK_NO_QOS_CLASS);
-	pthread_priority_t pri = 0;
-#if HAVE_PTHREAD_WORKQUEUE_QOS
-	pri = _pthread_qos_class_encode(qos_class, relative_priority, 0);
-#endif
-	return _dispatch_block_create_with_voucher_and_priority(flags, voucher,
-			pri, block);
-}
-
-void
-dispatch_block_perform(dispatch_block_flags_t flags, dispatch_block_t block)
-{
-	if (!_dispatch_block_flags_valid(flags)) {
-		DISPATCH_CLIENT_CRASH(flags, "Invalid flags passed to "
-				"dispatch_block_perform()");
-	}
-	flags = _dispatch_block_normalize_flags(flags);
-
-	voucher_t voucher = DISPATCH_NO_VOUCHER;
-	if (flags & DISPATCH_BLOCK_DETACHED) {
-		voucher = VOUCHER_NULL;
-		flags |= DISPATCH_BLOCK_HAS_VOUCHER;
-	}
-
-	struct dispatch_block_private_data_s dbpds =
-		DISPATCH_BLOCK_PRIVATE_DATA_PERFORM_INITIALIZER(flags, block, voucher);
-	return _dispatch_block_invoke_direct(&dbpds);
-}
-
-void
-_dispatch_block_invoke_direct(const struct dispatch_block_private_data_s *dbcpd)
-{
-	dispatch_block_private_data_t dbpd = (dispatch_block_private_data_t)dbcpd;
-	dispatch_block_flags_t flags = dbpd->dbpd_flags;
-	unsigned int atomic_flags = dbpd->dbpd_atomic_flags;
-	if (unlikely(atomic_flags & DBF_WAITED)) {
-		DISPATCH_CLIENT_CRASH(atomic_flags, "A block object may not be both "
-				"run more than once and waited for");
-	}
-	if (atomic_flags & DBF_CANCELED) goto out;
-
-	pthread_priority_t op = 0, p = 0;
-	op = _dispatch_block_invoke_should_set_priority(flags, dbpd->dbpd_priority);
-	if (op) {
-		p = dbpd->dbpd_priority;
-	}
-	voucher_t ov, v = DISPATCH_NO_VOUCHER;
-	if (flags & DISPATCH_BLOCK_HAS_VOUCHER) {
-		v = dbpd->dbpd_voucher;
-	}
-	ov = _dispatch_set_priority_and_voucher(p, v, 0);
-	dbpd->dbpd_thread = _dispatch_tid_self();
-	_dispatch_client_callout(dbpd->dbpd_block,
-			_dispatch_Block_invoke(dbpd->dbpd_block));
-	_dispatch_reset_priority_and_voucher(op, ov);
-out:
-	if ((atomic_flags & DBF_PERFORM) == 0) {
-		if (os_atomic_inc2o(dbpd, dbpd_performed, relaxed) == 1) {
-			dispatch_group_leave(dbpd->dbpd_group);
-		}
-	}
-}
-
-void
-_dispatch_block_sync_invoke(void *block)
-{
-	dispatch_block_t b = block;
-	dispatch_block_private_data_t dbpd = _dispatch_block_get_data(b);
-	dispatch_block_flags_t flags = dbpd->dbpd_flags;
-	unsigned int atomic_flags = dbpd->dbpd_atomic_flags;
-	if (unlikely(atomic_flags & DBF_WAITED)) {
-		DISPATCH_CLIENT_CRASH(atomic_flags, "A block object may not be both "
-				"run more than once and waited for");
-	}
-	if (atomic_flags & DBF_CANCELED) goto out;
-
-	voucher_t ov = DISPATCH_NO_VOUCHER;
-	if (flags & DISPATCH_BLOCK_HAS_VOUCHER) {
-		ov = _dispatch_adopt_priority_and_set_voucher(0, dbpd->dbpd_voucher, 0);
-	}
-	dbpd->dbpd_block();
-	_dispatch_reset_voucher(ov, 0);
-out:
-	if ((atomic_flags & DBF_PERFORM) == 0) {
-		if (os_atomic_inc2o(dbpd, dbpd_performed, relaxed) == 1) {
-			dispatch_group_leave(dbpd->dbpd_group);
-		}
-	}
-
-	dispatch_queue_t boost_dq;
-	boost_dq = os_atomic_xchg2o(dbpd, dbpd_queue, NULL, relaxed);
-	if (boost_dq) {
-		// balances dispatch_{,barrier_,}sync
-		_dispatch_release_2(boost_dq);
-	}
-}
-
-#define DISPATCH_BLOCK_ASYNC_INVOKE_RELEASE           0x1
-
-DISPATCH_NOINLINE
-static void
-_dispatch_block_async_invoke2(dispatch_block_t b, unsigned long invoke_flags)
-{
-	dispatch_block_private_data_t dbpd = _dispatch_block_get_data(b);
-	unsigned int atomic_flags = dbpd->dbpd_atomic_flags;
-	if (unlikely(atomic_flags & DBF_WAITED)) {
-		DISPATCH_CLIENT_CRASH(atomic_flags, "A block object may not be both "
-				"run more than once and waited for");
-	}
-
-	if (likely(!(atomic_flags & DBF_CANCELED))) {
-		dbpd->dbpd_block();
-	}
-	if ((atomic_flags & DBF_PERFORM) == 0) {
-		if (os_atomic_inc2o(dbpd, dbpd_performed, relaxed) == 1) {
-			dispatch_group_leave(dbpd->dbpd_group);
-		}
-	}
-
-	dispatch_queue_t boost_dq;
-	boost_dq = os_atomic_xchg2o(dbpd, dbpd_queue, NULL, relaxed);
-	if (boost_dq) {
-		// balances dispatch_{,barrier_,group_}async
-		_dispatch_release_2(boost_dq);
-	}
-
-	if (invoke_flags & DISPATCH_BLOCK_ASYNC_INVOKE_RELEASE) {
-		Block_release(b);
-	}
-}
-
-static void
-_dispatch_block_async_invoke(void *block)
-{
-	_dispatch_block_async_invoke2(block, 0);
-}
-
-static void
-_dispatch_block_async_invoke_and_release(void *block)
-{
-	_dispatch_block_async_invoke2(block, DISPATCH_BLOCK_ASYNC_INVOKE_RELEASE);
-}
-
-void
-dispatch_block_cancel(dispatch_block_t db)
-{
-	dispatch_block_private_data_t dbpd = _dispatch_block_get_data(db);
-	if (unlikely(!dbpd)) {
-		DISPATCH_CLIENT_CRASH(0, "Invalid block object passed to "
-				"dispatch_block_cancel()");
-	}
-	(void)os_atomic_or2o(dbpd, dbpd_atomic_flags, DBF_CANCELED, relaxed);
-}
-
-intptr_t
-dispatch_block_testcancel(dispatch_block_t db)
-{
-	dispatch_block_private_data_t dbpd = _dispatch_block_get_data(db);
-	if (unlikely(!dbpd)) {
-		DISPATCH_CLIENT_CRASH(0, "Invalid block object passed to "
-				"dispatch_block_testcancel()");
-	}
-	return (bool)(dbpd->dbpd_atomic_flags & DBF_CANCELED);
-}
-
-intptr_t
-dispatch_block_wait(dispatch_block_t db, dispatch_time_t timeout)
-{
-	dispatch_block_private_data_t dbpd = _dispatch_block_get_data(db);
-	if (unlikely(!dbpd)) {
-		DISPATCH_CLIENT_CRASH(0, "Invalid block object passed to "
-				"dispatch_block_wait()");
-	}
-
-	unsigned int flags = os_atomic_or_orig2o(dbpd, dbpd_atomic_flags,
-			DBF_WAITING, relaxed);
-	if (unlikely(flags & (DBF_WAITED | DBF_WAITING))) {
-		DISPATCH_CLIENT_CRASH(flags, "A block object may not be waited for "
-				"more than once");
-	}
-
-	// <rdar://problem/17703192> If we know the queue where this block is
-	// enqueued, or the thread that's executing it, then we should boost
-	// it here.
-
-	pthread_priority_t pp = _dispatch_get_priority();
-
-	dispatch_queue_t boost_dq;
-	boost_dq = os_atomic_xchg2o(dbpd, dbpd_queue, NULL, relaxed);
-	if (boost_dq) {
-		// release balances dispatch_{,barrier_,group_}async.
-		// Can't put the queue back in the timeout case: the block might
-		// finish after we fell out of group_wait and see our NULL, so
-		// neither of us would ever release. Side effect: After a _wait
-		// that times out, subsequent waits will not boost the qos of the
-		// still-running block.
-		dx_wakeup(boost_dq, _dispatch_qos_from_pp(pp),
-				DISPATCH_WAKEUP_BLOCK_WAIT | DISPATCH_WAKEUP_CONSUME_2);
-	}
-
-	mach_port_t boost_th = dbpd->dbpd_thread;
-	if (boost_th) {
-		_dispatch_thread_override_start(boost_th, pp, dbpd);
-	}
-
-	int performed = os_atomic_load2o(dbpd, dbpd_performed, relaxed);
-	if (unlikely(performed > 1 || (boost_th && boost_dq))) {
-		DISPATCH_CLIENT_CRASH(performed, "A block object may not be both "
-				"run more than once and waited for");
-	}
-
-	long ret = dispatch_group_wait(dbpd->dbpd_group, timeout);
-
-	if (boost_th) {
-		_dispatch_thread_override_end(boost_th, dbpd);
-	}
-
-	if (ret) {
-		// timed out: reverse our changes
-		os_atomic_and2o(dbpd, dbpd_atomic_flags, ~DBF_WAITING, relaxed);
-	} else {
-		os_atomic_or2o(dbpd, dbpd_atomic_flags, DBF_WAITED, relaxed);
-		// don't need to re-test here: the second call would see
-		// the first call's WAITING
-	}
-
-	return ret;
-}
-
-void
-dispatch_block_notify(dispatch_block_t db, dispatch_queue_t queue,
-		dispatch_block_t notification_block)
-{
-	dispatch_block_private_data_t dbpd = _dispatch_block_get_data(db);
-	if (!dbpd) {
-		DISPATCH_CLIENT_CRASH(db, "Invalid block object passed to "
-				"dispatch_block_notify()");
-	}
-	int performed = os_atomic_load2o(dbpd, dbpd_performed, relaxed);
-	if (unlikely(performed > 1)) {
-		DISPATCH_CLIENT_CRASH(performed, "A block object may not be both "
-				"run more than once and observed");
-	}
-
-	return dispatch_group_notify(dbpd->dbpd_group, queue, notification_block);
-}
-
-DISPATCH_NOINLINE
-dispatch_qos_t
-_dispatch_continuation_init_slow(dispatch_continuation_t dc,
-		dispatch_queue_t dq, dispatch_block_flags_t flags)
-{
-	dispatch_block_private_data_t dbpd = _dispatch_block_get_data(dc->dc_ctxt);
-	dispatch_block_flags_t block_flags = dbpd->dbpd_flags;
-	uintptr_t dc_flags = dc->dc_flags;
-	pthread_priority_t pp = 0;
-
-	// balanced in d_block_async_invoke_and_release or d_block_wait
-	if (os_atomic_cmpxchg2o(dbpd, dbpd_queue, NULL, dq, relaxed)) {
-		_dispatch_retain_2(dq);
-	}
-
-	if (dc_flags & DC_FLAG_CONSUME) {
-		dc->dc_func = _dispatch_block_async_invoke_and_release;
-	} else {
-		dc->dc_func = _dispatch_block_async_invoke;
-	}
-
-	flags |= block_flags;
-	if (block_flags & DISPATCH_BLOCK_HAS_PRIORITY) {
-		pp = dbpd->dbpd_priority & ~_PTHREAD_PRIORITY_FLAGS_MASK;
-	} else if (flags & DISPATCH_BLOCK_HAS_PRIORITY) {
-		// _dispatch_source_handler_alloc is calling is and doesn't want us
-		// to propagate priorities
-		pp = 0;
-	} else {
-		pp = _dispatch_priority_propagate();
-	}
-	_dispatch_continuation_priority_set(dc, dq, pp, flags);
-	if (block_flags & DISPATCH_BLOCK_BARRIER) {
-		dc_flags |= DC_FLAG_BARRIER;
-	}
-	if (block_flags & DISPATCH_BLOCK_HAS_VOUCHER) {
-		voucher_t v = dbpd->dbpd_voucher;
-		dc->dc_voucher = (v && v != DISPATCH_NO_VOUCHER) ? _voucher_retain(v)
-				: v;
-		_dispatch_voucher_debug("continuation[%p] set", dc->dc_voucher, dc);
-		_dispatch_voucher_ktrace_dc_push(dc);
-	} else {
-		_dispatch_continuation_voucher_set(dc, flags);
-	}
-	dc_flags |= DC_FLAG_BLOCK_WITH_PRIVATE_DATA;
-	dc->dc_flags = dc_flags;
-	return _dispatch_qos_from_pp(dc->dc_priority);
-}
-
-#endif // __BLOCKS__
-#pragma mark -
-#pragma mark dispatch_barrier_async
-
-DISPATCH_NOINLINE
-static void
-_dispatch_async_f_slow(dispatch_queue_t dq, void *ctxt,
-		dispatch_function_t func, dispatch_block_flags_t flags,
-		uintptr_t dc_flags)
-{
-	dispatch_continuation_t dc = _dispatch_continuation_alloc_from_heap();
-	dispatch_qos_t qos;
-
-	qos = _dispatch_continuation_init_f(dc, dq, ctxt, func, flags, dc_flags);
-	_dispatch_continuation_async(dq, dc, qos, dc->dc_flags);
-}
-
-DISPATCH_NOINLINE
-void
-dispatch_barrier_async_f(dispatch_queue_t dq, void *ctxt,
-		dispatch_function_t func)
-{
-	dispatch_continuation_t dc = _dispatch_continuation_alloc_cacheonly();
-	uintptr_t dc_flags = DC_FLAG_CONSUME | DC_FLAG_BARRIER;
-	dispatch_qos_t qos;
-
-	if (likely(!dc)) {
-		return _dispatch_async_f_slow(dq, ctxt, func, 0, dc_flags);
-	}
-
-	qos = _dispatch_continuation_init_f(dc, dq, ctxt, func, 0, dc_flags);
-	_dispatch_continuation_async(dq, dc, qos, dc_flags);
-}
-
-DISPATCH_NOINLINE
-void
-_dispatch_barrier_async_detached_f(dispatch_queue_class_t dq, void *ctxt,
-		dispatch_function_t func)
-{
-	dispatch_continuation_t dc = _dispatch_continuation_alloc();
-	dc->dc_flags = DC_FLAG_CONSUME | DC_FLAG_BARRIER | DC_FLAG_ALLOCATED;
-	dc->dc_func = func;
-	dc->dc_ctxt = ctxt;
-	dc->dc_voucher = DISPATCH_NO_VOUCHER;
-	dc->dc_priority = DISPATCH_NO_PRIORITY;
-	_dispatch_trace_item_push(dq, dc);
-	dx_push(dq._dq, dc, 0);
-}
-
-#ifdef __BLOCKS__
-void
-dispatch_barrier_async(dispatch_queue_t dq, dispatch_block_t work)
-{
-	dispatch_continuation_t dc = _dispatch_continuation_alloc();
-	uintptr_t dc_flags = DC_FLAG_CONSUME | DC_FLAG_BARRIER;
-	dispatch_qos_t qos;
-
-	qos = _dispatch_continuation_init(dc, dq, work, 0, dc_flags);
-	_dispatch_continuation_async(dq, dc, qos, dc_flags);
-}
-#endif
-
-#pragma mark -
-#pragma mark dispatch_async
-
-void
-_dispatch_async_redirect_invoke(dispatch_continuation_t dc,
-		dispatch_invoke_context_t dic, dispatch_invoke_flags_t flags)
-{
-	dispatch_thread_frame_s dtf;
-	struct dispatch_continuation_s *other_dc = dc->dc_other;
-	dispatch_invoke_flags_t ctxt_flags = (dispatch_invoke_flags_t)dc->dc_ctxt;
-	// if we went through _dispatch_root_queue_push_override,
-	// the "right" root queue was stuffed into dc_func
-	dispatch_queue_global_t assumed_rq = (dispatch_queue_global_t)dc->dc_func;
-	dispatch_lane_t dq = dc->dc_data;
-	dispatch_queue_t rq, old_dq;
-	dispatch_priority_t old_dbp;
-
-	if (ctxt_flags) {
-		flags &= ~_DISPATCH_INVOKE_AUTORELEASE_MASK;
-		flags |= ctxt_flags;
-	}
-	old_dq = _dispatch_queue_get_current();
-	if (assumed_rq) {
-		old_dbp = _dispatch_root_queue_identity_assume(assumed_rq);
-		_dispatch_set_basepri(dq->dq_priority);
-	} else {
-		old_dbp = _dispatch_set_basepri(dq->dq_priority);
-	}
-
-	uintptr_t dc_flags = DC_FLAG_CONSUME | DC_FLAG_NO_INTROSPECTION;
-	_dispatch_thread_frame_push(&dtf, dq);
-	_dispatch_continuation_pop_forwarded(dc, dc_flags, NULL, {
-		_dispatch_continuation_pop(other_dc, dic, flags, dq);
-	});
-	_dispatch_thread_frame_pop(&dtf);
-	if (assumed_rq) _dispatch_queue_set_current(old_dq);
-	_dispatch_reset_basepri(old_dbp);
-
-	rq = dq->do_targetq;
-	while (unlikely(rq->do_targetq && rq != old_dq)) {
-		_dispatch_lane_non_barrier_complete(upcast(rq)._dl, 0);
-		rq = rq->do_targetq;
-	}
-
-	// pairs with _dispatch_async_redirect_wrap
-	_dispatch_lane_non_barrier_complete(dq, DISPATCH_WAKEUP_CONSUME_2);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_continuation_t
-_dispatch_async_redirect_wrap(dispatch_lane_t dq, dispatch_object_t dou)
-{
-	dispatch_continuation_t dc = _dispatch_continuation_alloc();
-
-	dou._do->do_next = NULL;
-	dc->do_vtable = DC_VTABLE(ASYNC_REDIRECT);
-	dc->dc_func = NULL;
-	dc->dc_ctxt = (void *)(uintptr_t)_dispatch_queue_autorelease_frequency(dq);
-	dc->dc_data = dq;
-	dc->dc_other = dou._do;
-	dc->dc_voucher = DISPATCH_NO_VOUCHER;
-	dc->dc_priority = DISPATCH_NO_PRIORITY;
-	_dispatch_retain_2(dq); // released in _dispatch_async_redirect_invoke
-	return dc;
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_continuation_redirect_push(dispatch_lane_t dl,
-		dispatch_object_t dou, dispatch_qos_t qos)
-{
-	if (likely(!_dispatch_object_is_redirection(dou))) {
-		dou._dc = _dispatch_async_redirect_wrap(dl, dou);
-	} else if (!dou._dc->dc_ctxt) {
-		// find first queue in descending target queue order that has
-		// an autorelease frequency set, and use that as the frequency for
-		// this continuation.
-		dou._dc->dc_ctxt = (void *)
-		(uintptr_t)_dispatch_queue_autorelease_frequency(dl);
-	}
-
-	dispatch_queue_t dq = dl->do_targetq;
-	if (!qos) qos = _dispatch_priority_qos(dq->dq_priority);
-	dx_push(dq, dou, qos);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_async_f(dispatch_queue_t dq, void *ctxt, dispatch_function_t func,
-		dispatch_block_flags_t flags)
-{
-	dispatch_continuation_t dc = _dispatch_continuation_alloc_cacheonly();
-	uintptr_t dc_flags = DC_FLAG_CONSUME;
-	dispatch_qos_t qos;
-
-	if (unlikely(!dc)) {
-		return _dispatch_async_f_slow(dq, ctxt, func, flags, dc_flags);
-	}
-
-	qos = _dispatch_continuation_init_f(dc, dq, ctxt, func, flags, dc_flags);
-	_dispatch_continuation_async(dq, dc, qos, dc->dc_flags);
-}
-
-DISPATCH_NOINLINE
-void
-dispatch_async_f(dispatch_queue_t dq, void *ctxt, dispatch_function_t func)
-{
-	_dispatch_async_f(dq, ctxt, func, 0);
-}
-
-DISPATCH_NOINLINE
-void
-dispatch_async_enforce_qos_class_f(dispatch_queue_t dq, void *ctxt,
-		dispatch_function_t func)
-{
-	_dispatch_async_f(dq, ctxt, func, DISPATCH_BLOCK_ENFORCE_QOS_CLASS);
-}
-
-#ifdef __BLOCKS__
-void
-dispatch_async(dispatch_queue_t dq, dispatch_block_t work)
-{
-	dispatch_continuation_t dc = _dispatch_continuation_alloc();
-	uintptr_t dc_flags = DC_FLAG_CONSUME;
-	dispatch_qos_t qos;
-
-	qos = _dispatch_continuation_init(dc, dq, work, 0, dc_flags);
-	_dispatch_continuation_async(dq, dc, qos, dc->dc_flags);
-}
-#endif
-
-#pragma mark -
-#pragma mark _dispatch_sync_invoke / _dispatch_sync_complete
-
-DISPATCH_ALWAYS_INLINE
-static uint64_t
-_dispatch_lane_non_barrier_complete_try_lock(dispatch_lane_t dq,
-		uint64_t old_state, uint64_t new_state, uint64_t owner_self)
-{
-	uint64_t full_width = new_state;
-	if (_dq_state_has_pending_barrier(new_state)) {
-		full_width -= DISPATCH_QUEUE_PENDING_BARRIER;
-		full_width += DISPATCH_QUEUE_WIDTH_INTERVAL;
-		full_width += DISPATCH_QUEUE_IN_BARRIER;
-	} else {
-		full_width += dq->dq_width * DISPATCH_QUEUE_WIDTH_INTERVAL;
-		full_width += DISPATCH_QUEUE_IN_BARRIER;
-	}
-	if ((full_width & DISPATCH_QUEUE_WIDTH_MASK) ==
-			DISPATCH_QUEUE_WIDTH_FULL_BIT) {
-		new_state = full_width;
-		new_state &= ~DISPATCH_QUEUE_DIRTY;
-		new_state |= owner_self;
-	} else if (_dq_state_is_dirty(old_state)) {
-		new_state |= DISPATCH_QUEUE_ENQUEUED;
-	}
-	return new_state;
-}
-
-DISPATCH_ALWAYS_INLINE
-static void
-_dispatch_lane_non_barrier_complete_finish(dispatch_lane_t dq,
-		dispatch_wakeup_flags_t flags, uint64_t old_state, uint64_t new_state)
-{
-	if (_dq_state_received_override(old_state)) {
-		// Ensure that the root queue sees that this thread was overridden.
-		_dispatch_set_basepri_override_qos(_dq_state_max_qos(old_state));
-	}
-
-	if ((old_state ^ new_state) & DISPATCH_QUEUE_IN_BARRIER) {
-		if (_dq_state_is_dirty(old_state)) {
-			// <rdar://problem/14637483>
-			// dependency ordering for dq state changes that were flushed
-			// and not acted upon
-			os_atomic_thread_fence(dependency);
-			dq = os_atomic_force_dependency_on(dq, old_state);
-		}
-		return _dispatch_lane_barrier_complete(dq, 0, flags);
-	}
-
-	if ((old_state ^ new_state) & DISPATCH_QUEUE_ENQUEUED) {
-		if (!(flags & DISPATCH_WAKEUP_CONSUME_2)) {
-			_dispatch_retain_2(dq);
-		}
-		dispatch_assert(!_dq_state_is_base_wlh(new_state));
-		_dispatch_trace_item_push(dq->do_targetq, dq);
-		return dx_push(dq->do_targetq, dq, _dq_state_max_qos(new_state));
-	}
-
-	if (flags & DISPATCH_WAKEUP_CONSUME_2) {
-		_dispatch_release_2_tailcall(dq);
-	}
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_lane_non_barrier_complete(dispatch_lane_t dq,
-		dispatch_wakeup_flags_t flags)
-{
-	uint64_t old_state, new_state, owner_self = _dispatch_lock_value_for_self();
-
-	// see _dispatch_lane_resume()
-	os_atomic_rmw_loop2o(dq, dq_state, old_state, new_state, relaxed, {
-		new_state = old_state - DISPATCH_QUEUE_WIDTH_INTERVAL;
-		if (unlikely(_dq_state_drain_locked(old_state))) {
-			// make drain_try_unlock() fail and reconsider whether there's
-			// enough width now for a new item
-			new_state |= DISPATCH_QUEUE_DIRTY;
-		} else if (likely(_dq_state_is_runnable(new_state))) {
-			new_state = _dispatch_lane_non_barrier_complete_try_lock(dq,
-					old_state, new_state, owner_self);
-		}
-	});
-
-	_dispatch_lane_non_barrier_complete_finish(dq, flags, old_state, new_state);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_sync_function_invoke_inline(dispatch_queue_class_t dq, void *ctxt,
-		dispatch_function_t func)
-{
-	dispatch_thread_frame_s dtf;
-	_dispatch_thread_frame_push(&dtf, dq);
-	_dispatch_client_callout(ctxt, func);
-	_dispatch_perfmon_workitem_inc();
-	_dispatch_thread_frame_pop(&dtf);
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_sync_function_invoke(dispatch_queue_class_t dq, void *ctxt,
-		dispatch_function_t func)
-{
-	_dispatch_sync_function_invoke_inline(dq, ctxt, func);
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_sync_complete_recurse(dispatch_queue_t dq, dispatch_queue_t stop_dq,
-		uintptr_t dc_flags)
-{
-	bool barrier = (dc_flags & DC_FLAG_BARRIER);
-	do {
-		if (dq == stop_dq) return;
-		if (barrier) {
-			dx_wakeup(dq, 0, DISPATCH_WAKEUP_BARRIER_COMPLETE);
-		} else {
-			_dispatch_lane_non_barrier_complete(upcast(dq)._dl, 0);
-		}
-		dq = dq->do_targetq;
-		barrier = (dq->dq_width == 1);
-	} while (unlikely(dq->do_targetq));
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_sync_invoke_and_complete_recurse(dispatch_queue_class_t dq,
-		void *ctxt, dispatch_function_t func, uintptr_t dc_flags
-		DISPATCH_TRACE_ARG(void *dc))
-{
-	_dispatch_sync_function_invoke_inline(dq, ctxt, func);
-	_dispatch_trace_item_complete(dc);
-	_dispatch_sync_complete_recurse(dq._dq, NULL, dc_flags);
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_sync_invoke_and_complete(dispatch_lane_t dq, void *ctxt,
-		dispatch_function_t func DISPATCH_TRACE_ARG(void *dc))
-{
-	_dispatch_sync_function_invoke_inline(dq, ctxt, func);
-	_dispatch_trace_item_complete(dc);
-	_dispatch_lane_non_barrier_complete(dq, 0);
-}
-
-/*
- * For queues we can cheat and inline the unlock code, which is invalid
- * for objects with a more complex state machine (sources or mach channels)
- */
-DISPATCH_NOINLINE
-static void
-_dispatch_lane_barrier_sync_invoke_and_complete(dispatch_lane_t dq,
-		void *ctxt, dispatch_function_t func DISPATCH_TRACE_ARG(void *dc))
-{
-	_dispatch_sync_function_invoke_inline(dq, ctxt, func);
-	_dispatch_trace_item_complete(dc);
-	if (unlikely(dq->dq_items_tail || dq->dq_width > 1)) {
-		return _dispatch_lane_barrier_complete(dq, 0, 0);
-	}
-
-	// Presence of any of these bits requires more work that only
-	// _dispatch_*_barrier_complete() handles properly
-	//
-	// Note: testing for RECEIVED_OVERRIDE or RECEIVED_SYNC_WAIT without
-	// checking the role is sloppy, but is a super fast check, and neither of
-	// these bits should be set if the lock was never contended/discovered.
-	const uint64_t fail_unlock_mask = DISPATCH_QUEUE_SUSPEND_BITS_MASK |
-			DISPATCH_QUEUE_ENQUEUED | DISPATCH_QUEUE_DIRTY |
-			DISPATCH_QUEUE_RECEIVED_OVERRIDE | DISPATCH_QUEUE_SYNC_TRANSFER |
-			DISPATCH_QUEUE_RECEIVED_SYNC_WAIT;
-	uint64_t old_state, new_state;
-
-	// similar to _dispatch_queue_drain_try_unlock
-	os_atomic_rmw_loop2o(dq, dq_state, old_state, new_state, release, {
-		new_state  = old_state - DISPATCH_QUEUE_SERIAL_DRAIN_OWNED;
-		new_state &= ~DISPATCH_QUEUE_DRAIN_UNLOCK_MASK;
-		new_state &= ~DISPATCH_QUEUE_MAX_QOS_MASK;
-		if (unlikely(old_state & fail_unlock_mask)) {
-			os_atomic_rmw_loop_give_up({
-				return _dispatch_lane_barrier_complete(dq, 0, 0);
-			});
-		}
-	});
-	if (_dq_state_is_base_wlh(old_state)) {
-		_dispatch_event_loop_assert_not_owned((dispatch_wlh_t)dq);
-	}
-}
-
-#pragma mark -
-#pragma mark _dispatch_sync_wait / _dispatch_sync_waiter_wake
-
-DISPATCH_NOINLINE
-static void
-_dispatch_waiter_wake_wlh_anon(dispatch_sync_context_t dsc)
-{
-	if (dsc->dsc_override_qos > dsc->dsc_override_qos_floor) {
-		_dispatch_wqthread_override_start(dsc->dsc_waiter,
-				dsc->dsc_override_qos);
-	}
-	_dispatch_thread_event_signal(&dsc->dsc_event);
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_waiter_wake(dispatch_sync_context_t dsc, dispatch_wlh_t wlh,
-		uint64_t old_state, uint64_t new_state)
-{
-	dispatch_wlh_t waiter_wlh = dsc->dc_data;
-
-#if DISPATCH_USE_KEVENT_WORKLOOP
-	//
-	// We need to interact with a workloop if any of the following 3 cases:
-	// 1. the current owner of the lock has a SYNC_WAIT knote to destroy
-	// 2. the next owner of the lock is a workloop, we need to make sure it has
-	//    a SYNC_WAIT knote to destroy when it will later release the lock
-	// 3. the waiter is waiting on a workloop (which may be different from `wlh`
-	//    if the hierarchy was mutated after the next owner started waiting)
-	//
-	// However, note that even when (2) is true, the next owner may be waiting
-	// without pushing (waiter_wlh == DISPATCH_WLH_ANON), in which case the next
-	// owner is really woken up when the thread event is signaled.
-	//
-#endif
-	if (_dq_state_in_sync_transfer(old_state) ||
-			_dq_state_in_sync_transfer(new_state) ||
-			(waiter_wlh != DISPATCH_WLH_ANON)) {
-		_dispatch_event_loop_wake_owner(dsc, wlh, old_state, new_state);
-	}
-	if (unlikely(waiter_wlh == DISPATCH_WLH_ANON)) {
-		_dispatch_waiter_wake_wlh_anon(dsc);
-	}
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_async_waiter_update(dispatch_sync_context_t dsc,
-		dispatch_queue_class_t dqu)
-{
-	dispatch_queue_t dq = dqu._dq;
-	dispatch_priority_t p = dq->dq_priority & DISPATCH_PRIORITY_REQUESTED_MASK;
-	if (p) {
-		pthread_priority_t pp = _dispatch_priority_to_pp_strip_flags(p);
-		if (pp > (dsc->dc_priority & ~_PTHREAD_PRIORITY_FLAGS_MASK)) {
-			dsc->dc_priority = pp | _PTHREAD_PRIORITY_ENFORCE_FLAG;
-		}
-	}
-
-	if (dsc->dsc_autorelease == 0) {
-		dispatch_queue_flags_t dqf = _dispatch_queue_atomic_flags(dqu);
-		dqf &= (dispatch_queue_flags_t)_DQF_AUTORELEASE_MASK;
-		dsc->dsc_autorelease = (uint8_t)(dqf / DQF_AUTORELEASE_ALWAYS);
-	}
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_non_barrier_waiter_redirect_or_wake(dispatch_lane_t dq,
-		dispatch_object_t dou)
-{
-	dispatch_sync_context_t dsc = (dispatch_sync_context_t)dou._dc;
-	uint64_t old_state;
-
-	dispatch_assert(!(dsc->dc_flags & DC_FLAG_BARRIER));
-
-again:
-	old_state = os_atomic_load2o(dq, dq_state, relaxed);
-
-	if (dsc->dsc_override_qos < _dq_state_max_qos(old_state)) {
-		dsc->dsc_override_qos = (uint8_t)_dq_state_max_qos(old_state);
-	}
-
-	if (dsc->dc_flags & DC_FLAG_ASYNC_AND_WAIT) {
-		_dispatch_async_waiter_update(dsc, dq);
-	}
-
-	if (unlikely(_dq_state_is_inner_queue(old_state))) {
-		dispatch_queue_t tq = dq->do_targetq;
-		if (likely(tq->dq_width == 1)) {
-			dsc->dc_flags |= DC_FLAG_BARRIER;
-		} else {
-			dsc->dc_flags &= ~DC_FLAG_BARRIER;
-			if (_dispatch_queue_try_reserve_sync_width(upcast(tq)._dl)) {
-				dq = upcast(tq)._dl;
-				goto again;
-			}
-		}
-		return dx_push(tq, dsc, 0);
-	}
-
-	if (dsc->dc_flags & DC_FLAG_ASYNC_AND_WAIT) {
-		// _dispatch_barrier_async_and_wait_f_slow() expects dc_other to be the
-		// bottom queue of the graph
-		dsc->dc_other = dq;
-	}
-	return _dispatch_waiter_wake_wlh_anon(dsc);
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_barrier_waiter_redirect_or_wake(dispatch_queue_class_t dqu,
-		dispatch_object_t dc, dispatch_wakeup_flags_t flags,
-		uint64_t old_state, uint64_t new_state)
-{
-	dispatch_sync_context_t dsc = (dispatch_sync_context_t)dc._dc;
-	dispatch_queue_t dq = dqu._dq;
-	dispatch_wlh_t wlh = DISPATCH_WLH_ANON;
-
-	if (dsc->dc_data == DISPATCH_WLH_ANON) {
-		if (dsc->dsc_override_qos < _dq_state_max_qos(old_state)) {
-			dsc->dsc_override_qos = (uint8_t)_dq_state_max_qos(old_state);
-		}
-	}
-
-	if (_dq_state_is_base_wlh(old_state)) {
-		wlh = (dispatch_wlh_t)dq;
-	} else if (_dq_state_received_override(old_state)) {
-		// Ensure that the root queue sees that this thread was overridden.
-		_dispatch_set_basepri_override_qos(_dq_state_max_qos(old_state));
-	}
-
-	if (flags & DISPATCH_WAKEUP_CONSUME_2) {
-		if (_dq_state_is_base_wlh(old_state) &&
-				_dq_state_is_enqueued_on_target(new_state)) {
-			// If the thread request still exists, we need to leave it a +1
-			_dispatch_release_no_dispose(dq);
-		} else {
-			_dispatch_release_2_no_dispose(dq);
-		}
-	} else if (_dq_state_is_base_wlh(old_state) &&
-			_dq_state_is_enqueued_on_target(old_state) &&
-			!_dq_state_is_enqueued_on_target(new_state)) {
-		// If we cleared the enqueued bit, we're about to destroy the workloop
-		// thread request, and we need to consume its +1.
-		_dispatch_release_no_dispose(dq);
-	}
-
-	//
-	// Past this point we are borrowing the reference of the sync waiter
-	//
-	if (unlikely(_dq_state_is_inner_queue(old_state))) {
-		dispatch_queue_t tq = dq->do_targetq;
-		if (dsc->dc_flags & DC_FLAG_ASYNC_AND_WAIT) {
-			_dispatch_async_waiter_update(dsc, dq);
-		}
-		if (likely(tq->dq_width == 1)) {
-			dsc->dc_flags |= DC_FLAG_BARRIER;
-		} else {
-			dispatch_lane_t dl = upcast(tq)._dl;
-			dsc->dc_flags &= ~DC_FLAG_BARRIER;
-			if (_dispatch_queue_try_reserve_sync_width(dl)) {
-				return _dispatch_non_barrier_waiter_redirect_or_wake(dl, dc);
-			}
-		}
-		// passing the QoS of `dq` helps pushing on low priority waiters with
-		// legacy workloops.
-#if DISPATCH_INTROSPECTION
-		dsc->dsc_from_async = false;
-#endif
-		return dx_push(tq, dsc, _dq_state_max_qos(old_state));
-	}
-
-	if (dsc->dc_flags & DC_FLAG_ASYNC_AND_WAIT) {
-		// _dispatch_async_and_wait_f_slow() expects dc_other to be the
-		// bottom queue of the graph
-		dsc->dc_other = dq;
-	}
-#if DISPATCH_INTROSPECTION
-	if (dsc->dsc_from_async) {
-		_dispatch_trace_runtime_event(async_sync_handoff, dq, 0);
-	} else {
-		_dispatch_trace_runtime_event(sync_sync_handoff, dq, 0);
-	}
-#endif // DISPATCH_INTROSPECTION
-	return _dispatch_waiter_wake(dsc, wlh, old_state, new_state);
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_lane_drain_barrier_waiter(dispatch_lane_t dq,
-		struct dispatch_object_s *dc, dispatch_wakeup_flags_t flags,
-		uint64_t enqueued_bits)
-{
-	dispatch_sync_context_t dsc = (dispatch_sync_context_t)dc;
-	struct dispatch_object_s *next_dc;
-	uint64_t next_owner = 0, old_state, new_state;
-
-	next_owner = _dispatch_lock_value_from_tid(dsc->dsc_waiter);
-	next_dc = _dispatch_queue_pop_head(dq, dc);
-
-transfer_lock_again:
-	os_atomic_rmw_loop2o(dq, dq_state, old_state, new_state, release, {
-		new_state  = old_state;
-		new_state &= ~DISPATCH_QUEUE_DRAIN_UNLOCK_MASK;
-		new_state &= ~DISPATCH_QUEUE_DIRTY;
-		new_state |= next_owner;
-
-		if (_dq_state_is_base_wlh(old_state)) {
-			new_state |= DISPATCH_QUEUE_SYNC_TRANSFER;
-			if (next_dc) {
-				// we know there's a next item, keep the enqueued bit if any
-			} else if (unlikely(_dq_state_is_dirty(old_state))) {
-				os_atomic_rmw_loop_give_up({
-					os_atomic_xor2o(dq, dq_state, DISPATCH_QUEUE_DIRTY, acquire);
-					next_dc = os_atomic_load2o(dq, dq_items_head, relaxed);
-					goto transfer_lock_again;
-				});
-			} else {
-				new_state &= ~DISPATCH_QUEUE_MAX_QOS_MASK;
-				new_state &= ~DISPATCH_QUEUE_ENQUEUED;
-			}
-		} else {
-			new_state -= enqueued_bits;
-		}
-	});
-
-	return _dispatch_barrier_waiter_redirect_or_wake(dq, dc, flags,
-			old_state, new_state);
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_lane_class_barrier_complete(dispatch_lane_t dq, dispatch_qos_t qos,
-		dispatch_wakeup_flags_t flags, dispatch_queue_wakeup_target_t target,
-		uint64_t owned)
-{
-	uint64_t old_state, new_state, enqueue;
-	dispatch_queue_t tq;
-
-	if (target == DISPATCH_QUEUE_WAKEUP_MGR) {
-		tq = _dispatch_mgr_q._as_dq;
-		enqueue = DISPATCH_QUEUE_ENQUEUED_ON_MGR;
-	} else if (target) {
-		tq = (target == DISPATCH_QUEUE_WAKEUP_TARGET) ? dq->do_targetq : target;
-		enqueue = DISPATCH_QUEUE_ENQUEUED;
-	} else {
-		tq = NULL;
-		enqueue = 0;
-	}
-
-	os_atomic_rmw_loop2o(dq, dq_state, old_state, new_state, release, {
-		new_state  = _dq_state_merge_qos(old_state - owned, qos);
-		new_state &= ~DISPATCH_QUEUE_DRAIN_UNLOCK_MASK;
-		if (unlikely(_dq_state_is_suspended(old_state))) {
-			if (likely(_dq_state_is_base_wlh(old_state))) {
-				new_state &= ~DISPATCH_QUEUE_ENQUEUED;
-			}
-		} else if (enqueue) {
-			if (!_dq_state_is_enqueued(old_state)) {
-				new_state |= enqueue;
-			}
-		} else if (unlikely(_dq_state_is_dirty(old_state))) {
-			os_atomic_rmw_loop_give_up({
-				// just renew the drain lock with an acquire barrier, to see
-				// what the enqueuer that set DIRTY has done.
-				// the xor generates better assembly as DISPATCH_QUEUE_DIRTY
-				// is already in a register
-				os_atomic_xor2o(dq, dq_state, DISPATCH_QUEUE_DIRTY, acquire);
-				flags |= DISPATCH_WAKEUP_BARRIER_COMPLETE;
-				return dx_wakeup(dq, qos, flags);
-			});
-		} else {
-			new_state &= ~DISPATCH_QUEUE_MAX_QOS_MASK;
-		}
-	});
-	old_state -= owned;
-	dispatch_assert(_dq_state_drain_locked_by_self(old_state));
-	dispatch_assert(!_dq_state_is_enqueued_on_manager(old_state));
-
-	if (_dq_state_is_enqueued(new_state)) {
-		_dispatch_trace_runtime_event(sync_async_handoff, dq, 0);
-	}
-
-#if DISPATCH_USE_KEVENT_WORKLOOP
-	if (_dq_state_is_base_wlh(old_state)) {
-		// - Only non-"du_is_direct" sources & mach channels can be enqueued
-		//   on the manager.
-		//
-		// - Only dispatch_source_cancel_and_wait() and
-		//   dispatch_source_set_*_handler() use the barrier complete codepath,
-		//   none of which are used by mach channels.
-		//
-		// Hence no source-ish object can both be a workloop and need to use the
-		// manager at the same time.
-		dispatch_assert(!_dq_state_is_enqueued_on_manager(new_state));
-		if (_dq_state_is_enqueued_on_target(old_state) ||
-				_dq_state_is_enqueued_on_target(new_state) ||
-				_dq_state_received_sync_wait(old_state) ||
-				_dq_state_in_sync_transfer(old_state)) {
-			return _dispatch_event_loop_end_ownership((dispatch_wlh_t)dq,
-					old_state, new_state, flags);
-		}
-		_dispatch_event_loop_assert_not_owned((dispatch_wlh_t)dq);
-		if (flags & DISPATCH_WAKEUP_CONSUME_2) {
-			return _dispatch_release_2_tailcall(dq);
-		}
-		return;
-	}
-#endif
-
-	if (_dq_state_received_override(old_state)) {
-		// Ensure that the root queue sees that this thread was overridden.
-		_dispatch_set_basepri_override_qos(_dq_state_max_qos(old_state));
-	}
-
-	if (tq) {
-		if (likely((old_state ^ new_state) & enqueue)) {
-			dispatch_assert(_dq_state_is_enqueued(new_state));
-			dispatch_assert(flags & DISPATCH_WAKEUP_CONSUME_2);
-			return _dispatch_queue_push_queue(tq, dq, new_state);
-		}
-#if HAVE_PTHREAD_WORKQUEUE_QOS
-		// <rdar://problem/27694093> when doing sync to async handoff
-		// if the queue received an override we have to forecefully redrive
-		// the same override so that a new stealer is enqueued because
-		// the previous one may be gone already
-		if (_dq_state_should_override(new_state)) {
-			return _dispatch_queue_wakeup_with_override(dq, new_state, flags);
-		}
-#endif
-	}
-	if (flags & DISPATCH_WAKEUP_CONSUME_2) {
-		return _dispatch_release_2_tailcall(dq);
-	}
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_lane_drain_non_barriers(dispatch_lane_t dq,
-		struct dispatch_object_s *dc, dispatch_wakeup_flags_t flags)
-{
-	size_t owned_width = dq->dq_width;
-	struct dispatch_object_s *next_dc;
-
-	// see _dispatch_lane_drain, go in non barrier mode, and drain items
-
-	os_atomic_and2o(dq, dq_state, ~DISPATCH_QUEUE_IN_BARRIER, release);
-
-	do {
-		if (likely(owned_width)) {
-			owned_width--;
-		} else if (_dispatch_object_is_waiter(dc)) {
-			// sync "readers" don't observe the limit
-			_dispatch_queue_reserve_sync_width(dq);
-		} else if (!_dispatch_queue_try_acquire_async(dq)) {
-			// no width left
-			break;
-		}
-		next_dc = _dispatch_queue_pop_head(dq, dc);
-		if (_dispatch_object_is_waiter(dc)) {
-			_dispatch_non_barrier_waiter_redirect_or_wake(dq, dc);
-		} else {
-			_dispatch_continuation_redirect_push(dq, dc,
-					_dispatch_queue_max_qos(dq));
-		}
-drain_again:
-		dc = next_dc;
-	} while (dc && !_dispatch_object_is_barrier(dc));
-
-	uint64_t old_state, new_state, owner_self = _dispatch_lock_value_for_self();
-	uint64_t owned = owned_width * DISPATCH_QUEUE_WIDTH_INTERVAL;
-
-	if (dc) {
-		owned = _dispatch_queue_adjust_owned(dq, owned, dc);
-	}
-
-	os_atomic_rmw_loop2o(dq, dq_state, old_state, new_state, relaxed, {
-		new_state  = old_state - owned;
-		new_state &= ~DISPATCH_QUEUE_DRAIN_UNLOCK_MASK;
-		new_state &= ~DISPATCH_QUEUE_DIRTY;
-
-		// similar to _dispatch_lane_non_barrier_complete():
-		// if by the time we get here all redirected non barrier syncs are
-		// done and returned their width to the queue, we may be the last
-		// chance for the next item to run/be re-driven.
-		if (unlikely(dc)) {
-			new_state |= DISPATCH_QUEUE_DIRTY;
-			new_state = _dispatch_lane_non_barrier_complete_try_lock(dq,
-					old_state, new_state, owner_self);
-		} else if (unlikely(_dq_state_is_dirty(old_state))) {
-			os_atomic_rmw_loop_give_up({
-				os_atomic_xor2o(dq, dq_state, DISPATCH_QUEUE_DIRTY, acquire);
-				next_dc = os_atomic_load2o(dq, dq_items_head, relaxed);
-				goto drain_again;
-			});
-		}
-	});
-
-	old_state -= owned;
-	_dispatch_lane_non_barrier_complete_finish(dq, flags, old_state, new_state);
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_lane_barrier_complete(dispatch_lane_class_t dqu, dispatch_qos_t qos,
-		dispatch_wakeup_flags_t flags)
-{
-	dispatch_queue_wakeup_target_t target = DISPATCH_QUEUE_WAKEUP_NONE;
-	dispatch_lane_t dq = dqu._dl;
-
-	if (dq->dq_items_tail && !DISPATCH_QUEUE_IS_SUSPENDED(dq)) {
-		struct dispatch_object_s *dc = _dispatch_queue_get_head(dq);
-		if (likely(dq->dq_width == 1 || _dispatch_object_is_barrier(dc))) {
-			if (_dispatch_object_is_waiter(dc)) {
-				return _dispatch_lane_drain_barrier_waiter(dq, dc, flags, 0);
-			}
-		} else if (dq->dq_width > 1 && !_dispatch_object_is_barrier(dc)) {
-			return _dispatch_lane_drain_non_barriers(dq, dc, flags);
-		}
-
-		if (!(flags & DISPATCH_WAKEUP_CONSUME_2)) {
-			_dispatch_retain_2(dq);
-			flags |= DISPATCH_WAKEUP_CONSUME_2;
-		}
-		target = DISPATCH_QUEUE_WAKEUP_TARGET;
-	}
-
-	uint64_t owned = DISPATCH_QUEUE_IN_BARRIER +
-			dq->dq_width * DISPATCH_QUEUE_WIDTH_INTERVAL;
-	return _dispatch_lane_class_barrier_complete(dq, qos, flags, target, owned);
-}
-
-static void
-_dispatch_async_and_wait_invoke(void *ctxt)
-{
-	dispatch_sync_context_t dsc = ctxt;
-	dispatch_queue_t top_dq = dsc->dc_other;
-	dispatch_invoke_flags_t iflags;
-
-	// the block runs on the thread the queue is bound to and not
-	// on the calling thread, but we want to see the calling thread
-	// dispatch thread frames, so we fake the link, and then undo it
-	iflags = dsc->dsc_autorelease * DISPATCH_INVOKE_AUTORELEASE_ALWAYS;
-	dispatch_invoke_with_autoreleasepool(iflags, {
-		dispatch_thread_frame_s dtf;
-		_dispatch_introspection_sync_begin(top_dq);
-		_dispatch_thread_frame_push_and_rebase(&dtf, top_dq, &dsc->dsc_dtf);
-		_dispatch_client_callout(dsc->dsc_ctxt, dsc->dsc_func);
-		_dispatch_thread_frame_pop(&dtf);
-	});
-
-	// communicate back to _dispatch_async_and_wait_f_slow and
-	// _dispatch_sync_f_slow on which queue the work item was invoked
-	// so that the *_complete_recurse() call stops unlocking when it reaches it
-	dsc->dc_other = _dispatch_queue_get_current();
-	dsc->dsc_func = NULL;
-
-	if (dsc->dc_data == DISPATCH_WLH_ANON) {
-		_dispatch_thread_event_signal(&dsc->dsc_event); // release
-	} else {
-		_dispatch_event_loop_cancel_waiter(dsc);
-	}
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline uint64_t
-_dispatch_wait_prepare(dispatch_queue_t dq)
-{
-	uint64_t old_state, new_state;
-
-	os_atomic_rmw_loop2o(dq, dq_state, old_state, new_state, relaxed, {
-		if (_dq_state_is_suspended(old_state) ||
-				!_dq_state_is_base_wlh(old_state)) {
-			os_atomic_rmw_loop_give_up(return old_state);
-		}
-		if (!_dq_state_drain_locked(old_state) ||
-				_dq_state_in_sync_transfer(old_state)) {
-			os_atomic_rmw_loop_give_up(return old_state);
-		}
-		new_state = old_state | DISPATCH_QUEUE_RECEIVED_SYNC_WAIT;
-	});
-	return new_state;
-}
-
-static void
-_dispatch_wait_compute_wlh(dispatch_lane_t dq, dispatch_sync_context_t dsc)
-{
-	bool needs_locking = _dispatch_queue_is_mutable(dq);
-
-	if (needs_locking) {
-		dsc->dsc_release_storage = true;
-		_dispatch_queue_sidelock_lock(dq);
-	}
-
-	dispatch_queue_t tq = dq->do_targetq;
-	uint64_t tq_state = _dispatch_wait_prepare(tq);
-
-	if (_dq_state_is_suspended(tq_state) ||
-			_dq_state_is_base_anon(tq_state)) {
-		dsc->dsc_release_storage = false;
-		dsc->dc_data = DISPATCH_WLH_ANON;
-	} else if (_dq_state_is_base_wlh(tq_state)) {
-		if (dx_metatype(tq) == _DISPATCH_WORKLOOP_TYPE) {
-			dsc->dsc_wlh_is_workloop = true;
-			dsc->dsc_release_storage = false;
-		} else if (dsc->dsc_release_storage) {
-			_dispatch_queue_retain_storage(tq);
-		}
-		dsc->dc_data = (dispatch_wlh_t)tq;
-	} else {
-		_dispatch_wait_compute_wlh(upcast(tq)._dl, dsc);
-	}
-	if (needs_locking) {
-		if (dsc->dsc_wlh_is_workloop) {
-			_dispatch_queue_atomic_flags_clear(dq, DQF_MUTABLE);
-		}
-		_dispatch_queue_sidelock_unlock(dq);
-	}
-}
-
-DISPATCH_NOINLINE
-static void
-__DISPATCH_WAIT_FOR_QUEUE__(dispatch_sync_context_t dsc, dispatch_queue_t dq)
-{
-	uint64_t dq_state = _dispatch_wait_prepare(dq);
-	if (unlikely(_dq_state_drain_locked_by(dq_state, dsc->dsc_waiter))) {
-		DISPATCH_CLIENT_CRASH((uintptr_t)dq_state,
-				"dispatch_sync called on queue "
-				"already owned by current thread");
-	}
-
-	// Blocks submitted to the main thread MUST run on the main thread, and
-	// dispatch_async_and_wait also executes on the remote context rather than
-	// the current thread.
-	//
-	// For both these cases we need to save the frame linkage for the sake of
-	// _dispatch_async_and_wait_invoke
-	_dispatch_thread_frame_save_state(&dsc->dsc_dtf);
-
-	if (_dq_state_is_suspended(dq_state) ||
-			_dq_state_is_base_anon(dq_state)) {
-		dsc->dc_data = DISPATCH_WLH_ANON;
-	} else if (_dq_state_is_base_wlh(dq_state)) {
-		dsc->dc_data = (dispatch_wlh_t)dq;
-	} else {
-		_dispatch_wait_compute_wlh(upcast(dq)._dl, dsc);
-	}
-
-	if (dsc->dc_data == DISPATCH_WLH_ANON) {
-		dsc->dsc_override_qos_floor = dsc->dsc_override_qos =
-				(uint8_t)_dispatch_get_basepri_override_qos_floor();
-		_dispatch_thread_event_init(&dsc->dsc_event);
-	}
-	dx_push(dq, dsc, _dispatch_qos_from_pp(dsc->dc_priority));
-	_dispatch_trace_runtime_event(sync_wait, dq, 0);
-	if (dsc->dc_data == DISPATCH_WLH_ANON) {
-		_dispatch_thread_event_wait(&dsc->dsc_event); // acquire
-	} else {
-		_dispatch_event_loop_wait_for_ownership(dsc);
-	}
-	if (dsc->dc_data == DISPATCH_WLH_ANON) {
-		_dispatch_thread_event_destroy(&dsc->dsc_event);
-		// If _dispatch_sync_waiter_wake() gave this thread an override,
-		// ensure that the root queue sees it.
-		if (dsc->dsc_override_qos > dsc->dsc_override_qos_floor) {
-			_dispatch_set_basepri_override_qos(dsc->dsc_override_qos);
-		}
-	}
-}
-
-#pragma mark -
-#pragma mark _dispatch_barrier_trysync_or_async_f
-
-DISPATCH_NOINLINE
-static void
-_dispatch_barrier_trysync_or_async_f_complete(dispatch_lane_t dq,
-		void *ctxt, dispatch_function_t func, uint32_t flags)
-{
-	dispatch_wakeup_flags_t wflags = DISPATCH_WAKEUP_BARRIER_COMPLETE;
-
-	_dispatch_sync_function_invoke_inline(dq, ctxt, func);
-	if (flags & DISPATCH_BARRIER_TRYSYNC_SUSPEND) {
-		uint64_t dq_state = os_atomic_sub2o(dq, dq_state,
-				DISPATCH_QUEUE_SUSPEND_INTERVAL, relaxed);
-		if (!_dq_state_is_suspended(dq_state)) {
-			wflags |= DISPATCH_WAKEUP_CONSUME_2;
-		}
-	}
-	dx_wakeup(dq, 0, wflags);
-}
-
-// Use for mutation of queue-/source-internal state only
-// ignores target queue hierarchy!
-DISPATCH_NOINLINE
-void
-_dispatch_barrier_trysync_or_async_f(dispatch_lane_t dq, void *ctxt,
-		dispatch_function_t func, uint32_t flags)
-{
-	dispatch_tid tid = _dispatch_tid_self();
-	uint64_t suspend_count = (flags & DISPATCH_BARRIER_TRYSYNC_SUSPEND) ? 1 : 0;
-	if (unlikely(!_dispatch_queue_try_acquire_barrier_sync_and_suspend(dq, tid,
-			suspend_count))) {
-		return _dispatch_barrier_async_detached_f(dq, ctxt, func);
-	}
-	if (flags & DISPATCH_BARRIER_TRYSYNC_SUSPEND) {
-		_dispatch_retain_2(dq); // see _dispatch_lane_suspend
-	}
-	_dispatch_barrier_trysync_or_async_f_complete(dq, ctxt, func, flags);
-}
-
-#pragma mark -
-#pragma mark dispatch_sync / dispatch_barrier_sync
-
-DISPATCH_NOINLINE
-static void
-_dispatch_sync_f_slow(dispatch_queue_class_t top_dqu, void *ctxt,
-		dispatch_function_t func, uintptr_t top_dc_flags,
-		dispatch_queue_class_t dqu, uintptr_t dc_flags)
-{
-	dispatch_queue_t top_dq = top_dqu._dq;
-	dispatch_queue_t dq = dqu._dq;
-	if (unlikely(!dq->do_targetq)) {
-		return _dispatch_sync_function_invoke(dq, ctxt, func);
-	}
-
-	pthread_priority_t pp = _dispatch_get_priority();
-	struct dispatch_sync_context_s dsc = {
-		.dc_flags    = DC_FLAG_SYNC_WAITER | dc_flags,
-		.dc_func     = _dispatch_async_and_wait_invoke,
-		.dc_ctxt     = &dsc,
-		.dc_other    = top_dq,
-		.dc_priority = pp | _PTHREAD_PRIORITY_ENFORCE_FLAG,
-		.dc_voucher  = _voucher_get(),
-		.dsc_func    = func,
-		.dsc_ctxt    = ctxt,
-		.dsc_waiter  = _dispatch_tid_self(),
-	};
-
-	_dispatch_trace_item_push(top_dq, &dsc);
-	__DISPATCH_WAIT_FOR_QUEUE__(&dsc, dq);
-
-	if (dsc.dsc_func == NULL) {
-		dispatch_queue_t stop_dq = dsc.dc_other;
-		return _dispatch_sync_complete_recurse(top_dq, stop_dq, top_dc_flags);
-	}
-
-	_dispatch_introspection_sync_begin(top_dq);
-	_dispatch_trace_item_pop(top_dq, &dsc);
-	_dispatch_sync_invoke_and_complete_recurse(top_dq, ctxt, func,top_dc_flags
-			DISPATCH_TRACE_ARG(&dsc));
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_sync_recurse(dispatch_lane_t dq, void *ctxt,
-		dispatch_function_t func, uintptr_t dc_flags)
-{
-	dispatch_tid tid = _dispatch_tid_self();
-	dispatch_queue_t tq = dq->do_targetq;
-
-	do {
-		if (likely(tq->dq_width == 1)) {
-			if (unlikely(!_dispatch_queue_try_acquire_barrier_sync(tq, tid))) {
-				return _dispatch_sync_f_slow(dq, ctxt, func, dc_flags, tq,
-						DC_FLAG_BARRIER);
-			}
-		} else {
-			dispatch_queue_concurrent_t dl = upcast(tq)._dl;
-			if (unlikely(!_dispatch_queue_try_reserve_sync_width(dl))) {
-				return _dispatch_sync_f_slow(dq, ctxt, func, dc_flags, tq, 0);
-			}
-		}
-		tq = tq->do_targetq;
-	} while (unlikely(tq->do_targetq));
-
-	_dispatch_introspection_sync_begin(dq);
-	_dispatch_sync_invoke_and_complete_recurse(dq, ctxt, func, dc_flags
-			DISPATCH_TRACE_ARG(_dispatch_trace_item_sync_push_pop(
-					dq, ctxt, func, dc_flags)));
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_barrier_sync_f_inline(dispatch_queue_t dq, void *ctxt,
-		dispatch_function_t func, uintptr_t dc_flags)
-{
-	dispatch_tid tid = _dispatch_tid_self();
-
-	if (unlikely(dx_metatype(dq) != _DISPATCH_LANE_TYPE)) {
-		DISPATCH_CLIENT_CRASH(0, "Queue type doesn't support dispatch_sync");
-	}
-
-	dispatch_lane_t dl = upcast(dq)._dl;
-	// The more correct thing to do would be to merge the qos of the thread
-	// that just acquired the barrier lock into the queue state.
-	//
-	// However this is too expensive for the fast path, so skip doing it.
-	// The chosen tradeoff is that if an enqueue on a lower priority thread
-	// contends with this fast path, this thread may receive a useless override.
-	//
-	// Global concurrent queues and queues bound to non-dispatch threads
-	// always fall into the slow case, see DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE
-	if (unlikely(!_dispatch_queue_try_acquire_barrier_sync(dl, tid))) {
-		return _dispatch_sync_f_slow(dl, ctxt, func, DC_FLAG_BARRIER, dl,
-				DC_FLAG_BARRIER | dc_flags);
-	}
-
-	if (unlikely(dl->do_targetq->do_targetq)) {
-		return _dispatch_sync_recurse(dl, ctxt, func,
-				DC_FLAG_BARRIER | dc_flags);
-	}
-	_dispatch_introspection_sync_begin(dl);
-	_dispatch_lane_barrier_sync_invoke_and_complete(dl, ctxt, func
-			DISPATCH_TRACE_ARG(_dispatch_trace_item_sync_push_pop(
-					dq, ctxt, func, dc_flags | DC_FLAG_BARRIER)));
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_barrier_sync_f(dispatch_queue_t dq, void *ctxt,
-		dispatch_function_t func, uintptr_t dc_flags)
-{
-	_dispatch_barrier_sync_f_inline(dq, ctxt, func, dc_flags);
-}
-
-DISPATCH_NOINLINE
-void
-dispatch_barrier_sync_f(dispatch_queue_t dq, void *ctxt,
-		dispatch_function_t func)
-{
-	_dispatch_barrier_sync_f_inline(dq, ctxt, func, 0);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_sync_f_inline(dispatch_queue_t dq, void *ctxt,
-		dispatch_function_t func, uintptr_t dc_flags)
-{
-	if (likely(dq->dq_width == 1)) {
-		return _dispatch_barrier_sync_f(dq, ctxt, func, dc_flags);
-	}
-
-	if (unlikely(dx_metatype(dq) != _DISPATCH_LANE_TYPE)) {
-		DISPATCH_CLIENT_CRASH(0, "Queue type doesn't support dispatch_sync");
-	}
-
-	dispatch_lane_t dl = upcast(dq)._dl;
-	// Global concurrent queues and queues bound to non-dispatch threads
-	// always fall into the slow case, see DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE
-	if (unlikely(!_dispatch_queue_try_reserve_sync_width(dl))) {
-		return _dispatch_sync_f_slow(dl, ctxt, func, 0, dl, dc_flags);
-	}
-
-	if (unlikely(dq->do_targetq->do_targetq)) {
-		return _dispatch_sync_recurse(dl, ctxt, func, dc_flags);
-	}
-	_dispatch_introspection_sync_begin(dl);
-	_dispatch_sync_invoke_and_complete(dl, ctxt, func DISPATCH_TRACE_ARG(
-			_dispatch_trace_item_sync_push_pop(dq, ctxt, func, dc_flags)));
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_sync_f(dispatch_queue_t dq, void *ctxt, dispatch_function_t func,
-		uintptr_t dc_flags)
-{
-	_dispatch_sync_f_inline(dq, ctxt, func, dc_flags);
-}
-
-DISPATCH_NOINLINE
-void
-dispatch_sync_f(dispatch_queue_t dq, void *ctxt, dispatch_function_t func)
-{
-	_dispatch_sync_f_inline(dq, ctxt, func, 0);
-}
-
-#ifdef __BLOCKS__
-DISPATCH_NOINLINE
-static void
-_dispatch_sync_block_with_privdata(dispatch_queue_t dq, dispatch_block_t work,
-		uintptr_t dc_flags)
-{
-	dispatch_block_private_data_t dbpd = _dispatch_block_get_data(work);
-	pthread_priority_t op = 0, p = 0;
-	dispatch_block_flags_t flags = dbpd->dbpd_flags;
-
-	if (flags & DISPATCH_BLOCK_BARRIER) {
-		dc_flags |= DC_FLAG_BLOCK_WITH_PRIVATE_DATA | DC_FLAG_BARRIER;
-	} else {
-		dc_flags |= DC_FLAG_BLOCK_WITH_PRIVATE_DATA;
-	}
-
-	op = _dispatch_block_invoke_should_set_priority(flags, dbpd->dbpd_priority);
-	if (op) {
-		p = dbpd->dbpd_priority;
-	}
-	voucher_t ov, v = DISPATCH_NO_VOUCHER;
-	if (flags & DISPATCH_BLOCK_HAS_VOUCHER) {
-		v = dbpd->dbpd_voucher;
-	}
-	ov = _dispatch_set_priority_and_voucher(p, v, 0);
-
-	// balanced in d_block_sync_invoke or d_block_wait
-	if (os_atomic_cmpxchg2o(dbpd, dbpd_queue, NULL, dq, relaxed)) {
-		_dispatch_retain_2(dq);
-	}
-	if (dc_flags & DC_FLAG_BARRIER) {
-		_dispatch_barrier_sync_f(dq, work, _dispatch_block_sync_invoke,
-				dc_flags);
-	} else {
-		_dispatch_sync_f(dq, work, _dispatch_block_sync_invoke, dc_flags);
-	}
-	_dispatch_reset_priority_and_voucher(op, ov);
-}
-
-void
-dispatch_barrier_sync(dispatch_queue_t dq, dispatch_block_t work)
-{
-	uintptr_t dc_flags = DC_FLAG_BARRIER | DC_FLAG_BLOCK;
-	if (unlikely(_dispatch_block_has_private_data(work))) {
-		return _dispatch_sync_block_with_privdata(dq, work, dc_flags);
-	}
-	_dispatch_barrier_sync_f(dq, work, _dispatch_Block_invoke(work), dc_flags);
-}
-
-DISPATCH_NOINLINE
-void
-dispatch_sync(dispatch_queue_t dq, dispatch_block_t work)
-{
-	uintptr_t dc_flags = DC_FLAG_BLOCK;
-	if (unlikely(_dispatch_block_has_private_data(work))) {
-		return _dispatch_sync_block_with_privdata(dq, work, dc_flags);
-	}
-	_dispatch_sync_f(dq, work, _dispatch_Block_invoke(work), dc_flags);
-}
-#endif // __BLOCKS__
-
-#pragma mark -
-#pragma mark dispatch_async_and_wait
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_wlh_t
-_dispatch_fake_wlh(dispatch_queue_t dq)
-{
-	dispatch_wlh_t new_wlh = DISPATCH_WLH_ANON;
-	if (likely(dx_metatype(dq) == _DISPATCH_WORKLOOP_TYPE) ||
-			_dq_state_is_base_wlh(os_atomic_load2o(dq, dq_state, relaxed))) {
-		new_wlh = (dispatch_wlh_t)dq;
-	}
-	dispatch_wlh_t old_wlh = _dispatch_get_wlh();
-	_dispatch_thread_setspecific(dispatch_wlh_key, new_wlh);
-	return old_wlh;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_restore_wlh(dispatch_wlh_t wlh)
-{
-	_dispatch_thread_setspecific(dispatch_wlh_key, wlh);
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_async_and_wait_invoke_and_complete_recurse(dispatch_queue_t dq,
-		dispatch_sync_context_t dsc, dispatch_queue_t bottom_q,
-		uintptr_t top_dc_flags)
-{
-	dispatch_invoke_flags_t iflags;
-	dispatch_wlh_t old_wlh = _dispatch_fake_wlh(bottom_q);
-
-	iflags = dsc->dsc_autorelease * DISPATCH_INVOKE_AUTORELEASE_ALWAYS;
-	dispatch_invoke_with_autoreleasepool(iflags, {
-		dispatch_block_flags_t bflags = DISPATCH_BLOCK_HAS_PRIORITY;
-		dispatch_thread_frame_s dtf;
-		pthread_priority_t op = 0, p = dsc->dc_priority;
-		voucher_t ov, v = dsc->dc_voucher;
-
-		_dispatch_introspection_sync_begin(dq);
-		_dispatch_thread_frame_push(&dtf, dq);
-		op = _dispatch_block_invoke_should_set_priority(bflags, p);
-		ov = _dispatch_set_priority_and_voucher(op ? p : 0, v, 0);
-		_dispatch_trace_item_pop(dq, dsc);
-		_dispatch_client_callout(dsc->dsc_ctxt, dsc->dsc_func);
-		_dispatch_perfmon_workitem_inc();
-		_dispatch_reset_priority_and_voucher(op, ov);
-		_dispatch_thread_frame_pop(&dtf);
-	});
-
-	_dispatch_trace_item_complete(dsc);
-
-	_dispatch_restore_wlh(old_wlh);
-	_dispatch_sync_complete_recurse(dq, NULL, top_dc_flags);
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_async_and_wait_f_slow(dispatch_queue_t dq, uintptr_t top_dc_flags,
-		dispatch_sync_context_t dsc, dispatch_queue_t tq)
-{
-	__DISPATCH_WAIT_FOR_QUEUE__(dsc, tq);
-
-	if (unlikely(dsc->dsc_func == NULL)) {
-		// see _dispatch_async_and_wait_invoke
-		dispatch_queue_t stop_dq = dsc->dc_other;
-		return _dispatch_sync_complete_recurse(dq, stop_dq, top_dc_flags);
-	}
-
-	// see _dispatch_*_redirect_or_wake
-	dispatch_queue_t bottom_q = dsc->dc_other;
-	return _dispatch_async_and_wait_invoke_and_complete_recurse(dq, dsc,
-			bottom_q, top_dc_flags);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dispatch_async_and_wait_should_always_async(dispatch_queue_class_t dqu,
-		uint64_t dq_state)
-{
-	// If the queue is anchored at a pthread root queue for which we can't
-	// mirror attributes, then we need to take the async path.
-	return !_dq_state_is_inner_queue(dq_state) &&
-			!_dispatch_is_in_root_queues_array(dqu._dq->do_targetq);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dispatch_async_and_wait_recurse_one(dispatch_queue_t dq, dispatch_tid tid,
-		uintptr_t dc_flags)
-{
-	uint64_t dq_state = os_atomic_load2o(dq, dq_state, relaxed);
-	if (unlikely(_dispatch_async_and_wait_should_always_async(dq, dq_state))) {
-		return false;
-	}
-	if (likely(dc_flags & DC_FLAG_BARRIER)) {
-		return _dispatch_queue_try_acquire_barrier_sync(dq, tid);
-	}
-	return _dispatch_queue_try_reserve_sync_width(upcast(dq)._dl);
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_async_and_wait_recurse(dispatch_queue_t top_dq,
-		dispatch_sync_context_t dsc, dispatch_tid tid, uintptr_t top_flags)
-{
-	dispatch_queue_t dq = top_dq;
-	uintptr_t dc_flags = top_flags;
-
-	_dispatch_trace_item_push(top_dq, dsc);
-
-	for (;;) {
-		if (unlikely(!_dispatch_async_and_wait_recurse_one(dq, tid, dc_flags))){
-			return _dispatch_async_and_wait_f_slow(top_dq, top_flags, dsc, dq);
-		}
-
-		_dispatch_async_waiter_update(dsc, dq);
-		if (likely(!dq->do_targetq->do_targetq)) break;
-		dq = dq->do_targetq;
-		if (likely(dq->dq_width == 1)) {
-			dc_flags |= DC_FLAG_BARRIER;
-		} else {
-			dc_flags &= ~DC_FLAG_BARRIER;
-		}
-		dsc->dc_flags = dc_flags;
-	}
-
-	_dispatch_async_and_wait_invoke_and_complete_recurse(top_dq, dsc, dq,
-			top_flags);
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_async_and_wait_f(dispatch_queue_t dq,
-		void *ctxt, dispatch_function_t func, uintptr_t dc_flags)
-{
-	pthread_priority_t pp = _dispatch_get_priority();
-	dispatch_tid tid = _dispatch_tid_self();
-	struct dispatch_sync_context_s dsc = {
-		.dc_flags    = dc_flags,
-		.dc_func     = _dispatch_async_and_wait_invoke,
-		.dc_ctxt     = &dsc,
-		.dc_other    = dq,
-		.dc_priority = pp | _PTHREAD_PRIORITY_ENFORCE_FLAG,
-		.dc_voucher  = _voucher_get(),
-		.dsc_func    = func,
-		.dsc_ctxt    = ctxt,
-		.dsc_waiter  = tid,
-	};
-
-	return _dispatch_async_and_wait_recurse(dq, &dsc, tid, dc_flags);
-}
-
-DISPATCH_NOINLINE
-void
-dispatch_async_and_wait_f(dispatch_queue_t dq, void *ctxt,
-		dispatch_function_t func)
-{
-	if (unlikely(!dq->do_targetq)) {
-		return _dispatch_sync_function_invoke(dq, ctxt, func);
-	}
-
-	uintptr_t dc_flags = DC_FLAG_ASYNC_AND_WAIT;
-	if (likely(dq->dq_width == 1)) dc_flags |= DC_FLAG_BARRIER;
-	return _dispatch_async_and_wait_f(dq, ctxt, func, dc_flags);
-}
-
-DISPATCH_NOINLINE
-void
-dispatch_barrier_async_and_wait_f(dispatch_queue_t dq, void *ctxt,
-		dispatch_function_t func)
-{
-	if (unlikely(!dq->do_targetq)) {
-		return _dispatch_sync_function_invoke(dq, ctxt, func);
-	}
-
-	uintptr_t dc_flags = DC_FLAG_ASYNC_AND_WAIT | DC_FLAG_BARRIER;
-	return _dispatch_async_and_wait_f(dq, ctxt, func, dc_flags);
-}
-
-#ifdef __BLOCKS__
-DISPATCH_NOINLINE
-static void
-_dispatch_async_and_wait_block_with_privdata(dispatch_queue_t dq,
-		dispatch_block_t work, uintptr_t dc_flags)
-{
-	dispatch_block_private_data_t dbpd = _dispatch_block_get_data(work);
-	dispatch_block_flags_t flags = dbpd->dbpd_flags;
-	pthread_priority_t pp;
-	voucher_t v;
-
-	if (dbpd->dbpd_flags & DISPATCH_BLOCK_BARRIER) {
-		dc_flags |= DC_FLAG_BLOCK_WITH_PRIVATE_DATA | DC_FLAG_BARRIER;
-	} else {
-		dc_flags |= DC_FLAG_BLOCK_WITH_PRIVATE_DATA;
-	}
-
-	if (_dispatch_block_invoke_should_set_priority(flags, dbpd->dbpd_priority)){
-		pp = dbpd->dbpd_priority;
-	} else {
-		pp = _dispatch_get_priority();
-	}
-	if (dbpd->dbpd_flags & DISPATCH_BLOCK_HAS_VOUCHER) {
-		v = dbpd->dbpd_voucher;
-	} else {
-		v = _voucher_get();
-	}
-
-	// balanced in d_block_sync_invoke or d_block_wait
-	if (os_atomic_cmpxchg2o(dbpd, dbpd_queue, NULL, dq, relaxed)) {
-		_dispatch_retain_2(dq);
-	}
-
-	dispatch_tid tid = _dispatch_tid_self();
-	struct dispatch_sync_context_s dsc = {
-		.dc_flags    = dc_flags,
-		.dc_func     = _dispatch_async_and_wait_invoke,
-		.dc_ctxt     = &dsc,
-		.dc_other    = dq,
-		.dc_priority = pp | _PTHREAD_PRIORITY_ENFORCE_FLAG,
-		.dc_voucher  = v,
-		.dsc_func    = _dispatch_block_sync_invoke,
-		.dsc_ctxt    = work,
-		.dsc_waiter  = tid,
-	};
-
-	return _dispatch_async_and_wait_recurse(dq, &dsc, tid, dc_flags);
-}
-
-void
-dispatch_barrier_async_and_wait(dispatch_queue_t dq, dispatch_block_t work)
-{
-	if (unlikely(!dq->do_targetq)) {
-		return dispatch_barrier_sync(dq, work);
-	}
-
-	uintptr_t dc_flags = DC_FLAG_ASYNC_AND_WAIT | DC_FLAG_BLOCK|DC_FLAG_BARRIER;
-	if (unlikely(_dispatch_block_has_private_data(work))) {
-		return _dispatch_async_and_wait_block_with_privdata(dq, work, dc_flags);
-	}
-
-	dispatch_function_t func = _dispatch_Block_invoke(work);
-	return _dispatch_async_and_wait_f(dq, work, func, dc_flags);
-}
-
-void
-dispatch_async_and_wait(dispatch_queue_t dq, dispatch_block_t work)
-{
-	if (unlikely(!dq->do_targetq)) {
-		return dispatch_sync(dq, work);
-	}
-
-	uintptr_t dc_flags = DC_FLAG_ASYNC_AND_WAIT | DC_FLAG_BLOCK;
-	if (likely(dq->dq_width == 1)) dc_flags |= DC_FLAG_BARRIER;
-	if (unlikely(_dispatch_block_has_private_data(work))) {
-		return _dispatch_async_and_wait_block_with_privdata(dq, work, dc_flags);
-	}
-
-	dispatch_function_t func = _dispatch_Block_invoke(work);
-	return _dispatch_async_and_wait_f(dq, work, func, dc_flags);
-}
-#endif // __BLOCKS__
-
-#pragma mark -
-#pragma mark dispatch_queue_specific
-
-static void
-_dispatch_queue_specific_head_dispose_slow(void *ctxt)
-{
-	dispatch_queue_specific_head_t dqsh = ctxt;
-	dispatch_queue_specific_t dqs, tmp;
-
-	TAILQ_FOREACH_SAFE(dqs, &dqsh->dqsh_entries, dqs_entry, tmp) {
-		dispatch_assert(dqs->dqs_destructor);
-		_dispatch_client_callout(dqs->dqs_ctxt, dqs->dqs_destructor);
-		free(dqs);
-	}
-	free(dqsh);
-}
-
-static void
-_dispatch_queue_specific_head_dispose(dispatch_queue_specific_head_t dqsh)
-{
-	dispatch_queue_t rq = _dispatch_get_default_queue(false);
-	dispatch_queue_specific_t dqs, tmp;
-	TAILQ_HEAD(, dispatch_queue_specific_s) entries =
-			TAILQ_HEAD_INITIALIZER(entries);
-
-	TAILQ_CONCAT(&entries, &dqsh->dqsh_entries, dqs_entry);
-	TAILQ_FOREACH_SAFE(dqs, &entries, dqs_entry, tmp) {
-		if (dqs->dqs_destructor) {
-			TAILQ_INSERT_TAIL(&dqsh->dqsh_entries, dqs, dqs_entry);
-		} else {
-			free(dqs);
-		}
-	}
-
-	if (TAILQ_EMPTY(&dqsh->dqsh_entries)) {
-		free(dqsh);
-	} else {
-		_dispatch_barrier_async_detached_f(rq, dqsh,
-				_dispatch_queue_specific_head_dispose_slow);
-	}
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_queue_init_specific(dispatch_queue_t dq)
-{
-	dispatch_queue_specific_head_t dqsh;
-
-	dqsh = _dispatch_calloc(1, sizeof(struct dispatch_queue_specific_head_s));
-	TAILQ_INIT(&dqsh->dqsh_entries);
-	if (unlikely(!os_atomic_cmpxchg2o(dq, dq_specific_head,
-			NULL, dqsh, release))) {
-		_dispatch_queue_specific_head_dispose(dqsh);
-	}
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_queue_specific_t
-_dispatch_queue_specific_find(dispatch_queue_specific_head_t dqsh,
-		const void *key)
-{
-	dispatch_queue_specific_t dqs;
-
-	TAILQ_FOREACH(dqs, &dqsh->dqsh_entries, dqs_entry) {
-		if (dqs->dqs_key == key) {
-			return dqs;
-		}
-	}
-	return NULL;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dispatch_queue_admits_specific(dispatch_queue_t dq)
-{
-	if (dx_metatype(dq) == _DISPATCH_LANE_TYPE) {
-		return (dx_type(dq) == DISPATCH_QUEUE_MAIN_TYPE ||
-			!dx_hastypeflag(dq, QUEUE_BASE));
-	}
-	return dx_metatype(dq) == _DISPATCH_WORKLOOP_TYPE;
-}
-
-DISPATCH_NOINLINE
-void
-dispatch_queue_set_specific(dispatch_queue_t dq, const void *key,
-	void *ctxt, dispatch_function_t destructor)
-{
-	if (unlikely(!key)) {
-		return;
-	}
-	dispatch_queue_t rq = _dispatch_get_default_queue(false);
-	dispatch_queue_specific_head_t dqsh = dq->dq_specific_head;
-	dispatch_queue_specific_t dqs;
-
-	if (unlikely(!_dispatch_queue_admits_specific(dq))) {
-		DISPATCH_CLIENT_CRASH(0,
-				"Queue doesn't support dispatch_queue_set_specific");
-	}
-
-	if (ctxt && !dqsh) {
-		_dispatch_queue_init_specific(dq);
-		dqsh = dq->dq_specific_head;
-	} else if (!dqsh) {
-		return;
-	}
-
-	_dispatch_unfair_lock_lock(&dqsh->dqsh_lock);
-	dqs = _dispatch_queue_specific_find(dqsh, key);
-	if (dqs) {
-		if (dqs->dqs_destructor) {
-			_dispatch_barrier_async_detached_f(rq, dqs->dqs_ctxt,
-					dqs->dqs_destructor);
-		}
-		if (ctxt) {
-			dqs->dqs_ctxt = ctxt;
-			dqs->dqs_destructor = destructor;
-		} else {
-			TAILQ_REMOVE(&dqsh->dqsh_entries, dqs, dqs_entry);
-			free(dqs);
-		}
-	} else if (ctxt) {
-		dqs = _dispatch_calloc(1, sizeof(struct dispatch_queue_specific_s));
-		dqs->dqs_key = key;
-		dqs->dqs_ctxt = ctxt;
-		dqs->dqs_destructor = destructor;
-		TAILQ_INSERT_TAIL(&dqsh->dqsh_entries, dqs, dqs_entry);
-	}
-
-	_dispatch_unfair_lock_unlock(&dqsh->dqsh_lock);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void *
-_dispatch_queue_get_specific_inline(dispatch_queue_t dq, const void *key)
-{
-	dispatch_queue_specific_head_t dqsh = dq->dq_specific_head;
-	dispatch_queue_specific_t dqs;
-	void *ctxt = NULL;
-
-	if (likely(_dispatch_queue_admits_specific(dq) && dqsh)) {
-		_dispatch_unfair_lock_lock(&dqsh->dqsh_lock);
-		dqs = _dispatch_queue_specific_find(dqsh, key);
-		if (dqs) ctxt = dqs->dqs_ctxt;
-		_dispatch_unfair_lock_unlock(&dqsh->dqsh_lock);
-	}
-	return ctxt;
-}
-
-DISPATCH_NOINLINE
-void *
-dispatch_queue_get_specific(dispatch_queue_t dq, const void *key)
-{
-	if (unlikely(!key)) {
-		return NULL;
-	}
-	return _dispatch_queue_get_specific_inline(dq, key);
-}
-
-DISPATCH_NOINLINE
-void *
-dispatch_get_specific(const void *key)
-{
-	dispatch_queue_t dq = _dispatch_queue_get_current();
-	void *ctxt = NULL;
-
-	if (likely(key && dq)) {
-		do {
-			ctxt = _dispatch_queue_get_specific_inline(dq, key);
-			dq = dq->do_targetq;
-		} while (unlikely(ctxt == NULL && dq));
-	}
-	return ctxt;
-}
-
-#pragma mark -
-#pragma mark dispatch_queue_t / dispatch_lane_t
-
-void
-dispatch_queue_set_label_nocopy(dispatch_queue_t dq, const char *label)
-{
-	if (unlikely(_dispatch_object_is_global(dq))) {
-		return;
-	}
-	dispatch_queue_flags_t dqf = _dispatch_queue_atomic_flags(dq);
-	if (unlikely(dqf & DQF_LABEL_NEEDS_FREE)) {
-		DISPATCH_CLIENT_CRASH(dq, "Cannot change label for this queue");
-	}
-	dq->dq_label = label;
-}
-
-static inline bool
-_dispatch_base_lane_is_wlh(dispatch_lane_t dq, dispatch_queue_t tq)
-{
-#if DISPATCH_USE_KEVENT_WORKLOOP
-	if (unlikely(!_dispatch_kevent_workqueue_enabled)) {
-		return false;
-	}
-	if (dx_type(dq) == DISPATCH_QUEUE_NETWORK_EVENT_TYPE) {
-		return true;
-	}
-	if (dx_metatype(dq) == _DISPATCH_SOURCE_TYPE) {
-		// Sources don't support sync waiters, so the ones that never change QoS
-		// don't benefit from any of the workloop features which have overhead,
-		// so just use the workqueue kqueue for these.
-		if (likely(!upcast(dq)._ds->ds_refs->du_can_be_wlh)) {
-			return false;
-		}
-		dispatch_assert(upcast(dq)._ds->ds_refs->du_is_direct);
-	}
-	return dq->dq_width == 1 && _dispatch_is_in_root_queues_array(tq);
-#else
-	(void)dq; (void)tq;
-	return false;
-#endif // DISPATCH_USE_KEVENT_WORKLOOP
-}
-
-static void
-_dispatch_lane_inherit_wlh_from_target(dispatch_lane_t dq, dispatch_queue_t tq)
-{
-	uint64_t old_state, new_state, role;
-
-	if (!dx_hastypeflag(tq, QUEUE_ROOT)) {
-		role = DISPATCH_QUEUE_ROLE_INNER;
-	} else if (_dispatch_base_lane_is_wlh(dq, tq)) {
-		role = DISPATCH_QUEUE_ROLE_BASE_WLH;
-	} else {
-		role = DISPATCH_QUEUE_ROLE_BASE_ANON;
-	}
-
-	os_atomic_rmw_loop2o(dq, dq_state, old_state, new_state, relaxed, {
-		new_state = old_state & ~DISPATCH_QUEUE_ROLE_MASK;
-		new_state |= role;
-		if (old_state == new_state) {
-			os_atomic_rmw_loop_give_up(break);
-		}
-	});
-
-	if (_dq_state_is_base_wlh(old_state) && !_dq_state_is_base_wlh(new_state)) {
-		dispatch_deferred_items_t ddi = _dispatch_deferred_items_get();
-		if (ddi && ddi->ddi_wlh == (dispatch_wlh_t)dq) {
-			_dispatch_event_loop_leave_immediate(new_state);
-		}
-	}
-	if (!dx_hastypeflag(tq, QUEUE_ROOT)) {
-		dispatch_queue_flags_t clear = 0, set = DQF_TARGETED;
-		if (dx_metatype(tq) == _DISPATCH_WORKLOOP_TYPE) {
-			clear |= DQF_MUTABLE;
-#if !DISPATCH_ALLOW_NON_LEAF_RETARGET
-		} else {
-			clear |= DQF_MUTABLE;
-#endif
-		}
-		if (clear) {
-			_dispatch_queue_atomic_flags_set_and_clear(tq, set, clear);
-		} else {
-			_dispatch_queue_atomic_flags_set(tq, set);
-		}
-	}
-}
-
-dispatch_priority_t
-_dispatch_queue_compute_priority_and_wlh(dispatch_queue_t dq,
-		dispatch_wlh_t *wlh_out)
-{
-	dispatch_priority_t dpri = dq->dq_priority;
-	dispatch_priority_t p = dpri & DISPATCH_PRIORITY_REQUESTED_MASK;
-	dispatch_qos_t fallback = _dispatch_priority_fallback_qos(dpri);
-	dispatch_queue_t tq = dq->do_targetq;
-	dispatch_wlh_t wlh = DISPATCH_WLH_ANON;
-
-	if (_dq_state_is_base_wlh(dq->dq_state)) {
-		wlh = (dispatch_wlh_t)dq;
-	}
-
-	while (unlikely(!dx_hastypeflag(tq, QUEUE_ROOT))) {
-		if (unlikely(tq == _dispatch_mgr_q._as_dq)) {
-			if (wlh_out) *wlh_out = DISPATCH_WLH_ANON;
-			return DISPATCH_PRIORITY_FLAG_MANAGER;
-		}
-		if (unlikely(_dispatch_queue_is_thread_bound(tq))) {
-			if (wlh_out) *wlh_out = DISPATCH_WLH_ANON;
-			return tq->dq_priority;
-		}
-		if (unlikely(DISPATCH_QUEUE_IS_SUSPENDED(tq))) {
-			// this queue may not be activated yet, so the queue graph may not
-			// have stabilized yet
-			_dispatch_ktrace2(DISPATCH_PERF_delayed_registration, dq,
-					  dx_metatype(dq) == _DISPATCH_SOURCE_TYPE ? dq : NULL);
-			if (wlh_out) *wlh_out = NULL;
-			return 0;
-		}
-
-		if (_dq_state_is_base_wlh(tq->dq_state)) {
-			wlh = (dispatch_wlh_t)tq;
-			if (dx_metatype(tq) == _DISPATCH_WORKLOOP_TYPE) {
-				_dispatch_queue_atomic_flags_clear(dq, DQF_MUTABLE);
-			}
-		} else if (unlikely(_dispatch_queue_is_mutable(tq))) {
-			// we're not allowed to dereference tq->do_targetq
-			_dispatch_ktrace2(DISPATCH_PERF_delayed_registration, dq,
-					  dx_metatype(dq) == _DISPATCH_SOURCE_TYPE ? dq : NULL);
-			if (wlh_out) *wlh_out = NULL;
-			return 0;
-		}
-
-		dispatch_priority_t tqp = tq->dq_priority;
-
-		tq = tq->do_targetq;
-		if (tqp & DISPATCH_PRIORITY_FLAG_INHERITED) {
-			// if the priority is inherited, it means we got it from our target
-			// which has fallback and various magical flags that the code below
-			// will handle, so do not bother here.
-			break;
-		}
-
-		if (!fallback) fallback = _dispatch_priority_fallback_qos(tqp);
-		tqp &= DISPATCH_PRIORITY_REQUESTED_MASK;
-		if (p < tqp) p = tqp;
-	}
-
-	if (likely(_dispatch_is_in_root_queues_array(tq) ||
-			tq->dq_serialnum == DISPATCH_QUEUE_SERIAL_NUMBER_WLF)) {
-		dispatch_priority_t rqp = tq->dq_priority;
-
-		if (!fallback) fallback = _dispatch_priority_fallback_qos(rqp);
-		rqp &= DISPATCH_PRIORITY_REQUESTED_MASK;
-		if (p < rqp) p = rqp;
-
-		p |= (tq->dq_priority & DISPATCH_PRIORITY_FLAG_OVERCOMMIT);
-		if ((dpri & DISPATCH_PRIORITY_FLAG_FLOOR) ||
-				!(dpri & DISPATCH_PRIORITY_REQUESTED_MASK)) {
-			p |= (dpri & DISPATCH_PRIORITY_FLAG_FLOOR);
-			if (fallback > _dispatch_priority_qos(p)) {
-				p |= _dispatch_priority_make_fallback(fallback);
-			}
-		}
-		if (wlh_out) *wlh_out = wlh;
-		return p;
-	}
-
-	// pthread root queues opt out of QoS
-	if (wlh_out) *wlh_out = DISPATCH_WLH_ANON;
-	return DISPATCH_PRIORITY_FLAG_MANAGER;
-}
-
-DISPATCH_ALWAYS_INLINE
-static void
-_dispatch_queue_setter_assert_inactive(dispatch_queue_class_t dq)
-{
-	uint64_t dq_state = os_atomic_load2o(dq._dq, dq_state, relaxed);
-	if (likely(dq_state & DISPATCH_QUEUE_INACTIVE)) return;
-#if DISPATCH_SIZEOF_PTR == 4
-	dq_state >>= 32;
-#endif
-	DISPATCH_CLIENT_CRASH((uintptr_t)dq_state,
-			"dispatch queue/source property setter called after activation");
-}
-
-DISPATCH_ALWAYS_INLINE
-static void
-_dispatch_workloop_attributes_alloc_if_needed(dispatch_workloop_t dwl)
-{
-	if (unlikely(!dwl->dwl_attr)) {
-		dwl->dwl_attr = _dispatch_calloc(1, sizeof(dispatch_workloop_attr_s));
-	}
-}
-
-void
-dispatch_set_qos_class_floor(dispatch_object_t dou,
-		dispatch_qos_class_t cls, int relpri)
-{
-	if (dx_cluster(dou._do) != _DISPATCH_QUEUE_CLUSTER) {
-		DISPATCH_CLIENT_CRASH(0,
-				"dispatch_set_qos_class_floor called on invalid object type");
-	}
-	if (dx_metatype(dou._do) == _DISPATCH_WORKLOOP_TYPE) {
-		return dispatch_workloop_set_qos_class_floor(dou._dwl, cls, relpri, 0);
-	}
-
-	dispatch_qos_t qos = _dispatch_qos_from_qos_class(cls);
-	dispatch_priority_t pri = _dispatch_priority_make(qos, relpri);
-	dispatch_priority_t old_pri = dou._dq->dq_priority;
-
-	if (pri) pri |= DISPATCH_PRIORITY_FLAG_FLOOR;
-	old_pri &= ~DISPATCH_PRIORITY_REQUESTED_MASK;
-	old_pri &= ~DISPATCH_PRIORITY_FLAG_FLOOR;
-	dou._dq->dq_priority = pri | old_pri;
-
-	_dispatch_queue_setter_assert_inactive(dou._dq);
-}
-
-void
-dispatch_set_qos_class(dispatch_object_t dou, dispatch_qos_class_t cls,
-		int relpri)
-{
-	if (dx_cluster(dou._do) != _DISPATCH_QUEUE_CLUSTER ||
-			dx_metatype(dou._do) == _DISPATCH_WORKLOOP_TYPE) {
-		DISPATCH_CLIENT_CRASH(0,
-				"dispatch_set_qos_class called on invalid object type");
-	}
-
-	dispatch_qos_t qos = _dispatch_qos_from_qos_class(cls);
-	dispatch_priority_t pri = _dispatch_priority_make(qos, relpri);
-	dispatch_priority_t old_pri = dou._dq->dq_priority;
-
-	old_pri &= ~DISPATCH_PRIORITY_REQUESTED_MASK;
-	old_pri &= ~DISPATCH_PRIORITY_FLAG_FLOOR;
-	dou._dq->dq_priority = pri | old_pri;
-
-	_dispatch_queue_setter_assert_inactive(dou._dq);
-}
-
-void
-dispatch_set_qos_class_fallback(dispatch_object_t dou, dispatch_qos_class_t cls)
-{
-	if (dx_cluster(dou._do) != _DISPATCH_QUEUE_CLUSTER) {
-		DISPATCH_CLIENT_CRASH(0,
-				"dispatch_set_qos_class_fallback called on invalid object type");
-	}
-
-	dispatch_qos_t qos = _dispatch_qos_from_qos_class(cls);
-	dispatch_priority_t pri = _dispatch_priority_make_fallback(qos);
-	dispatch_priority_t old_pri = dou._dq->dq_priority;
-
-	old_pri &= ~DISPATCH_PRIORITY_FALLBACK_QOS_MASK;
-	old_pri &= ~DISPATCH_PRIORITY_FLAG_FALLBACK;
-	dou._dq->dq_priority = pri | old_pri;
-
-	_dispatch_queue_setter_assert_inactive(dou._dq);
-}
-
-static dispatch_queue_t
-_dispatch_queue_priority_inherit_from_target(dispatch_lane_class_t dq,
-		dispatch_queue_t tq)
-{
-	const dispatch_priority_t inherited = DISPATCH_PRIORITY_FLAG_INHERITED;
-	dispatch_priority_t pri = dq._dl->dq_priority;
-
-	// This priority has been selected by the client, leave it alone
-	// However, when the client picked a QoS, we should adjust the target queue
-	// if it is a root queue to best match the ask
-	if (_dispatch_queue_priority_manually_selected(pri)) {
-		if (_dispatch_is_in_root_queues_array(tq)) {
-			dispatch_qos_t qos = _dispatch_priority_qos(pri);
-			if (!qos) qos = DISPATCH_QOS_DEFAULT;
-			tq = _dispatch_get_root_queue(qos,
-					pri & DISPATCH_PRIORITY_FLAG_OVERCOMMIT)->_as_dq;
-		}
-		return tq;
-	}
-
-	if (_dispatch_is_in_root_queues_array(tq)) {
-		// <rdar://problem/32921639> base queues need to know they target
-		// the default root queue so that _dispatch_queue_wakeup_qos()
-		// in _dispatch_queue_wakeup() can fallback to QOS_DEFAULT
-		// if no other priority was provided.
-		pri = tq->dq_priority | inherited;
-	} else if (pri & inherited) {
-		// if the FALLBACK flag is set on queues due to the code above
-		// we need to clear it if the queue is retargeted within a hierachy
-		// and is no longer a base queue.
-		pri &= ~DISPATCH_PRIORITY_FALLBACK_QOS_MASK;
-		pri &= ~DISPATCH_PRIORITY_FLAG_FALLBACK;
-	}
-
-	dq._dl->dq_priority = pri;
-	return tq;
-}
-
-
-DISPATCH_NOINLINE
-static dispatch_queue_t
-_dispatch_lane_create_with_target(const char *label, dispatch_queue_attr_t dqa,
-		dispatch_queue_t tq, bool legacy)
-{
-	dispatch_queue_attr_info_t dqai = _dispatch_queue_attr_to_info(dqa);
-
-	//
-	// Step 1: Normalize arguments (qos, overcommit, tq)
-	//
-
-	dispatch_qos_t qos = dqai.dqai_qos;
-#if !HAVE_PTHREAD_WORKQUEUE_QOS
-	if (qos == DISPATCH_QOS_USER_INTERACTIVE) {
-		dqai.dqai_qos = qos = DISPATCH_QOS_USER_INITIATED;
-	}
-	if (qos == DISPATCH_QOS_MAINTENANCE) {
-		dqai.dqai_qos = qos = DISPATCH_QOS_BACKGROUND;
-	}
-#endif // !HAVE_PTHREAD_WORKQUEUE_QOS
-
-	_dispatch_queue_attr_overcommit_t overcommit = dqai.dqai_overcommit;
-	if (overcommit != _dispatch_queue_attr_overcommit_unspecified && tq) {
-		if (tq->do_targetq) {
-			DISPATCH_CLIENT_CRASH(tq, "Cannot specify both overcommit and "
-					"a non-global target queue");
-		}
-	}
-
-	if (tq && dx_type(tq) == DISPATCH_QUEUE_GLOBAL_ROOT_TYPE) {
-		// Handle discrepancies between attr and target queue, attributes win
-		if (overcommit == _dispatch_queue_attr_overcommit_unspecified) {
-			if (tq->dq_priority & DISPATCH_PRIORITY_FLAG_OVERCOMMIT) {
-				overcommit = _dispatch_queue_attr_overcommit_enabled;
-			} else {
-				overcommit = _dispatch_queue_attr_overcommit_disabled;
-			}
-		}
-		if (qos == DISPATCH_QOS_UNSPECIFIED) {
-			qos = _dispatch_priority_qos(tq->dq_priority);
-		}
-		tq = NULL;
-	} else if (tq && !tq->do_targetq) {
-		// target is a pthread or runloop root queue, setting QoS or overcommit
-		// is disallowed
-		if (overcommit != _dispatch_queue_attr_overcommit_unspecified) {
-			DISPATCH_CLIENT_CRASH(tq, "Cannot specify an overcommit attribute "
-					"and use this kind of target queue");
-		}
-	} else {
-		if (overcommit == _dispatch_queue_attr_overcommit_unspecified) {
-			// Serial queues default to overcommit!
-			overcommit = dqai.dqai_concurrent ?
-					_dispatch_queue_attr_overcommit_disabled :
-					_dispatch_queue_attr_overcommit_enabled;
-		}
-	}
-	if (!tq) {
-		tq = _dispatch_get_root_queue(
-				qos == DISPATCH_QOS_UNSPECIFIED ? DISPATCH_QOS_DEFAULT : qos,
-				overcommit == _dispatch_queue_attr_overcommit_enabled)->_as_dq;
-		if (unlikely(!tq)) {
-			DISPATCH_CLIENT_CRASH(qos, "Invalid queue attribute");
-		}
-	}
-
-	//
-	// Step 2: Initialize the queue
-	//
-
-	if (legacy) {
-		// if any of these attributes is specified, use non legacy classes
-		if (dqai.dqai_inactive || dqai.dqai_autorelease_frequency) {
-			legacy = false;
-		}
-	}
-
-	const void *vtable;
-	dispatch_queue_flags_t dqf = legacy ? DQF_MUTABLE : 0;
-	if (dqai.dqai_concurrent) {
-		vtable = DISPATCH_VTABLE(queue_concurrent);
-	} else {
-		vtable = DISPATCH_VTABLE(queue_serial);
-	}
-	switch (dqai.dqai_autorelease_frequency) {
-	case DISPATCH_AUTORELEASE_FREQUENCY_NEVER:
-		dqf |= DQF_AUTORELEASE_NEVER;
-		break;
-	case DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM:
-		dqf |= DQF_AUTORELEASE_ALWAYS;
-		break;
-	}
-	if (label) {
-		const char *tmp = _dispatch_strdup_if_mutable(label);
-		if (tmp != label) {
-			dqf |= DQF_LABEL_NEEDS_FREE;
-			label = tmp;
-		}
-	}
-
-	dispatch_lane_t dq = _dispatch_object_alloc(vtable,
-			sizeof(struct dispatch_lane_s));
-	_dispatch_queue_init(dq, dqf, dqai.dqai_concurrent ?
-			DISPATCH_QUEUE_WIDTH_MAX : 1, DISPATCH_QUEUE_ROLE_INNER |
-			(dqai.dqai_inactive ? DISPATCH_QUEUE_INACTIVE : 0));
-
-	dq->dq_label = label;
-	dq->dq_priority = _dispatch_priority_make((dispatch_qos_t)dqai.dqai_qos,
-			dqai.dqai_relpri);
-	if (overcommit == _dispatch_queue_attr_overcommit_enabled) {
-		dq->dq_priority |= DISPATCH_PRIORITY_FLAG_OVERCOMMIT;
-	}
-	if (!dqai.dqai_inactive) {
-		_dispatch_queue_priority_inherit_from_target(dq, tq);
-		_dispatch_lane_inherit_wlh_from_target(dq, tq);
-	}
-	_dispatch_retain(tq);
-	dq->do_targetq = tq;
-	_dispatch_object_debug(dq, "%s", __func__);
-	return _dispatch_trace_queue_create(dq)._dq;
-}
-
-dispatch_queue_t
-dispatch_queue_create_with_target(const char *label, dispatch_queue_attr_t dqa,
-		dispatch_queue_t tq)
-{
-	return _dispatch_lane_create_with_target(label, dqa, tq, false);
-}
-
-dispatch_queue_t
-dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
-{
-	return _dispatch_lane_create_with_target(label, attr,
-			DISPATCH_TARGET_QUEUE_DEFAULT, true);
-}
-
-dispatch_queue_t
-dispatch_queue_create_with_accounting_override_voucher(const char *label,
-		dispatch_queue_attr_t attr, voucher_t voucher)
-{
-	(void)label; (void)attr; (void)voucher;
-	DISPATCH_CLIENT_CRASH(0, "Unsupported interface");
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_queue_dispose(dispatch_queue_class_t dqu, bool *allow_free)
-{
-	dispatch_queue_specific_head_t dqsh;
-	dispatch_queue_t dq = dqu._dq;
-
-	if (dq->dq_label && _dispatch_queue_label_needs_free(dq)) {
-		free((void*)dq->dq_label);
-	}
-	dqsh = os_atomic_xchg2o(dq, dq_specific_head, (void *)0x200, relaxed);
-	if (dqsh) _dispatch_queue_specific_head_dispose(dqsh);
-
-	// fast path for queues that never got their storage retained
-	if (likely(os_atomic_load2o(dq, dq_sref_cnt, relaxed) == 0)) {
-		// poison the state with something that is suspended and is easy to spot
-		dq->dq_state = 0xdead000000000000;
-		return;
-	}
-
-	// Take over freeing the memory from _dispatch_object_dealloc()
-	//
-	// As soon as we call _dispatch_queue_release_storage(), we forfeit
-	// the possibility for the caller of dx_dispose() to finalize the object
-	// so that responsibility is ours.
-	_dispatch_object_finalize(dq);
-	*allow_free = false;
-	dq->dq_label = "<released queue, pending free>";
-	dq->do_targetq = NULL;
-	dq->do_finalizer = NULL;
-	dq->do_ctxt = NULL;
-	return _dispatch_queue_release_storage(dq);
-}
-
-void
-_dispatch_lane_class_dispose(dispatch_lane_class_t dqu, bool *allow_free)
-{
-	dispatch_lane_t dq = dqu._dl;
-	uint64_t dq_state = os_atomic_load2o(dq, dq_state, relaxed);
-	uint64_t initial_state = DISPATCH_QUEUE_STATE_INIT_VALUE(dq->dq_width);
-
-	if (dx_hastypeflag(dq, QUEUE_ROOT)) {
-		initial_state = DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE;
-	}
-	dq_state &= ~DISPATCH_QUEUE_MAX_QOS_MASK;
-	dq_state &= ~DISPATCH_QUEUE_DIRTY;
-	dq_state &= ~DISPATCH_QUEUE_ROLE_MASK;
-	if (unlikely(dq_state != initial_state)) {
-		if (_dq_state_drain_locked(dq_state)) {
-			DISPATCH_CLIENT_CRASH((uintptr_t)dq_state,
-					"Release of a locked queue");
-		}
-#if DISPATCH_SIZEOF_PTR == 4
-		dq_state >>= 32;
-#endif
-		DISPATCH_CLIENT_CRASH((uintptr_t)dq_state,
-				"Release of a queue with corrupt state");
-	}
-
-	if (unlikely(dq->dq_items_tail)) {
-		DISPATCH_CLIENT_CRASH(dq->dq_items_tail,
-				"Release of a queue while items are enqueued");
-	}
-	dq->dq_items_head = (void *)0x200;
-	dq->dq_items_tail = (void *)0x200;
-
-	_dispatch_queue_dispose(dqu, allow_free);
-}
-
-void
-_dispatch_lane_dispose(dispatch_lane_t dq, bool *allow_free)
-{
-	_dispatch_object_debug(dq, "%s", __func__);
-	_dispatch_trace_queue_dispose(dq);
-	_dispatch_lane_class_dispose(dq, allow_free);
-}
-
-void
-_dispatch_queue_xref_dispose(dispatch_queue_t dq)
-{
-	uint64_t dq_state = os_atomic_load2o(dq, dq_state, relaxed);
-	if (unlikely(_dq_state_is_suspended(dq_state))) {
-		long state = (long)dq_state;
-		if (sizeof(long) < sizeof(uint64_t)) state = (long)(dq_state >> 32);
-		if (unlikely(_dq_state_is_inactive(dq_state))) {
-			// Arguments for and against this assert are within 6705399
-			DISPATCH_CLIENT_CRASH(state, "Release of an inactive object");
-		}
-		DISPATCH_CLIENT_CRASH(dq_state, "Release of a suspended object");
-	}
-	os_atomic_or2o(dq, dq_atomic_flags, DQF_RELEASED, relaxed);
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_lane_suspend_slow(dispatch_lane_t dq)
-{
-	uint64_t old_state, new_state, delta;
-
-	_dispatch_queue_sidelock_lock(dq);
-
-	// what we want to transfer (remove from dq_state)
-	delta  = DISPATCH_QUEUE_SUSPEND_HALF * DISPATCH_QUEUE_SUSPEND_INTERVAL;
-	// but this is a suspend so add a suspend count at the same time
-	delta -= DISPATCH_QUEUE_SUSPEND_INTERVAL;
-	if (dq->dq_side_suspend_cnt == 0) {
-		// we substract delta from dq_state, and we want to set this bit
-		delta -= DISPATCH_QUEUE_HAS_SIDE_SUSPEND_CNT;
-	}
-
-	os_atomic_rmw_loop2o(dq, dq_state, old_state, new_state, relaxed, {
-		// unsigned underflow of the substraction can happen because other
-		// threads could have touched this value while we were trying to acquire
-		// the lock, or because another thread raced us to do the same operation
-		// and got to the lock first.
-		if (unlikely(os_sub_overflow(old_state, delta, &new_state))) {
-			os_atomic_rmw_loop_give_up(goto retry);
-		}
-	});
-	if (unlikely(os_add_overflow(dq->dq_side_suspend_cnt,
-			DISPATCH_QUEUE_SUSPEND_HALF, &dq->dq_side_suspend_cnt))) {
-		DISPATCH_CLIENT_CRASH(0, "Too many nested calls to dispatch_suspend()");
-	}
-	return _dispatch_queue_sidelock_unlock(dq);
-
-retry:
-	_dispatch_queue_sidelock_unlock(dq);
-	return _dispatch_lane_suspend(dq);
-}
-
-void
-_dispatch_lane_suspend(dispatch_lane_t dq)
-{
-	uint64_t old_state, new_state;
-
-	os_atomic_rmw_loop2o(dq, dq_state, old_state, new_state, relaxed, {
-		new_state = DISPATCH_QUEUE_SUSPEND_INTERVAL;
-		if (unlikely(os_add_overflow(old_state, new_state, &new_state))) {
-			os_atomic_rmw_loop_give_up({
-				return _dispatch_lane_suspend_slow(dq);
-			});
-		}
-	});
-
-	if (!_dq_state_is_suspended(old_state)) {
-		// rdar://8181908 we need to extend the queue life for the duration
-		// of the call to wakeup at _dispatch_lane_resume() time.
-		_dispatch_retain_2(dq);
-	}
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_lane_resume_slow(dispatch_lane_t dq)
-{
-	uint64_t old_state, new_state, delta;
-
-	_dispatch_queue_sidelock_lock(dq);
-
-	// what we want to transfer
-	delta  = DISPATCH_QUEUE_SUSPEND_HALF * DISPATCH_QUEUE_SUSPEND_INTERVAL;
-	// but this is a resume so consume a suspend count at the same time
-	delta -= DISPATCH_QUEUE_SUSPEND_INTERVAL;
-	switch (dq->dq_side_suspend_cnt) {
-	case 0:
-		goto retry;
-	case DISPATCH_QUEUE_SUSPEND_HALF:
-		// we will transition the side count to 0, so we want to clear this bit
-		delta -= DISPATCH_QUEUE_HAS_SIDE_SUSPEND_CNT;
-		break;
-	}
-	os_atomic_rmw_loop2o(dq, dq_state, old_state, new_state, relaxed, {
-		// unsigned overflow of the addition can happen because other
-		// threads could have touched this value while we were trying to acquire
-		// the lock, or because another thread raced us to do the same operation
-		// and got to the lock first.
-		if (unlikely(os_add_overflow(old_state, delta, &new_state))) {
-			os_atomic_rmw_loop_give_up(goto retry);
-		}
-	});
-	dq->dq_side_suspend_cnt -= DISPATCH_QUEUE_SUSPEND_HALF;
-	return _dispatch_queue_sidelock_unlock(dq);
-
-retry:
-	_dispatch_queue_sidelock_unlock(dq);
-	return _dispatch_lane_resume(dq, false);
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_lane_resume_activate(dispatch_lane_t dq)
-{
-	bool allow_resume = true;
-	// Step 2: run the activation finalizer
-	if (dx_vtable(dq)->dq_activate) {
-		dx_vtable(dq)->dq_activate(dq, &allow_resume);
-	}
-	// Step 3: consume the suspend count
-	if (allow_resume) {
-		return _dispatch_lane_resume(dq, false);
-	}
-}
-
-void
-_dispatch_lane_resume(dispatch_lane_t dq, bool activate)
-{
-	// covers all suspend and inactive bits, including side suspend bit
-	const uint64_t suspend_bits = DISPATCH_QUEUE_SUSPEND_BITS_MASK;
-	uint64_t pending_barrier_width =
-			(dq->dq_width - 1) * DISPATCH_QUEUE_WIDTH_INTERVAL;
-	uint64_t set_owner_and_set_full_width_and_in_barrier =
-			_dispatch_lock_value_for_self() | DISPATCH_QUEUE_WIDTH_FULL_BIT |
-			DISPATCH_QUEUE_IN_BARRIER;
-
-	// backward compatibility: only dispatch sources can abuse
-	// dispatch_resume() to really mean dispatch_activate()
-	bool is_source = (dx_metatype(dq) == _DISPATCH_SOURCE_TYPE);
-	uint64_t old_state, new_state;
-
-	// Activation is a bit tricky as it needs to finalize before the wakeup.
-	//
-	// If after doing its updates to the suspend count and/or inactive bit,
-	// the last suspension related bit that would remain is the
-	// NEEDS_ACTIVATION one, then this function:
-	//
-	// 1. moves the state to { sc:1 i:0 na:0 } (converts the needs-activate into
-	//    a suspend count)
-	// 2. runs the activation finalizer
-	// 3. consumes the suspend count set in (1), and finishes the resume flow
-	//
-	// Concurrently, some property setters such as setting dispatch source
-	// handlers or _dispatch_lane_set_target_queue try to do in-place changes
-	// before activation. These protect their action by taking a suspend count.
-	// Step (1) above cannot happen if such a setter has locked the object.
-	if (activate) {
-		// relaxed atomic because this doesn't publish anything, this is only
-		// about picking the thread that gets to finalize the activation
-		os_atomic_rmw_loop2o(dq, dq_state, old_state, new_state, relaxed, {
-			if ((old_state & suspend_bits) ==
-					DISPATCH_QUEUE_NEEDS_ACTIVATION + DISPATCH_QUEUE_INACTIVE) {
-				// { sc:0 i:1 na:1 } -> { sc:1 i:0 na:0 }
-				new_state = old_state - DISPATCH_QUEUE_INACTIVE
-						- DISPATCH_QUEUE_NEEDS_ACTIVATION
-						+ DISPATCH_QUEUE_SUSPEND_INTERVAL;
-			} else if (_dq_state_is_inactive(old_state)) {
-				// { sc:>0 i:1 na:1 } -> { i:0 na:1 }
-				// simple activation because sc is not 0
-				// resume will deal with na:1 later
-				new_state = old_state - DISPATCH_QUEUE_INACTIVE;
-			} else {
-				// object already active, this is a no-op, just exit
-				os_atomic_rmw_loop_give_up(return);
-			}
-		});
-	} else {
-		// release barrier needed to publish the effect of
-		// - dispatch_set_target_queue()
-		// - dispatch_set_*_handler()
-		// - dq_activate()
-		os_atomic_rmw_loop2o(dq, dq_state, old_state, new_state, release, {
-			if ((old_state & suspend_bits) == DISPATCH_QUEUE_SUSPEND_INTERVAL
-					+ DISPATCH_QUEUE_NEEDS_ACTIVATION) {
-				// { sc:1 i:0 na:1 } -> { sc:1 i:0 na:0 }
-				new_state = old_state - DISPATCH_QUEUE_NEEDS_ACTIVATION;
-			} else if (is_source && (old_state & suspend_bits) ==
-					DISPATCH_QUEUE_NEEDS_ACTIVATION + DISPATCH_QUEUE_INACTIVE) {
-				// { sc:0 i:1 na:1 } -> { sc:1 i:0 na:0 }
-				new_state = old_state - DISPATCH_QUEUE_INACTIVE
-						- DISPATCH_QUEUE_NEEDS_ACTIVATION
-						+ DISPATCH_QUEUE_SUSPEND_INTERVAL;
-			} else if (unlikely(os_sub_overflow(old_state,
-					DISPATCH_QUEUE_SUSPEND_INTERVAL, &new_state))) {
-				// underflow means over-resume or a suspend count transfer
-				// to the side count is needed
-				os_atomic_rmw_loop_give_up({
-					if (!(old_state & DISPATCH_QUEUE_HAS_SIDE_SUSPEND_CNT)) {
-						goto over_resume;
-					}
-					return _dispatch_lane_resume_slow(dq);
-				});
-		//
-		// below this, new_state = old_state - DISPATCH_QUEUE_SUSPEND_INTERVAL
-		//
-			} else if (!_dq_state_is_runnable(new_state)) {
-				// Out of width or still suspended.
-				// For the former, force _dispatch_lane_non_barrier_complete
-				// to reconsider whether it has work to do
-				new_state |= DISPATCH_QUEUE_DIRTY;
-			} else if (_dq_state_drain_locked(new_state)) {
-				// still locked by someone else, make drain_try_unlock() fail
-				// and reconsider whether it has work to do
-				new_state |= DISPATCH_QUEUE_DIRTY;
-			} else if (!is_source && (_dq_state_has_pending_barrier(new_state) ||
-					new_state + pending_barrier_width <
-					DISPATCH_QUEUE_WIDTH_FULL_BIT)) {
-				// if we can, acquire the full width drain lock
-				// and then perform a lock transfer
-				//
-				// However this is never useful for a source where there are no
-				// sync waiters, so never take the lock and do a plain wakeup
-				new_state &= DISPATCH_QUEUE_DRAIN_PRESERVED_BITS_MASK;
-				new_state |= set_owner_and_set_full_width_and_in_barrier;
-			} else {
-				// clear overrides and force a wakeup
-				new_state &= ~DISPATCH_QUEUE_DRAIN_UNLOCK_MASK;
-				new_state &= ~DISPATCH_QUEUE_MAX_QOS_MASK;
-			}
-		});
-	}
-
-	if ((old_state ^ new_state) & DISPATCH_QUEUE_NEEDS_ACTIVATION) {
-		// we cleared the NEEDS_ACTIVATION bit and we have a valid suspend count
-		return _dispatch_lane_resume_activate(dq);
-	}
-
-	if (activate) {
-		// if we're still in an activate codepath here we should have
-		// { sc:>0 na:1 }, if not we've got a corrupt state
-		if (unlikely(!_dq_state_is_suspended(new_state))) {
-			DISPATCH_CLIENT_CRASH(dq, "Invalid suspension state");
-		}
-		return;
-	}
-
-	if (_dq_state_is_suspended(new_state)) {
-		return;
-	}
-
-	if (_dq_state_is_dirty(old_state)) {
-		// <rdar://problem/14637483>
-		// dependency ordering for dq state changes that were flushed
-		// and not acted upon
-		os_atomic_thread_fence(dependency);
-		dq = os_atomic_force_dependency_on(dq, old_state);
-	}
-	// Balancing the retain_2 done in suspend() for rdar://8181908
-	dispatch_wakeup_flags_t flags = DISPATCH_WAKEUP_CONSUME_2;
-	if ((old_state ^ new_state) & DISPATCH_QUEUE_IN_BARRIER) {
-		flags |= DISPATCH_WAKEUP_BARRIER_COMPLETE;
-	} else if (!_dq_state_is_runnable(new_state)) {
-		if (_dq_state_is_base_wlh(old_state)) {
-			_dispatch_event_loop_assert_not_owned((dispatch_wlh_t)dq);
-		}
-		return _dispatch_release_2(dq);
-	}
-	dispatch_assert(!_dq_state_received_sync_wait(old_state));
-	dispatch_assert(!_dq_state_in_sync_transfer(old_state));
-	return dx_wakeup(dq, _dq_state_max_qos(old_state), flags);
-
-over_resume:
-	if (unlikely(_dq_state_is_inactive(old_state))) {
-		DISPATCH_CLIENT_CRASH(dq, "Over-resume of an inactive object");
-	}
-	DISPATCH_CLIENT_CRASH(dq, "Over-resume of an object");
-}
-
-const char *
-dispatch_queue_get_label(dispatch_queue_t dq)
-{
-	if (unlikely(dq == DISPATCH_CURRENT_QUEUE_LABEL)) {
-		dq = _dispatch_queue_get_current_or_default();
-	}
-	return dq->dq_label ? dq->dq_label : "";
-}
-
-qos_class_t
-dispatch_queue_get_qos_class(dispatch_queue_t dq, int *relpri_ptr)
-{
-	dispatch_priority_t pri = dq->dq_priority;
-	dispatch_qos_t qos = _dispatch_priority_qos(pri);
-	if (relpri_ptr) {
-		*relpri_ptr = qos ? _dispatch_priority_relpri(dq->dq_priority) : 0;
-	}
-	return _dispatch_qos_to_qos_class(qos);
-}
-
-static void
-_dispatch_lane_set_width(void *ctxt)
-{
-	int w = (int)(intptr_t)ctxt; // intentional truncation
-	uint32_t tmp;
-	dispatch_lane_t dq = upcast(_dispatch_queue_get_current())._dl;
-
-	if (w >= 0) {
-		tmp = w ? (unsigned int)w : 1;
-	} else {
-		dispatch_qos_t qos = _dispatch_qos_from_pp(_dispatch_get_priority());
-		switch (w) {
-		case DISPATCH_QUEUE_WIDTH_MAX_PHYSICAL_CPUS:
-			tmp = _dispatch_qos_max_parallelism(qos,
-					DISPATCH_MAX_PARALLELISM_PHYSICAL);
-			break;
-		case DISPATCH_QUEUE_WIDTH_ACTIVE_CPUS:
-			tmp = _dispatch_qos_max_parallelism(qos,
-					DISPATCH_MAX_PARALLELISM_ACTIVE);
-			break;
-		case DISPATCH_QUEUE_WIDTH_MAX_LOGICAL_CPUS:
-		default:
-			tmp = _dispatch_qos_max_parallelism(qos, 0);
-			break;
-		}
-	}
-	if (tmp > DISPATCH_QUEUE_WIDTH_MAX) {
-		tmp = DISPATCH_QUEUE_WIDTH_MAX;
-	}
-
-	dispatch_queue_flags_t old_dqf, new_dqf;
-	os_atomic_rmw_loop2o(dq, dq_atomic_flags, old_dqf, new_dqf, relaxed, {
-		new_dqf = (old_dqf & DQF_FLAGS_MASK) | DQF_WIDTH(tmp);
-	});
-	_dispatch_lane_inherit_wlh_from_target(dq, dq->do_targetq);
-	_dispatch_object_debug(dq, "%s", __func__);
-}
-
-void
-dispatch_queue_set_width(dispatch_queue_t dq, long width)
-{
-	unsigned long type = dx_type(dq);
-	if (unlikely(dx_metatype(dq) != _DISPATCH_LANE_TYPE)) {
-		DISPATCH_CLIENT_CRASH(type, "Unexpected dispatch object type");
-	} else if (unlikely(type != DISPATCH_QUEUE_CONCURRENT_TYPE)) {
-		DISPATCH_CLIENT_CRASH(type, "Cannot set width of a serial queue");
-	}
-
-	if (likely((int)width >= 0)) {
-		dispatch_lane_t dl = upcast(dq)._dl;
-		_dispatch_barrier_trysync_or_async_f(dl, (void*)(intptr_t)width,
-				_dispatch_lane_set_width, DISPATCH_BARRIER_TRYSYNC_SUSPEND);
-	} else {
-		// The negative width constants need to execute on the queue to
-		// query the queue QoS
-		_dispatch_barrier_async_detached_f(dq, (void*)(intptr_t)width,
-				_dispatch_lane_set_width);
-	}
-}
-
-static void
-_dispatch_lane_legacy_set_target_queue(void *ctxt)
-{
-	dispatch_lane_t dq = upcast(_dispatch_queue_get_current())._dl;
-	dispatch_queue_t tq = ctxt;
-	dispatch_queue_t otq = dq->do_targetq;
-
-	if (_dispatch_queue_atomic_flags(dq) & DQF_TARGETED) {
-#if DISPATCH_ALLOW_NON_LEAF_RETARGET
-		_dispatch_ktrace3(DISPATCH_PERF_non_leaf_retarget, dq, otq, tq);
-		_dispatch_bug_deprecated("Changing the target of a queue "
-				"already targeted by other dispatch objects");
-#else
-		DISPATCH_CLIENT_CRASH(0, "Cannot change the target of a queue "
-				"already targeted by other dispatch objects");
-#endif
-	}
-
-	tq = _dispatch_queue_priority_inherit_from_target(dq, tq);
-	_dispatch_lane_inherit_wlh_from_target(dq, tq);
-#if HAVE_PTHREAD_WORKQUEUE_QOS
-	// see _dispatch_queue_wakeup()
-	_dispatch_queue_sidelock_lock(dq);
-#endif
-	dq->do_targetq = tq;
-#if HAVE_PTHREAD_WORKQUEUE_QOS
-	// see _dispatch_queue_wakeup()
-	_dispatch_queue_sidelock_unlock(dq);
-#endif
-
-	_dispatch_object_debug(dq, "%s", __func__);
-	_dispatch_introspection_target_queue_changed(dq->_as_dq);
-	_dispatch_release_tailcall(otq);
-}
-
-void
-_dispatch_lane_set_target_queue(dispatch_lane_t dq, dispatch_queue_t tq)
-{
-	if (tq == DISPATCH_TARGET_QUEUE_DEFAULT) {
-		bool overcommit = (dq->dq_width == 1);
-		tq = _dispatch_get_default_queue(overcommit);
-	}
-
-	if (_dispatch_lane_try_inactive_suspend(dq)) {
-		_dispatch_object_set_target_queue_inline(dq, tq);
-		return _dispatch_lane_resume(dq, false);
-	}
-
-#if !DISPATCH_ALLOW_NON_LEAF_RETARGET
-	if (_dispatch_queue_atomic_flags(dq) & DQF_TARGETED) {
-		DISPATCH_CLIENT_CRASH(0, "Cannot change the target of a queue "
-				"already targeted by other dispatch objects");
-	}
-#endif
-
-	if (unlikely(!_dispatch_queue_is_mutable(dq))) {
-#if DISPATCH_ALLOW_NON_LEAF_RETARGET
-		if (_dispatch_queue_atomic_flags(dq) & DQF_TARGETED) {
-			DISPATCH_CLIENT_CRASH(0, "Cannot change the target of a queue "
-					"already targeted by other dispatch objects");
-		}
-#endif
-		DISPATCH_CLIENT_CRASH(0, "Cannot change the target of this object "
-				"after it has been activated");
-	}
-
-	unsigned long metatype = dx_metatype(dq);
-	switch (metatype) {
-	case _DISPATCH_LANE_TYPE:
-#if DISPATCH_ALLOW_NON_LEAF_RETARGET
-		if (_dispatch_queue_atomic_flags(dq) & DQF_TARGETED) {
-			_dispatch_bug_deprecated("Changing the target of a queue "
-					"already targeted by other dispatch objects");
-		}
-#endif
-		break;
-	case _DISPATCH_SOURCE_TYPE:
-		_dispatch_ktrace1(DISPATCH_PERF_post_activate_retarget, dq);
-		_dispatch_bug_deprecated("Changing the target of a source "
-				"after it has been activated");
-		break;
-	default:
-		DISPATCH_CLIENT_CRASH(metatype, "Unexpected dispatch object type");
-	}
-
-	_dispatch_retain(tq);
-	return _dispatch_barrier_trysync_or_async_f(dq, tq,
-			_dispatch_lane_legacy_set_target_queue,
-			DISPATCH_BARRIER_TRYSYNC_SUSPEND);
-}
-
-#pragma mark -
-#pragma mark _dispatch_queue_debug
-
-size_t
-_dispatch_queue_debug_attr(dispatch_queue_t dq, char* buf, size_t bufsiz)
-{
-	size_t offset = 0;
-	dispatch_queue_t target = dq->do_targetq;
-	const char *tlabel = target && target->dq_label ? target->dq_label : "";
-	uint64_t dq_state = os_atomic_load2o(dq, dq_state, relaxed);
-
-	offset += dsnprintf(&buf[offset], bufsiz - offset, "sref = %d, "
-			"target = %s[%p], width = 0x%x, state = 0x%016llx",
-			dq->dq_sref_cnt + 1, tlabel, target, dq->dq_width,
-			(unsigned long long)dq_state);
-	if (_dq_state_is_suspended(dq_state)) {
-		offset += dsnprintf(&buf[offset], bufsiz - offset, ", suspended = %d",
-			_dq_state_suspend_cnt(dq_state));
-	}
-	if (_dq_state_is_inactive(dq_state)) {
-		offset += dsnprintf(&buf[offset], bufsiz - offset, ", inactive");
-	} else if (_dq_state_needs_activation(dq_state)) {
-		offset += dsnprintf(&buf[offset], bufsiz - offset, ", needs-activation");
-	}
-	if (_dq_state_is_enqueued(dq_state)) {
-		offset += dsnprintf(&buf[offset], bufsiz - offset, ", enqueued");
-	}
-	if (_dq_state_is_dirty(dq_state)) {
-		offset += dsnprintf(&buf[offset], bufsiz - offset, ", dirty");
-	}
-	dispatch_qos_t qos = _dq_state_max_qos(dq_state);
-	if (qos) {
-		offset += dsnprintf(&buf[offset], bufsiz - offset, ", max qos %d", qos);
-	}
-	mach_port_t owner = _dq_state_drain_owner(dq_state);
-	if (!_dispatch_queue_is_thread_bound(dq) && owner) {
-		offset += dsnprintf(&buf[offset], bufsiz - offset, ", draining on 0x%x",
-				owner);
-	}
-	if (_dq_state_is_in_barrier(dq_state)) {
-		offset += dsnprintf(&buf[offset], bufsiz - offset, ", in-barrier");
-	} else  {
-		offset += dsnprintf(&buf[offset], bufsiz - offset, ", in-flight = %d",
-				_dq_state_used_width(dq_state, dq->dq_width));
-	}
-	if (_dq_state_has_pending_barrier(dq_state)) {
-		offset += dsnprintf(&buf[offset], bufsiz - offset, ", pending-barrier");
-	}
-	if (_dispatch_queue_is_thread_bound(dq)) {
-		offset += dsnprintf(&buf[offset], bufsiz - offset, ", thread = 0x%x ",
-				owner);
-	}
-	return offset;
-}
-
-size_t
-_dispatch_queue_debug(dispatch_queue_t dq, char* buf, size_t bufsiz)
-{
-	size_t offset = 0;
-	offset += dsnprintf(&buf[offset], bufsiz - offset, "%s[%p] = { ",
-			dq->dq_label ? dq->dq_label : _dispatch_object_class_name(dq), dq);
-	offset += _dispatch_object_debug_attr(dq, &buf[offset], bufsiz - offset);
-	offset += _dispatch_queue_debug_attr(dq, &buf[offset], bufsiz - offset);
-	offset += dsnprintf(&buf[offset], bufsiz - offset, "}");
-	return offset;
-}
-
-#if DISPATCH_PERF_MON
-
-#define DISPATCH_PERF_MON_BUCKETS 8
-
-static struct {
-	uint64_t volatile time_total;
-	uint64_t volatile count_total;
-	uint64_t volatile thread_total;
-} _dispatch_stats[DISPATCH_PERF_MON_BUCKETS];
-DISPATCH_USED static size_t _dispatch_stat_buckets = DISPATCH_PERF_MON_BUCKETS;
-
-void
-_dispatch_queue_merge_stats(uint64_t start, bool trace, perfmon_thread_type type)
-{
-	uint64_t delta = _dispatch_uptime() - start;
-	unsigned long count;
-	int bucket = 0;
-	count = (unsigned long)_dispatch_thread_getspecific(dispatch_bcounter_key);
-	_dispatch_thread_setspecific(dispatch_bcounter_key, NULL);
-	if (count == 0) {
-		bucket = 0;
-		if (trace) _dispatch_ktrace1(DISPATCH_PERF_MON_worker_useless, type);
-	} else {
-		bucket = MIN(DISPATCH_PERF_MON_BUCKETS - 1,
-				(int)sizeof(count) * CHAR_BIT - __builtin_clzl(count));
-		os_atomic_add(&_dispatch_stats[bucket].count_total, count, relaxed);
-	}
-	os_atomic_add(&_dispatch_stats[bucket].time_total, delta, relaxed);
-	os_atomic_inc(&_dispatch_stats[bucket].thread_total, relaxed);
-	if (trace) {
-		_dispatch_ktrace3(DISPATCH_PERF_MON_worker_thread_end, count, delta, type);
-	}
-}
-
-#endif
-
-#pragma mark -
-#pragma mark dispatch queue/lane drain & invoke
-
-DISPATCH_NOINLINE
-static void
-_dispatch_return_to_kernel(void)
-{
-#if DISPATCH_USE_KEVENT_WORKQUEUE
-	dispatch_deferred_items_t ddi = _dispatch_deferred_items_get();
-	if (likely(ddi && ddi->ddi_wlh != DISPATCH_WLH_ANON)) {
-		dispatch_assert(ddi->ddi_wlh_servicing);
-		_dispatch_event_loop_drain(KEVENT_FLAG_IMMEDIATE);
-	} else {
-		_dispatch_clear_return_to_kernel();
-	}
-#endif
-}
-
-void
-_dispatch_poll_for_events_4launchd(void)
-{
-	_dispatch_return_to_kernel();
-}
-
-#if DISPATCH_USE_WORKQUEUE_NARROWING
-DISPATCH_STATIC_GLOBAL(os_atomic(uint64_t)
-_dispatch_narrowing_deadlines[DISPATCH_QOS_NBUCKETS]);
-#if !DISPATCH_TIME_UNIT_USES_NANOSECONDS
-DISPATCH_STATIC_GLOBAL(uint64_t _dispatch_narrow_check_interval_cache);
-#endif
-
-DISPATCH_ALWAYS_INLINE
-static inline uint64_t
-_dispatch_narrow_check_interval(void)
-{
-#if DISPATCH_TIME_UNIT_USES_NANOSECONDS
-	return 50 * NSEC_PER_MSEC;
-#else
-	if (_dispatch_narrow_check_interval_cache == 0) {
-		_dispatch_narrow_check_interval_cache =
-				_dispatch_time_nano2mach(50 * NSEC_PER_MSEC);
-	}
-	return _dispatch_narrow_check_interval_cache;
-#endif
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_queue_drain_init_narrowing_check_deadline(dispatch_invoke_context_t dic,
-		dispatch_priority_t pri)
-{
-	if (!(pri & DISPATCH_PRIORITY_FLAG_OVERCOMMIT)) {
-		dic->dic_next_narrow_check = _dispatch_approximate_time() +
-				_dispatch_narrow_check_interval();
-	}
-}
-
-DISPATCH_NOINLINE
-static bool
-_dispatch_queue_drain_should_narrow_slow(uint64_t now,
-		dispatch_invoke_context_t dic)
-{
-	if (dic->dic_next_narrow_check != DISPATCH_THREAD_IS_NARROWING) {
-		pthread_priority_t pp = _dispatch_get_priority();
-		dispatch_qos_t qos = _dispatch_qos_from_pp(pp);
-		if (unlikely(qos < DISPATCH_QOS_MIN || qos > DISPATCH_QOS_MAX)) {
-			DISPATCH_CLIENT_CRASH(pp, "Thread QoS corruption");
-		}
-		size_t idx = DISPATCH_QOS_BUCKET(qos);
-		os_atomic(uint64_t) *deadline = &_dispatch_narrowing_deadlines[idx];
-		uint64_t oldval, newval = now + _dispatch_narrow_check_interval();
-
-		dic->dic_next_narrow_check = newval;
-		os_atomic_rmw_loop(deadline, oldval, newval, relaxed, {
-			if (now < oldval) {
-				os_atomic_rmw_loop_give_up(return false);
-			}
-		});
-
-		if (!_pthread_workqueue_should_narrow(pp)) {
-			return false;
-		}
-		dic->dic_next_narrow_check = DISPATCH_THREAD_IS_NARROWING;
-	}
-	return true;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dispatch_queue_drain_should_narrow(dispatch_invoke_context_t dic)
-{
-	uint64_t next_check = dic->dic_next_narrow_check;
-	if (unlikely(next_check)) {
-		uint64_t now = _dispatch_approximate_time();
-		if (unlikely(next_check < now)) {
-			return _dispatch_queue_drain_should_narrow_slow(now, dic);
-		}
-	}
-	return false;
-}
-#else
-#define _dispatch_queue_drain_init_narrowing_check_deadline(rq, dic) ((void)0)
-#define _dispatch_queue_drain_should_narrow(dic)  false
-#endif
-
-/*
- * Drain comes in 2 flavours (serial/concurrent) and 2 modes
- * (redirecting or not).
- *
- * Serial
- * ~~~~~~
- * Serial drain is about serial queues (width == 1). It doesn't support
- * the redirecting mode, which doesn't make sense, and treats all continuations
- * as barriers. Bookkeeping is minimal in serial flavour, most of the loop
- * is optimized away.
- *
- * Serial drain stops if the width of the queue grows to larger than 1.
- * Going through a serial drain prevents any recursive drain from being
- * redirecting.
- *
- * Concurrent
- * ~~~~~~~~~~
- * When in non-redirecting mode (meaning one of the target queues is serial),
- * non-barriers and barriers alike run in the context of the drain thread.
- * Slow non-barrier items are still all signaled so that they can make progress
- * toward the dispatch_sync() that will serialize them all .
- *
- * In redirecting mode, non-barrier work items are redirected downward.
- *
- * Concurrent drain stops if the width of the queue becomes 1, so that the
- * queue drain moves to the more efficient serial mode.
- */
-DISPATCH_ALWAYS_INLINE
-static dispatch_queue_wakeup_target_t
-_dispatch_lane_drain(dispatch_lane_t dq, dispatch_invoke_context_t dic,
-		dispatch_invoke_flags_t flags, uint64_t *owned_ptr, bool serial_drain)
-{
-	dispatch_queue_t orig_tq = dq->do_targetq;
-	dispatch_thread_frame_s dtf;
-	struct dispatch_object_s *dc = NULL, *next_dc;
-	uint64_t dq_state, owned = *owned_ptr;
-
-	if (unlikely(!dq->dq_items_tail)) return NULL;
-
-	_dispatch_thread_frame_push(&dtf, dq);
-	if (serial_drain || _dq_state_is_in_barrier(owned)) {
-		// we really own `IN_BARRIER + dq->dq_width * WIDTH_INTERVAL`
-		// but width can change while draining barrier work items, so we only
-		// convert to `dq->dq_width * WIDTH_INTERVAL` when we drop `IN_BARRIER`
-		owned = DISPATCH_QUEUE_IN_BARRIER;
-	} else {
-		owned &= DISPATCH_QUEUE_WIDTH_MASK;
-	}
-
-	dc = _dispatch_queue_get_head(dq);
-	goto first_iteration;
-
-	for (;;) {
-		dispatch_assert(dic->dic_barrier_waiter == NULL);
-		dc = next_dc;
-		if (unlikely(!dc)) {
-			if (!dq->dq_items_tail) {
-				break;
-			}
-			dc = _dispatch_queue_get_head(dq);
-		}
-		if (unlikely(_dispatch_needs_to_return_to_kernel())) {
-			_dispatch_return_to_kernel();
-		}
-		if (unlikely(serial_drain != (dq->dq_width == 1))) {
-			break;
-		}
-		if (unlikely(_dispatch_queue_drain_should_narrow(dic))) {
-			break;
-		}
-		if (likely(flags & DISPATCH_INVOKE_WORKLOOP_DRAIN)) {
-			dispatch_workloop_t dwl = (dispatch_workloop_t)_dispatch_get_wlh();
-			if (unlikely(_dispatch_queue_max_qos(dwl) > dwl->dwl_drained_qos)) {
-				break;
-			}
-		}
-
-first_iteration:
-		dq_state = os_atomic_load(&dq->dq_state, relaxed);
-		if (unlikely(_dq_state_is_suspended(dq_state))) {
-			break;
-		}
-		if (unlikely(orig_tq != dq->do_targetq)) {
-			break;
-		}
-
-		if (serial_drain || _dispatch_object_is_barrier(dc)) {
-			if (!serial_drain && owned != DISPATCH_QUEUE_IN_BARRIER) {
-				if (!_dispatch_queue_try_upgrade_full_width(dq, owned)) {
-					goto out_with_no_width;
-				}
-				owned = DISPATCH_QUEUE_IN_BARRIER;
-			}
-			if (_dispatch_object_is_sync_waiter(dc) &&
-					!(flags & DISPATCH_INVOKE_THREAD_BOUND)) {
-				dic->dic_barrier_waiter = dc;
-				goto out_with_barrier_waiter;
-			}
-			next_dc = _dispatch_queue_pop_head(dq, dc);
-		} else {
-			if (owned == DISPATCH_QUEUE_IN_BARRIER) {
-				// we just ran barrier work items, we have to make their
-				// effect visible to other sync work items on other threads
-				// that may start coming in after this point, hence the
-				// release barrier
-				os_atomic_xor2o(dq, dq_state, owned, release);
-				owned = dq->dq_width * DISPATCH_QUEUE_WIDTH_INTERVAL;
-			} else if (unlikely(owned == 0)) {
-				if (_dispatch_object_is_waiter(dc)) {
-					// sync "readers" don't observe the limit
-					_dispatch_queue_reserve_sync_width(dq);
-				} else if (!_dispatch_queue_try_acquire_async(dq)) {
-					goto out_with_no_width;
-				}
-				owned = DISPATCH_QUEUE_WIDTH_INTERVAL;
-			}
-
-			next_dc = _dispatch_queue_pop_head(dq, dc);
-			if (_dispatch_object_is_waiter(dc)) {
-				owned -= DISPATCH_QUEUE_WIDTH_INTERVAL;
-				_dispatch_non_barrier_waiter_redirect_or_wake(dq, dc);
-				continue;
-			}
-
-			if (flags & DISPATCH_INVOKE_REDIRECTING_DRAIN) {
-				owned -= DISPATCH_QUEUE_WIDTH_INTERVAL;
-				// This is a re-redirect, overrides have already been applied by
-				// _dispatch_continuation_async*
-				// However we want to end up on the root queue matching `dc`
-				// qos, so pick up the current override of `dq` which includes
-				// dc's override (and maybe more)
-				_dispatch_continuation_redirect_push(dq, dc,
-						_dispatch_queue_max_qos(dq));
-				continue;
-			}
-		}
-
-		_dispatch_continuation_pop_inline(dc, dic, flags, dq);
-	}
-
-	if (owned == DISPATCH_QUEUE_IN_BARRIER) {
-		// if we're IN_BARRIER we really own the full width too
-		owned += dq->dq_width * DISPATCH_QUEUE_WIDTH_INTERVAL;
-	}
-	if (dc) {
-		owned = _dispatch_queue_adjust_owned(dq, owned, dc);
-	}
-	*owned_ptr &= DISPATCH_QUEUE_ENQUEUED | DISPATCH_QUEUE_ENQUEUED_ON_MGR;
-	*owned_ptr |= owned;
-	_dispatch_thread_frame_pop(&dtf);
-	return dc ? dq->do_targetq : NULL;
-
-out_with_no_width:
-	*owned_ptr &= DISPATCH_QUEUE_ENQUEUED | DISPATCH_QUEUE_ENQUEUED_ON_MGR;
-	_dispatch_thread_frame_pop(&dtf);
-	return DISPATCH_QUEUE_WAKEUP_WAIT_FOR_EVENT;
-
-out_with_barrier_waiter:
-	if (unlikely(flags & DISPATCH_INVOKE_DISALLOW_SYNC_WAITERS)) {
-		DISPATCH_INTERNAL_CRASH(0,
-				"Deferred continuation on source, mach channel or mgr");
-	}
-	_dispatch_thread_frame_pop(&dtf);
-	return dq->do_targetq;
-}
-
-DISPATCH_NOINLINE
-static dispatch_queue_wakeup_target_t
-_dispatch_lane_concurrent_drain(dispatch_lane_class_t dqu,
-		dispatch_invoke_context_t dic, dispatch_invoke_flags_t flags,
-		uint64_t *owned)
-{
-	return _dispatch_lane_drain(dqu._dl, dic, flags, owned, false);
-}
-
-DISPATCH_NOINLINE
-dispatch_queue_wakeup_target_t
-_dispatch_lane_serial_drain(dispatch_lane_class_t dqu,
-		dispatch_invoke_context_t dic, dispatch_invoke_flags_t flags,
-		uint64_t *owned)
-{
-	flags &= ~(dispatch_invoke_flags_t)DISPATCH_INVOKE_REDIRECTING_DRAIN;
-	return _dispatch_lane_drain(dqu._dl, dic, flags, owned, true);
-}
-
-void
-_dispatch_queue_invoke_finish(dispatch_queue_t dq,
-		dispatch_invoke_context_t dic, dispatch_queue_t tq, uint64_t owned)
-{
-	struct dispatch_object_s *dc = dic->dic_barrier_waiter;
-	dispatch_qos_t qos = dic->dic_barrier_waiter_bucket;
-	if (dc) {
-		dic->dic_barrier_waiter = NULL;
-		dic->dic_barrier_waiter_bucket = DISPATCH_QOS_UNSPECIFIED;
-		owned &= DISPATCH_QUEUE_ENQUEUED | DISPATCH_QUEUE_ENQUEUED_ON_MGR;
-#if DISPATCH_INTROSPECTION
-		dispatch_sync_context_t dsc = (dispatch_sync_context_t)dc;
-		dsc->dsc_from_async = true;
-#endif
-		if (qos) {
-			return _dispatch_workloop_drain_barrier_waiter(upcast(dq)._dwl,
-					dc, qos, DISPATCH_WAKEUP_CONSUME_2, owned);
-		}
-		return _dispatch_lane_drain_barrier_waiter(upcast(dq)._dl, dc,
-				DISPATCH_WAKEUP_CONSUME_2, owned);
-	}
-
-	uint64_t old_state, new_state, enqueued = DISPATCH_QUEUE_ENQUEUED;
-	if (tq == DISPATCH_QUEUE_WAKEUP_MGR) {
-		enqueued = DISPATCH_QUEUE_ENQUEUED_ON_MGR;
-	}
-	os_atomic_rmw_loop2o(dq, dq_state, old_state, new_state, release, {
-		new_state  = old_state - owned;
-		new_state &= ~DISPATCH_QUEUE_DRAIN_UNLOCK_MASK;
-		new_state |= DISPATCH_QUEUE_DIRTY;
-		if (_dq_state_is_runnable(new_state) &&
-				!_dq_state_is_enqueued(new_state)) {
-			// drain was not interupted for suspension
-			// we will reenqueue right away, just put ENQUEUED back
-			new_state |= enqueued;
-		}
-	});
-	old_state -= owned;
-	if (_dq_state_received_override(old_state)) {
-		// Ensure that the root queue sees that this thread was overridden.
-		_dispatch_set_basepri_override_qos(_dq_state_max_qos(new_state));
-	}
-	if ((old_state ^ new_state) & enqueued) {
-		dispatch_assert(_dq_state_is_enqueued(new_state));
-		return _dispatch_queue_push_queue(tq, dq, new_state);
-	}
-	return _dispatch_release_2_tailcall(dq);
-}
-
-void
-_dispatch_lane_activate(dispatch_lane_class_t dq,
-		DISPATCH_UNUSED bool *allow_resume)
-{
-	dispatch_queue_t tq = dq._dl->do_targetq;
-	dispatch_priority_t pri = dq._dl->dq_priority;
-
-	// Normalize priority: keep the fallback only when higher than the floor
-	if (_dispatch_priority_fallback_qos(pri) <= _dispatch_priority_qos(pri) ||
-			(_dispatch_priority_qos(pri) &&
-			!(pri & DISPATCH_PRIORITY_FLAG_FLOOR))) {
-		pri &= ~DISPATCH_PRIORITY_FALLBACK_QOS_MASK;
-		pri &= ~DISPATCH_PRIORITY_FLAG_FALLBACK;
-		dq._dl->dq_priority = pri;
-	}
-	tq = _dispatch_queue_priority_inherit_from_target(dq, tq);
-	_dispatch_lane_inherit_wlh_from_target(dq._dl, tq);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_queue_wakeup_target_t
-_dispatch_lane_invoke2(dispatch_lane_t dq, dispatch_invoke_context_t dic,
-		dispatch_invoke_flags_t flags, uint64_t *owned)
-{
-	dispatch_queue_t otq = dq->do_targetq;
-	dispatch_queue_t cq = _dispatch_queue_get_current();
-
-	if (unlikely(cq != otq)) {
-		return otq;
-	}
-	if (dq->dq_width == 1) {
-		return _dispatch_lane_serial_drain(dq, dic, flags, owned);
-	}
-	return _dispatch_lane_concurrent_drain(dq, dic, flags, owned);
-}
-
-DISPATCH_NOINLINE
-void
-_dispatch_lane_invoke(dispatch_lane_t dq, dispatch_invoke_context_t dic,
-		dispatch_invoke_flags_t flags)
-{
-	_dispatch_queue_class_invoke(dq, dic, flags, 0, _dispatch_lane_invoke2);
-}
-
-#pragma mark -
-#pragma mark dispatch_workloop_t
-
-#define _dispatch_wl(dwl, qos) os_mpsc(dwl, dwl, s[DISPATCH_QOS_BUCKET(qos)])
-#define _dispatch_workloop_looks_empty(dwl, qos) \
-		os_mpsc_looks_empty(_dispatch_wl(dwl, qos))
-#define _dispatch_workloop_get_head(dwl, qos) \
-		os_mpsc_get_head(_dispatch_wl(dwl, qos))
-#define _dispatch_workloop_pop_head(dwl, qos, dc) \
-		os_mpsc_pop_head(_dispatch_wl(dwl, qos), dc, do_next)
-#define _dispatch_workloop_push_update_tail(dwl, qos, dou) \
-		os_mpsc_push_update_tail(_dispatch_wl(dwl, qos), dou, do_next)
-#define _dispatch_workloop_push_update_prev(dwl, qos, prev, dou) \
-		os_mpsc_push_update_prev(_dispatch_wl(dwl, qos), prev, dou, do_next)
-
-dispatch_workloop_t
-dispatch_workloop_copy_current(void)
-{
-	dispatch_workloop_t dwl = _dispatch_wlh_to_workloop(_dispatch_get_wlh());
-	if (likely(dwl)) {
-		_os_object_retain_with_resurrect(dwl->_as_os_obj);
-		return dwl;
-	}
-	return NULL;
-}
-
-bool
-dispatch_workloop_is_current(dispatch_workloop_t dwl)
-{
-	return _dispatch_get_wlh() == (dispatch_wlh_t)dwl;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline uint64_t
-_dispatch_workloop_role_bits(void)
-{
-#if DISPATCH_USE_KEVENT_WORKLOOP
-	if (likely(_dispatch_kevent_workqueue_enabled)) {
-		return DISPATCH_QUEUE_ROLE_BASE_WLH;
-	}
-#endif
-	return DISPATCH_QUEUE_ROLE_BASE_ANON;
-}
-
-bool
-_dispatch_workloop_should_yield_4NW(void)
-{
-	dispatch_workloop_t dwl = _dispatch_wlh_to_workloop(_dispatch_get_wlh());
-	if (likely(dwl)) {
-		return _dispatch_queue_max_qos(dwl) > dwl->dwl_drained_qos;
-	}
-	return false;
-}
-
-DISPATCH_NOINLINE
-static dispatch_workloop_t
-_dispatch_workloop_create(const char *label, uint64_t dq_state)
-{
-	dispatch_queue_flags_t dqf = DQF_AUTORELEASE_ALWAYS;
-	dispatch_workloop_t dwl;
-
-	if (label) {
-		const char *tmp = _dispatch_strdup_if_mutable(label);
-		if (tmp != label) {
-			dqf |= DQF_LABEL_NEEDS_FREE;
-			label = tmp;
-		}
-	}
-
-	dq_state |= _dispatch_workloop_role_bits();
-
-	dwl = _dispatch_queue_alloc(workloop, dqf, 1, dq_state)._dwl;
-	dwl->dq_label = label;
-	dwl->do_targetq = _dispatch_get_default_queue(true);
-	if (!(dq_state & DISPATCH_QUEUE_INACTIVE)) {
-		dwl->dq_priority = DISPATCH_PRIORITY_FLAG_OVERCOMMIT |
-				_dispatch_priority_make_fallback(DISPATCH_QOS_DEFAULT);
-	}
-	_dispatch_object_debug(dwl, "%s", __func__);
-	return _dispatch_introspection_queue_create(dwl)._dwl;
-}
-
-dispatch_workloop_t
-dispatch_workloop_create(const char *label)
-{
-	return _dispatch_workloop_create(label, 0);
-}
-
-dispatch_workloop_t
-dispatch_workloop_create_inactive(const char *label)
-{
-	return _dispatch_workloop_create(label, DISPATCH_QUEUE_INACTIVE);
-}
-
-void
-dispatch_workloop_set_autorelease_frequency(dispatch_workloop_t dwl,
-		dispatch_autorelease_frequency_t frequency)
-{
-	if (frequency == DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM) {
-		_dispatch_queue_atomic_flags_set_and_clear(dwl,
-				DQF_AUTORELEASE_ALWAYS, DQF_AUTORELEASE_NEVER);
-	} else {
-		_dispatch_queue_atomic_flags_set_and_clear(dwl,
-				DQF_AUTORELEASE_NEVER, DQF_AUTORELEASE_ALWAYS);
-	}
-	_dispatch_queue_setter_assert_inactive(dwl);
-}
-
-DISPATCH_ALWAYS_INLINE
-static void
-_dispatch_workloop_attributes_dispose(dispatch_workloop_t dwl)
-{
-	if (dwl->dwl_attr) {
-		free(dwl->dwl_attr);
-	}
-}
-
-#if TARGET_OS_MAC
-DISPATCH_ALWAYS_INLINE
-static bool
-_dispatch_workloop_has_kernel_attributes(dispatch_workloop_t dwl)
-{
-	return dwl->dwl_attr && (dwl->dwl_attr->dwla_flags &
-			(DISPATCH_WORKLOOP_ATTR_HAS_SCHED |
-			 DISPATCH_WORKLOOP_ATTR_HAS_POLICY |
-			 DISPATCH_WORKLOOP_ATTR_HAS_CPUPERCENT));
-}
-
-void
-dispatch_workloop_set_scheduler_priority(dispatch_workloop_t dwl, int priority,
-		uint64_t flags)
-{
-	_dispatch_queue_setter_assert_inactive(dwl);
-	_dispatch_workloop_attributes_alloc_if_needed(dwl);
-
-	if (priority) {
-		dwl->dwl_attr->dwla_sched.sched_priority = priority;
-		dwl->dwl_attr->dwla_flags |= DISPATCH_WORKLOOP_ATTR_HAS_SCHED;
-	} else {
-		dwl->dwl_attr->dwla_sched.sched_priority = 0;
-		dwl->dwl_attr->dwla_flags &= ~DISPATCH_WORKLOOP_ATTR_HAS_SCHED;
-	}
-
-	if (flags & DISPATCH_WORKLOOP_FIXED_PRIORITY) {
-		dwl->dwl_attr->dwla_policy = POLICY_RR;
-		dwl->dwl_attr->dwla_flags |= DISPATCH_WORKLOOP_ATTR_HAS_POLICY;
-	} else {
-		dwl->dwl_attr->dwla_flags &= ~DISPATCH_WORKLOOP_ATTR_HAS_POLICY;
-	}
-}
-#endif // TARGET_OS_MAC
-
-void
-dispatch_workloop_set_qos_class_floor(dispatch_workloop_t dwl,
-		qos_class_t cls, int relpri, uint64_t flags)
-{
-	_dispatch_queue_setter_assert_inactive(dwl);
-	_dispatch_workloop_attributes_alloc_if_needed(dwl);
-
-	dispatch_qos_t qos = _dispatch_qos_from_qos_class(cls);
-
-	if (qos) {
-		dwl->dwl_attr->dwla_pri = _dispatch_priority_make(qos, relpri);
-		dwl->dwl_attr->dwla_flags |= DISPATCH_WORKLOOP_ATTR_HAS_QOS_CLASS;
-	} else {
-		dwl->dwl_attr->dwla_pri = 0;
-		dwl->dwl_attr->dwla_flags &= ~DISPATCH_WORKLOOP_ATTR_HAS_QOS_CLASS;
-	}
-
-#if TARGET_OS_MAC
-	if (flags & DISPATCH_WORKLOOP_FIXED_PRIORITY) {
-		dwl->dwl_attr->dwla_policy = POLICY_RR;
-		dwl->dwl_attr->dwla_flags |= DISPATCH_WORKLOOP_ATTR_HAS_POLICY;
-	} else {
-		dwl->dwl_attr->dwla_flags &= ~DISPATCH_WORKLOOP_ATTR_HAS_POLICY;
-	}
-#else // TARGET_OS_MAC
-	(void)flags;
-#endif // TARGET_OS_MAC
-}
-
-void
-dispatch_workloop_set_qos_class(dispatch_workloop_t dwl,
-		qos_class_t cls, uint64_t flags)
-{
-	dispatch_workloop_set_qos_class_floor(dwl, cls, 0, flags);
-}
-
-void
-dispatch_workloop_set_cpupercent(dispatch_workloop_t dwl, uint8_t percent,
-		uint32_t refillms)
-{
-	_dispatch_queue_setter_assert_inactive(dwl);
-	_dispatch_workloop_attributes_alloc_if_needed(dwl);
-
-	if ((dwl->dwl_attr->dwla_flags & (DISPATCH_WORKLOOP_ATTR_HAS_SCHED |
-			DISPATCH_WORKLOOP_ATTR_HAS_QOS_CLASS)) == 0) {
-		DISPATCH_CLIENT_CRASH(0, "workloop qos class or priority must be "
-				"set before cpupercent");
-	}
-
-	dwl->dwl_attr->dwla_cpupercent.percent = percent;
-	dwl->dwl_attr->dwla_cpupercent.refillms = refillms;
-	dwl->dwl_attr->dwla_flags |= DISPATCH_WORKLOOP_ATTR_HAS_CPUPERCENT;
-}
-
-#if TARGET_OS_MAC
-static void
-_dispatch_workloop_activate_simulator_fallback(dispatch_workloop_t dwl,
-		pthread_attr_t *attr)
-{
-	uint64_t old_state, new_state;
-	dispatch_queue_global_t dprq;
-
-	dprq = dispatch_pthread_root_queue_create(
-			"com.apple.libdispatch.workloop_fallback", 0, attr, NULL);
-
-	dwl->do_targetq = dprq->_as_dq;
-	_dispatch_retain(dprq);
-	dispatch_release(dprq);
-
-	os_atomic_rmw_loop2o(dwl, dq_state, old_state, new_state, relaxed, {
-		new_state = old_state & ~DISPATCH_QUEUE_ROLE_MASK;
-		new_state |= DISPATCH_QUEUE_ROLE_BASE_ANON;
-	});
-}
-
-static const struct dispatch_queue_global_s _dispatch_custom_workloop_root_queue = {
-	DISPATCH_GLOBAL_OBJECT_HEADER(queue_global),
-	.dq_state = DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE,
-	.do_ctxt = NULL,
-	.dq_label = "com.apple.root.workloop-custom",
-	.dq_atomic_flags = DQF_WIDTH(DISPATCH_QUEUE_WIDTH_POOL),
-	.dq_priority = DISPATCH_PRIORITY_FLAG_MANAGER |
-			DISPATCH_PRIORITY_SATURATED_OVERRIDE,
-	.dq_serialnum = DISPATCH_QUEUE_SERIAL_NUMBER_WLF,
-	.dgq_thread_pool_size = 1,
-};
-#endif // TARGET_OS_MAC
-
-static void
-_dispatch_workloop_activate_attributes(dispatch_workloop_t dwl)
-{
-#if defined(_POSIX_THREADS)
-	dispatch_workloop_attr_t dwla = dwl->dwl_attr;
-	pthread_attr_t attr;
-
-	pthread_attr_init(&attr);
-	if (dwla->dwla_flags & DISPATCH_WORKLOOP_ATTR_HAS_QOS_CLASS) {
-		dwl->dq_priority |= dwla->dwla_pri | DISPATCH_PRIORITY_FLAG_FLOOR;
-	}
-#if TARGET_OS_MAC
-	if (dwla->dwla_flags & DISPATCH_WORKLOOP_ATTR_HAS_SCHED) {
-		pthread_attr_setschedparam(&attr, &dwla->dwla_sched);
-		// _dispatch_async_and_wait_should_always_async detects when a queue
-		// targets a root queue that is not part of the root queues array in
-		// order to force async_and_wait to async. We want this path to always
-		// be taken on workloops that have a scheduler priority set.
-		dwl->do_targetq =
-				(dispatch_queue_t)_dispatch_custom_workloop_root_queue._as_dq;
-	}
-	if (dwla->dwla_flags & DISPATCH_WORKLOOP_ATTR_HAS_POLICY) {
-		pthread_attr_setschedpolicy(&attr, dwla->dwla_policy);
-	}
-#endif // TARGET_OS_MAC
-#if HAVE_PTHREAD_ATTR_SETCPUPERCENT_NP
-	if (dwla->dwla_flags & DISPATCH_WORKLOOP_ATTR_HAS_CPUPERCENT) {
-		pthread_attr_setcpupercent_np(&attr, dwla->dwla_cpupercent.percent,
-				(unsigned long)dwla->dwla_cpupercent.refillms);
-	}
-#endif // HAVE_PTHREAD_ATTR_SETCPUPERCENT_NP
-#if TARGET_OS_MAC
-	if (_dispatch_workloop_has_kernel_attributes(dwl)) {
-		int rv = _pthread_workloop_create((uint64_t)dwl, 0, &attr);
-		switch (rv) {
-		case 0:
-			dwla->dwla_flags |= DISPATCH_WORKLOOP_ATTR_NEEDS_DESTROY;
-			break;
-		case ENOTSUP:
-			/* simulator fallback */
-			_dispatch_workloop_activate_simulator_fallback(dwl, &attr);
-			break;
-		default:
-			dispatch_assert_zero(rv);
-		}
-	}
-#endif // TARGET_OS_MAC
-	pthread_attr_destroy(&attr);
-#endif // defined(_POSIX_THREADS)
-}
-
-void
-_dispatch_workloop_dispose(dispatch_workloop_t dwl, bool *allow_free)
-{
-	uint64_t dq_state = os_atomic_load2o(dwl, dq_state, relaxed);
-	uint64_t initial_state = DISPATCH_QUEUE_STATE_INIT_VALUE(1);
-
-	initial_state |= _dispatch_workloop_role_bits();
-
-	if (unlikely(dq_state != initial_state)) {
-		if (_dq_state_drain_locked(dq_state)) {
-			DISPATCH_CLIENT_CRASH((uintptr_t)dq_state,
-					"Release of a locked workloop");
-		}
-#if DISPATCH_SIZEOF_PTR == 4
-		dq_state >>= 32;
-#endif
-		DISPATCH_CLIENT_CRASH((uintptr_t)dq_state,
-				"Release of a workloop with corrupt state");
-	}
-
-	_dispatch_object_debug(dwl, "%s", __func__);
-	_dispatch_introspection_queue_dispose(dwl);
-
-	for (size_t i = 0; i < countof(dwl->dwl_tails); i++) {
-		if (unlikely(dwl->dwl_tails[i])) {
-			DISPATCH_CLIENT_CRASH(dwl->dwl_tails[i],
-					"Release of a workloop while items are enqueued");
-		}
-		// trash the queue so that use after free will crash
-		dwl->dwl_tails[i] = (void *)0x200;
-		dwl->dwl_heads[i] = (void *)0x200;
-	}
-
-	if (dwl->dwl_timer_heap) {
-		for (size_t i = 0; i < DISPATCH_TIMER_WLH_COUNT; i++) {
-			dispatch_assert(dwl->dwl_timer_heap[i].dth_count == 0);
-		}
-		free(dwl->dwl_timer_heap);
-		dwl->dwl_timer_heap = NULL;
-	}
-
-#if TARGET_OS_MAC
-	if (dwl->dwl_attr && (dwl->dwl_attr->dwla_flags &
-			DISPATCH_WORKLOOP_ATTR_NEEDS_DESTROY)) {
-		(void)dispatch_assume_zero(_pthread_workloop_destroy((uint64_t)dwl));
-	}
-#endif // TARGET_OS_MAC
-	_dispatch_workloop_attributes_dispose(dwl);
-	_dispatch_queue_dispose(dwl, allow_free);
-}
-
-void
-_dispatch_workloop_activate(dispatch_workloop_t dwl)
-{
-	uint64_t dq_state = os_atomic_and_orig2o(dwl, dq_state,
-			~DISPATCH_QUEUE_INACTIVE, relaxed);
-
-	if (likely(dq_state & DISPATCH_QUEUE_INACTIVE)) {
-		if (dwl->dwl_attr) {
-			// Activation of a workloop with attributes forces us to create
-			// the workloop up front and register the attributes with the
-			// kernel.
-			_dispatch_workloop_activate_attributes(dwl);
-		}
-		if (!dwl->dq_priority) {
-			dwl->dq_priority =
-					_dispatch_priority_make_fallback(DISPATCH_QOS_DEFAULT);
-		}
-		dwl->dq_priority |= DISPATCH_PRIORITY_FLAG_OVERCOMMIT;
-		os_atomic_and2o(dwl, dq_state, ~DISPATCH_QUEUE_NEEDS_ACTIVATION,
-				relaxed);
-		_dispatch_workloop_wakeup(dwl, 0, DISPATCH_WAKEUP_CONSUME_2);
-		return;
-	}
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dispatch_workloop_try_lower_max_qos(dispatch_workloop_t dwl,
-		dispatch_qos_t qos)
-{
-	uint64_t old_state, new_state, qos_bits = _dq_state_from_qos(qos);
-
-	os_atomic_rmw_loop2o(dwl, dq_state, old_state, new_state, relaxed, {
-		if ((old_state & DISPATCH_QUEUE_MAX_QOS_MASK) <= qos_bits) {
-			os_atomic_rmw_loop_give_up(return true);
-		}
-
-		if (unlikely(_dq_state_is_dirty(old_state))) {
-			os_atomic_rmw_loop_give_up({
-				os_atomic_xor2o(dwl, dq_state, DISPATCH_QUEUE_DIRTY, acquire);
-				return false;
-			});
-		}
-
-		new_state  = old_state;
-		new_state &= ~DISPATCH_QUEUE_MAX_QOS_MASK;
-		new_state |= qos_bits;
-	});
-
-#if DISPATCH_USE_KEVENT_WORKQUEUE
-	dispatch_deferred_items_t ddi = _dispatch_deferred_items_get();
-	if (likely(ddi)) {
-		ddi->ddi_wlh_needs_update = true;
-		_dispatch_return_to_kernel();
-	}
-#endif // DISPATCH_USE_KEVENT_WORKQUEUE
-	return true;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_queue_wakeup_target_t
-_dispatch_workloop_invoke2(dispatch_workloop_t dwl,
-		dispatch_invoke_context_t dic, dispatch_invoke_flags_t flags,
-		uint64_t *owned)
-{
-	dispatch_thread_frame_s dtf;
-	struct dispatch_object_s *dc = NULL, *next_dc;
-
-	_dispatch_thread_frame_push(&dtf, dwl);
-
-	for (;;) {
-		dispatch_qos_t qos;
-		for (qos = DISPATCH_QOS_MAX; qos >= DISPATCH_QOS_MIN; qos--) {
-			if (!_dispatch_workloop_looks_empty(dwl, qos)) break;
-		}
-		if (qos < DISPATCH_QOS_MIN) {
-			break;
-		}
-		if (unlikely(!_dispatch_workloop_try_lower_max_qos(dwl, qos))) {
-			continue;
-		}
-		dwl->dwl_drained_qos = (uint8_t)qos;
-
-		dc = _dispatch_workloop_get_head(dwl, qos);
-		do {
-			if (_dispatch_object_is_sync_waiter(dc)) {
-				dic->dic_barrier_waiter_bucket = qos;
-				dic->dic_barrier_waiter = dc;
-				dwl->dwl_drained_qos = DISPATCH_QOS_UNSPECIFIED;
-				goto out_with_barrier_waiter;
-			}
-			next_dc = _dispatch_workloop_pop_head(dwl, qos, dc);
-			if (unlikely(_dispatch_needs_to_return_to_kernel())) {
-				_dispatch_return_to_kernel();
-			}
-
-			_dispatch_continuation_pop_inline(dc, dic, flags, dwl);
-			qos = dwl->dwl_drained_qos;
-		} while ((dc = next_dc) && (_dispatch_queue_max_qos(dwl) <= qos));
-	}
-
-	*owned = (*owned & DISPATCH_QUEUE_ENQUEUED) +
-			DISPATCH_QUEUE_IN_BARRIER + DISPATCH_QUEUE_WIDTH_INTERVAL;
-	_dispatch_thread_frame_pop(&dtf);
-	return NULL;
-
-out_with_barrier_waiter:
-	_dispatch_thread_frame_pop(&dtf);
-	return dwl->do_targetq;
-}
-
-void
-_dispatch_workloop_invoke(dispatch_workloop_t dwl,
-		dispatch_invoke_context_t dic, dispatch_invoke_flags_t flags)
-{
-	flags &= ~(dispatch_invoke_flags_t)DISPATCH_INVOKE_REDIRECTING_DRAIN;
-	flags |= DISPATCH_INVOKE_WORKLOOP_DRAIN;
-	_dispatch_queue_class_invoke(dwl, dic, flags, 0,_dispatch_workloop_invoke2);
-}
-
-DISPATCH_ALWAYS_INLINE
-static bool
-_dispatch_workloop_probe(dispatch_workloop_t dwl)
-{
-	dispatch_qos_t qos;
-	for (qos = DISPATCH_QOS_MAX; qos >= DISPATCH_QOS_MIN; qos--) {
-		if (!_dispatch_workloop_looks_empty(dwl, qos)) return true;
-	}
-	return false;
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_workloop_drain_barrier_waiter(dispatch_workloop_t dwl,
-		struct dispatch_object_s *dc, dispatch_qos_t qos,
-		dispatch_wakeup_flags_t flags, uint64_t enqueued_bits)
-{
-	dispatch_sync_context_t dsc = (dispatch_sync_context_t)dc;
-	uint64_t next_owner = 0, old_state, new_state;
-	bool has_more_work;
-
-	next_owner = _dispatch_lock_value_from_tid(dsc->dsc_waiter);
-	has_more_work = (_dispatch_workloop_pop_head(dwl, qos, dc) != NULL);
-
-transfer_lock_again:
-	if (!has_more_work) {
-		has_more_work = _dispatch_workloop_probe(dwl);
-	}
-
-	os_atomic_rmw_loop2o(dwl, dq_state, old_state, new_state, release, {
-		new_state  = old_state;
-		new_state &= ~DISPATCH_QUEUE_DRAIN_UNLOCK_MASK;
-		new_state &= ~DISPATCH_QUEUE_DIRTY;
-		new_state |= next_owner;
-
-		if (likely(_dq_state_is_base_wlh(old_state))) {
-			new_state |= DISPATCH_QUEUE_SYNC_TRANSFER;
-			if (has_more_work) {
-				// we know there's a next item, keep the enqueued bit if any
-			} else if (unlikely(_dq_state_is_dirty(old_state))) {
-				os_atomic_rmw_loop_give_up({
-					os_atomic_xor2o(dwl, dq_state, DISPATCH_QUEUE_DIRTY, acquire);
-					goto transfer_lock_again;
-				});
-			} else {
-				new_state &= ~DISPATCH_QUEUE_MAX_QOS_MASK;
-				new_state &= ~DISPATCH_QUEUE_ENQUEUED;
-			}
-		} else {
-			new_state -= enqueued_bits;
-		}
-	});
-
-	return _dispatch_barrier_waiter_redirect_or_wake(dwl, dc, flags,
-			old_state, new_state);
-}
-
-static void
-_dispatch_workloop_barrier_complete(dispatch_workloop_t dwl, dispatch_qos_t qos,
-		dispatch_wakeup_flags_t flags)
-{
-	dispatch_queue_wakeup_target_t target = DISPATCH_QUEUE_WAKEUP_NONE;
-	dispatch_qos_t wl_qos;
-
-again:
-	for (wl_qos = DISPATCH_QOS_MAX; wl_qos >= DISPATCH_QOS_MIN; wl_qos--) {
-		struct dispatch_object_s *dc;
-
-		if (_dispatch_workloop_looks_empty(dwl, wl_qos)) continue;
-		dc = _dispatch_workloop_get_head(dwl, wl_qos);
-
-		if (_dispatch_object_is_waiter(dc)) {
-			return _dispatch_workloop_drain_barrier_waiter(dwl, dc, wl_qos,
-					flags, 0);
-		}
-
-		// We have work to do, we need to wake up
-		target = DISPATCH_QUEUE_WAKEUP_TARGET;
-	}
-
-	if (unlikely(target && !(flags & DISPATCH_WAKEUP_CONSUME_2))) {
-		_dispatch_retain_2(dwl);
-		flags |= DISPATCH_WAKEUP_CONSUME_2;
-	}
-
-	uint64_t old_state, new_state;
-
-	os_atomic_rmw_loop2o(dwl, dq_state, old_state, new_state, release, {
-		new_state  = _dq_state_merge_qos(old_state, qos);
-		new_state -= DISPATCH_QUEUE_IN_BARRIER;
-		new_state -= DISPATCH_QUEUE_WIDTH_INTERVAL;
-		new_state &= ~DISPATCH_QUEUE_DRAIN_UNLOCK_MASK;
-		if (target) {
-			new_state |= DISPATCH_QUEUE_ENQUEUED;
-		} else if (unlikely(_dq_state_is_dirty(old_state))) {
-			os_atomic_rmw_loop_give_up({
-				// just renew the drain lock with an acquire barrier, to see
-				// what the enqueuer that set DIRTY has done.
-				// the xor generates better assembly as DISPATCH_QUEUE_DIRTY
-				// is already in a register
-				os_atomic_xor2o(dwl, dq_state, DISPATCH_QUEUE_DIRTY, acquire);
-				goto again;
-			});
-		} else if (likely(_dq_state_is_base_wlh(old_state))) {
-			new_state &= ~DISPATCH_QUEUE_MAX_QOS_MASK;
-			new_state &= ~DISPATCH_QUEUE_ENQUEUED;
-		} else {
-			new_state &= ~DISPATCH_QUEUE_MAX_QOS_MASK;
-		}
-	});
-	dispatch_assert(_dq_state_drain_locked_by_self(old_state));
-	dispatch_assert(!_dq_state_is_enqueued_on_manager(old_state));
-
-	if (_dq_state_is_enqueued(new_state)) {
-		_dispatch_trace_runtime_event(sync_async_handoff, dwl, 0);
-	}
-
-#if DISPATCH_USE_KEVENT_WORKLOOP
-	if (_dq_state_is_base_wlh(old_state)) {
-		// - Only non-"du_is_direct" sources & mach channels can be enqueued
-		//   on the manager.
-		//
-		// - Only dispatch_source_cancel_and_wait() and
-		//   dispatch_source_set_*_handler() use the barrier complete codepath,
-		//   none of which are used by mach channels.
-		//
-		// Hence no source-ish object can both be a workloop and need to use the
-		// manager at the same time.
-		dispatch_assert(!_dq_state_is_enqueued_on_manager(new_state));
-		if (_dq_state_is_enqueued_on_target(old_state) ||
-				_dq_state_is_enqueued_on_target(new_state) ||
-				_dq_state_received_sync_wait(old_state) ||
-				_dq_state_in_sync_transfer(old_state)) {
-			return _dispatch_event_loop_end_ownership((dispatch_wlh_t)dwl,
-					old_state, new_state, flags);
-		}
-		_dispatch_event_loop_assert_not_owned((dispatch_wlh_t)dwl);
-		goto done;
-	}
-#endif
-
-	if (_dq_state_received_override(old_state)) {
-		// Ensure that the root queue sees that this thread was overridden.
-		_dispatch_set_basepri_override_qos(_dq_state_max_qos(old_state));
-	}
-
-	if (target) {
-		if (likely((old_state ^ new_state) & DISPATCH_QUEUE_ENQUEUED)) {
-			dispatch_assert(_dq_state_is_enqueued(new_state));
-			dispatch_assert(flags & DISPATCH_WAKEUP_CONSUME_2);
-			return _dispatch_queue_push_queue(dwl->do_targetq, dwl, new_state);
-		}
-#if HAVE_PTHREAD_WORKQUEUE_QOS
-		// <rdar://problem/27694093> when doing sync to async handoff
-		// if the queue received an override we have to forecefully redrive
-		// the same override so that a new stealer is enqueued because
-		// the previous one may be gone already
-		if (_dq_state_should_override(new_state)) {
-			return _dispatch_queue_wakeup_with_override(dwl, new_state, flags);
-		}
-#endif
-	}
-
-#if DISPATCH_USE_KEVENT_WORKLOOP
-done:
-#endif
-	if (flags & DISPATCH_WAKEUP_CONSUME_2) {
-		return _dispatch_release_2_tailcall(dwl);
-	}
-}
-
-#if HAVE_PTHREAD_WORKQUEUE_QOS
-static void
-_dispatch_workloop_stealer_invoke(dispatch_continuation_t dc,
-		dispatch_invoke_context_t dic, dispatch_invoke_flags_t flags)
-{
-	uintptr_t dc_flags = DC_FLAG_CONSUME | DC_FLAG_NO_INTROSPECTION;
-	_dispatch_continuation_pop_forwarded(dc, dc_flags, NULL, {
-		dispatch_queue_t dq = dc->dc_data;
-		dx_invoke(dq, dic, flags | DISPATCH_INVOKE_STEALING);
-	});
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_workloop_push_stealer(dispatch_workloop_t dwl, dispatch_queue_t dq,
-		dispatch_qos_t qos)
-{
-	dispatch_continuation_t dc = _dispatch_continuation_alloc();
-
-	dc->do_vtable = DC_VTABLE(WORKLOOP_STEALING);
-	_dispatch_retain_2(dq);
-	dc->dc_func = NULL;
-	dc->dc_ctxt = dc;
-	dc->dc_other = NULL;
-	dc->dc_data = dq;
-	dc->dc_priority = DISPATCH_NO_PRIORITY;
-	dc->dc_voucher = DISPATCH_NO_VOUCHER;
-	_dispatch_workloop_push(dwl, dc, qos);
-}
-#endif // HAVE_PTHREAD_WORKQUEUE_QOS
-
-void
-_dispatch_workloop_wakeup(dispatch_workloop_t dwl, dispatch_qos_t qos,
-		dispatch_wakeup_flags_t flags)
-{
-	if (unlikely(flags & DISPATCH_WAKEUP_BARRIER_COMPLETE)) {
-		return _dispatch_workloop_barrier_complete(dwl, qos, flags);
-	}
-
-	if (unlikely(!(flags & DISPATCH_WAKEUP_CONSUME_2))) {
-		DISPATCH_INTERNAL_CRASH(flags, "Invalid way to wake up a workloop");
-	}
-
-	if (unlikely(flags & DISPATCH_WAKEUP_BLOCK_WAIT)) {
-		goto done;
-	}
-
-	uint64_t old_state, new_state;
-
-	os_atomic_rmw_loop2o(dwl, dq_state, old_state, new_state, release, {
-		new_state = _dq_state_merge_qos(old_state, qos);
-		if (_dq_state_max_qos(new_state)) {
-			new_state |= DISPATCH_QUEUE_ENQUEUED;
-		}
-		if (flags & DISPATCH_WAKEUP_MAKE_DIRTY) {
-			new_state |= DISPATCH_QUEUE_DIRTY;
-		} else if (new_state == old_state) {
-			os_atomic_rmw_loop_give_up(goto done);
-		}
-	});
-
-	if (unlikely(_dq_state_is_suspended(old_state))) {
-#if DISPATCH_SIZEOF_PTR == 4
-		old_state >>= 32;
-#endif
-		DISPATCH_CLIENT_CRASH(old_state, "Waking up an inactive workloop");
-	}
-	if (likely((old_state ^ new_state) & DISPATCH_QUEUE_ENQUEUED)) {
-		return _dispatch_queue_push_queue(dwl->do_targetq, dwl, new_state);
-	}
-#if HAVE_PTHREAD_WORKQUEUE_QOS
-	if (likely((old_state ^ new_state) & DISPATCH_QUEUE_MAX_QOS_MASK)) {
-		return _dispatch_queue_wakeup_with_override(dwl, new_state, flags);
-	}
-#endif // HAVE_PTHREAD_WORKQUEUE_QOS
-done:
-	return _dispatch_release_2_tailcall(dwl);
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_workloop_push_waiter(dispatch_workloop_t dwl,
-		dispatch_sync_context_t dsc, dispatch_qos_t qos)
-{
-	struct dispatch_object_s *prev, *dc = (struct dispatch_object_s *)dsc;
-
-	dispatch_priority_t p = _dispatch_priority_from_pp(dsc->dc_priority);
-	if (qos < _dispatch_priority_qos(p)) {
-		qos = _dispatch_priority_qos(p);
-	}
-	if (qos == DISPATCH_QOS_UNSPECIFIED) {
-		qos = DISPATCH_QOS_DEFAULT;
-	}
-
-	prev = _dispatch_workloop_push_update_tail(dwl, qos, dc);
-	_dispatch_workloop_push_update_prev(dwl, qos, prev, dc);
-	if (likely(!os_mpsc_push_was_empty(prev))) return;
-
-	uint64_t set_owner_and_set_full_width_and_in_barrier =
-			_dispatch_lock_value_for_self() |
-			DISPATCH_QUEUE_WIDTH_FULL_BIT | DISPATCH_QUEUE_IN_BARRIER;
-	uint64_t old_state, new_state;
-
-	os_atomic_rmw_loop2o(dwl, dq_state, old_state, new_state, release, {
-		new_state  = _dq_state_merge_qos(old_state, qos);
-		new_state |= DISPATCH_QUEUE_DIRTY;
-		if (unlikely(_dq_state_drain_locked(old_state))) {
-			// not runnable, so we should just handle overrides
-		} else if (_dq_state_is_enqueued(old_state)) {
-			// 32123779 let the event thread redrive since it's out already
-		} else {
-			// see _dispatch_queue_drain_try_lock
-			new_state &= DISPATCH_QUEUE_DRAIN_PRESERVED_BITS_MASK;
-			new_state |= set_owner_and_set_full_width_and_in_barrier;
-		}
-	});
-
-	dsc->dsc_wlh_was_first = (dsc->dsc_waiter == _dispatch_tid_self());
-
-	if ((old_state ^ new_state) & DISPATCH_QUEUE_IN_BARRIER) {
-		return _dispatch_workloop_barrier_complete(dwl, qos, 0);
-	}
-#if HAVE_PTHREAD_WORKQUEUE_QOS
-	if (unlikely((old_state ^ new_state) & DISPATCH_QUEUE_MAX_QOS_MASK)) {
-		if (_dq_state_should_override(new_state)) {
-			return _dispatch_queue_wakeup_with_override(dwl, new_state, 0);
-		}
-	}
-#endif // HAVE_PTHREAD_WORKQUEUE_QOS
-}
-
-void
-_dispatch_workloop_push(dispatch_workloop_t dwl, dispatch_object_t dou,
-		dispatch_qos_t qos)
-{
-	struct dispatch_object_s *prev;
-
-	if (unlikely(_dispatch_object_is_waiter(dou))) {
-		return _dispatch_workloop_push_waiter(dwl, dou._dsc, qos);
-	}
-
-	if (qos < _dispatch_priority_qos(dwl->dq_priority)) {
-		qos = _dispatch_priority_qos(dwl->dq_priority);
-	}
-	if (qos == DISPATCH_QOS_UNSPECIFIED) {
-		qos = _dispatch_priority_fallback_qos(dwl->dq_priority);
-	}
-	prev = _dispatch_workloop_push_update_tail(dwl, qos, dou._do);
-	if (unlikely(os_mpsc_push_was_empty(prev))) {
-		_dispatch_retain_2_unsafe(dwl);
-	}
-	_dispatch_workloop_push_update_prev(dwl, qos, prev, dou._do);
-	if (unlikely(os_mpsc_push_was_empty(prev))) {
-		return _dispatch_workloop_wakeup(dwl, qos, DISPATCH_WAKEUP_CONSUME_2 |
-				DISPATCH_WAKEUP_MAKE_DIRTY);
-	}
-}
-
-#pragma mark -
-#pragma mark dispatch queue/lane push & wakeup
-
-#if HAVE_PTHREAD_WORKQUEUE_QOS
-static void
-_dispatch_queue_override_invoke(dispatch_continuation_t dc,
-		dispatch_invoke_context_t dic, dispatch_invoke_flags_t flags)
-{
-	dispatch_queue_t old_rq = _dispatch_queue_get_current();
-	dispatch_queue_global_t assumed_rq = dc->dc_other;
-	dispatch_priority_t old_dp;
-	dispatch_object_t dou;
-	uintptr_t dc_flags = DC_FLAG_CONSUME;
-
-	dou._do = dc->dc_data;
-	old_dp = _dispatch_root_queue_identity_assume(assumed_rq);
-	if (dc_type(dc) == DISPATCH_CONTINUATION_TYPE(OVERRIDE_STEALING)) {
-		flags |= DISPATCH_INVOKE_STEALING;
-		dc_flags |= DC_FLAG_NO_INTROSPECTION;
-	}
-	_dispatch_continuation_pop_forwarded(dc, dc_flags, assumed_rq, {
-		if (_dispatch_object_has_vtable(dou._do)) {
-			dx_invoke(dou._dq, dic, flags);
-		} else {
-			_dispatch_continuation_invoke_inline(dou, flags, assumed_rq);
-		}
-	});
-	_dispatch_reset_basepri(old_dp);
-	_dispatch_queue_set_current(old_rq);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dispatch_root_queue_push_needs_override(dispatch_queue_global_t rq,
-		dispatch_qos_t qos)
-{
-	dispatch_qos_t fallback = _dispatch_priority_fallback_qos(rq->dq_priority);
-	if (fallback) {
-		return qos && qos != fallback;
-	}
-
-	dispatch_qos_t rqos = _dispatch_priority_qos(rq->dq_priority);
-	return rqos && qos > rqos;
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_root_queue_push_override(dispatch_queue_global_t orig_rq,
-		dispatch_object_t dou, dispatch_qos_t qos)
-{
-	bool overcommit = orig_rq->dq_priority & DISPATCH_PRIORITY_FLAG_OVERCOMMIT;
-	dispatch_queue_global_t rq = _dispatch_get_root_queue(qos, overcommit);
-	dispatch_continuation_t dc = dou._dc;
-
-	if (_dispatch_object_is_redirection(dc)) {
-		// no double-wrap is needed, _dispatch_async_redirect_invoke will do
-		// the right thing
-		dc->dc_func = (void *)orig_rq;
-	} else {
-		dc = _dispatch_continuation_alloc();
-		dc->do_vtable = DC_VTABLE(OVERRIDE_OWNING);
-		dc->dc_ctxt = dc;
-		dc->dc_other = orig_rq;
-		dc->dc_data = dou._do;
-		dc->dc_priority = DISPATCH_NO_PRIORITY;
-		dc->dc_voucher = DISPATCH_NO_VOUCHER;
-	}
-	_dispatch_root_queue_push_inline(rq, dc, dc, 1);
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_root_queue_push_override_stealer(dispatch_queue_global_t orig_rq,
-		dispatch_queue_t dq, dispatch_qos_t qos)
-{
-	bool overcommit = orig_rq->dq_priority & DISPATCH_PRIORITY_FLAG_OVERCOMMIT;
-	dispatch_queue_global_t rq = _dispatch_get_root_queue(qos, overcommit);
-	dispatch_continuation_t dc = _dispatch_continuation_alloc();
-
-	dc->do_vtable = DC_VTABLE(OVERRIDE_STEALING);
-	_dispatch_retain_2(dq);
-	dc->dc_func = NULL;
-	dc->dc_ctxt = dc;
-	dc->dc_other = orig_rq;
-	dc->dc_data = dq;
-	dc->dc_priority = DISPATCH_NO_PRIORITY;
-	dc->dc_voucher = DISPATCH_NO_VOUCHER;
-	_dispatch_root_queue_push_inline(rq, dc, dc, 1);
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_queue_wakeup_with_override_slow(dispatch_queue_t dq,
-		uint64_t dq_state, dispatch_wakeup_flags_t flags)
-{
-	dispatch_qos_t oqos, qos = _dq_state_max_qos(dq_state);
-	dispatch_queue_t tq = dq->do_targetq;
-	mach_port_t owner;
-	bool locked;
-
-	if (_dq_state_is_base_anon(dq_state)) {
-		if (!_dispatch_is_in_root_queues_array(tq)) {
-			// <rdar://problem/40320044> Do not try to override pthread root
-			// queues, it isn't supported and can cause things to run
-			// on the wrong hierarchy if we enqueue a stealer by accident
-			goto out;
-		} else if ((owner = _dq_state_drain_owner(dq_state))) {
-			(void)_dispatch_wqthread_override_start_check_owner(owner, qos,
-					&dq->dq_state_lock);
-			goto out;
-		}
-
-		// avoid locking when we recognize the target queue as a global root
-		// queue it is gross, but is a very common case. The locking isn't
-		// needed because these target queues cannot go away.
-		locked = false;
-	} else if (likely(!_dispatch_queue_is_mutable(dq))) {
-		locked = false;
-	} else if (_dispatch_queue_sidelock_trylock(upcast(dq)._dl, qos)) {
-		// <rdar://problem/17735825> to traverse the tq chain safely we must
-		// lock it to ensure it cannot change
-		locked = true;
-		tq = dq->do_targetq;
-		_dispatch_ktrace1(DISPATCH_PERF_mutable_target, dq);
-	} else {
-		//
-		// Leading to being there, the current thread has:
-		// 1. enqueued an object on `dq`
-		// 2. raised the max_qos value, set RECEIVED_OVERRIDE on `dq`
-		//    and didn't see an owner
-		// 3. tried and failed to acquire the side lock
-		//
-		// The side lock owner can only be one of three things:
-		//
-		// - The suspend/resume side count code. Besides being unlikely,
-		//   it means that at this moment the queue is actually suspended,
-		//   which transfers the responsibility of applying the override to
-		//   the eventual dispatch_resume().
-		//
-		// - A dispatch_set_target_queue() call. The fact that we saw no `owner`
-		//   means that the trysync it does wasn't being drained when (2)
-		//   happened which can only be explained by one of these interleavings:
-		//
-		//    o `dq` became idle between when the object queued in (1) ran and
-		//      the set_target_queue call and we were unlucky enough that our
-		//      step (2) happened while this queue was idle. There is no reason
-		//		to override anything anymore, the queue drained to completion
-		//      while we were preempted, our job is done.
-		//
-		//    o `dq` is queued but not draining during (1-2), then when we try
-		//      to lock at (3) the queue is now draining a set_target_queue.
-		//      This drainer must have seen the effects of (2) and that guy has
-		//      applied our override. Our job is done.
-		//
-		// - Another instance of _dispatch_queue_wakeup_with_override_slow(),
-		//   which is fine because trylock leaves a hint that we failed our
-		//   trylock, causing the tryunlock below to fail and reassess whether
-		//   a better override needs to be applied.
-		//
-		_dispatch_ktrace1(DISPATCH_PERF_mutable_target, dq);
-		goto out;
-	}
-
-apply_again:
-	if (dx_hastypeflag(tq, QUEUE_ROOT)) {
-		dispatch_queue_global_t rq = upcast(tq)._dgq;
-		if (qos > _dispatch_priority_qos(rq->dq_priority)) {
-			_dispatch_root_queue_push_override_stealer(rq, dq, qos);
-		}
-	} else if (dx_metatype(tq) == _DISPATCH_WORKLOOP_TYPE) {
-		_dispatch_workloop_push_stealer(upcast(tq)._dwl, dq, qos);
-	} else if (_dispatch_queue_need_override(tq, qos)) {
-		dx_wakeup(tq, qos, 0);
-	}
-	if (likely(!locked)) {
-		goto out;
-	}
-	while (unlikely(!_dispatch_queue_sidelock_tryunlock(upcast(dq)._dl))) {
-		// rdar://problem/24081326
-		//
-		// Another instance of _dispatch_queue_wakeup_with_override() tried
-		// to acquire the side lock while we were running, and could have
-		// had a better override than ours to apply.
-		//
-		oqos = _dispatch_queue_max_qos(dq);
-		if (oqos > qos) {
-			qos = oqos;
-			// The other instance had a better priority than ours, override
-			// our thread, and apply the override that wasn't applied to `dq`
-			// because of us.
-			goto apply_again;
-		}
-	}
-
-out:
-	if (flags & DISPATCH_WAKEUP_CONSUME_2) {
-		return _dispatch_release_2_tailcall(dq);
-	}
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_queue_wakeup_with_override(dispatch_queue_class_t dq,
-		uint64_t dq_state, dispatch_wakeup_flags_t flags)
-{
-	dispatch_assert(_dq_state_should_override(dq_state));
-
-#if DISPATCH_USE_KEVENT_WORKLOOP
-	if (likely(_dq_state_is_base_wlh(dq_state))) {
-		_dispatch_trace_runtime_event(worker_request, dq._dq, 1);
-		return _dispatch_event_loop_poke((dispatch_wlh_t)dq._dq, dq_state,
-				flags | DISPATCH_EVENT_LOOP_OVERRIDE);
-	}
-#endif // DISPATCH_USE_KEVENT_WORKLOOP
-	return _dispatch_queue_wakeup_with_override_slow(dq._dq, dq_state, flags);
-}
-#endif // HAVE_PTHREAD_WORKQUEUE_QOS
-
-DISPATCH_NOINLINE
-void
-_dispatch_queue_wakeup(dispatch_queue_class_t dqu, dispatch_qos_t qos,
-		dispatch_wakeup_flags_t flags, dispatch_queue_wakeup_target_t target)
-{
-	dispatch_queue_t dq = dqu._dq;
-	dispatch_assert(target != DISPATCH_QUEUE_WAKEUP_WAIT_FOR_EVENT);
-
-	if (target && !(flags & DISPATCH_WAKEUP_CONSUME_2)) {
-		_dispatch_retain_2(dq);
-		flags |= DISPATCH_WAKEUP_CONSUME_2;
-	}
-
-	if (unlikely(flags & DISPATCH_WAKEUP_BARRIER_COMPLETE)) {
-		//
-		// _dispatch_lane_class_barrier_complete() is about what both regular
-		// queues and sources needs to evaluate, but the former can have sync
-		// handoffs to perform which _dispatch_lane_class_barrier_complete()
-		// doesn't handle, only _dispatch_lane_barrier_complete() does.
-		//
-		// _dispatch_lane_wakeup() is the one for plain queues that calls
-		// _dispatch_lane_barrier_complete(), and this is only taken for non
-		// queue types.
-		//
-		dispatch_assert(dx_metatype(dq) == _DISPATCH_SOURCE_TYPE);
-		qos = _dispatch_queue_wakeup_qos(dq, qos);
-		return _dispatch_lane_class_barrier_complete(upcast(dq)._dl, qos,
-				flags, target, DISPATCH_QUEUE_SERIAL_DRAIN_OWNED);
-	}
-
-	if (target) {
-		uint64_t old_state, new_state, enqueue = DISPATCH_QUEUE_ENQUEUED;
-		if (target == DISPATCH_QUEUE_WAKEUP_MGR) {
-			enqueue = DISPATCH_QUEUE_ENQUEUED_ON_MGR;
-		}
-		qos = _dispatch_queue_wakeup_qos(dq, qos);
-		os_atomic_rmw_loop2o(dq, dq_state, old_state, new_state, release, {
-			new_state = _dq_state_merge_qos(old_state, qos);
-			if (likely(!_dq_state_is_suspended(old_state) &&
-					!_dq_state_is_enqueued(old_state) &&
-					(!_dq_state_drain_locked(old_state) ||
-					(enqueue != DISPATCH_QUEUE_ENQUEUED_ON_MGR &&
-					_dq_state_is_base_wlh(old_state))))) {
-				new_state |= enqueue;
-			}
-			if (flags & DISPATCH_WAKEUP_MAKE_DIRTY) {
-				new_state |= DISPATCH_QUEUE_DIRTY;
-			} else if (new_state == old_state) {
-				os_atomic_rmw_loop_give_up(goto done);
-			}
-		});
-
-		if (likely((old_state ^ new_state) & enqueue)) {
-			dispatch_queue_t tq;
-			if (target == DISPATCH_QUEUE_WAKEUP_TARGET) {
-				// the rmw_loop above has no acquire barrier, as the last block
-				// of a queue asyncing to that queue is not an uncommon pattern
-				// and in that case the acquire would be completely useless
-				//
-				// so instead use depdendency ordering to read
-				// the targetq pointer.
-				os_atomic_thread_fence(dependency);
-				tq = os_atomic_load_with_dependency_on2o(dq, do_targetq,
-						(long)new_state);
-			} else {
-				tq = target;
-			}
-			dispatch_assert(_dq_state_is_enqueued(new_state));
-			return _dispatch_queue_push_queue(tq, dq, new_state);
-		}
-#if HAVE_PTHREAD_WORKQUEUE_QOS
-		if (unlikely((old_state ^ new_state) & DISPATCH_QUEUE_MAX_QOS_MASK)) {
-			if (_dq_state_should_override(new_state)) {
-				return _dispatch_queue_wakeup_with_override(dq, new_state,
-						flags);
-			}
-		}
-	} else if (qos) {
-		//
-		// Someone is trying to override the last work item of the queue.
-		//
-		uint64_t old_state, new_state;
-		os_atomic_rmw_loop2o(dq, dq_state, old_state, new_state, relaxed, {
-			if (!_dq_state_drain_locked(old_state) ||
-					!_dq_state_is_enqueued(old_state)) {
-				os_atomic_rmw_loop_give_up(goto done);
-			}
-			new_state = _dq_state_merge_qos(old_state, qos);
-			if (new_state == old_state) {
-				os_atomic_rmw_loop_give_up(goto done);
-			}
-		});
-		if (_dq_state_should_override(new_state)) {
-			return _dispatch_queue_wakeup_with_override(dq, new_state, flags);
-		}
-#endif // HAVE_PTHREAD_WORKQUEUE_QOS
-	}
-done:
-	if (likely(flags & DISPATCH_WAKEUP_CONSUME_2)) {
-		return _dispatch_release_2_tailcall(dq);
-	}
-}
-
-DISPATCH_NOINLINE
-void
-_dispatch_lane_wakeup(dispatch_lane_class_t dqu, dispatch_qos_t qos,
-		dispatch_wakeup_flags_t flags)
-{
-	dispatch_queue_wakeup_target_t target = DISPATCH_QUEUE_WAKEUP_NONE;
-
-	if (unlikely(flags & DISPATCH_WAKEUP_BARRIER_COMPLETE)) {
-		return _dispatch_lane_barrier_complete(dqu, qos, flags);
-	}
-	if (_dispatch_queue_class_probe(dqu)) {
-		target = DISPATCH_QUEUE_WAKEUP_TARGET;
-	}
-	return _dispatch_queue_wakeup(dqu, qos, flags, target);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dispatch_lane_push_waiter_should_wakeup(dispatch_lane_t dq,
-		dispatch_sync_context_t dsc)
-{
-	if (_dispatch_queue_is_thread_bound(dq)) {
-		return true;
-	}
-	if (dsc->dc_flags & DC_FLAG_ASYNC_AND_WAIT) {
-		uint64_t dq_state = os_atomic_load2o(dq, dq_state, relaxed);
-		return _dispatch_async_and_wait_should_always_async(dq, dq_state);
-	}
-	return false;
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_lane_push_waiter(dispatch_lane_t dq, dispatch_sync_context_t dsc,
-		dispatch_qos_t qos)
-{
-	uint64_t old_state, new_state;
-
-	if (dsc->dc_data != DISPATCH_WLH_ANON) {
-		// The kernel will handle all the overrides / priorities on our behalf.
-		qos = 0;
-	}
-
-	if (unlikely(_dispatch_queue_push_item(dq, dsc))) {
-		if (unlikely(_dispatch_lane_push_waiter_should_wakeup(dq, dsc))) {
-			return dx_wakeup(dq, qos, DISPATCH_WAKEUP_MAKE_DIRTY);
-		}
-
-		uint64_t pending_barrier_width =
-				(dq->dq_width - 1) * DISPATCH_QUEUE_WIDTH_INTERVAL;
-		uint64_t set_owner_and_set_full_width_and_in_barrier =
-				_dispatch_lock_value_for_self() |
-				DISPATCH_QUEUE_WIDTH_FULL_BIT | DISPATCH_QUEUE_IN_BARRIER;
-		os_atomic_rmw_loop2o(dq, dq_state, old_state, new_state, release, {
-			new_state  = _dq_state_merge_qos(old_state, qos);
-			new_state |= DISPATCH_QUEUE_DIRTY;
-			if (unlikely(_dq_state_drain_locked(old_state) ||
-					!_dq_state_is_runnable(old_state))) {
-				// not runnable, so we should just handle overrides
-			} else if (_dq_state_is_base_wlh(old_state) &&
-					_dq_state_is_enqueued(old_state)) {
-				// 32123779 let the event thread redrive since it's out already
-			} else if (_dq_state_has_pending_barrier(old_state) ||
-					new_state + pending_barrier_width <
-					DISPATCH_QUEUE_WIDTH_FULL_BIT) {
-				// see _dispatch_queue_drain_try_lock
-				new_state &= DISPATCH_QUEUE_DRAIN_PRESERVED_BITS_MASK;
-				new_state |= set_owner_and_set_full_width_and_in_barrier;
-			}
-		});
-
-		if (_dq_state_is_base_wlh(old_state)) {
-			dsc->dsc_wlh_was_first = (dsc->dsc_waiter == _dispatch_tid_self());
-		}
-
-		if ((old_state ^ new_state) & DISPATCH_QUEUE_IN_BARRIER) {
-			return _dispatch_lane_barrier_complete(dq, qos, 0);
-		}
-#if HAVE_PTHREAD_WORKQUEUE_QOS
-		if (unlikely((old_state ^ new_state) & DISPATCH_QUEUE_MAX_QOS_MASK)) {
-			if (_dq_state_should_override(new_state)) {
-				return _dispatch_queue_wakeup_with_override(dq, new_state, 0);
-			}
-		}
-	} else if (unlikely(qos)) {
-		os_atomic_rmw_loop2o(dq, dq_state, old_state, new_state, relaxed, {
-			new_state = _dq_state_merge_qos(old_state, qos);
-			if (old_state == new_state) {
-				os_atomic_rmw_loop_give_up(return);
-			}
-		});
-		if (_dq_state_should_override(new_state)) {
-			return _dispatch_queue_wakeup_with_override(dq, new_state, 0);
-		}
-#endif // HAVE_PTHREAD_WORKQUEUE_QOS
-	}
-}
-
-DISPATCH_NOINLINE
-void
-_dispatch_lane_push(dispatch_lane_t dq, dispatch_object_t dou,
-		dispatch_qos_t qos)
-{
-	dispatch_wakeup_flags_t flags = 0;
-	struct dispatch_object_s *prev;
-
-	if (unlikely(_dispatch_object_is_waiter(dou))) {
-		return _dispatch_lane_push_waiter(dq, dou._dsc, qos);
-	}
-
-	dispatch_assert(!_dispatch_object_is_global(dq));
-	qos = _dispatch_queue_push_qos(dq, qos);
-
-	// If we are going to call dx_wakeup(), the queue must be retained before
-	// the item we're pushing can be dequeued, which means:
-	// - before we exchange the tail if we have to override
-	// - before we set the head if we made the queue non empty.
-	// Otherwise, if preempted between one of these and the call to dx_wakeup()
-	// the blocks submitted to the queue may release the last reference to the
-	// queue when invoked by _dispatch_lane_drain. <rdar://problem/6932776>
-
-	prev = os_mpsc_push_update_tail(os_mpsc(dq, dq_items), dou._do, do_next);
-	if (unlikely(os_mpsc_push_was_empty(prev))) {
-		_dispatch_retain_2_unsafe(dq);
-		flags = DISPATCH_WAKEUP_CONSUME_2 | DISPATCH_WAKEUP_MAKE_DIRTY;
-	} else if (unlikely(_dispatch_queue_need_override(dq, qos))) {
-		// There's a race here, _dispatch_queue_need_override may read a stale
-		// dq_state value.
-		//
-		// If it's a stale load from the same drain streak, given that
-		// the max qos is monotonic, too old a read can only cause an
-		// unnecessary attempt at overriding which is harmless.
-		//
-		// We'll assume here that a stale load from an a previous drain streak
-		// never happens in practice.
-		_dispatch_retain_2_unsafe(dq);
-		flags = DISPATCH_WAKEUP_CONSUME_2;
-	}
-	os_mpsc_push_update_prev(os_mpsc(dq, dq_items), prev, dou._do, do_next);
-	if (flags) {
-		return dx_wakeup(dq, qos, flags);
-	}
-}
-
-DISPATCH_NOINLINE
-void
-_dispatch_lane_concurrent_push(dispatch_lane_t dq, dispatch_object_t dou,
-		dispatch_qos_t qos)
-{
-	// <rdar://problem/24738102&24743140> reserving non barrier width
-	// doesn't fail if only the ENQUEUED bit is set (unlike its barrier
-	// width equivalent), so we have to check that this thread hasn't
-	// enqueued anything ahead of this call or we can break ordering
-	if (dq->dq_items_tail == NULL &&
-			!_dispatch_object_is_waiter(dou) &&
-			!_dispatch_object_is_barrier(dou) &&
-			_dispatch_queue_try_acquire_async(dq)) {
-		return _dispatch_continuation_redirect_push(dq, dou, qos);
-	}
-
-	_dispatch_lane_push(dq, dou, qos);
-}
-
-#pragma mark -
-#pragma mark dispatch_mgr_queue
-
-#if DISPATCH_USE_PTHREAD_ROOT_QUEUES || DISPATCH_USE_KEVENT_WORKQUEUE
-struct _dispatch_mgr_sched_s {
-	volatile int prio;
-	volatile qos_class_t qos;
-	int default_prio;
-	int policy;
-#if defined(_WIN32)
-	HANDLE hThread;
-#else
-	pthread_t tid;
-#endif
-};
-
-DISPATCH_STATIC_GLOBAL(struct _dispatch_mgr_sched_s _dispatch_mgr_sched);
-DISPATCH_STATIC_GLOBAL(dispatch_once_t _dispatch_mgr_sched_pred);
-
-#if HAVE_PTHREAD_WORKQUEUE_QOS
-// TODO: switch to "event-reflector thread" property <rdar://problem/18126138>
-// Must be kept in sync with list of qos classes in sys/qos.h
-static int
-_dispatch_mgr_sched_qos2prio(qos_class_t qos)
-{
-	switch (qos) {
-	case QOS_CLASS_MAINTENANCE: return 4;
-	case QOS_CLASS_BACKGROUND: return 4;
-	case QOS_CLASS_UTILITY: return 20;
-	case QOS_CLASS_DEFAULT: return 31;
-	case QOS_CLASS_USER_INITIATED: return 37;
-	case QOS_CLASS_USER_INTERACTIVE: return 47;
-	}
-	return 0;
-}
-#endif // HAVE_PTHREAD_WORKQUEUE_QOS
-
-static void
-_dispatch_mgr_sched_init(void *ctxt DISPATCH_UNUSED)
-{
-#if !defined(_WIN32)
-	struct sched_param param;
-#if DISPATCH_USE_MGR_THREAD && DISPATCH_USE_PTHREAD_ROOT_QUEUES
-	dispatch_pthread_root_queue_context_t pqc = _dispatch_mgr_root_queue.do_ctxt;
-	pthread_attr_t *attr = &pqc->dpq_thread_attr;
-#else
-	pthread_attr_t a, *attr = &a;
-#endif
-	(void)dispatch_assume_zero(pthread_attr_init(attr));
-	(void)dispatch_assume_zero(pthread_attr_getschedpolicy(attr,
-			&_dispatch_mgr_sched.policy));
-	(void)dispatch_assume_zero(pthread_attr_getschedparam(attr, &param));
-#if HAVE_PTHREAD_WORKQUEUE_QOS
-	qos_class_t qos = qos_class_main();
-	if (qos == QOS_CLASS_DEFAULT) {
-		qos = QOS_CLASS_USER_INITIATED; // rdar://problem/17279292
-	}
-	if (qos) {
-		_dispatch_mgr_sched.qos = qos;
-		param.sched_priority = _dispatch_mgr_sched_qos2prio(qos);
-	}
-#endif
-	_dispatch_mgr_sched.default_prio = param.sched_priority;
-#else // defined(_WIN32)
-	_dispatch_mgr_sched.policy = 0;
-	_dispatch_mgr_sched.default_prio = THREAD_PRIORITY_NORMAL;
-#endif // defined(_WIN32)
-	_dispatch_mgr_sched.prio = _dispatch_mgr_sched.default_prio;
-}
-#endif // DISPATCH_USE_PTHREAD_ROOT_QUEUES || DISPATCH_USE_KEVENT_WORKQUEUE
-
-#if DISPATCH_USE_PTHREAD_ROOT_QUEUES
-#if DISPATCH_USE_MGR_THREAD
-#if !defined(_WIN32)
-DISPATCH_NOINLINE
-static pthread_t *
-_dispatch_mgr_root_queue_init(void)
-{
-	dispatch_once_f(&_dispatch_mgr_sched_pred, NULL, _dispatch_mgr_sched_init);
-	dispatch_pthread_root_queue_context_t pqc = _dispatch_mgr_root_queue.do_ctxt;
-	pthread_attr_t *attr = &pqc->dpq_thread_attr;
-	struct sched_param param;
-	(void)dispatch_assume_zero(pthread_attr_setdetachstate(attr,
-			PTHREAD_CREATE_DETACHED));
-#if !DISPATCH_DEBUG
-	(void)dispatch_assume_zero(pthread_attr_setstacksize(attr, 64 * 1024));
-#endif
-#if HAVE_PTHREAD_WORKQUEUE_QOS
-	qos_class_t qos = _dispatch_mgr_sched.qos;
-	if (qos) {
-		if (_dispatch_set_qos_class_enabled) {
-			(void)dispatch_assume_zero(pthread_attr_set_qos_class_np(attr,
-					qos, 0));
-		}
-	}
-#endif
-	param.sched_priority = _dispatch_mgr_sched.prio;
-	if (param.sched_priority > _dispatch_mgr_sched.default_prio) {
-		(void)dispatch_assume_zero(pthread_attr_setschedparam(attr, &param));
-	}
-	return &_dispatch_mgr_sched.tid;
-}
-#else // defined(_WIN32)
-DISPATCH_NOINLINE
-static PHANDLE
-_dispatch_mgr_root_queue_init(void)
-{
-	dispatch_once_f(&_dispatch_mgr_sched_pred, NULL, _dispatch_mgr_sched_init);
-	return &_dispatch_mgr_sched.hThread;
-}
-#endif // defined(_WIN32)
-
-static inline void
-_dispatch_mgr_priority_apply(void)
-{
-#if !defined(_WIN32)
-	struct sched_param param;
-	do {
-		param.sched_priority = _dispatch_mgr_sched.prio;
-		if (param.sched_priority > _dispatch_mgr_sched.default_prio) {
-			(void)dispatch_assume_zero(pthread_setschedparam(
-					_dispatch_mgr_sched.tid, _dispatch_mgr_sched.policy,
-					&param));
-		}
-	} while (_dispatch_mgr_sched.prio > param.sched_priority);
-#else // defined(_WIN32)
-	int nPriority = _dispatch_mgr_sched.prio;
-	do {
-		if (nPriority > _dispatch_mgr_sched.default_prio) {
-			// TODO(compnerd) set thread scheduling policy
-			dispatch_assume_zero(SetThreadPriority(_dispatch_mgr_sched.hThread, nPriority));
-			nPriority = GetThreadPriority(_dispatch_mgr_sched.hThread);
-		}
-	} while (_dispatch_mgr_sched.prio > nPriority);
-#endif // defined(_WIN32)
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_mgr_priority_init(void)
-{
-#if !defined(_WIN32)
-	dispatch_pthread_root_queue_context_t pqc = _dispatch_mgr_root_queue.do_ctxt;
-	pthread_attr_t *attr = &pqc->dpq_thread_attr;
-	struct sched_param param;
-	(void)dispatch_assume_zero(pthread_attr_getschedparam(attr, &param));
-#if HAVE_PTHREAD_WORKQUEUE_QOS
-	qos_class_t qos = 0;
-	(void)pthread_attr_get_qos_class_np(attr, &qos, NULL);
-	if (_dispatch_mgr_sched.qos > qos && _dispatch_set_qos_class_enabled) {
-		(void)pthread_set_qos_class_self_np(_dispatch_mgr_sched.qos, 0);
-		int p = _dispatch_mgr_sched_qos2prio(_dispatch_mgr_sched.qos);
-		if (p > param.sched_priority) {
-			param.sched_priority = p;
-		}
-	}
-#endif
-	if (unlikely(_dispatch_mgr_sched.prio > param.sched_priority)) {
-		return _dispatch_mgr_priority_apply();
-	}
-#else // defined(_WIN32)
-	int nPriority = GetThreadPriority(_dispatch_mgr_sched.hThread);
-	if (slowpath(_dispatch_mgr_sched.prio > nPriority)) {
-		return _dispatch_mgr_priority_apply();
-	}
-#endif // defined(_WIN32)
-}
-#endif // DISPATCH_USE_MGR_THREAD
-
-#if !defined(_WIN32)
-DISPATCH_NOINLINE
-static void
-_dispatch_mgr_priority_raise(const pthread_attr_t *attr)
-{
-	dispatch_once_f(&_dispatch_mgr_sched_pred, NULL, _dispatch_mgr_sched_init);
-	struct sched_param param;
-	(void)dispatch_assume_zero(pthread_attr_getschedparam(attr, &param));
-#if HAVE_PTHREAD_WORKQUEUE_QOS
-	qos_class_t q, qos = 0;
-	(void)pthread_attr_get_qos_class_np((pthread_attr_t *)attr, &qos, NULL);
-	if (qos) {
-		param.sched_priority = _dispatch_mgr_sched_qos2prio(qos);
-		os_atomic_rmw_loop2o(&_dispatch_mgr_sched, qos, q, qos, relaxed, {
-			if (q >= qos) os_atomic_rmw_loop_give_up(break);
-		});
-	}
-#endif
-	int p, prio = param.sched_priority;
-	os_atomic_rmw_loop2o(&_dispatch_mgr_sched, prio, p, prio, relaxed, {
-		if (p >= prio) os_atomic_rmw_loop_give_up(return);
-	});
-#if DISPATCH_USE_KEVENT_WORKQUEUE
-	_dispatch_root_queues_init();
-	if (_dispatch_kevent_workqueue_enabled) {
-		pthread_priority_t pp = 0;
-		if (prio > _dispatch_mgr_sched.default_prio) {
-			// The values of _PTHREAD_PRIORITY_SCHED_PRI_FLAG and
-			// _PTHREAD_PRIORITY_ROOTQUEUE_FLAG overlap, but that is not
-			// problematic in this case, since it the second one is only ever
-			// used on dq_priority fields.
-			// We never pass the _PTHREAD_PRIORITY_ROOTQUEUE_FLAG to a syscall,
-			// it is meaningful to libdispatch only.
-			pp = (pthread_priority_t)prio | _PTHREAD_PRIORITY_SCHED_PRI_FLAG;
-		} else if (qos) {
-			pp = _pthread_qos_class_encode(qos, 0, 0);
-		}
-		if (pp) {
-			int r = _pthread_workqueue_set_event_manager_priority(pp);
-			(void)dispatch_assume_zero(r);
-		}
-		return;
-	}
-#endif
-#if DISPATCH_USE_MGR_THREAD
-	if (_dispatch_mgr_sched.tid) {
-		return _dispatch_mgr_priority_apply();
-	}
-#endif
-}
-#endif // !defined(_WIN32)
-#endif // DISPATCH_USE_PTHREAD_ROOT_QUEUES
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_queue_mgr_lock(struct dispatch_queue_static_s *dq)
-{
-	uint64_t old_state, new_state, set_owner_and_set_full_width =
-			_dispatch_lock_value_for_self() | DISPATCH_QUEUE_SERIAL_DRAIN_OWNED;
-
-	os_atomic_rmw_loop2o(dq, dq_state, old_state, new_state, acquire, {
-		new_state = old_state;
-		if (unlikely(!_dq_state_is_runnable(old_state) ||
-				_dq_state_drain_locked(old_state))) {
-			DISPATCH_INTERNAL_CRASH((uintptr_t)old_state,
-					"Locking the manager should not fail");
-		}
-		new_state &= DISPATCH_QUEUE_DRAIN_PRESERVED_BITS_MASK;
-		new_state |= set_owner_and_set_full_width;
-	});
-}
-
-#if DISPATCH_USE_KEVENT_WORKQUEUE
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dispatch_queue_mgr_unlock(struct dispatch_queue_static_s *dq)
-{
-	uint64_t old_state, new_state;
-	os_atomic_rmw_loop2o(dq, dq_state, old_state, new_state, release, {
-		new_state = old_state - DISPATCH_QUEUE_SERIAL_DRAIN_OWNED;
-		new_state &= ~DISPATCH_QUEUE_DRAIN_UNLOCK_MASK;
-		new_state &= ~DISPATCH_QUEUE_MAX_QOS_MASK;
-	});
-	return _dq_state_is_dirty(old_state);
-}
-#endif // DISPATCH_USE_KEVENT_WORKQUEUE
-
-static void
-_dispatch_mgr_queue_drain(void)
-{
-	const dispatch_invoke_flags_t flags = DISPATCH_INVOKE_MANAGER_DRAIN;
-	dispatch_invoke_context_s dic = { };
-	struct dispatch_queue_static_s *dq = &_dispatch_mgr_q;
-	uint64_t owned = DISPATCH_QUEUE_SERIAL_DRAIN_OWNED;
-
-	if (dq->dq_items_tail) {
-		_dispatch_perfmon_start();
-		_dispatch_set_basepri_override_qos(DISPATCH_QOS_SATURATED);
-		if (unlikely(_dispatch_lane_serial_drain(dq, &dic, flags, &owned))) {
-			DISPATCH_INTERNAL_CRASH(0, "Interrupted drain on manager queue");
-		}
-		_dispatch_voucher_debug("mgr queue clear", NULL);
-		_voucher_clear();
-		_dispatch_reset_basepri_override();
-		_dispatch_perfmon_end(perfmon_thread_manager);
-	}
-
-#if DISPATCH_USE_KEVENT_WORKQUEUE
-	if (!_dispatch_kevent_workqueue_enabled)
-#endif
-	{
-		_dispatch_force_cache_cleanup();
-	}
-}
-
-void
-_dispatch_mgr_queue_push(dispatch_lane_t dq, dispatch_object_t dou,
-		DISPATCH_UNUSED dispatch_qos_t qos)
-{
-	uint64_t dq_state;
-
-	if (unlikely(_dispatch_object_is_waiter(dou))) {
-		DISPATCH_CLIENT_CRASH(0, "Waiter pushed onto manager");
-	}
-
-	if (unlikely(_dispatch_queue_push_item(dq, dou))) {
-		dq_state = os_atomic_or2o(dq, dq_state, DISPATCH_QUEUE_DIRTY, release);
-		if (!_dq_state_drain_locked_by_self(dq_state)) {
-			_dispatch_trace_runtime_event(worker_request, &_dispatch_mgr_q, 1);
-			_dispatch_event_loop_poke(DISPATCH_WLH_MANAGER, 0, 0);
-		}
-	}
-}
-
-DISPATCH_NORETURN
-void
-_dispatch_mgr_queue_wakeup(DISPATCH_UNUSED dispatch_lane_t dq,
-		DISPATCH_UNUSED dispatch_qos_t qos,
-		DISPATCH_UNUSED dispatch_wakeup_flags_t flags)
-{
-	DISPATCH_INTERNAL_CRASH(0, "Don't try to wake up or override the manager");
-}
-
-#if DISPATCH_USE_MGR_THREAD
-DISPATCH_NOINLINE DISPATCH_NORETURN
-static void
-_dispatch_mgr_invoke(void)
-{
-#if DISPATCH_EVENT_BACKEND_KEVENT
-	dispatch_kevent_s evbuf[DISPATCH_DEFERRED_ITEMS_EVENT_COUNT];
-#endif
-	dispatch_deferred_items_s ddi = {
-		.ddi_wlh = DISPATCH_WLH_ANON,
-#if DISPATCH_EVENT_BACKEND_KEVENT
-		.ddi_maxevents = DISPATCH_DEFERRED_ITEMS_EVENT_COUNT,
-		.ddi_eventlist = evbuf,
-#endif
-	};
-
-	_dispatch_deferred_items_set(&ddi);
-	for (;;) {
-		bool poll = false;
-		_dispatch_mgr_queue_drain();
-		_dispatch_event_loop_drain_anon_timers();
-		poll = _dispatch_queue_class_probe(&_dispatch_mgr_q);
-		_dispatch_event_loop_drain(poll ? KEVENT_FLAG_IMMEDIATE : 0);
-	}
-}
-
-DISPATCH_NORETURN
-void
-_dispatch_mgr_thread(dispatch_lane_t dq DISPATCH_UNUSED,
-		dispatch_invoke_context_t dic DISPATCH_UNUSED,
-		dispatch_invoke_flags_t flags DISPATCH_UNUSED)
-{
-#if DISPATCH_USE_KEVENT_WORKQUEUE
-	if (_dispatch_kevent_workqueue_enabled) {
-		DISPATCH_INTERNAL_CRASH(0, "Manager queue invoked with "
-				"kevent workqueue enabled");
-	}
-#endif
-	_dispatch_queue_set_current(&_dispatch_mgr_q);
-#if DISPATCH_USE_PTHREAD_ROOT_QUEUES
-	_dispatch_mgr_priority_init();
-#endif
-	_dispatch_queue_mgr_lock(&_dispatch_mgr_q);
-	// never returns, so burn bridges behind us & clear stack 2k ahead
-	_dispatch_clear_stack(2048);
-	_dispatch_mgr_invoke();
-}
-#endif // DISPATCH_USE_MGR_THREAD
-
-#if DISPATCH_USE_KEVENT_WORKQUEUE
-
-dispatch_static_assert(WORKQ_KEVENT_EVENT_BUFFER_LEN >=
-		DISPATCH_DEFERRED_ITEMS_EVENT_COUNT,
-		"our list should not be longer than the kernel's");
-
-static void _dispatch_root_queue_drain_deferred_item(
-		dispatch_deferred_items_t ddi DISPATCH_PERF_MON_ARGS_PROTO);
-static void _dispatch_root_queue_drain_deferred_wlh(
-		dispatch_deferred_items_t ddi DISPATCH_PERF_MON_ARGS_PROTO);
-
-void
-_dispatch_kevent_workqueue_init(void)
-{
-	// Initialize kevent workqueue support
-	_dispatch_root_queues_init();
-	if (!_dispatch_kevent_workqueue_enabled) return;
-	dispatch_once_f(&_dispatch_mgr_sched_pred, NULL, _dispatch_mgr_sched_init);
-	qos_class_t qos = _dispatch_mgr_sched.qos;
-	int prio = _dispatch_mgr_sched.prio;
-	pthread_priority_t pp = 0;
-	if (qos) {
-		pp = _pthread_qos_class_encode(qos, 0, 0);
-	}
-	if (prio > _dispatch_mgr_sched.default_prio) {
-		pp = (pthread_priority_t)prio | _PTHREAD_PRIORITY_SCHED_PRI_FLAG;
-	}
-	if (pp) {
-		int r = _pthread_workqueue_set_event_manager_priority(pp);
-		(void)dispatch_assume_zero(r);
-	}
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dispatch_wlh_worker_thread_init(dispatch_deferred_items_t ddi)
-{
-	dispatch_assert(ddi->ddi_wlh);
-
-	pthread_priority_t pp = _dispatch_get_priority();
-	if (!(pp & _PTHREAD_PRIORITY_EVENT_MANAGER_FLAG)) {
-		// If this thread does not have the event manager flag set, don't setup
-		// as the dispatch manager and let the caller know to only process
-		// the delivered events.
-		//
-		// Also add the NEEDS_UNBIND flag so that
-		// _dispatch_priority_compute_update knows it has to unbind
-		pp &= _PTHREAD_PRIORITY_OVERCOMMIT_FLAG | ~_PTHREAD_PRIORITY_FLAGS_MASK;
-		if (ddi->ddi_wlh == DISPATCH_WLH_ANON) {
-			pp |= _PTHREAD_PRIORITY_NEEDS_UNBIND_FLAG;
-		} else {
-			// pthread sets the flag when it is an event delivery thread
-			// so we need to explicitly clear it
-			pp &= ~(pthread_priority_t)_PTHREAD_PRIORITY_NEEDS_UNBIND_FLAG;
-		}
-		_dispatch_thread_setspecific(dispatch_priority_key,
-				(void *)(uintptr_t)pp);
-		if (ddi->ddi_wlh != DISPATCH_WLH_ANON) {
-			_dispatch_debug("wlh[%p]: handling events", ddi->ddi_wlh);
-		} else {
-			ddi->ddi_can_stash = true;
-		}
-		return false;
-	}
-
-	if ((pp & _PTHREAD_PRIORITY_SCHED_PRI_FLAG) ||
-			!(pp & ~_PTHREAD_PRIORITY_FLAGS_MASK)) {
-		// When the phtread kext is delivering kevents to us, and pthread
-		// root queues are in use, then the pthread priority TSD is set
-		// to a sched pri with the _PTHREAD_PRIORITY_SCHED_PRI_FLAG bit set.
-		//
-		// Given that this isn't a valid QoS we need to fixup the TSD,
-		// and the best option is to clear the qos/priority bits which tells
-		// us to not do any QoS related calls on this thread.
-		//
-		// However, in that case the manager thread is opted out of QoS,
-		// as far as pthread is concerned, and can't be turned into
-		// something else, so we can't stash.
-		pp &= (pthread_priority_t)_PTHREAD_PRIORITY_FLAGS_MASK;
-	}
-	// Managers always park without mutating to a regular worker thread, and
-	// hence never need to unbind from userland, and when draining a manager,
-	// the NEEDS_UNBIND flag would cause the mutation to happen.
-	// So we need to strip this flag
-	pp &= ~(pthread_priority_t)_PTHREAD_PRIORITY_NEEDS_UNBIND_FLAG;
-	_dispatch_thread_setspecific(dispatch_priority_key, (void *)(uintptr_t)pp);
-
-	// ensure kevents registered from this thread are registered at manager QoS
-	_dispatch_init_basepri_wlh(DISPATCH_PRIORITY_FLAG_MANAGER);
-	_dispatch_queue_set_current(&_dispatch_mgr_q);
-	_dispatch_queue_mgr_lock(&_dispatch_mgr_q);
-	return true;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_wlh_worker_thread_reset(void)
-{
-	bool needs_poll = _dispatch_queue_mgr_unlock(&_dispatch_mgr_q);
-	_dispatch_clear_basepri();
-	_dispatch_queue_set_current(NULL);
-	if (needs_poll) {
-		_dispatch_trace_runtime_event(worker_request, &_dispatch_mgr_q, 1);
-		_dispatch_event_loop_poke(DISPATCH_WLH_MANAGER, 0, 0);
-	}
-}
-
-DISPATCH_ALWAYS_INLINE
-static void
-_dispatch_wlh_worker_thread(dispatch_wlh_t wlh, dispatch_kevent_t events,
-		int *nevents)
-{
-	_dispatch_introspection_thread_add();
-
-	DISPATCH_PERF_MON_VAR_INIT
-
-	dispatch_deferred_items_s ddi = {
-		.ddi_wlh = wlh,
-		.ddi_eventlist = events,
-	};
-	bool is_manager;
-
-	is_manager = _dispatch_wlh_worker_thread_init(&ddi);
-	if (!is_manager) {
-		_dispatch_trace_runtime_event(worker_event_delivery,
-				wlh == DISPATCH_WLH_ANON ? NULL : wlh, (uint64_t)*nevents);
-		_dispatch_perfmon_start_impl(true);
-	} else {
-		_dispatch_trace_runtime_event(worker_event_delivery,
-				&_dispatch_mgr_q, (uint64_t)*nevents);
-		ddi.ddi_wlh = DISPATCH_WLH_ANON;
-	}
-	_dispatch_deferred_items_set(&ddi);
-	_dispatch_event_loop_merge(events, *nevents);
-
-	if (is_manager) {
-		_dispatch_trace_runtime_event(worker_unpark, &_dispatch_mgr_q, 0);
-		_dispatch_mgr_queue_drain();
-		_dispatch_event_loop_drain_anon_timers();
-		_dispatch_wlh_worker_thread_reset();
-	} else if (ddi.ddi_stashed_dou._do) {
-		_dispatch_debug("wlh[%p]: draining deferred item %p", ddi.ddi_wlh,
-				ddi.ddi_stashed_dou._do);
-		if (ddi.ddi_wlh == DISPATCH_WLH_ANON) {
-			dispatch_assert(ddi.ddi_nevents == 0);
-			_dispatch_deferred_items_set(NULL);
-			_dispatch_trace_runtime_event(worker_unpark, ddi.ddi_stashed_rq, 0);
-			_dispatch_root_queue_drain_deferred_item(&ddi
-					DISPATCH_PERF_MON_ARGS);
-		} else {
-			_dispatch_trace_runtime_event(worker_unpark, wlh, 0);
-			_dispatch_root_queue_drain_deferred_wlh(&ddi
-					DISPATCH_PERF_MON_ARGS);
-		}
-	}
-
-	_dispatch_deferred_items_set(NULL);
-	if (!is_manager && !ddi.ddi_stashed_dou._do) {
-		_dispatch_perfmon_end(perfmon_thread_event_no_steal);
-	}
-	_dispatch_debug("returning %d deferred kevents", ddi.ddi_nevents);
-	_dispatch_clear_return_to_kernel();
-	*nevents = ddi.ddi_nevents;
-
-	_dispatch_trace_runtime_event(worker_park, NULL, 0);
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_kevent_worker_thread(dispatch_kevent_t *events, int *nevents)
-{
-	if (!events || !nevents) {
-		// events for worker thread request have already been delivered earlier
-		return;
-	}
-	if (!dispatch_assume(*nevents && *events)) return;
-	_dispatch_adopt_wlh_anon();
-	_dispatch_wlh_worker_thread(DISPATCH_WLH_ANON, *events, nevents);
-	_dispatch_reset_wlh();
-}
-
-#if DISPATCH_USE_KEVENT_WORKLOOP
-DISPATCH_NOINLINE
-static void
-_dispatch_workloop_worker_thread(uint64_t *workloop_id,
-		dispatch_kevent_t *events, int *nevents)
-{
-	if (!workloop_id || !dispatch_assume(*workloop_id != 0)) {
-		return _dispatch_kevent_worker_thread(events, nevents);
-	}
-	if (!events || !nevents) {
-		// events for worker thread request have already been delivered earlier
-		return;
-	}
-	if (!dispatch_assume(*nevents && *events)) return;
-	dispatch_wlh_t wlh = (dispatch_wlh_t)*workloop_id;
-	_dispatch_adopt_wlh(wlh);
-	_dispatch_wlh_worker_thread(wlh, *events, nevents);
-	_dispatch_preserve_wlh_storage_reference(wlh);
-}
-#endif // DISPATCH_USE_KEVENT_WORKLOOP
-#endif // DISPATCH_USE_KEVENT_WORKQUEUE
-#pragma mark -
-#pragma mark dispatch_root_queue
-
-#if DISPATCH_USE_PTHREAD_POOL
-static void *_dispatch_worker_thread(void *context);
-#if defined(_WIN32)
-static unsigned WINAPI _dispatch_worker_thread_thunk(LPVOID lpParameter);
-#endif
-#endif // DISPATCH_USE_PTHREAD_POOL
-
-#if DISPATCH_DEBUG && DISPATCH_ROOT_QUEUE_DEBUG
-#define _dispatch_root_queue_debug(...) _dispatch_debug(__VA_ARGS__)
-static void
-_dispatch_debug_root_queue(dispatch_queue_class_t dqu, const char *str)
-{
-	if (likely(dqu._dq)) {
-		_dispatch_object_debug(dqu._dq, "%s", str);
-	} else {
-		_dispatch_log("queue[NULL]: %s", str);
-	}
-}
-#else
-#define _dispatch_root_queue_debug(...)
-#define _dispatch_debug_root_queue(...)
-#endif // DISPATCH_DEBUG && DISPATCH_ROOT_QUEUE_DEBUG
-
-DISPATCH_NOINLINE
-static void
-_dispatch_root_queue_poke_slow(dispatch_queue_global_t dq, int n, int floor)
-{
-	int remaining = n;
-#if !defined(_WIN32)
-	int r = ENOSYS;
-#endif
-
-	_dispatch_root_queues_init();
-	_dispatch_debug_root_queue(dq, __func__);
-	_dispatch_trace_runtime_event(worker_request, dq, (uint64_t)n);
-
-#if !DISPATCH_USE_INTERNAL_WORKQUEUE
-#if DISPATCH_USE_PTHREAD_ROOT_QUEUES
-	if (dx_type(dq) == DISPATCH_QUEUE_GLOBAL_ROOT_TYPE)
-#endif
-	{
-		_dispatch_root_queue_debug("requesting new worker thread for global "
-				"queue: %p", dq);
-		r = _pthread_workqueue_addthreads(remaining,
-				_dispatch_priority_to_pp_prefer_fallback(dq->dq_priority));
-		(void)dispatch_assume_zero(r);
-		return;
-	}
-#endif // !DISPATCH_USE_INTERNAL_WORKQUEUE
-#if DISPATCH_USE_PTHREAD_POOL
-	dispatch_pthread_root_queue_context_t pqc = dq->do_ctxt;
-	if (likely(pqc->dpq_thread_mediator.do_vtable)) {
-		while (dispatch_semaphore_signal(&pqc->dpq_thread_mediator)) {
-			_dispatch_root_queue_debug("signaled sleeping worker for "
-					"global queue: %p", dq);
-			if (!--remaining) {
-				return;
-			}
-		}
-	}
-
-	bool overcommit = dq->dq_priority & DISPATCH_PRIORITY_FLAG_OVERCOMMIT;
-	if (overcommit) {
-		os_atomic_add2o(dq, dgq_pending, remaining, relaxed);
-	} else {
-		if (!os_atomic_cmpxchg2o(dq, dgq_pending, 0, remaining, relaxed)) {
-			_dispatch_root_queue_debug("worker thread request still pending for "
-					"global queue: %p", dq);
-			return;
-		}
-	}
-
-	int can_request, t_count;
-	// seq_cst with atomic store to tail <rdar://problem/16932833>
-	t_count = os_atomic_load2o(dq, dgq_thread_pool_size, ordered);
-	do {
-		can_request = t_count < floor ? 0 : t_count - floor;
-		if (remaining > can_request) {
-			_dispatch_root_queue_debug("pthread pool reducing request from %d to %d",
-					remaining, can_request);
-			os_atomic_sub2o(dq, dgq_pending, remaining - can_request, relaxed);
-			remaining = can_request;
-		}
-		if (remaining == 0) {
-			_dispatch_root_queue_debug("pthread pool is full for root queue: "
-					"%p", dq);
-			return;
-		}
-	} while (!os_atomic_cmpxchgvw2o(dq, dgq_thread_pool_size, t_count,
-			t_count - remaining, &t_count, acquire));
-
-#if !defined(_WIN32)
-	pthread_attr_t *attr = &pqc->dpq_thread_attr;
-	pthread_t tid, *pthr = &tid;
-#if DISPATCH_USE_MGR_THREAD && DISPATCH_USE_PTHREAD_ROOT_QUEUES
-	if (unlikely(dq == &_dispatch_mgr_root_queue)) {
-		pthr = _dispatch_mgr_root_queue_init();
-	}
-#endif
-	do {
-		_dispatch_retain(dq); // released in _dispatch_worker_thread
-		while ((r = pthread_create(pthr, attr, _dispatch_worker_thread, dq))) {
-			if (r != EAGAIN) {
-				(void)dispatch_assume_zero(r);
-			}
-			_dispatch_temporary_resource_shortage();
-		}
-	} while (--remaining);
-#else // defined(_WIN32)
-#if DISPATCH_USE_MGR_THREAD && DISPATCH_USE_PTHREAD_ROOT_QUEUES
-	if (unlikely(dq == &_dispatch_mgr_root_queue)) {
-		_dispatch_mgr_root_queue_init();
-	}
-#endif
-	do {
-		_dispatch_retain(dq); // released in _dispatch_worker_thread
-		uintptr_t hThread = 0;
-		while (!(hThread = _beginthreadex(NULL, /* stack_size */ 0, _dispatch_worker_thread_thunk, dq, STACK_SIZE_PARAM_IS_A_RESERVATION, NULL))) {
-			if (errno != EAGAIN) {
-				(void)dispatch_assume(hThread);
-			}
-			_dispatch_temporary_resource_shortage();
-		}
-#if DISPATCH_USE_PTHREAD_ROOT_QUEUES
-		if (_dispatch_mgr_sched.prio > _dispatch_mgr_sched.default_prio) {
-			(void)dispatch_assume_zero(SetThreadPriority((HANDLE)hThread, _dispatch_mgr_sched.prio) == TRUE);
-		}
-#endif
-		CloseHandle((HANDLE)hThread);
-	} while (--remaining);
-#endif // defined(_WIN32)
-#else
-	(void)floor;
-#endif // DISPATCH_USE_PTHREAD_POOL
-}
-
-DISPATCH_NOINLINE
-void
-_dispatch_root_queue_poke(dispatch_queue_global_t dq, int n, int floor)
-{
-	if (!_dispatch_queue_class_probe(dq)) {
-		return;
-	}
-#if !DISPATCH_USE_INTERNAL_WORKQUEUE
-#if DISPATCH_USE_PTHREAD_POOL
-	if (likely(dx_type(dq) == DISPATCH_QUEUE_GLOBAL_ROOT_TYPE))
-#endif
-	{
-		if (unlikely(!os_atomic_cmpxchg2o(dq, dgq_pending, 0, n, relaxed))) {
-			_dispatch_root_queue_debug("worker thread request still pending "
-					"for global queue: %p", dq);
-			return;
-		}
-	}
-#endif // !DISPATCH_USE_INTERNAL_WORKQUEUE
-	return _dispatch_root_queue_poke_slow(dq, n, floor);
-}
-
-#define DISPATCH_ROOT_QUEUE_MEDIATOR ((struct dispatch_object_s *)~0ul)
-
-enum {
-	DISPATCH_ROOT_QUEUE_DRAIN_WAIT,
-	DISPATCH_ROOT_QUEUE_DRAIN_READY,
-	DISPATCH_ROOT_QUEUE_DRAIN_ABORT,
-};
-
-static int
-_dispatch_root_queue_mediator_is_gone(dispatch_queue_global_t dq)
-{
-	return os_atomic_load2o(dq, dq_items_head, relaxed) !=
-			DISPATCH_ROOT_QUEUE_MEDIATOR;
-}
-
-static int
-_dispatch_root_queue_head_tail_quiesced(dispatch_queue_global_t dq)
-{
-	// Wait for queue head and tail to be both non-empty or both empty
-	struct dispatch_object_s *head, *tail;
-	head = os_atomic_load2o(dq, dq_items_head, relaxed);
-	tail = os_atomic_load2o(dq, dq_items_tail, relaxed);
-	if ((head == NULL) == (tail == NULL)) {
-		if (tail == NULL) { // <rdar://problem/15917893>
-			return DISPATCH_ROOT_QUEUE_DRAIN_ABORT;
-		}
-		return DISPATCH_ROOT_QUEUE_DRAIN_READY;
-	}
-	return DISPATCH_ROOT_QUEUE_DRAIN_WAIT;
-}
-
-DISPATCH_NOINLINE
-static bool
-__DISPATCH_ROOT_QUEUE_CONTENDED_WAIT__(dispatch_queue_global_t dq,
-		int (*predicate)(dispatch_queue_global_t dq))
-{
-	unsigned int sleep_time = DISPATCH_CONTENTION_USLEEP_START;
-	int status = DISPATCH_ROOT_QUEUE_DRAIN_READY;
-	bool pending = false;
-
-	do {
-		// Spin for a short while in case the contention is temporary -- e.g.
-		// when starting up after dispatch_apply, or when executing a few
-		// short continuations in a row.
-		if (_dispatch_contention_wait_until(status = predicate(dq))) {
-			goto out;
-		}
-		// Since we have serious contention, we need to back off.
-		if (!pending) {
-			// Mark this queue as pending to avoid requests for further threads
-			(void)os_atomic_inc2o(dq, dgq_pending, relaxed);
-			pending = true;
-		}
-		_dispatch_contention_usleep(sleep_time);
-		if (likely(status = predicate(dq))) goto out;
-		sleep_time *= 2;
-	} while (sleep_time < DISPATCH_CONTENTION_USLEEP_MAX);
-
-	// The ratio of work to libdispatch overhead must be bad. This
-	// scenario implies that there are too many threads in the pool.
-	// Create a new pending thread and then exit this thread.
-	// The kernel will grant a new thread when the load subsides.
-	_dispatch_debug("contention on global queue: %p", dq);
-out:
-	if (pending) {
-		(void)os_atomic_dec2o(dq, dgq_pending, relaxed);
-	}
-	if (status == DISPATCH_ROOT_QUEUE_DRAIN_WAIT) {
-		_dispatch_root_queue_poke(dq, 1, 0);
-	}
-	return status == DISPATCH_ROOT_QUEUE_DRAIN_READY;
-}
-
-DISPATCH_ALWAYS_INLINE_NDEBUG
-static inline struct dispatch_object_s *
-_dispatch_root_queue_drain_one(dispatch_queue_global_t dq)
-{
-	struct dispatch_object_s *head, *next;
-
-start:
-	// The MEDIATOR value acts both as a "lock" and a signal
-	head = os_atomic_xchg2o(dq, dq_items_head,
-			DISPATCH_ROOT_QUEUE_MEDIATOR, relaxed);
-
-	if (unlikely(head == NULL)) {
-		// The first xchg on the tail will tell the enqueueing thread that it
-		// is safe to blindly write out to the head pointer. A cmpxchg honors
-		// the algorithm.
-		if (unlikely(!os_atomic_cmpxchg2o(dq, dq_items_head,
-				DISPATCH_ROOT_QUEUE_MEDIATOR, NULL, relaxed))) {
-			goto start;
-		}
-		if (unlikely(dq->dq_items_tail)) { // <rdar://problem/14416349>
-			if (__DISPATCH_ROOT_QUEUE_CONTENDED_WAIT__(dq,
-					_dispatch_root_queue_head_tail_quiesced)) {
-				goto start;
-			}
-		}
-		_dispatch_root_queue_debug("no work on global queue: %p", dq);
-		return NULL;
-	}
-
-	if (unlikely(head == DISPATCH_ROOT_QUEUE_MEDIATOR)) {
-		// This thread lost the race for ownership of the queue.
-		if (likely(__DISPATCH_ROOT_QUEUE_CONTENDED_WAIT__(dq,
-				_dispatch_root_queue_mediator_is_gone))) {
-			goto start;
-		}
-		return NULL;
-	}
-
-	// Restore the head pointer to a sane value before returning.
-	// If 'next' is NULL, then this item _might_ be the last item.
-	next = head->do_next;
-
-	if (unlikely(!next)) {
-		os_atomic_store2o(dq, dq_items_head, NULL, relaxed);
-		// 22708742: set tail to NULL with release, so that NULL write to head
-		//           above doesn't clobber head from concurrent enqueuer
-		if (os_atomic_cmpxchg2o(dq, dq_items_tail, head, NULL, release)) {
-			// both head and tail are NULL now
-			goto out;
-		}
-		// There must be a next item now.
-		next = os_mpsc_get_next(head, do_next);
-	}
-
-	os_atomic_store2o(dq, dq_items_head, next, relaxed);
-	_dispatch_root_queue_poke(dq, 1, 0);
-out:
-	return head;
-}
-
-#if DISPATCH_USE_KEVENT_WORKQUEUE
-static void
-_dispatch_root_queue_drain_deferred_wlh(dispatch_deferred_items_t ddi
-		DISPATCH_PERF_MON_ARGS_PROTO)
-{
-	dispatch_queue_global_t rq = ddi->ddi_stashed_rq;
-	dispatch_queue_t dq = ddi->ddi_stashed_dou._dq;
-	_dispatch_queue_set_current(rq);
-
-	dispatch_invoke_context_s dic = { };
-	dispatch_invoke_flags_t flags = DISPATCH_INVOKE_WORKER_DRAIN |
-			DISPATCH_INVOKE_REDIRECTING_DRAIN | DISPATCH_INVOKE_WLH;
-	_dispatch_queue_drain_init_narrowing_check_deadline(&dic, rq->dq_priority);
-	uint64_t dq_state;
-
-	_dispatch_init_basepri_wlh(rq->dq_priority);
-	ddi->ddi_wlh_servicing = true;
-retry:
-	dispatch_assert(ddi->ddi_wlh_needs_delete);
-	_dispatch_trace_item_pop(rq, dq);
-
-	if (_dispatch_queue_drain_try_lock_wlh(dq, &dq_state)) {
-		dx_invoke(dq, &dic, flags);
-#if DISPATCH_USE_KEVENT_WORKLOOP
-		//
-		// dx_invoke() will always return `dq` unlocked or locked by another
-		// thread, and either have consumed the +2 or transferred it to the
-		// other thread.
-		//
-#endif
-		if (!ddi->ddi_wlh_needs_delete) {
-#if DISPATCH_USE_KEVENT_WORKLOOP
-			//
-			// The fate of the workloop thread request has already been dealt
-			// with, which can happen for 4 reasons, for which we just want
-			// to go park and skip trying to unregister the thread request:
-			// - the workloop target has been changed
-			// - the workloop has been re-enqueued because of narrowing
-			// - the workloop has been re-enqueued on the manager queue
-			// - the workloop ownership has been handed off to a sync owner
-			//
-#endif
-			goto park;
-		}
-#if DISPATCH_USE_KEVENT_WORKLOOP
-		//
-		// The workloop has been drained to completion or suspended.
-		// dx_invoke() has cleared the enqueued bit before it returned.
-		//
-		// Since a dispatch_set_target_queue() could occur between the unlock
-		// and our reload of `dq_state` (rdar://32671286) we need to re-assess
-		// the workloop-ness of the queue. If it's not a workloop anymore,
-		// _dispatch_event_loop_leave_immediate() will have handled the kevent
-		// deletion already.
-		//
-		// Then, we check one last time that the queue is still not enqueued,
-		// in which case we attempt to quiesce it.
-		//
-		// If we find it enqueued again, it means someone else has been
-		// enqueuing concurrently and has made a thread request that coalesced
-		// with ours, but since dx_invoke() cleared the enqueued bit,
-		// the other thread didn't realize that and added a +1 ref count.
-		// Take over that +1, and add our own to make the +2 this loop expects,
-		// and drain again.
-		//
-#endif // DISPATCH_USE_KEVENT_WORKLOOP
-		dq_state = os_atomic_load2o(dq, dq_state, relaxed);
-		if (unlikely(!_dq_state_is_base_wlh(dq_state))) { // rdar://32671286
-			goto park;
-		}
-		if (unlikely(_dq_state_is_enqueued_on_target(dq_state))) {
-			_dispatch_retain(dq);
-			_dispatch_trace_item_push(dq->do_targetq, dq);
-			goto retry;
-		}
-	} else {
-#if DISPATCH_USE_KEVENT_WORKLOOP
-		//
-		// The workloop enters this function with a +2 refcount, however we
-		// couldn't acquire the lock due to suspension or discovering that
-		// the workloop was locked by a sync owner.
-		//
-		// We need to give up, and _dispatch_event_loop_leave_deferred()
-		// will do a DISPATCH_WORKLOOP_ASYNC_DISCOVER_SYNC transition to
-		// tell the kernel to stop driving this thread request. We leave
-		// a +1 with the thread request, and consume the extra +1 we have.
-		//
-#endif
-		if (_dq_state_is_suspended(dq_state)) {
-			dispatch_assert(!_dq_state_is_enqueued(dq_state));
-			_dispatch_release_2_no_dispose(dq);
-		} else {
-			dispatch_assert(_dq_state_is_enqueued(dq_state));
-			dispatch_assert(_dq_state_drain_locked(dq_state));
-			_dispatch_release_no_dispose(dq);
-		}
-	}
-
-	_dispatch_event_loop_leave_deferred(ddi, dq_state);
-
-park:
-	// event thread that could steal
-	_dispatch_perfmon_end(perfmon_thread_event_steal);
-	_dispatch_clear_basepri();
-	_dispatch_queue_set_current(NULL);
-
-	_dispatch_voucher_debug("root queue clear", NULL);
-	_dispatch_reset_voucher(NULL, DISPATCH_THREAD_PARK);
-}
-
-static void
-_dispatch_root_queue_drain_deferred_item(dispatch_deferred_items_t ddi
-		DISPATCH_PERF_MON_ARGS_PROTO)
-{
-	dispatch_queue_global_t rq = ddi->ddi_stashed_rq;
-	_dispatch_queue_set_current(rq);
-	_dispatch_trace_runtime_event(worker_unpark, NULL, 0);
-
-	dispatch_invoke_context_s dic = { };
-	dispatch_invoke_flags_t flags = DISPATCH_INVOKE_WORKER_DRAIN |
-			DISPATCH_INVOKE_REDIRECTING_DRAIN;
-#if DISPATCH_COCOA_COMPAT
-	_dispatch_last_resort_autorelease_pool_push(&dic);
-#endif // DISPATCH_COCOA_COMPAT
-	_dispatch_queue_drain_init_narrowing_check_deadline(&dic, rq->dq_priority);
-	_dispatch_init_basepri(rq->dq_priority);
-
-	_dispatch_continuation_pop_inline(ddi->ddi_stashed_dou, &dic, flags, rq);
-
-	// event thread that could steal
-	_dispatch_perfmon_end(perfmon_thread_event_steal);
-#if DISPATCH_COCOA_COMPAT
-	_dispatch_last_resort_autorelease_pool_pop(&dic);
-#endif // DISPATCH_COCOA_COMPAT
-	_dispatch_clear_basepri();
-	_dispatch_queue_set_current(NULL);
-
-	_dispatch_voucher_debug("root queue clear", NULL);
-	_dispatch_reset_voucher(NULL, DISPATCH_THREAD_PARK);
-}
-#endif
-
-DISPATCH_NOT_TAIL_CALLED // prevent tailcall (for Instrument DTrace probe)
-static void
-_dispatch_root_queue_drain(dispatch_queue_global_t dq,
-		dispatch_priority_t pri, dispatch_invoke_flags_t flags)
-{
-#if DISPATCH_DEBUG
-	dispatch_queue_t cq;
-	if (unlikely(cq = _dispatch_queue_get_current())) {
-		DISPATCH_INTERNAL_CRASH(cq, "Premature thread recycling");
-	}
-#endif
-	_dispatch_queue_set_current(dq);
-	_dispatch_init_basepri(pri);
-	_dispatch_adopt_wlh_anon();
-
-	struct dispatch_object_s *item;
-	bool reset = false;
-	dispatch_invoke_context_s dic = { };
-#if DISPATCH_COCOA_COMPAT
-	_dispatch_last_resort_autorelease_pool_push(&dic);
-#endif // DISPATCH_COCOA_COMPAT
-	_dispatch_queue_drain_init_narrowing_check_deadline(&dic, pri);
-	_dispatch_perfmon_start();
-	while (likely(item = _dispatch_root_queue_drain_one(dq))) {
-		if (reset) _dispatch_wqthread_override_reset();
-		_dispatch_continuation_pop_inline(item, &dic, flags, dq);
-		reset = _dispatch_reset_basepri_override();
-		if (unlikely(_dispatch_queue_drain_should_narrow(&dic))) {
-			break;
-		}
-	}
-
-	// overcommit or not. worker thread
-	if (pri & DISPATCH_PRIORITY_FLAG_OVERCOMMIT) {
-		_dispatch_perfmon_end(perfmon_thread_worker_oc);
-	} else {
-		_dispatch_perfmon_end(perfmon_thread_worker_non_oc);
-	}
-
-#if DISPATCH_COCOA_COMPAT
-	_dispatch_last_resort_autorelease_pool_pop(&dic);
-#endif // DISPATCH_COCOA_COMPAT
-	_dispatch_reset_wlh();
-	_dispatch_clear_basepri();
-	_dispatch_queue_set_current(NULL);
-}
-
-#if !DISPATCH_USE_INTERNAL_WORKQUEUE
-static void
-_dispatch_worker_thread2(pthread_priority_t pp)
-{
-	bool overcommit = pp & _PTHREAD_PRIORITY_OVERCOMMIT_FLAG;
-	dispatch_queue_global_t dq;
-
-	pp &= _PTHREAD_PRIORITY_OVERCOMMIT_FLAG | ~_PTHREAD_PRIORITY_FLAGS_MASK;
-	_dispatch_thread_setspecific(dispatch_priority_key, (void *)(uintptr_t)pp);
-	dq = _dispatch_get_root_queue(_dispatch_qos_from_pp(pp), overcommit);
-
-	_dispatch_introspection_thread_add();
-	_dispatch_trace_runtime_event(worker_unpark, dq, 0);
-
-	int pending = os_atomic_dec2o(dq, dgq_pending, relaxed);
-	dispatch_assert(pending >= 0);
-	_dispatch_root_queue_drain(dq, dq->dq_priority,
-			DISPATCH_INVOKE_WORKER_DRAIN | DISPATCH_INVOKE_REDIRECTING_DRAIN);
-	_dispatch_voucher_debug("root queue clear", NULL);
-	_dispatch_reset_voucher(NULL, DISPATCH_THREAD_PARK);
-	_dispatch_trace_runtime_event(worker_park, NULL, 0);
-}
-#endif // !DISPATCH_USE_INTERNAL_WORKQUEUE
-
-#if DISPATCH_USE_PTHREAD_POOL
-static inline void
-_dispatch_root_queue_init_pthread_pool(dispatch_queue_global_t dq,
-		int pool_size, dispatch_priority_t pri)
-{
-	dispatch_pthread_root_queue_context_t pqc = dq->do_ctxt;
-	int thread_pool_size = DISPATCH_WORKQ_MAX_PTHREAD_COUNT;
-	if (!(pri & DISPATCH_PRIORITY_FLAG_OVERCOMMIT)) {
-		thread_pool_size = (int32_t)dispatch_hw_config(active_cpus);
-	}
-	if (pool_size && pool_size < thread_pool_size) thread_pool_size = pool_size;
-	dq->dgq_thread_pool_size = thread_pool_size;
-	qos_class_t cls = _dispatch_qos_to_qos_class(_dispatch_priority_qos(pri) ?:
-			_dispatch_priority_fallback_qos(pri));
-	if (cls) {
-#if !defined(_WIN32)
-		pthread_attr_t *attr = &pqc->dpq_thread_attr;
-		int r = pthread_attr_init(attr);
-		dispatch_assume_zero(r);
-		r = pthread_attr_setdetachstate(attr, PTHREAD_CREATE_DETACHED);
-		dispatch_assume_zero(r);
-#endif // !defined(_WIN32)
-#if HAVE_PTHREAD_WORKQUEUE_QOS
-		r = pthread_attr_set_qos_class_np(attr, cls, 0);
-		dispatch_assume_zero(r);
-#endif // HAVE_PTHREAD_WORKQUEUE_QOS
-	}
-	_dispatch_sema4_t *sema = &pqc->dpq_thread_mediator.dsema_sema;
-	pqc->dpq_thread_mediator.do_vtable = DISPATCH_VTABLE(semaphore);
-	_dispatch_sema4_init(sema, _DSEMA4_POLICY_LIFO);
-	_dispatch_sema4_create(sema, _DSEMA4_POLICY_LIFO);
-}
-
-// 6618342 Contact the team that owns the Instrument DTrace probe before
-//         renaming this symbol
-static void *
-_dispatch_worker_thread(void *context)
-{
-	dispatch_queue_global_t dq = context;
-	dispatch_pthread_root_queue_context_t pqc = dq->do_ctxt;
-
-	int pending = os_atomic_dec2o(dq, dgq_pending, relaxed);
-	if (unlikely(pending < 0)) {
-		DISPATCH_INTERNAL_CRASH(pending, "Pending thread request underflow");
-	}
-
-	if (pqc->dpq_observer_hooks.queue_will_execute) {
-		_dispatch_set_pthread_root_queue_observer_hooks(
-				&pqc->dpq_observer_hooks);
-	}
-	if (pqc->dpq_thread_configure) {
-		pqc->dpq_thread_configure();
-	}
-
-#if !defined(_WIN32)
-	// workaround tweaks the kernel workqueue does for us
-	_dispatch_sigmask();
-#endif
-	_dispatch_introspection_thread_add();
-
-	const int64_t timeout = 5ull * NSEC_PER_SEC;
-	pthread_priority_t pp = _dispatch_get_priority();
-	dispatch_priority_t pri = dq->dq_priority;
-
-	// If the queue is neither
-	// - the manager
-	// - with a fallback set
-	// - with a requested QoS or QoS floor
-	// then infer the basepri from the current priority.
-	if ((pri & (DISPATCH_PRIORITY_FLAG_MANAGER |
-			DISPATCH_PRIORITY_FLAG_FALLBACK |
-			DISPATCH_PRIORITY_FLAG_FLOOR |
-			DISPATCH_PRIORITY_REQUESTED_MASK)) == 0) {
-		pri &= DISPATCH_PRIORITY_FLAG_OVERCOMMIT;
-		if (pp & _PTHREAD_PRIORITY_QOS_CLASS_MASK) {
-			pri |= _dispatch_priority_from_pp(pp);
-		} else {
-			pri |= _dispatch_priority_make_override(DISPATCH_QOS_SATURATED);
-		}
-	}
-
-#if DISPATCH_USE_INTERNAL_WORKQUEUE
-	bool monitored = ((pri & (DISPATCH_PRIORITY_FLAG_OVERCOMMIT |
-			DISPATCH_PRIORITY_FLAG_MANAGER)) == 0);
-	if (monitored) _dispatch_workq_worker_register(dq);
-#endif
-
-	do {
-		_dispatch_trace_runtime_event(worker_unpark, dq, 0);
-		_dispatch_root_queue_drain(dq, pri, DISPATCH_INVOKE_REDIRECTING_DRAIN);
-		_dispatch_reset_priority_and_voucher(pp, NULL);
-		_dispatch_trace_runtime_event(worker_park, NULL, 0);
-	} while (dispatch_semaphore_wait(&pqc->dpq_thread_mediator,
-			dispatch_time(0, timeout)) == 0);
-
-#if DISPATCH_USE_INTERNAL_WORKQUEUE
-	if (monitored) _dispatch_workq_worker_unregister(dq);
-#endif
-	(void)os_atomic_inc2o(dq, dgq_thread_pool_size, release);
-	_dispatch_root_queue_poke(dq, 1, 0);
-	_dispatch_release(dq); // retained in _dispatch_root_queue_poke_slow
-	return NULL;
-}
-#if defined(_WIN32)
-static unsigned WINAPI
-_dispatch_worker_thread_thunk(LPVOID lpParameter)
-{
-  _dispatch_worker_thread(lpParameter);
-  return 0;
-}
-#endif // defined(_WIN32)
-#endif // DISPATCH_USE_PTHREAD_POOL
-
-DISPATCH_NOINLINE
-void
-_dispatch_root_queue_wakeup(dispatch_queue_global_t dq,
-		DISPATCH_UNUSED dispatch_qos_t qos, dispatch_wakeup_flags_t flags)
-{
-	if (!(flags & DISPATCH_WAKEUP_BLOCK_WAIT)) {
-		DISPATCH_INTERNAL_CRASH(dq->dq_priority,
-				"Don't try to wake up or override a root queue");
-	}
-	if (flags & DISPATCH_WAKEUP_CONSUME_2) {
-		return _dispatch_release_2_tailcall(dq);
-	}
-}
-
-DISPATCH_NOINLINE
-void
-_dispatch_root_queue_push(dispatch_queue_global_t rq, dispatch_object_t dou,
-		dispatch_qos_t qos)
-{
-#if DISPATCH_USE_KEVENT_WORKQUEUE
-	dispatch_deferred_items_t ddi = _dispatch_deferred_items_get();
-	if (unlikely(ddi && ddi->ddi_can_stash)) {
-		dispatch_object_t old_dou = ddi->ddi_stashed_dou;
-		dispatch_priority_t rq_overcommit;
-		rq_overcommit = rq->dq_priority & DISPATCH_PRIORITY_FLAG_OVERCOMMIT;
-
-		if (likely(!old_dou._do || rq_overcommit)) {
-			dispatch_queue_global_t old_rq = ddi->ddi_stashed_rq;
-			dispatch_qos_t old_qos = ddi->ddi_stashed_qos;
-			ddi->ddi_stashed_rq = rq;
-			ddi->ddi_stashed_dou = dou;
-			ddi->ddi_stashed_qos = qos;
-			_dispatch_debug("deferring item %p, rq %p, qos %d",
-					dou._do, rq, qos);
-			if (rq_overcommit) {
-				ddi->ddi_can_stash = false;
-			}
-			if (likely(!old_dou._do)) {
-				return;
-			}
-			// push the previously stashed item
-			qos = old_qos;
-			rq = old_rq;
-			dou = old_dou;
-		}
-	}
-#endif
-#if HAVE_PTHREAD_WORKQUEUE_QOS
-	if (_dispatch_root_queue_push_needs_override(rq, qos)) {
-		return _dispatch_root_queue_push_override(rq, dou, qos);
-	}
-#else
-	(void)qos;
-#endif
-	_dispatch_root_queue_push_inline(rq, dou, dou, 1);
-}
-
-#pragma mark -
-#pragma mark dispatch_pthread_root_queue
-#if DISPATCH_USE_PTHREAD_ROOT_QUEUES
-
-static dispatch_queue_global_t
-_dispatch_pthread_root_queue_create(const char *label, unsigned long flags,
-		const pthread_attr_t *attr, dispatch_block_t configure,
-		dispatch_pthread_root_queue_observer_hooks_t observer_hooks)
-{
-	dispatch_queue_pthread_root_t dpq;
-	dispatch_queue_flags_t dqf = 0;
-	int32_t pool_size = flags & _DISPATCH_PTHREAD_ROOT_QUEUE_FLAG_POOL_SIZE ?
-			(int8_t)(flags & ~_DISPATCH_PTHREAD_ROOT_QUEUE_FLAG_POOL_SIZE) : 0;
-
-	if (label) {
-		const char *tmp = _dispatch_strdup_if_mutable(label);
-		if (tmp != label) {
-			dqf |= DQF_LABEL_NEEDS_FREE;
-			label = tmp;
-		}
-	}
-
-	dpq = _dispatch_queue_alloc(queue_pthread_root, dqf,
-			DISPATCH_QUEUE_WIDTH_POOL, 0)._dpq;
-	dpq->dq_label = label;
-	dpq->dq_state = DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE;
-	dpq->dq_priority = DISPATCH_PRIORITY_FLAG_OVERCOMMIT;
-	dpq->do_ctxt = &dpq->dpq_ctxt;
-
-	dispatch_pthread_root_queue_context_t pqc = &dpq->dpq_ctxt;
-	_dispatch_root_queue_init_pthread_pool(dpq->_as_dgq, pool_size,
-			DISPATCH_PRIORITY_FLAG_OVERCOMMIT);
-
-#if !defined(_WIN32)
-	if (attr) {
-		memcpy(&pqc->dpq_thread_attr, attr, sizeof(pthread_attr_t));
-		_dispatch_mgr_priority_raise(&pqc->dpq_thread_attr);
-	} else {
-		(void)dispatch_assume_zero(pthread_attr_init(&pqc->dpq_thread_attr));
-	}
-	(void)dispatch_assume_zero(pthread_attr_setdetachstate(
-			&pqc->dpq_thread_attr, PTHREAD_CREATE_DETACHED));
-#else // defined(_WIN32)
-	dispatch_assert(attr == NULL);
-#endif // defined(_WIN32)
-	if (configure) {
-		pqc->dpq_thread_configure = _dispatch_Block_copy(configure);
-	}
-	if (observer_hooks) {
-		pqc->dpq_observer_hooks = *observer_hooks;
-	}
-	_dispatch_object_debug(dpq, "%s", __func__);
-	return _dispatch_trace_queue_create(dpq)._dgq;
-}
-
-dispatch_queue_global_t
-dispatch_pthread_root_queue_create(const char *label, unsigned long flags,
-		const pthread_attr_t *attr, dispatch_block_t configure)
-{
-	return _dispatch_pthread_root_queue_create(label, flags, attr, configure,
-			NULL);
-}
-
-#if DISPATCH_IOHID_SPI
-dispatch_queue_global_t
-_dispatch_pthread_root_queue_create_with_observer_hooks_4IOHID(const char *label,
-		unsigned long flags, const pthread_attr_t *attr,
-		dispatch_pthread_root_queue_observer_hooks_t observer_hooks,
-		dispatch_block_t configure)
-{
-	if (!observer_hooks->queue_will_execute ||
-			!observer_hooks->queue_did_execute) {
-		DISPATCH_CLIENT_CRASH(0, "Invalid pthread root queue observer hooks");
-	}
-	return _dispatch_pthread_root_queue_create(label, flags, attr, configure,
-			observer_hooks);
-}
-
-bool
-_dispatch_queue_is_exclusively_owned_by_current_thread_4IOHID(
-		dispatch_queue_t dq) // rdar://problem/18033810
-{
-	if (dq->dq_width != 1) {
-		DISPATCH_CLIENT_CRASH(dq->dq_width, "Invalid queue type");
-	}
-	uint64_t dq_state = os_atomic_load2o(dq, dq_state, relaxed);
-	return _dq_state_drain_locked_by_self(dq_state);
-}
-#endif
-
-dispatch_queue_global_t
-dispatch_pthread_root_queue_copy_current(void)
-{
-	dispatch_queue_t dq = _dispatch_queue_get_current();
-	if (!dq) return NULL;
-	while (unlikely(dq->do_targetq)) {
-		dq = dq->do_targetq;
-	}
-	if (dx_type(dq) != DISPATCH_QUEUE_PTHREAD_ROOT_TYPE) {
-		return NULL;
-	}
-	_os_object_retain_with_resurrect(dq->_as_os_obj);
-	return upcast(dq)._dgq;
-}
-
-void
-_dispatch_pthread_root_queue_dispose(dispatch_queue_global_t dq,
-		bool *allow_free)
-{
-	dispatch_pthread_root_queue_context_t pqc = dq->do_ctxt;
-
-	_dispatch_object_debug(dq, "%s", __func__);
-	_dispatch_trace_queue_dispose(dq);
-
-#if !defined(_WIN32)
-	pthread_attr_destroy(&pqc->dpq_thread_attr);
-#endif
-	_dispatch_semaphore_dispose(&pqc->dpq_thread_mediator, NULL);
-	if (pqc->dpq_thread_configure) {
-		Block_release(pqc->dpq_thread_configure);
-	}
-	dq->do_targetq = _dispatch_get_default_queue(false);
-	_dispatch_lane_class_dispose(dq, allow_free);
-}
-
-#endif // DISPATCH_USE_PTHREAD_ROOT_QUEUES
-#pragma mark -
-#pragma mark dispatch_runloop_queue
-
-DISPATCH_STATIC_GLOBAL(bool _dispatch_program_is_probably_callback_driven);
-
-#if DISPATCH_COCOA_COMPAT
-DISPATCH_STATIC_GLOBAL(dispatch_once_t _dispatch_main_q_handle_pred);
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dispatch_runloop_handle_is_valid(dispatch_runloop_handle_t handle)
-{
-#if TARGET_OS_MAC
-	return MACH_PORT_VALID(handle);
-#elif defined(__linux__)
-	return handle >= 0;
-#elif defined(_WIN32)
-	return handle != NULL;
-#else
-#error "runloop support not implemented on this platform"
-#endif
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_runloop_handle_t
-_dispatch_runloop_queue_get_handle(dispatch_lane_t dq)
-{
-#if TARGET_OS_MAC
-	return ((dispatch_runloop_handle_t)(uintptr_t)dq->do_ctxt);
-#elif defined(__linux__)
-	// decode: 0 is a valid fd, so offset by 1 to distinguish from NULL
-	return ((dispatch_runloop_handle_t)(uintptr_t)dq->do_ctxt) - 1;
-#elif defined(_WIN32)
-	return ((dispatch_runloop_handle_t)(uintptr_t)dq->do_ctxt);
-#else
-#error "runloop support not implemented on this platform"
-#endif
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_runloop_queue_set_handle(dispatch_lane_t dq,
-		dispatch_runloop_handle_t handle)
-{
-#if TARGET_OS_MAC
-	dq->do_ctxt = (void *)(uintptr_t)handle;
-#elif defined(__linux__)
-	// encode: 0 is a valid fd, so offset by 1 to distinguish from NULL
-	dq->do_ctxt = (void *)(uintptr_t)(handle + 1);
-#elif defined(_WIN32)
-	dq->do_ctxt = (void *)(uintptr_t)handle;
-#else
-#error "runloop support not implemented on this platform"
-#endif
-}
-
-static void
-_dispatch_runloop_queue_handle_init(void *ctxt)
-{
-	dispatch_lane_t dq = (dispatch_lane_t)ctxt;
-	dispatch_runloop_handle_t handle;
-
-	_dispatch_fork_becomes_unsafe();
-
-#if TARGET_OS_MAC
-	mach_port_options_t opts = {
-		.flags = MPO_CONTEXT_AS_GUARD | MPO_STRICT | MPO_INSERT_SEND_RIGHT,
-	};
-	mach_port_context_t guard = (uintptr_t)dq;
-	kern_return_t kr;
-	mach_port_t mp;
-
-	if (dx_type(dq) == DISPATCH_QUEUE_MAIN_TYPE) {
-		opts.flags |= MPO_QLIMIT;
-		opts.mpl.mpl_qlimit = 1;
-	}
-
-	kr = mach_port_construct(mach_task_self(), &opts, guard, &mp);
-	DISPATCH_VERIFY_MIG(kr);
-	(void)dispatch_assume_zero(kr);
-
-	handle = mp;
-#elif defined(__linux__)
-	int fd = eventfd(0, EFD_CLOEXEC | EFD_NONBLOCK);
-	if (fd == -1) {
-		int err = errno;
-		switch (err) {
-		case EMFILE:
-			DISPATCH_CLIENT_CRASH(err, "eventfd() failure: "
-					"process is out of file descriptors");
-			break;
-		case ENFILE:
-			DISPATCH_CLIENT_CRASH(err, "eventfd() failure: "
-					"system is out of file descriptors");
-			break;
-		case ENOMEM:
-			DISPATCH_CLIENT_CRASH(err, "eventfd() failure: "
-					"kernel is out of memory");
-			break;
-		default:
-			DISPATCH_INTERNAL_CRASH(err, "eventfd() failure");
-			break;
-		}
-	}
-	handle = fd;
-#elif defined(_WIN32)
-	HANDLE hEvent;
-	hEvent = CreateEventW(NULL, /*bManualReset=*/FALSE,
-		/*bInitialState=*/FALSE, NULL);
-	if (hEvent == NULL) {
-		DISPATCH_INTERNAL_CRASH(GetLastError(), "CreateEventW");
-	}
-	handle = hEvent;
-#else
-#error "runloop support not implemented on this platform"
-#endif
-	_dispatch_runloop_queue_set_handle(dq, handle);
-
-	_dispatch_program_is_probably_callback_driven = true;
-}
-
-static void
-_dispatch_runloop_queue_handle_dispose(dispatch_lane_t dq)
-{
-	dispatch_runloop_handle_t handle = _dispatch_runloop_queue_get_handle(dq);
-	if (!_dispatch_runloop_handle_is_valid(handle)) {
-		return;
-	}
-	dq->do_ctxt = NULL;
-#if TARGET_OS_MAC
-	mach_port_t mp = (mach_port_t)handle;
-	mach_port_context_t guard = (uintptr_t)dq;
-	kern_return_t kr;
-	kr = mach_port_destruct(mach_task_self(), mp, -1, guard);
-	DISPATCH_VERIFY_MIG(kr);
-	(void)dispatch_assume_zero(kr);
-#elif defined(__linux__)
-	int rc = close(handle);
-	(void)dispatch_assume_zero(rc);
-#elif defined(_WIN32)
-	BOOL bSuccess;
-	bSuccess = CloseHandle(handle);
-	(void)dispatch_assume(bSuccess);
-#else
-#error "runloop support not implemented on this platform"
-#endif
-}
-
-static inline void
-_dispatch_runloop_queue_class_poke(dispatch_lane_t dq)
-{
-	dispatch_runloop_handle_t handle = _dispatch_runloop_queue_get_handle(dq);
-	if (!_dispatch_runloop_handle_is_valid(handle)) {
-		return;
-	}
-
-	_dispatch_trace_runtime_event(worker_request, dq, 1);
-#if HAVE_MACH
-	mach_port_t mp = handle;
-	kern_return_t kr = _dispatch_send_wakeup_runloop_thread(mp, 0);
-	switch (kr) {
-	case MACH_SEND_TIMEOUT:
-	case MACH_SEND_TIMED_OUT:
-	case MACH_SEND_INVALID_DEST:
-		break;
-	default:
-		(void)dispatch_assume_zero(kr);
-		break;
-	}
-#elif defined(__linux__)
-	int result;
-	do {
-		result = eventfd_write(handle, 1);
-	} while (result == -1 && errno == EINTR);
-	(void)dispatch_assume_zero(result);
-#elif defined(_WIN32)
-	BOOL bSuccess;
-	bSuccess = SetEvent(handle);
-	(void)dispatch_assume(bSuccess);
-#else
-#error "runloop support not implemented on this platform"
-#endif
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_runloop_queue_poke(dispatch_lane_t dq, dispatch_qos_t qos,
-		dispatch_wakeup_flags_t flags)
-{
-	// it's not useful to handle WAKEUP_MAKE_DIRTY because mach_msg() will have
-	// a release barrier and that when runloop queues stop being thread-bound
-	// they have a non optional wake-up to start being a "normal" queue
-	// either in _dispatch_runloop_queue_xref_dispose,
-	// or in _dispatch_queue_cleanup2() for the main thread.
-	uint64_t old_state, new_state;
-
-	if (dx_type(dq) == DISPATCH_QUEUE_MAIN_TYPE) {
-		dispatch_once_f(&_dispatch_main_q_handle_pred, dq,
-				_dispatch_runloop_queue_handle_init);
-	}
-
-	os_atomic_rmw_loop2o(dq, dq_state, old_state, new_state, relaxed, {
-		new_state = _dq_state_merge_qos(old_state, qos);
-		if (old_state == new_state) {
-			os_atomic_rmw_loop_give_up(goto no_change);
-		}
-	});
-
-	dispatch_qos_t dq_qos = _dispatch_priority_qos(dq->dq_priority);
-	if (qos > dq_qos) {
-		mach_port_t owner = _dq_state_drain_owner(new_state);
-		pthread_priority_t pp = _dispatch_qos_to_pp(qos);
-		_dispatch_thread_override_start(owner, pp, dq);
-		if (_dq_state_max_qos(old_state) > dq_qos) {
-			_dispatch_thread_override_end(owner, dq);
-		}
-	}
-no_change:
-	_dispatch_runloop_queue_class_poke(dq);
-	if (flags & DISPATCH_WAKEUP_CONSUME_2) {
-		return _dispatch_release_2_tailcall(dq);
-	}
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_qos_t
-_dispatch_runloop_queue_reset_max_qos(dispatch_lane_t dq)
-{
-	uint64_t old_state, clear_bits = DISPATCH_QUEUE_MAX_QOS_MASK |
-			DISPATCH_QUEUE_RECEIVED_OVERRIDE;
-	old_state = os_atomic_and_orig2o(dq, dq_state, ~clear_bits, relaxed);
-	return _dq_state_max_qos(old_state);
-}
-
-void
-_dispatch_runloop_queue_wakeup(dispatch_lane_t dq, dispatch_qos_t qos,
-		dispatch_wakeup_flags_t flags)
-{
-	if (unlikely(_dispatch_queue_atomic_flags(dq) & DQF_RELEASED)) {
-		// <rdar://problem/14026816>
-		return _dispatch_lane_wakeup(dq, qos, flags);
-	}
-
-	if (flags & DISPATCH_WAKEUP_MAKE_DIRTY) {
-		os_atomic_or2o(dq, dq_state, DISPATCH_QUEUE_DIRTY, release);
-	}
-	if (_dispatch_queue_class_probe(dq)) {
-		return _dispatch_runloop_queue_poke(dq, qos, flags);
-	}
-
-	qos = _dispatch_runloop_queue_reset_max_qos(dq);
-	if (qos) {
-		mach_port_t owner = DISPATCH_QUEUE_DRAIN_OWNER(dq);
-		if (_dispatch_queue_class_probe(dq)) {
-			_dispatch_runloop_queue_poke(dq, qos, flags);
-		}
-		_dispatch_thread_override_end(owner, dq);
-		return;
-	}
-	if (flags & DISPATCH_WAKEUP_CONSUME_2) {
-		return _dispatch_release_2_tailcall(dq);
-	}
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_main_queue_update_priority_from_thread(void)
-{
-	dispatch_queue_main_t dq = &_dispatch_main_q;
-	uint64_t dq_state = os_atomic_load2o(dq, dq_state, relaxed);
-	mach_port_t owner = _dq_state_drain_owner(dq_state);
-
-	dispatch_priority_t main_pri =
-			_dispatch_priority_from_pp_strip_flags(_dispatch_get_priority());
-	dispatch_qos_t main_qos = _dispatch_priority_qos(main_pri);
-	dispatch_qos_t max_qos = _dq_state_max_qos(dq_state);
-	dispatch_qos_t old_qos = _dispatch_priority_qos(dq->dq_priority);
-
-	// the main thread QoS was adjusted by someone else, learn the new QoS
-	// and reinitialize _dispatch_main_q.dq_priority
-	dq->dq_priority = main_pri;
-
-	if (old_qos < max_qos && main_qos == DISPATCH_QOS_UNSPECIFIED) {
-		// main thread is opted out of QoS and we had an override
-		return _dispatch_thread_override_end(owner, dq);
-	}
-
-	if (old_qos < max_qos && max_qos <= main_qos) {
-		// main QoS was raised, and we had an override which is now useless
-		return _dispatch_thread_override_end(owner, dq);
-	}
-
-	if (main_qos < max_qos && max_qos <= old_qos) {
-		// main thread QoS was lowered, and we actually need an override
-		pthread_priority_t pp = _dispatch_qos_to_pp(max_qos);
-		return _dispatch_thread_override_start(owner, pp, dq);
-	}
-}
-
-static void
-_dispatch_main_queue_drain(dispatch_queue_main_t dq)
-{
-	dispatch_thread_frame_s dtf;
-
-	if (!dq->dq_items_tail) {
-		return;
-	}
-
-	_dispatch_perfmon_start_notrace();
-	if (unlikely(!_dispatch_queue_is_thread_bound(dq))) {
-		DISPATCH_CLIENT_CRASH(0, "_dispatch_main_queue_callback_4CF called"
-				" after dispatch_main()");
-	}
-	uint64_t dq_state = os_atomic_load2o(dq, dq_state, relaxed);
-	if (unlikely(!_dq_state_drain_locked_by_self(dq_state))) {
-		DISPATCH_CLIENT_CRASH((uintptr_t)dq_state,
-				"_dispatch_main_queue_callback_4CF called"
-				" from the wrong thread");
-	}
-
-	dispatch_once_f(&_dispatch_main_q_handle_pred, dq,
-			_dispatch_runloop_queue_handle_init);
-
-	// <rdar://problem/23256682> hide the frame chaining when CFRunLoop
-	// drains the main runloop, as this should not be observable that way
-	_dispatch_adopt_wlh_anon();
-	_dispatch_thread_frame_push_and_rebase(&dtf, dq, NULL);
-
-	pthread_priority_t pp = _dispatch_get_priority();
-	dispatch_priority_t pri = _dispatch_priority_from_pp(pp);
-	dispatch_qos_t qos = _dispatch_priority_qos(pri);
-	voucher_t voucher = _voucher_copy();
-
-	if (unlikely(qos != _dispatch_priority_qos(dq->dq_priority))) {
-		_dispatch_main_queue_update_priority_from_thread();
-	}
-	dispatch_priority_t old_dbp = _dispatch_set_basepri(pri);
-	_dispatch_set_basepri_override_qos(DISPATCH_QOS_SATURATED);
-
-	dispatch_invoke_context_s dic = { };
-	struct dispatch_object_s *dc, *next_dc, *tail;
-	dc = os_mpsc_capture_snapshot(os_mpsc(dq, dq_items), &tail);
-	do {
-		next_dc = os_mpsc_pop_snapshot_head(dc, tail, do_next);
-		_dispatch_continuation_pop_inline(dc, &dic,
-				DISPATCH_INVOKE_THREAD_BOUND, dq);
-	} while ((dc = next_dc));
-
-	dx_wakeup(dq->_as_dq, 0, 0);
-	_dispatch_voucher_debug("main queue restore", voucher);
-	_dispatch_reset_basepri(old_dbp);
-	_dispatch_reset_basepri_override();
-	_dispatch_reset_priority_and_voucher(pp, voucher);
-	_dispatch_thread_frame_pop(&dtf);
-	_dispatch_reset_wlh();
-	_dispatch_force_cache_cleanup();
-	_dispatch_perfmon_end_notrace();
-}
-
-static bool
-_dispatch_runloop_queue_drain_one(dispatch_lane_t dq)
-{
-	if (!dq->dq_items_tail) {
-		return false;
-	}
-	_dispatch_perfmon_start_notrace();
-	dispatch_thread_frame_s dtf;
-	bool should_reset_wlh = _dispatch_adopt_wlh_anon_recurse();
-	_dispatch_thread_frame_push(&dtf, dq);
-	pthread_priority_t pp = _dispatch_get_priority();
-	dispatch_priority_t pri = _dispatch_priority_from_pp(pp);
-	voucher_t voucher = _voucher_copy();
-	dispatch_priority_t old_dbp = _dispatch_set_basepri(pri);
-	_dispatch_set_basepri_override_qos(DISPATCH_QOS_SATURATED);
-
-	dispatch_invoke_context_s dic = { };
-	struct dispatch_object_s *dc, *next_dc;
-	dc = _dispatch_queue_get_head(dq);
-	next_dc = _dispatch_queue_pop_head(dq, dc);
-	_dispatch_continuation_pop_inline(dc, &dic,
-			DISPATCH_INVOKE_THREAD_BOUND, dq);
-
-	if (!next_dc) {
-		dx_wakeup(dq, 0, 0);
-	}
-
-	_dispatch_voucher_debug("runloop queue restore", voucher);
-	_dispatch_reset_basepri(old_dbp);
-	_dispatch_reset_basepri_override();
-	_dispatch_reset_priority_and_voucher(pp, voucher);
-	_dispatch_thread_frame_pop(&dtf);
-	if (should_reset_wlh) _dispatch_reset_wlh();
-	_dispatch_force_cache_cleanup();
-	_dispatch_perfmon_end_notrace();
-	return next_dc;
-}
-
-dispatch_queue_serial_t
-_dispatch_runloop_root_queue_create_4CF(const char *label, unsigned long flags)
-{
-	pthread_priority_t pp = _dispatch_get_priority();
-	dispatch_lane_t dq;
-
-	if (unlikely(flags)) {
-		return DISPATCH_BAD_INPUT;
-	}
-	dq = _dispatch_object_alloc(DISPATCH_VTABLE(queue_runloop),
-			sizeof(struct dispatch_lane_s));
-	_dispatch_queue_init(dq, DQF_THREAD_BOUND, 1,
-			DISPATCH_QUEUE_ROLE_BASE_ANON);
-	dq->do_targetq = _dispatch_get_default_queue(true);
-	dq->dq_label = label ? label : "runloop-queue"; // no-copy contract
-	if (pp & _PTHREAD_PRIORITY_QOS_CLASS_MASK) {
-		dq->dq_priority = _dispatch_priority_from_pp_strip_flags(pp);
-	}
-	_dispatch_runloop_queue_handle_init(dq);
-	_dispatch_queue_set_bound_thread(dq);
-	_dispatch_object_debug(dq, "%s", __func__);
-	return _dispatch_trace_queue_create(dq)._dl;
-}
-
-void
-_dispatch_runloop_queue_xref_dispose(dispatch_lane_t dq)
-{
-	_dispatch_object_debug(dq, "%s", __func__);
-
-	dispatch_qos_t qos = _dispatch_runloop_queue_reset_max_qos(dq);
-	_dispatch_queue_clear_bound_thread(dq);
-	dx_wakeup(dq, qos, DISPATCH_WAKEUP_MAKE_DIRTY);
-	if (qos) _dispatch_thread_override_end(DISPATCH_QUEUE_DRAIN_OWNER(dq), dq);
-}
-
-void
-_dispatch_runloop_queue_dispose(dispatch_lane_t dq, bool *allow_free)
-{
-	_dispatch_object_debug(dq, "%s", __func__);
-	_dispatch_trace_queue_dispose(dq);
-	_dispatch_runloop_queue_handle_dispose(dq);
-	_dispatch_lane_class_dispose(dq, allow_free);
-}
-
-bool
-_dispatch_runloop_root_queue_perform_4CF(dispatch_queue_t dq)
-{
-	if (unlikely(dx_type(dq) != DISPATCH_QUEUE_RUNLOOP_TYPE)) {
-		DISPATCH_CLIENT_CRASH(dx_type(dq), "Not a runloop queue");
-	}
-	dispatch_retain(dq);
-	bool r = _dispatch_runloop_queue_drain_one(upcast(dq)._dl);
-	dispatch_release(dq);
-	return r;
-}
-
-void
-_dispatch_runloop_root_queue_wakeup_4CF(dispatch_queue_t dq)
-{
-	if (unlikely(dx_type(dq) != DISPATCH_QUEUE_RUNLOOP_TYPE)) {
-		DISPATCH_CLIENT_CRASH(dx_type(dq), "Not a runloop queue");
-	}
-	_dispatch_runloop_queue_wakeup(upcast(dq)._dl, 0, false);
-}
-
-#if TARGET_OS_MAC || defined(_WIN32)
-dispatch_runloop_handle_t
-_dispatch_runloop_root_queue_get_port_4CF(dispatch_queue_t dq)
-{
-	if (unlikely(dx_type(dq) != DISPATCH_QUEUE_RUNLOOP_TYPE)) {
-		DISPATCH_CLIENT_CRASH(dx_type(dq), "Not a runloop queue");
-	}
-	return _dispatch_runloop_queue_get_handle(upcast(dq)._dl);
-}
-#endif
-
-#endif // DISPATCH_COCOA_COMPAT
-#pragma mark -
-#pragma mark dispatch_main_queue
-#if DISPATCH_COCOA_COMPAT
-
-dispatch_runloop_handle_t
-_dispatch_get_main_queue_handle_4CF(void)
-{
-	dispatch_queue_main_t dq = &_dispatch_main_q;
-	dispatch_once_f(&_dispatch_main_q_handle_pred, dq,
-			_dispatch_runloop_queue_handle_init);
-	return _dispatch_runloop_queue_get_handle(dq->_as_dl);
-}
-
-dispatch_runloop_handle_t
-_dispatch_get_main_queue_port_4CF(void)
-{
-	return _dispatch_get_main_queue_handle_4CF();
-}
-
-void
-_dispatch_main_queue_callback_4CF(
-		void *ignored DISPATCH_UNUSED)
-{
-	// the main queue cannot be suspended and no-one looks at this bit
-	// so abuse it to avoid dirtying more memory
-
-	if (_dispatch_main_q.dq_side_suspend_cnt) {
-		return;
-	}
-	_dispatch_main_q.dq_side_suspend_cnt = true;
-	_dispatch_main_queue_drain(&_dispatch_main_q);
-	_dispatch_main_q.dq_side_suspend_cnt = false;
-}
-
-#endif // DISPATCH_COCOA_COMPAT
-
-DISPATCH_NOINLINE
-void
-_dispatch_main_queue_push(dispatch_queue_main_t dq, dispatch_object_t dou,
-		dispatch_qos_t qos)
-{
-	// Same as _dispatch_lane_push() but without the refcounting due to being
-	// a global object
-	if (_dispatch_queue_push_item(dq, dou)) {
-		return dx_wakeup(dq, qos, DISPATCH_WAKEUP_MAKE_DIRTY);
-	}
-
-	qos = _dispatch_queue_push_qos(dq, qos);
-	if (_dispatch_queue_need_override(dq, qos)) {
-		return dx_wakeup(dq, qos, 0);
-	}
-}
-
-void
-_dispatch_main_queue_wakeup(dispatch_queue_main_t dq, dispatch_qos_t qos,
-		dispatch_wakeup_flags_t flags)
-{
-#if DISPATCH_COCOA_COMPAT
-	if (_dispatch_queue_is_thread_bound(dq)) {
-		return _dispatch_runloop_queue_wakeup(dq->_as_dl, qos, flags);
-	}
-#endif
-	return _dispatch_lane_wakeup(dq, qos, flags);
-}
-
-#if !defined(_WIN32)
-DISPATCH_NOINLINE DISPATCH_NORETURN
-static void
-_dispatch_sigsuspend(void)
-{
-	static const sigset_t mask;
-
-	for (;;) {
-		sigsuspend(&mask);
-	}
-}
-#endif // !defined(_WIN32)
-
-DISPATCH_NORETURN
-static void
-_dispatch_sig_thread(void *ctxt DISPATCH_UNUSED)
-{
-	// never returns, so burn bridges behind us
-	_dispatch_clear_stack(0);
-#if defined(_WIN32)
-	Sleep(INFINITE);
-#else
-	_dispatch_sigsuspend();
-#endif
-}
-
-void
-dispatch_main(void)
-{
-	_dispatch_root_queues_init();
-#if HAVE_PTHREAD_MAIN_NP
-	if (pthread_main_np()) {
-#endif
-		_dispatch_object_debug(&_dispatch_main_q, "%s", __func__);
-		_dispatch_program_is_probably_callback_driven = true;
-		_dispatch_ktrace0(ARIADNE_ENTER_DISPATCH_MAIN_CODE);
-#ifdef __linux__
-		// On Linux, if the main thread calls pthread_exit, the process becomes a zombie.
-		// To avoid that, just before calling pthread_exit we register a TSD destructor
-		// that will call _dispatch_sig_thread -- thus capturing the main thread in sigsuspend.
-		// This relies on an implementation detail (currently true in glibc) that TSD destructors
-		// will be called in the order of creation to cause all the TSD cleanup functions to
-		// run before the thread becomes trapped in sigsuspend.
-		pthread_key_t dispatch_main_key;
-		pthread_key_create(&dispatch_main_key, _dispatch_sig_thread);
-		pthread_setspecific(dispatch_main_key, &dispatch_main_key);
-		_dispatch_sigmask();
-#endif
-#if !defined(_WIN32)
-		pthread_exit(NULL);
-#else
-		_endthreadex(0);
-#endif // defined(_WIN32)
-		DISPATCH_INTERNAL_CRASH(errno, "pthread_exit() returned");
-#if HAVE_PTHREAD_MAIN_NP
-	}
-	DISPATCH_CLIENT_CRASH(0, "dispatch_main() must be called on the main thread");
-#endif
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_queue_cleanup2(void)
-{
-	dispatch_queue_main_t dq = &_dispatch_main_q;
-	uint64_t old_state, new_state;
-
-	// Turning the main queue from a runloop queue into an ordinary serial queue
-	// is a 3 steps operation:
-	// 1. finish taking the main queue lock the usual way
-	// 2. clear the THREAD_BOUND flag
-	// 3. do a handoff
-	//
-	// If an enqueuer executes concurrently, he may do the wakeup the runloop
-	// way, because he still believes the queue to be thread-bound, but the
-	// dirty bit will force this codepath to notice the enqueue, and the usual
-	// lock transfer will do the proper wakeup.
-	os_atomic_rmw_loop2o(dq, dq_state, old_state, new_state, acquire, {
-		new_state = old_state & ~DISPATCH_QUEUE_DIRTY;
-		new_state += DISPATCH_QUEUE_WIDTH_INTERVAL;
-		new_state += DISPATCH_QUEUE_IN_BARRIER;
-	});
-	_dispatch_queue_atomic_flags_clear(dq, DQF_THREAD_BOUND);
-	_dispatch_lane_barrier_complete(dq, 0, 0);
-
-	// overload the "probably" variable to mean that dispatch_main() or
-	// similar non-POSIX API was called
-	// this has to run before the DISPATCH_COCOA_COMPAT below
-	// See dispatch_main for call to _dispatch_sig_thread on linux.
-#ifndef __linux__
-	if (_dispatch_program_is_probably_callback_driven) {
-		_dispatch_barrier_async_detached_f(_dispatch_get_default_queue(true),
-				NULL, _dispatch_sig_thread);
-		sleep(1); // workaround 6778970
-	}
-#endif
-
-#if DISPATCH_COCOA_COMPAT
-	dispatch_once_f(&_dispatch_main_q_handle_pred, dq,
-			_dispatch_runloop_queue_handle_init);
-	_dispatch_runloop_queue_handle_dispose(dq->_as_dl);
-#endif
-}
-
-static void DISPATCH_TSD_DTOR_CC
-_dispatch_queue_cleanup(void *ctxt)
-{
-	if (ctxt == &_dispatch_main_q) {
-		return _dispatch_queue_cleanup2();
-	}
-	// POSIX defines that destructors are only called if 'ctxt' is non-null
-	DISPATCH_INTERNAL_CRASH(ctxt,
-			"Premature thread exit while a dispatch queue is running");
-}
-
-static void DISPATCH_TSD_DTOR_CC
-_dispatch_wlh_cleanup(void *ctxt)
-{
-	// POSIX defines that destructors are only called if 'ctxt' is non-null
-	dispatch_queue_t wlh;
-	wlh = (dispatch_queue_t)((uintptr_t)ctxt & ~DISPATCH_WLH_STORAGE_REF);
-	_dispatch_queue_release_storage(wlh);
-}
-
-DISPATCH_NORETURN
-static void DISPATCH_TSD_DTOR_CC
-_dispatch_deferred_items_cleanup(void *ctxt)
-{
-	// POSIX defines that destructors are only called if 'ctxt' is non-null
-	DISPATCH_INTERNAL_CRASH(ctxt,
-			"Premature thread exit with unhandled deferred items");
-}
-
-DISPATCH_NORETURN
-static DISPATCH_TSD_DTOR_CC void
-_dispatch_frame_cleanup(void *ctxt)
-{
-	// POSIX defines that destructors are only called if 'ctxt' is non-null
-	DISPATCH_INTERNAL_CRASH(ctxt,
-			"Premature thread exit while a dispatch frame is active");
-}
-
-DISPATCH_NORETURN
-static void DISPATCH_TSD_DTOR_CC
-_dispatch_context_cleanup(void *ctxt)
-{
-	// POSIX defines that destructors are only called if 'ctxt' is non-null
-	DISPATCH_INTERNAL_CRASH(ctxt,
-			"Premature thread exit while a dispatch context is set");
-}
-#pragma mark -
-#pragma mark dispatch_init
-
-static void
-_dispatch_root_queues_init_once(void *context DISPATCH_UNUSED)
-{
-	_dispatch_fork_becomes_unsafe();
-#if DISPATCH_USE_INTERNAL_WORKQUEUE
-	size_t i;
-	for (i = 0; i < DISPATCH_ROOT_QUEUE_COUNT; i++) {
-		_dispatch_root_queue_init_pthread_pool(&_dispatch_root_queues[i], 0,
-				_dispatch_root_queues[i].dq_priority);
-	}
-#else
-	int wq_supported = _pthread_workqueue_supported();
-	int r = ENOTSUP;
-
-	if (!(wq_supported & WORKQ_FEATURE_MAINTENANCE)) {
-		DISPATCH_INTERNAL_CRASH(wq_supported,
-				"QoS Maintenance support required");
-	}
-
-	if (unlikely(!_dispatch_kevent_workqueue_enabled)) {
-		r = _pthread_workqueue_init(_dispatch_worker_thread2,
-				offsetof(struct dispatch_queue_s, dq_serialnum), 0);
-#if DISPATCH_USE_KEVENT_WORKLOOP
-	} else if (wq_supported & WORKQ_FEATURE_WORKLOOP) {
-		r = _pthread_workqueue_init_with_workloop(_dispatch_worker_thread2,
-				(pthread_workqueue_function_kevent_t)
-				_dispatch_kevent_worker_thread,
-				(pthread_workqueue_function_workloop_t)
-				_dispatch_workloop_worker_thread,
-				offsetof(struct dispatch_queue_s, dq_serialnum), 0);
-#endif // DISPATCH_USE_KEVENT_WORKLOOP
-#if DISPATCH_USE_KEVENT_WORKQUEUE
-	} else if (wq_supported & WORKQ_FEATURE_KEVENT) {
-		r = _pthread_workqueue_init_with_kevent(_dispatch_worker_thread2,
-				(pthread_workqueue_function_kevent_t)
-				_dispatch_kevent_worker_thread,
-				offsetof(struct dispatch_queue_s, dq_serialnum), 0);
-#endif
-	} else {
-		DISPATCH_INTERNAL_CRASH(wq_supported, "Missing Kevent WORKQ support");
-	}
-
-	if (r != 0) {
-		DISPATCH_INTERNAL_CRASH((r << 16) | wq_supported,
-				"Root queue initialization failed");
-	}
-#endif // DISPATCH_USE_INTERNAL_WORKQUEUE
-}
-
-DISPATCH_STATIC_GLOBAL(dispatch_once_t _dispatch_root_queues_pred);
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_root_queues_init(void)
-{
-	dispatch_once_f(&_dispatch_root_queues_pred, NULL,
-			_dispatch_root_queues_init_once);
-}
-
-DISPATCH_EXPORT DISPATCH_NOTHROW
-void
-libdispatch_init(void)
-{
-	dispatch_assert(sizeof(struct dispatch_apply_s) <=
-			DISPATCH_CONTINUATION_SIZE);
-
-	if (_dispatch_getenv_bool("LIBDISPATCH_STRICT", false)) {
-		_dispatch_mode |= DISPATCH_MODE_STRICT;
-	}
-#if HAVE_OS_FAULT_WITH_PAYLOAD && TARGET_OS_IPHONE && !TARGET_OS_SIMULATOR
-	if (_dispatch_getenv_bool("LIBDISPATCH_NO_FAULTS", false)) {
-		_dispatch_mode |= DISPATCH_MODE_NO_FAULTS;
-	} else if (getpid() == 1 ||
-			!os_variant_has_internal_diagnostics("com.apple.libdispatch")) {
-		_dispatch_mode |= DISPATCH_MODE_NO_FAULTS;
-	}
-#endif // HAVE_OS_FAULT_WITH_PAYLOAD && TARGET_OS_IPHONE && !TARGET_OS_SIMULATOR
-
-
-#if DISPATCH_DEBUG || DISPATCH_PROFILE
-#if DISPATCH_USE_KEVENT_WORKQUEUE
-	if (getenv("LIBDISPATCH_DISABLE_KEVENT_WQ")) {
-		_dispatch_kevent_workqueue_enabled = false;
-	}
-#endif
-#endif
-
-#if HAVE_PTHREAD_WORKQUEUE_QOS
-	dispatch_qos_t qos = _dispatch_qos_from_qos_class(qos_class_main());
-	_dispatch_main_q.dq_priority = _dispatch_priority_make(qos, 0);
-#if DISPATCH_DEBUG
-	if (!getenv("LIBDISPATCH_DISABLE_SET_QOS")) {
-		_dispatch_set_qos_class_enabled = 1;
-	}
-#endif
-#endif
-
-#if DISPATCH_USE_THREAD_LOCAL_STORAGE
-	_dispatch_thread_key_create(&__dispatch_tsd_key, _libdispatch_tsd_cleanup);
-#else
-	_dispatch_thread_key_create(&dispatch_priority_key, NULL);
-	_dispatch_thread_key_create(&dispatch_r2k_key, NULL);
-	_dispatch_thread_key_create(&dispatch_queue_key, _dispatch_queue_cleanup);
-	_dispatch_thread_key_create(&dispatch_frame_key, _dispatch_frame_cleanup);
-	_dispatch_thread_key_create(&dispatch_cache_key, _dispatch_cache_cleanup);
-	_dispatch_thread_key_create(&dispatch_context_key, _dispatch_context_cleanup);
-	_dispatch_thread_key_create(&dispatch_pthread_root_queue_observer_hooks_key,
-			NULL);
-	_dispatch_thread_key_create(&dispatch_basepri_key, NULL);
-#if DISPATCH_INTROSPECTION
-	_dispatch_thread_key_create(&dispatch_introspection_key , NULL);
-#elif DISPATCH_PERF_MON
-	_dispatch_thread_key_create(&dispatch_bcounter_key, NULL);
-#endif
-	_dispatch_thread_key_create(&dispatch_wlh_key, _dispatch_wlh_cleanup);
-	_dispatch_thread_key_create(&dispatch_voucher_key, _voucher_thread_cleanup);
-	_dispatch_thread_key_create(&dispatch_deferred_items_key,
-			_dispatch_deferred_items_cleanup);
-#endif
-
-#if DISPATCH_USE_RESOLVERS // rdar://problem/8541707
-	_dispatch_main_q.do_targetq = _dispatch_get_default_queue(true);
-#endif
-
-	_dispatch_queue_set_current(&_dispatch_main_q);
-	_dispatch_queue_set_bound_thread(&_dispatch_main_q);
-
-#if DISPATCH_USE_PTHREAD_ATFORK
-	(void)dispatch_assume_zero(pthread_atfork(dispatch_atfork_prepare,
-			dispatch_atfork_parent, dispatch_atfork_child));
-#endif
-	_dispatch_hw_config_init();
-	_dispatch_time_init();
-	_dispatch_vtable_init();
-	_os_object_init();
-	_voucher_init();
-	_dispatch_introspection_init();
-}
-
-#if DISPATCH_USE_THREAD_LOCAL_STORAGE
-#if defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))
-#include <unistd.h>
-#endif
-#if !defined(_WIN32)
-#include <sys/syscall.h>
-#endif
-
-#ifdef SYS_gettid
-DISPATCH_ALWAYS_INLINE
-static inline pid_t
-_gettid(void)
-{
-	return (pid_t)syscall(SYS_gettid);
-}
-#elif defined(__FreeBSD__)
-DISPATCH_ALWAYS_INLINE
-static inline pid_t
-_gettid(void)
-{
-	return (pid_t)pthread_getthreadid_np();
-}
-#elif defined(_WIN32)
-DISPATCH_ALWAYS_INLINE
-static inline DWORD
-_gettid(void)
-{
-	return GetCurrentThreadId();
-}
-#else
-#error "SYS_gettid unavailable on this system"
-#endif /* SYS_gettid */
-
-#define _tsd_call_cleanup(k, f)  do { \
-		if ((f) && tsd->k) ((void(*)(void*))(f))(tsd->k); \
-	} while (0)
-
-#ifdef __ANDROID__
-static void (*_dispatch_thread_detach_callback)(void);
-
-void
-_dispatch_install_thread_detach_callback(void (*cb)(void))
-{
-	if (os_atomic_xchg(&_dispatch_thread_detach_callback, cb, relaxed)) {
-		DISPATCH_CLIENT_CRASH(0, "Installing a thread detach callback twice");
-	}
-}
-#endif
-
-#if defined(_WIN32)
-static bool
-_dispatch_process_is_exiting(void)
-{
-   // The goal here is to detect if the current thread is executing cleanup
-   // code (e.g. FLS destructors) as a result of calling ExitProcess(). Windows
-   // doesn't provide an official method of getting this information, so we
-   // take advantage of how ExitProcess() works internally. The first thing
-   // that it does (according to MSDN) is terminate every other thread in the
-   // process. Logically, it should not be possible to create more threads
-   // after this point, and Windows indeed enforces this. Try to create a
-   // lightweight suspended thread, and if access is denied, assume that this
-   // is because the process is exiting.
-   //
-   // We aren't worried about any race conditions here during process exit.
-   // Cleanup code is only run on the thread that already called ExitProcess(),
-   // and every other thread will have been forcibly terminated by the time
-   // that happens. Additionally, while CreateThread() could conceivably fail
-   // due to resource exhaustion, the process would already be in a bad state
-   // if that happens. This is only intended to prevent unwanted cleanup code
-   // from running, so the worst case is that a thread doesn't clean up after
-   // itself when the process is about to die anyway.
-   const size_t stack_size = 1;  // As small as possible
-   HANDLE thread = CreateThread(NULL, stack_size, NULL, NULL,
-           CREATE_SUSPENDED | STACK_SIZE_PARAM_IS_A_RESERVATION, NULL);
-   if (thread) {
-       // Although Microsoft recommends against using TerminateThread, it's
-       // safe to use it here because we know that the thread is suspended and
-       // it has not executed any code due to a NULL lpStartAddress. There was
-       // a bug in Windows Server 2003 and Windows XP where the initial stack
-       // would not be freed, but libdispatch does not support them anyway.
-       TerminateThread(thread, 0);
-       CloseHandle(thread);
-       return false;
-   }
-   return GetLastError() == ERROR_ACCESS_DENIED;
-}
-#endif // defined(_WIN32)
-
-
-void DISPATCH_TSD_DTOR_CC
-_libdispatch_tsd_cleanup(void *ctx)
-{
-#if defined(_WIN32)
-   // On Windows, exiting a process will still call FLS destructors for the
-   // thread that called ExitProcess(). pthreads-based platforms don't call key
-   // destructors on exit, so be consistent.
-   if (_dispatch_process_is_exiting()) {
-       return;
-   }
-#endif // defined(_WIN32)
-
-	struct dispatch_tsd *tsd = (struct dispatch_tsd*) ctx;
-
-	_tsd_call_cleanup(dispatch_priority_key, NULL);
-	_tsd_call_cleanup(dispatch_r2k_key, NULL);
-
-	_tsd_call_cleanup(dispatch_queue_key, _dispatch_queue_cleanup);
-	_tsd_call_cleanup(dispatch_frame_key, _dispatch_frame_cleanup);
-	_tsd_call_cleanup(dispatch_cache_key, _dispatch_cache_cleanup);
-	_tsd_call_cleanup(dispatch_context_key, _dispatch_context_cleanup);
-	_tsd_call_cleanup(dispatch_pthread_root_queue_observer_hooks_key,
-			NULL);
-	_tsd_call_cleanup(dispatch_basepri_key, NULL);
-#if DISPATCH_INTROSPECTION
-	_tsd_call_cleanup(dispatch_introspection_key, NULL);
-#elif DISPATCH_PERF_MON
-	_tsd_call_cleanup(dispatch_bcounter_key, NULL);
-#endif
-	_tsd_call_cleanup(dispatch_wlh_key, _dispatch_wlh_cleanup);
-	_tsd_call_cleanup(dispatch_voucher_key, _voucher_thread_cleanup);
-	_tsd_call_cleanup(dispatch_deferred_items_key,
-			_dispatch_deferred_items_cleanup);
-#ifdef __ANDROID__
-	if (_dispatch_thread_detach_callback) {
-		_dispatch_thread_detach_callback();
-	}
-#endif
-	tsd->tid = 0;
-}
-
-DISPATCH_NOINLINE
-void
-libdispatch_tsd_init(void)
-{
-#if !defined(_WIN32)
-	pthread_setspecific(__dispatch_tsd_key, &__dispatch_tsd);
-#else
-	FlsSetValue(__dispatch_tsd_key, &__dispatch_tsd);
-#endif // defined(_WIN32)
-	__dispatch_tsd.tid = _gettid();
-}
-#endif
-
-DISPATCH_NOTHROW
-void
-_dispatch_queue_atfork_child(void)
-{
-	dispatch_queue_main_t main_q = &_dispatch_main_q;
-	void *crash = (void *)0x100;
-	size_t i;
-
-	if (_dispatch_queue_is_thread_bound(main_q)) {
-		_dispatch_queue_set_bound_thread(main_q);
-	}
-
-	if (!_dispatch_is_multithreaded_inline()) return;
-
-	main_q->dq_items_head = crash;
-	main_q->dq_items_tail = crash;
-
-	_dispatch_mgr_q.dq_items_head = crash;
-	_dispatch_mgr_q.dq_items_tail = crash;
-
-	for (i = 0; i < DISPATCH_ROOT_QUEUE_COUNT; i++) {
-		_dispatch_root_queues[i].dq_items_head = crash;
-		_dispatch_root_queues[i].dq_items_tail = crash;
-	}
-}
-
-DISPATCH_NOINLINE
-void
-_dispatch_fork_becomes_unsafe_slow(void)
-{
-	uint8_t value = os_atomic_or(&_dispatch_unsafe_fork,
-			_DISPATCH_UNSAFE_FORK_MULTITHREADED, relaxed);
-	if (value & _DISPATCH_UNSAFE_FORK_PROHIBIT) {
-		DISPATCH_CLIENT_CRASH(0, "Transition to multithreaded is prohibited");
-	}
-}
-
-DISPATCH_NOINLINE
-void
-_dispatch_prohibit_transition_to_multithreaded(bool prohibit)
-{
-	if (prohibit) {
-		uint8_t value = os_atomic_or(&_dispatch_unsafe_fork,
-				_DISPATCH_UNSAFE_FORK_PROHIBIT, relaxed);
-		if (value & _DISPATCH_UNSAFE_FORK_MULTITHREADED) {
-			DISPATCH_CLIENT_CRASH(0, "The executable is already multithreaded");
-		}
-	} else {
-		os_atomic_and(&_dispatch_unsafe_fork,
-				(uint8_t)~_DISPATCH_UNSAFE_FORK_PROHIBIT, relaxed);
-	}
-}
--- a/Telegram/ThirdParty/dispatch/src/queue_internal.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/queue_internal.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,1239 +0,0 @@
-/*
- * Copyright (c) 2008-2013 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-/*
- * IMPORTANT: This header file describes INTERNAL interfaces to libdispatch
- * which are subject to change in future releases of Mac OS X. Any applications
- * relying on these interfaces WILL break.
- */
-
-#ifndef __DISPATCH_QUEUE_INTERNAL__
-#define __DISPATCH_QUEUE_INTERNAL__
-
-#ifndef __DISPATCH_INDIRECT__
-#error "Please #include <dispatch/dispatch.h> instead of this file directly."
-#include <dispatch/base.h> // for HeaderDoc
-#endif
-
-#pragma mark -
-#pragma mark dispatch_queue_flags, dq_state
-
-DISPATCH_ENUM(dispatch_queue_flags, uint32_t,
-	DQF_NONE                = 0x00000000,
-	DQF_AUTORELEASE_ALWAYS  = 0x00010000,
-	DQF_AUTORELEASE_NEVER   = 0x00020000,
-#define _DQF_AUTORELEASE_MASK 0x00030000
-	DQF_THREAD_BOUND        = 0x00040000, // queue is bound to a thread
-	DQF_BARRIER_BIT         = 0x00080000, // queue is a barrier on its target
-	DQF_TARGETED            = 0x00100000, // queue is targeted by another object
-	DQF_LABEL_NEEDS_FREE    = 0x00200000, // queue label was strdup()ed
-	DQF_MUTABLE             = 0x00400000,
-	DQF_RELEASED            = 0x00800000, // xref_cnt == -1
-
-	//
-	// Only applies to sources
-	//
-	// @const DSF_STRICT
-	// Semantics of the source are strict (implies DQF_MUTABLE being unset):
-	// - handlers can't be changed past activation
-	// - EV_VANISHED causes a hard failure
-	// - source can't change WLH
-	//
-	// @const DSF_WLH_CHANGED
-	// The wlh for the source changed (due to retarget past activation).
-	// Only used for debugging and diagnostics purposes.
-	//
-	// @const DSF_CANCELED
-	// Explicit cancelation has been requested.
-	//
-	// @const DSF_CANCEL_WAITER
-	// At least one caller of dispatch_source_cancel_and_wait() is waiting on
-	// the cancelation to finish. DSF_CANCELED must be set if this bit is set.
-	//
-	// @const DSF_NEEDS_EVENT
-	// The source has started to delete its unotes due to cancelation, but
-	// couldn't finish its unregistration and is waiting for some asynchronous
-	// events to fire to be able to.
-	//
-	// This flag prevents spurious wakeups when the source state machine
-	// requires specific events to make progress. Events that are likely
-	// to unblock a source state machine pass DISPATCH_WAKEUP_EVENT
-	// which neuters the effect of DSF_NEEDS_EVENT.
-	//
-	// @const DSF_DELETED
-	// The source can now only be used as a queue and is not allowed to register
-	// any new unote anymore. All the previously registered unotes are inactive
-	// and their knote is gone. However, these previously registered unotes may
-	// still be in the process of delivering their last event.
-	//
-	// Sources have an internal refcount taken always while they use eventing
-	// subsystems which is consumed when this bit is set.
-	//
-	DSF_STRICT              = 0x04000000,
-	DSF_WLH_CHANGED         = 0x08000000,
-	DSF_CANCELED            = 0x10000000,
-	DSF_CANCEL_WAITER       = 0x20000000,
-	DSF_NEEDS_EVENT         = 0x40000000,
-	DSF_DELETED             = 0x80000000,
-
-#define DQF_FLAGS_MASK        ((dispatch_queue_flags_t)0xffff0000)
-#define DQF_WIDTH_MASK        ((dispatch_queue_flags_t)0x0000ffff)
-#define DQF_WIDTH(n)          ((dispatch_queue_flags_t)(uint16_t)(n))
-);
-
-/*
- * dispatch queues `dq_state` demystified
- *
- *******************************************************************************
- *
- * Most Significant 32 bit Word
- * ----------------------------
- *
- * sc: suspend count (bits 63 - 58)
- *    The suspend count unsurprisingly holds the suspend count of the queue
- *    Only 7 bits are stored inline. Extra counts are transfered in a side
- *    suspend count and when that has happened, the ssc: bit is set.
- */
-#define DISPATCH_QUEUE_SUSPEND_INTERVAL		0x0400000000000000ull
-#define DISPATCH_QUEUE_SUSPEND_HALF			0x20u
-/*
- * ssc: side suspend count (bit 57)
- *    This bit means that the total suspend count didn't fit in the inline
- *    suspend count, and that there are additional suspend counts stored in the
- *    `dq_side_suspend_cnt` field.
- */
-#define DISPATCH_QUEUE_HAS_SIDE_SUSPEND_CNT	0x0200000000000000ull
-/*
- * i: inactive bit (bit 56)
- *    This bit means that the object is inactive (see dispatch_activate)
- */
-#define DISPATCH_QUEUE_INACTIVE				0x0100000000000000ull
-/*
- * na: needs activation (bit 55)
- *    This bit is set if the object is created inactive. It tells
- *    dispatch_queue_wakeup to perform various tasks at first wakeup.
- *
- *    This bit is cleared as part of the first wakeup. Having that bit prevents
- *    the object from being woken up (because _dq_state_should_wakeup will say
- *    no), except in the dispatch_activate/dispatch_resume codepath.
- */
-#define DISPATCH_QUEUE_NEEDS_ACTIVATION		0x0080000000000000ull
-/*
- * This mask covers the suspend count (sc), side suspend count bit (ssc),
- * inactive (i) and needs activation (na) bits
- */
-#define DISPATCH_QUEUE_SUSPEND_BITS_MASK	0xff80000000000000ull
-/*
- * ib: in barrier (bit 54)
- *    This bit is set when the queue is currently executing a barrier
- */
-#define DISPATCH_QUEUE_IN_BARRIER			0x0040000000000000ull
-/*
- * qf: queue full (bit 53)
- *    This bit is a subtle hack that allows to check for any queue width whether
- *    the full width of the queue is used or reserved (depending on the context)
- *    In other words that the queue has reached or overflown its capacity.
- */
-#define DISPATCH_QUEUE_WIDTH_FULL_BIT		0x0020000000000000ull
-#define DISPATCH_QUEUE_WIDTH_FULL			0x1000ull
-#define DISPATCH_QUEUE_WIDTH_POOL (DISPATCH_QUEUE_WIDTH_FULL - 1)
-#define DISPATCH_QUEUE_WIDTH_MAX  (DISPATCH_QUEUE_WIDTH_FULL - 2)
-#define DISPATCH_QUEUE_USES_REDIRECTION(width) \
-		({ uint16_t _width = (width); \
-		_width > 1 && _width < DISPATCH_QUEUE_WIDTH_POOL; })
-/*
- * w:  width (bits 52 - 41)
- *    This encodes how many work items are in flight. Barriers hold `dq_width`
- *    of them while they run. This is encoded as a signed offset with respect,
- *    to full use, where the negative values represent how many available slots
- *    are left, and the positive values how many work items are exceeding our
- *    capacity.
- *
- *    When this value is positive, then `wo` is always set to 1.
- */
-#define DISPATCH_QUEUE_WIDTH_INTERVAL		0x0000020000000000ull
-#define DISPATCH_QUEUE_WIDTH_MASK			0x003ffe0000000000ull
-#define DISPATCH_QUEUE_WIDTH_SHIFT			41
-/*
- * pb: pending barrier (bit 40)
- *    Drainers set this bit when they couldn't run the next work item and it is
- *    a barrier. When this bit is set, `dq_width - 1` work item slots are
- *    reserved so that no wakeup happens until the last work item in flight
- *    completes.
- */
-#define DISPATCH_QUEUE_PENDING_BARRIER		0x0000010000000000ull
-/*
- * d: dirty bit (bit 39)
- *    This bit is set when a queue transitions from empty to not empty.
- *    This bit is set before dq_items_head is set, with appropriate barriers.
- *    Any thread looking at a queue head is responsible for unblocking any
- *    dispatch_*_sync that could be enqueued at the beginning.
- *
- *    Drainer perspective
- *    ===================
- *
- *    When done, any "Drainer", in particular for dispatch_*_sync() handoff
- *    paths, exits in 3 steps, and the point of the DIRTY bit is to make
- *    the Drainers take the slow path at step 2 to take into account enqueuers
- *    that could have made the queue non idle concurrently.
- *
- *    <code>
- *        // drainer-exit step 1
- *        if (unlikely(dq->dq_items_tail)) { // speculative test
- *            return handle_non_empty_queue_or_wakeup(dq);
- *        }
- *        // drainer-exit step 2
- *        if (!_dispatch_queue_drain_try_unlock(dq, ${owned}, ...)) {
- *            return handle_non_empty_queue_or_wakeup(dq);
- *        }
- *        // drainer-exit step 3
- *        // no need to wake up the queue, it's really empty for sure
- *        return;
- *    </code>
- *
- *    The crux is _dispatch_queue_drain_try_unlock(), it is a function whose
- *    contract is to release everything the current thread owns from the queue
- *    state, so that when it's successful, any other thread can acquire
- *    width from that queue.
- *
- *    But, that function must fail if it sees the DIRTY bit set, leaving
- *    the state untouched. Leaving the state untouched is vital as it ensures
- *    that no other Slayer^WDrainer can rise at the same time, because the
- *    resource stays locked.
- *
- *
- *    Note that releasing the DRAIN_LOCK or ENQUEUE_LOCK (see below) currently
- *    doesn't use that pattern, and always tries to requeue. It isn't a problem
- *    because while holding either of these locks prevents *some* sync (the
- *    barrier one) codepaths to acquire the resource, the retry they perform
- *    at their step D (see just below) isn't affected by the state of these bits
- *    at all.
- *
- *
- *    Sync items perspective
- *    ======================
- *
- *    On the dispatch_*_sync() acquire side, the code must look like this:
- *
- *    <code>
- *        // step A
- *        if (try_acquire_sync(dq)) {
- *            return sync_operation_fastpath(dq, item);
- *        }
- *
- *        // step B
- *        if (queue_push_and_inline(dq, item)) {
- *            atomic_store(dq->dq_items_head, item, relaxed);
- *            // step C
- *            atomic_or(dq->dq_state, DIRTY, release);
- *
- *            // step D
- *            if (try_acquire_sync(dq)) {
- *                try_lock_transfer_or_wakeup(dq);
- *            }
- *        }
- *
- *        // step E
- *        wait_for_lock_transfer(dq);
- *    </code>
- *
- *    A. If this code can acquire the resource it needs at step A, we're good.
- *
- *    B. If the item isn't the first at enqueue time, then there is no issue
- *       At least another thread went through C, this thread isn't interesting
- *       for the possible races, responsibility to make progress is transfered
- *       to the thread which went through C-D.
- *
- *    C. The DIRTY bit is set with a release barrier, after the head/tail
- *       has been set, so that seeing the DIRTY bit means that head/tail
- *       will be visible to any drainer that has the matching acquire barrier.
- *
- *       Drainers may see the head/tail and fail to see DIRTY, in which
- *       case, their _dispatch_queue_drain_try_unlock() will clear the DIRTY
- *       bit, and fail, causing the caller to retry exactly once.
- *
- *    D. At this stage, there's two possible outcomes:
- *
- *       - either the acquire works this time, in which case this thread
- *         successfuly becomes a drainer. That's obviously the happy path.
- *         It means all drainers are after Step 2 (or there is no Drainer)
- *
- *       - or the acquire fails, which means that another drainer is before
- *         its Step 2. Since we set the DIRTY bit on the dq_state by now,
- *         and that drainers manipulate the state atomically, at least one
- *         drainer that is still before its step 2 will fail its step 2, and
- *         be responsible for making progress.
- *
- *
- *    Async items perspective
- *    ======================
- *
- *    On the async codepath, when the queue becomes non empty, the queue
- *    is always woken up. There is no point in trying to avoid that wake up
- *    for the async case, because it's required for the async()ed item to make
- *    progress: a drain of the queue must happen.
- *
- *    So on the async "acquire" side, there is no subtlety at all.
- */
-#define DISPATCH_QUEUE_DIRTY				0x0000008000000000ull
-/*
- * md: enqueued/draining on manager (bit 38)
- *    Set when enqueued and draining on the manager hierarchy.
- *
- *    Unlike the ENQUEUED bit, it is kept until the queue is unlocked from its
- *    invoke call on the manager. This is used to prevent stealing, and
- *    overrides to be applied down the target queue chain.
- */
-#define DISPATCH_QUEUE_ENQUEUED_ON_MGR		0x0000004000000000ull
-/*
- * r: queue graph role (bits 37 - 36)
- *    Queue role in the target queue graph
- *
- *    11: unused
- *    10: WLH base
- *    01: non wlh base
- *    00: inner queue
- */
-#define DISPATCH_QUEUE_ROLE_MASK			0x0000003000000000ull
-#define DISPATCH_QUEUE_ROLE_BASE_WLH		0x0000002000000000ull
-#define DISPATCH_QUEUE_ROLE_BASE_ANON		0x0000001000000000ull
-#define DISPATCH_QUEUE_ROLE_INNER			0x0000000000000000ull
-/*
- * o: has override (bit 35, if role is DISPATCH_QUEUE_ROLE_BASE_ANON)
- *    Set when a queue has received a QOS override and needs to reset it.
- *    This bit is only cleared when the final drain_try_unlock() succeeds.
- *
- * sw: has received sync wait (bit 35, if role DISPATCH_QUEUE_ROLE_BASE_WLH)
- *    Set when a queue owner has been exposed to the kernel because of
- *    dispatch_sync() contention.
- */
-#define DISPATCH_QUEUE_RECEIVED_OVERRIDE	0x0000000800000000ull
-#define DISPATCH_QUEUE_RECEIVED_SYNC_WAIT	0x0000000800000000ull
-/*
- * max_qos: max qos (bits 34 - 32)
- *   This is the maximum qos that has been enqueued on the queue
- */
-#define DISPATCH_QUEUE_MAX_QOS_MASK			0x0000000700000000ull
-#define DISPATCH_QUEUE_MAX_QOS_SHIFT		32
-/*
- * dl: drain lock (bits 31-0)
- *    This is used by the normal drain to drain exlusively relative to other
- *    drain stealers (like the QoS Override codepath). It holds the identity
- *    (thread port) of the current drainer.
- *
- * st: sync transfer (bit 1 or 30)
- *    Set when a dispatch_sync() is transferred to
- *
- * e: enqueued bit (bit 0 or 31)
- *    Set when a queue is enqueued on its target queue
- */
-#define DISPATCH_QUEUE_DRAIN_OWNER_MASK		((uint64_t)DLOCK_OWNER_MASK)
-#define DISPATCH_QUEUE_SYNC_TRANSFER		((uint64_t)DLOCK_FAILED_TRYLOCK_BIT)
-#define DISPATCH_QUEUE_ENQUEUED				((uint64_t)DLOCK_WAITERS_BIT)
-
-#define DISPATCH_QUEUE_DRAIN_PRESERVED_BITS_MASK \
-		(DISPATCH_QUEUE_ENQUEUED_ON_MGR | DISPATCH_QUEUE_ENQUEUED | \
-		DISPATCH_QUEUE_ROLE_MASK | DISPATCH_QUEUE_MAX_QOS_MASK)
-
-#define DISPATCH_QUEUE_DRAIN_UNLOCK_MASK \
-		(DISPATCH_QUEUE_DRAIN_OWNER_MASK | DISPATCH_QUEUE_RECEIVED_OVERRIDE | \
-		DISPATCH_QUEUE_RECEIVED_SYNC_WAIT | DISPATCH_QUEUE_SYNC_TRANSFER)
-
-/*
- *******************************************************************************
- *
- * `Drainers`
- *
- * Drainers are parts of the code that hold the drain lock by setting its value
- * to their thread port. There are two kinds:
- * 1. async drainers,
- * 2. lock transfer handlers.
- *
- * Drainers from the first category are _dispatch_queue_class_invoke and its
- * stealers. Those drainers always try to reserve width at the same time they
- * acquire the drain lock, to make sure they can make progress, and else exit
- * quickly.
- *
- * Drainers from the second category are `slow` work items. Those run on the
- * calling thread, and when done, try to transfer the width they own to the
- * possible next `slow` work item, and if there is no such item, they reliquish
- * that right. To do so, prior to taking any decision, they also try to own
- * the full "barrier" width on the given queue.
- *
- *******************************************************************************
- *
- * Enqueuing and wakeup rules
- *
- * Nobody should enqueue any dispatch object if it has no chance to make any
- * progress. That means that queues that:
- * - are suspended
- * - have reached or overflown their capacity
- * - are currently draining
- * - are already enqueued
- *
- * should not try to be enqueued.
- *
- *******************************************************************************
- *
- * Lock transfer
- *
- * The point of the lock transfer code is to allow pure dispatch_*_sync()
- * callers to make progress without requiring the bring up of a drainer.
- * There are two reason for that:
- *
- * - performance, as draining has to give up for dispatch_*_sync() work items,
- *   so waking up a queue for this is wasteful.
- *
- * - liveness, as with dispatch_*_sync() you burn threads waiting, you're more
- *   likely to hit various thread limits and may not have any drain being
- *   brought up if the process hits a limit.
- *
- *
- * Lock transfer happens at the end on the dispatch_*_sync() codepaths:
- *
- * - obviously once a dispatch_*_sync() work item finishes, it owns queue
- *   width and it should try to transfer that ownership to the possible next
- *   queued item if it is a dispatch_*_sync() item
- *
- * - just before such a work item blocks to make sure that that work item
- *   itself isn't its own last chance to be woken up. That can happen when
- *   a Drainer pops up everything from the queue, and that a dispatch_*_sync()
- *   work item has taken the slow path then was preempted for a long time.
- *
- *   That's why such work items, if first in the queue, must try a lock
- *   transfer procedure.
- *
- *
- * For transfers where a partial width is owned, we give back that width.
- * If the queue state is "idle" again, we attempt to acquire the full width.
- * If that succeeds, this falls back to the full barrier lock
- * transfer, else it wakes up the queue according to its state.
- *
- * For full barrier transfers, if items eligible for lock transfer are found,
- * then they are woken up and the lock transfer is successful.
- *
- * If none are found, the full barrier width is released. If by doing so the
- * DIRTY bit is found, releasing the full barrier width fails and transferring
- * the lock is retried from scratch.
- */
-
-#define DISPATCH_QUEUE_STATE_INIT_VALUE(width) \
-		((DISPATCH_QUEUE_WIDTH_FULL - (width)) << DISPATCH_QUEUE_WIDTH_SHIFT)
-
-/* Magic dq_state values for global queues: they have QUEUE_FULL and IN_BARRIER
- * set to force the slow path in dispatch_barrier_sync() and dispatch_sync()
- */
-#define DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE \
-		(DISPATCH_QUEUE_WIDTH_FULL_BIT | DISPATCH_QUEUE_IN_BARRIER)
-
-#define DISPATCH_QUEUE_SERIAL_DRAIN_OWNED \
-		(DISPATCH_QUEUE_IN_BARRIER | DISPATCH_QUEUE_WIDTH_INTERVAL)
-
-#pragma mark -
-#pragma mark dispatch_queue_t
-
-typedef struct dispatch_queue_specific_s {
-	const void *dqs_key;
-	void *dqs_ctxt;
-	dispatch_function_t dqs_destructor;
-	TAILQ_ENTRY(dispatch_queue_specific_s) dqs_entry;
-} *dispatch_queue_specific_t;
-
-typedef struct dispatch_queue_specific_head_s {
-	dispatch_unfair_lock_s dqsh_lock;
-	TAILQ_HEAD(, dispatch_queue_specific_s) dqsh_entries;
-} *dispatch_queue_specific_head_t;
-
-#define DISPATCH_WORKLOOP_ATTR_HAS_SCHED 0x1u
-#define DISPATCH_WORKLOOP_ATTR_HAS_POLICY 0x2u
-#define DISPATCH_WORKLOOP_ATTR_HAS_CPUPERCENT 0x4u
-#define DISPATCH_WORKLOOP_ATTR_HAS_QOS_CLASS 0x8u
-#define DISPATCH_WORKLOOP_ATTR_NEEDS_DESTROY 0x10u
-typedef struct dispatch_workloop_attr_s *dispatch_workloop_attr_t;
-typedef struct dispatch_workloop_attr_s {
-	uint32_t dwla_flags;
-	dispatch_priority_t dwla_pri;
-#if TARGET_OS_MAC
-	struct sched_param dwla_sched;
-#endif // TARGET_OS_MAC
-	int dwla_policy;
-	struct {
-		uint8_t percent;
-		uint32_t refillms;
-	} dwla_cpupercent;
-} dispatch_workloop_attr_s;
-
-/*
- * Dispatch Queue cluster related types
- *
- * The dispatch queue cluster uses aliasing structs, and loosely follows the
- * external types exposed in <dispatch/queue.h>
- *
- * The API types pretend to have this hierarchy:
- *
- * dispatch_queue_t
- *  +--> dispatch_workloop_t
- *  +--> dispatch_queue_serial_t --> dispatch_queue_main_t
- *  +--> dispatch_queue_concurrent_t
- *  '--> dispatch_queue_global_t
- *
- *
- * However, in the library itself, there are more types and a finer grained
- * hierarchy when it comes to the struct members.
- *
- * dispatch_queue_class_t / struct dispatch_queue_s
- *  +--> struct dispatch_workloop_s
- *  '--> dispatch_lane_class_t
- *        +--> struct dispatch_lane_s
- *        |     +--> struct dispatch_source_s
- *        |     '--> struct dispatch_mach_s
- *        +--> struct dispatch_queue_static_s
- *        '--> struct dispatch_queue_global_s
- *              +--> struct dispatch_queue_pthread_root_s
- *
- *
- * dispatch_queue_class_t && struct dispatch_queue_s
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
- * The queue class type is a transparent union of all queue types, which allows
- * cutting down the explicit downcasts to `dispatch_queue_t` when calling
- * a function working on any dispatch_queue_t type.
- *
- * The concrete struct layout is struct dispatch_queue_s
- * it provides:
- * - dispatch object fields
- * - dq_state
- * - dq_serialnum
- * - dq_label
- * - dq_atomic_flags
- * - dq_sref_cnt
- * - an auxiliary pointer used by sub-classes (dq_specific_head, ds_refs, ...)
- * - dq_priority (XXX: we should push it down to lanes)
- *
- * It also provides storage for one opaque pointer sized field.
- *
- * dispatch_lane_class_t
- * ~~~~~~~~~~~~~~~~~~~~~
- *
- * The lane class type is a transparent union of all "lane" types, which have
- * a single head/tail pair.
- *
- * There's no proper concrete struct layout associated, `struct dispatch_lane_s`
- * is used most of the time instead. The lane class adds:
- * - dq_items_head
- * - dq_items_tail (allocated in the hole the queue class carves out)
- *
- *
- * struct dispatch_lane_s and variants
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
- * This is the concrete type used for:
- * - API serial/concurrent/runloop queues
- * - sources and mach channels
- * - the main and manager queues, as struct dispatch_queue_static_s which is
- *   a cacheline aligned variant of struct dispatch_lane_s.
- *
- * It also provides:
- * - dq_sidelock, used for suspension & target queue handling,
- * - dq_side_suspend_cnt.
- *
- * Sources (struct dispatch_source_s) and mach channels (struct dispatch_mach_s)
- * use the last 32bit word for flags private to their use.
- *
- * struct dispatch_queue_global_s is used for all dispatch root queues:
- * - global concurent queues
- * - pthread root queues
- * - the network event thread
- *
- * These pretend to derive from dispatch_lane_s but use the dq_sidelock,
- * dq_side_suspend_cnt differently, which is possible because root queues cannot
- * be targetted or suspended and hence have no use for these.
- */
-
-#if OS_OBJECT_HAVE_OBJC1
-#define _DISPATCH_QUEUE_CLASS_HEADER(x, __pointer_sized_field__) \
-	DISPATCH_OBJECT_HEADER(x); \
-	DISPATCH_UNION_LE(uint64_t volatile dq_state, \
-			dispatch_lock dq_state_lock, \
-			uint32_t dq_state_bits \
-	); \
-	__pointer_sized_field__
-#else
-#define _DISPATCH_QUEUE_CLASS_HEADER(x, __pointer_sized_field__) \
-	DISPATCH_OBJECT_HEADER(x); \
-	__pointer_sized_field__; \
-	DISPATCH_UNION_LE(uint64_t volatile dq_state, \
-			dispatch_lock dq_state_lock, \
-			uint32_t dq_state_bits \
-	)
-#endif
-
-#define DISPATCH_QUEUE_CLASS_HEADER(x, __pointer_sized_field__) \
-	_DISPATCH_QUEUE_CLASS_HEADER(x, __pointer_sized_field__); \
-	/* LP64 global queue cacheline boundary */ \
-	unsigned long dq_serialnum; \
-	const char *dq_label; \
-	DISPATCH_UNION_LE(uint32_t volatile dq_atomic_flags, \
-		const uint16_t dq_width, \
-		const uint16_t __dq_opaque2 \
-	); \
-	dispatch_priority_t dq_priority; \
-	union { \
-		struct dispatch_queue_specific_head_s *dq_specific_head; \
-		struct dispatch_source_refs_s *ds_refs; \
-		struct dispatch_timer_source_refs_s *ds_timer_refs; \
-		struct dispatch_mach_recv_refs_s *dm_recv_refs; \
-	}; \
-	int volatile dq_sref_cnt
-
-struct dispatch_queue_s {
-	DISPATCH_QUEUE_CLASS_HEADER(queue, void *__dq_opaque1);
-	/* 32bit hole on LP64 */
-} DISPATCH_ATOMIC64_ALIGN;
-
-struct dispatch_workloop_s {
-	struct dispatch_queue_s _as_dq[0];
-	DISPATCH_QUEUE_CLASS_HEADER(workloop, dispatch_timer_heap_t dwl_timer_heap);
-	uint8_t dwl_drained_qos;
-	/* 24 bits hole */
-	struct dispatch_object_s *dwl_heads[DISPATCH_QOS_NBUCKETS];
-	struct dispatch_object_s *dwl_tails[DISPATCH_QOS_NBUCKETS];
-	dispatch_workloop_attr_t dwl_attr;
-} DISPATCH_ATOMIC64_ALIGN;
-
-#define DISPATCH_LANE_CLASS_HEADER(x) \
-	struct dispatch_queue_s _as_dq[0]; \
-	DISPATCH_QUEUE_CLASS_HEADER(x, \
-			struct dispatch_object_s *volatile dq_items_tail); \
-	dispatch_unfair_lock_s dq_sidelock; \
-	struct dispatch_object_s *volatile dq_items_head; \
-	uint32_t dq_side_suspend_cnt
-
-typedef struct dispatch_lane_s {
-	DISPATCH_LANE_CLASS_HEADER(lane);
-	/* 32bit hole on LP64 */
-} DISPATCH_ATOMIC64_ALIGN *dispatch_lane_t;
-
-// Cache aligned type for static queues (main queue, manager)
-struct dispatch_queue_static_s {
-	struct dispatch_lane_s _as_dl[0]; \
-	DISPATCH_LANE_CLASS_HEADER(lane);
-} DISPATCH_CACHELINE_ALIGN;
-
-#define DISPATCH_QUEUE_ROOT_CLASS_HEADER(x) \
-	struct dispatch_queue_s _as_dq[0]; \
-	DISPATCH_QUEUE_CLASS_HEADER(x, \
-			struct dispatch_object_s *volatile dq_items_tail); \
-	int volatile dgq_thread_pool_size; \
-	struct dispatch_object_s *volatile dq_items_head; \
-	int volatile dgq_pending
-
-struct dispatch_queue_global_s {
-	DISPATCH_QUEUE_ROOT_CLASS_HEADER(lane);
-} DISPATCH_CACHELINE_ALIGN;
-
-
-typedef struct dispatch_pthread_root_queue_observer_hooks_s {
-	void (*queue_will_execute)(dispatch_queue_t queue);
-	void (*queue_did_execute)(dispatch_queue_t queue);
-} dispatch_pthread_root_queue_observer_hooks_s;
-typedef dispatch_pthread_root_queue_observer_hooks_s
-		*dispatch_pthread_root_queue_observer_hooks_t;
-
-#ifdef __APPLE__
-#define DISPATCH_IOHID_SPI 1
-
-DISPATCH_EXPORT DISPATCH_MALLOC DISPATCH_RETURNS_RETAINED DISPATCH_WARN_RESULT
-DISPATCH_NOTHROW DISPATCH_NONNULL4
-dispatch_queue_global_t
-_dispatch_pthread_root_queue_create_with_observer_hooks_4IOHID(
-	const char *label, unsigned long flags, const pthread_attr_t *attr,
-	dispatch_pthread_root_queue_observer_hooks_t observer_hooks,
-	dispatch_block_t configure);
-
-DISPATCH_EXPORT DISPATCH_PURE DISPATCH_WARN_RESULT DISPATCH_NOTHROW
-bool
-_dispatch_queue_is_exclusively_owned_by_current_thread_4IOHID(
-		dispatch_queue_t queue);
-
-#endif // __APPLE__
-
-#if DISPATCH_USE_PTHREAD_POOL
-typedef struct dispatch_pthread_root_queue_context_s {
-#if !defined(_WIN32)
-	pthread_attr_t dpq_thread_attr;
-#endif
-	dispatch_block_t dpq_thread_configure;
-	struct dispatch_semaphore_s dpq_thread_mediator;
-	dispatch_pthread_root_queue_observer_hooks_s dpq_observer_hooks;
-} *dispatch_pthread_root_queue_context_t;
-#endif // DISPATCH_USE_PTHREAD_POOL
-
-#if DISPATCH_USE_PTHREAD_ROOT_QUEUES
-typedef struct dispatch_queue_pthread_root_s {
-	struct dispatch_queue_global_s _as_dgq[0];
-	DISPATCH_QUEUE_ROOT_CLASS_HEADER(lane);
-	struct dispatch_pthread_root_queue_context_s dpq_ctxt;
-} *dispatch_queue_pthread_root_t;
-#endif // DISPATCH_USE_PTHREAD_ROOT_QUEUES
-
-dispatch_static_assert(sizeof(struct dispatch_queue_s) <= 128);
-dispatch_static_assert(sizeof(struct dispatch_lane_s) <= 128);
-dispatch_static_assert(sizeof(struct dispatch_queue_global_s) <= 128);
-dispatch_static_assert(offsetof(struct dispatch_queue_s, dq_state) %
-		sizeof(uint64_t) == 0, "dq_state must be 8-byte aligned");
-
-#define dispatch_assert_valid_queue_type(type) \
-		dispatch_static_assert(sizeof(struct dispatch_queue_s) <= \
-				sizeof(struct type), #type " smaller than dispatch_queue_s"); \
-		dispatch_static_assert(_Alignof(struct type) >= sizeof(uint64_t), \
-				#type " is not 8-byte aligned"); \
-		dispatch_assert_aliases(dispatch_queue_s, type, dq_state); \
-		dispatch_assert_aliases(dispatch_queue_s, type, dq_serialnum); \
-		dispatch_assert_aliases(dispatch_queue_s, type, dq_label); \
-		dispatch_assert_aliases(dispatch_queue_s, type, dq_atomic_flags); \
-		dispatch_assert_aliases(dispatch_queue_s, type, dq_sref_cnt); \
-		dispatch_assert_aliases(dispatch_queue_s, type, dq_specific_head); \
-		dispatch_assert_aliases(dispatch_queue_s, type, dq_priority)
-
-#define dispatch_assert_valid_lane_type(type) \
-		dispatch_assert_valid_queue_type(type); \
-		dispatch_assert_aliases(dispatch_lane_s, type, dq_items_head); \
-		dispatch_assert_aliases(dispatch_lane_s, type, dq_items_tail)
-
-dispatch_assert_valid_queue_type(dispatch_lane_s);
-dispatch_assert_valid_lane_type(dispatch_queue_static_s);
-dispatch_assert_valid_lane_type(dispatch_queue_global_s);
-#if DISPATCH_USE_PTHREAD_ROOT_QUEUES
-dispatch_assert_valid_lane_type(dispatch_queue_pthread_root_s);
-#endif
-
-DISPATCH_CLASS_DECL(queue, QUEUE);
-DISPATCH_CLASS_DECL_BARE(lane, QUEUE);
-DISPATCH_CLASS_DECL(workloop, QUEUE);
-DISPATCH_SUBCLASS_DECL(queue_serial, queue, lane);
-DISPATCH_SUBCLASS_DECL(queue_main, queue_serial, lane);
-DISPATCH_SUBCLASS_DECL(queue_concurrent, queue, lane);
-DISPATCH_SUBCLASS_DECL(queue_global, queue, lane);
-#if DISPATCH_USE_PTHREAD_ROOT_QUEUES
-DISPATCH_INTERNAL_SUBCLASS_DECL(queue_pthread_root, queue, lane);
-#endif
-DISPATCH_INTERNAL_SUBCLASS_DECL(queue_runloop, queue_serial, lane);
-DISPATCH_INTERNAL_SUBCLASS_DECL(queue_mgr, queue_serial, lane);
-
-struct firehose_client_s;
-
-typedef struct dispatch_thread_context_s *dispatch_thread_context_t;
-typedef struct dispatch_thread_context_s {
-	dispatch_thread_context_t dtc_prev;
-	const void *dtc_key;
-	union {
-		size_t dtc_apply_nesting;
-		dispatch_io_t dtc_io_in_barrier;
-		union firehose_buffer_u *dtc_fb;
-		void *dtc_mig_demux_ctx;
-		dispatch_mach_msg_t dtc_dmsg;
-		struct dispatch_ipc_handoff_s *dtc_dih;
-	};
-} dispatch_thread_context_s;
-
-typedef union dispatch_thread_frame_s *dispatch_thread_frame_t;
-typedef union dispatch_thread_frame_s {
-	struct {
-		// must be in the same order as our TSD keys!
-		dispatch_queue_t dtf_queue;
-		dispatch_thread_frame_t dtf_prev;
-	};
-	void *dtf_pair[2];
-} dispatch_thread_frame_s;
-
-typedef dispatch_queue_t dispatch_queue_wakeup_target_t;
-#define DISPATCH_QUEUE_WAKEUP_NONE           ((dispatch_queue_wakeup_target_t)0)
-#define DISPATCH_QUEUE_WAKEUP_TARGET         ((dispatch_queue_wakeup_target_t)1)
-#define DISPATCH_QUEUE_WAKEUP_MGR            (_dispatch_mgr_q._as_dq)
-#define DISPATCH_QUEUE_WAKEUP_WAIT_FOR_EVENT ((dispatch_queue_wakeup_target_t)-1)
-
-void _dispatch_queue_xref_dispose(dispatch_queue_class_t dq);
-void _dispatch_queue_wakeup(dispatch_queue_class_t dqu, dispatch_qos_t qos,
-		dispatch_wakeup_flags_t flags, dispatch_queue_wakeup_target_t target);
-void _dispatch_queue_invoke_finish(dispatch_queue_t dq,
-		dispatch_invoke_context_t dic, dispatch_queue_t tq, uint64_t owned);
-
-dispatch_priority_t _dispatch_queue_compute_priority_and_wlh(
-		dispatch_queue_class_t dq, dispatch_wlh_t *wlh_out);
-
-void _dispatch_lane_set_target_queue(dispatch_lane_t dq, dispatch_queue_t tq);
-void _dispatch_lane_class_dispose(dispatch_queue_class_t dq, bool *allow_free);
-void _dispatch_lane_dispose(dispatch_lane_class_t dq, bool *allow_free);
-void _dispatch_lane_suspend(dispatch_lane_class_t dq);
-void _dispatch_lane_resume(dispatch_lane_class_t dq, bool activate);
-void _dispatch_lane_activate(dispatch_lane_class_t dq, bool *allow_resume);
-void _dispatch_lane_invoke(dispatch_lane_class_t dq,
-		dispatch_invoke_context_t dic, dispatch_invoke_flags_t flags);
-void _dispatch_lane_push(dispatch_lane_class_t dq, dispatch_object_t dou,
-		dispatch_qos_t qos);
-void _dispatch_lane_concurrent_push(dispatch_lane_class_t dq,
-		dispatch_object_t dou, dispatch_qos_t qos);
-void _dispatch_lane_wakeup(dispatch_lane_class_t dq, dispatch_qos_t qos,
-		dispatch_wakeup_flags_t flags);
-dispatch_queue_wakeup_target_t _dispatch_lane_serial_drain(
-		dispatch_lane_class_t dq, dispatch_invoke_context_t dic,
-		dispatch_invoke_flags_t flags, uint64_t *owned);
-
-void _dispatch_workloop_dispose(dispatch_workloop_t dwl, bool *allow_free);
-void _dispatch_workloop_activate(dispatch_workloop_t dwl);
-void _dispatch_workloop_invoke(dispatch_workloop_t dwl,
-		dispatch_invoke_context_t dic, dispatch_invoke_flags_t flags);
-void _dispatch_workloop_push(dispatch_workloop_t dwl, dispatch_object_t dou,
-		dispatch_qos_t qos);
-void _dispatch_workloop_wakeup(dispatch_workloop_t dwl, dispatch_qos_t qos,
-		dispatch_wakeup_flags_t flags);
-
-void _dispatch_root_queue_poke(dispatch_queue_global_t dq, int n, int floor);
-void _dispatch_root_queue_wakeup(dispatch_queue_global_t dq, dispatch_qos_t qos,
-		dispatch_wakeup_flags_t flags);
-void _dispatch_root_queue_push(dispatch_queue_global_t dq,
-		dispatch_object_t dou, dispatch_qos_t qos);
-#if DISPATCH_USE_KEVENT_WORKQUEUE
-void _dispatch_kevent_workqueue_init(void);
-#endif
-#if DISPATCH_USE_PTHREAD_ROOT_QUEUES
-void _dispatch_pthread_root_queue_dispose(dispatch_lane_class_t dq,
-		bool *allow_free);
-#endif // DISPATCH_USE_PTHREAD_ROOT_QUEUES
-void _dispatch_main_queue_push(dispatch_queue_main_t dq, dispatch_object_t dou,
-		dispatch_qos_t qos);
-void _dispatch_main_queue_wakeup(dispatch_queue_main_t dq, dispatch_qos_t qos,
-		dispatch_wakeup_flags_t flags);
-#if DISPATCH_COCOA_COMPAT
-void _dispatch_runloop_queue_wakeup(dispatch_lane_t dq,
-		dispatch_qos_t qos, dispatch_wakeup_flags_t flags);
-void _dispatch_runloop_queue_xref_dispose(dispatch_lane_t dq);
-void _dispatch_runloop_queue_dispose(dispatch_lane_t dq, bool *allow_free);
-#endif // DISPATCH_COCOA_COMPAT
-void _dispatch_mgr_queue_push(dispatch_lane_t dq, dispatch_object_t dou,
-		dispatch_qos_t qos);
-void _dispatch_mgr_queue_wakeup(dispatch_lane_t dq, dispatch_qos_t qos,
-		dispatch_wakeup_flags_t flags);
-#if DISPATCH_USE_MGR_THREAD
-void _dispatch_mgr_thread(dispatch_lane_t dq, dispatch_invoke_context_t dic,
-		dispatch_invoke_flags_t flags);
-#endif
-
-void _dispatch_apply_invoke(void *ctxt);
-void _dispatch_apply_redirect_invoke(void *ctxt);
-void _dispatch_barrier_async_detached_f(dispatch_queue_class_t dq, void *ctxt,
-		dispatch_function_t func);
-#define DISPATCH_BARRIER_TRYSYNC_SUSPEND 0x1
-void _dispatch_barrier_trysync_or_async_f(dispatch_lane_class_t dq, void *ctxt,
-		dispatch_function_t func, uint32_t flags);
-void _dispatch_queue_atfork_child(void);
-
-DISPATCH_COLD
-size_t _dispatch_queue_debug(dispatch_queue_class_t dq,
-		char *buf, size_t bufsiz);
-DISPATCH_COLD
-size_t _dispatch_queue_debug_attr(dispatch_queue_t dq,
-		char *buf, size_t bufsiz);
-
-#define DISPATCH_ROOT_QUEUE_COUNT (DISPATCH_QOS_NBUCKETS * 2)
-
-// must be in lowest to highest qos order (as encoded in dispatch_qos_t)
-// overcommit qos index values need bit 1 set
-enum {
-	DISPATCH_ROOT_QUEUE_IDX_MAINTENANCE_QOS = 0,
-	DISPATCH_ROOT_QUEUE_IDX_MAINTENANCE_QOS_OVERCOMMIT,
-	DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_QOS,
-	DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_QOS_OVERCOMMIT,
-	DISPATCH_ROOT_QUEUE_IDX_UTILITY_QOS,
-	DISPATCH_ROOT_QUEUE_IDX_UTILITY_QOS_OVERCOMMIT,
-	DISPATCH_ROOT_QUEUE_IDX_DEFAULT_QOS,
-	DISPATCH_ROOT_QUEUE_IDX_DEFAULT_QOS_OVERCOMMIT,
-	DISPATCH_ROOT_QUEUE_IDX_USER_INITIATED_QOS,
-	DISPATCH_ROOT_QUEUE_IDX_USER_INITIATED_QOS_OVERCOMMIT,
-	DISPATCH_ROOT_QUEUE_IDX_USER_INTERACTIVE_QOS,
-	DISPATCH_ROOT_QUEUE_IDX_USER_INTERACTIVE_QOS_OVERCOMMIT,
-	_DISPATCH_ROOT_QUEUE_IDX_COUNT,
-};
-
-// skip zero
-// 1 - main_q
-// 2 - mgr_q
-// 3 - mgr_root_q
-// 4,5,6,7,8,9,10,11,12,13,14,15 - global queues
-// 17 - workloop_fallback_q
-// we use 'xadd' on Intel, so the initial value == next assigned
-#define DISPATCH_QUEUE_SERIAL_NUMBER_INIT 17
-extern unsigned long volatile _dispatch_queue_serial_numbers;
-
-// mark the workloop fallback queue to avoid finalizing objects on the base
-// queue of custom outside-of-qos workloops
-#define DISPATCH_QUEUE_SERIAL_NUMBER_WLF 16
-
-extern struct dispatch_queue_static_s _dispatch_mgr_q; // serial 2
-#if DISPATCH_USE_MGR_THREAD && DISPATCH_USE_PTHREAD_ROOT_QUEUES
-extern struct dispatch_queue_global_s _dispatch_mgr_root_queue; // serial 3
-#endif
-extern struct dispatch_queue_global_s _dispatch_root_queues[]; // serials 4 - 15
-
-#if DISPATCH_DEBUG
-#define DISPATCH_ASSERT_ON_MANAGER_QUEUE() \
-		dispatch_assert_queue(_dispatch_mgr_q._as_dq)
-#else
-#define DISPATCH_ASSERT_ON_MANAGER_QUEUE()
-#endif
-
-#pragma mark -
-#pragma mark dispatch_queue_attr_t
-
-DISPATCH_CLASS_DECL(queue_attr, OBJECT);
-struct dispatch_queue_attr_s {
-	OS_OBJECT_STRUCT_HEADER(dispatch_queue_attr);
-};
-
-typedef struct dispatch_queue_attr_info_s {
-	dispatch_qos_t dqai_qos : 8;
-	int      dqai_relpri : 8;
-	uint16_t dqai_overcommit:2;
-	uint16_t dqai_autorelease_frequency:2;
-	uint16_t dqai_concurrent:1;
-	uint16_t dqai_inactive:1;
-} dispatch_queue_attr_info_t;
-
-typedef enum {
-	_dispatch_queue_attr_overcommit_unspecified = 0,
-	_dispatch_queue_attr_overcommit_enabled,
-	_dispatch_queue_attr_overcommit_disabled,
-} _dispatch_queue_attr_overcommit_t;
-
-#define DISPATCH_QUEUE_ATTR_OVERCOMMIT_COUNT 3
-
-#define DISPATCH_QUEUE_ATTR_AUTORELEASE_FREQUENCY_COUNT 3
-
-#define DISPATCH_QUEUE_ATTR_QOS_COUNT (DISPATCH_QOS_MAX + 1)
-
-#define DISPATCH_QUEUE_ATTR_PRIO_COUNT (1 - QOS_MIN_RELATIVE_PRIORITY)
-
-#define DISPATCH_QUEUE_ATTR_CONCURRENCY_COUNT 2
-
-#define DISPATCH_QUEUE_ATTR_INACTIVE_COUNT 2
-
-#define DISPATCH_QUEUE_ATTR_COUNT  ( \
-		DISPATCH_QUEUE_ATTR_OVERCOMMIT_COUNT * \
-		DISPATCH_QUEUE_ATTR_AUTORELEASE_FREQUENCY_COUNT * \
-		DISPATCH_QUEUE_ATTR_QOS_COUNT * \
-		DISPATCH_QUEUE_ATTR_PRIO_COUNT * \
-		DISPATCH_QUEUE_ATTR_CONCURRENCY_COUNT * \
-		DISPATCH_QUEUE_ATTR_INACTIVE_COUNT )
-
-extern const struct dispatch_queue_attr_s
-_dispatch_queue_attrs[DISPATCH_QUEUE_ATTR_COUNT];
-
-dispatch_queue_attr_info_t _dispatch_queue_attr_to_info(dispatch_queue_attr_t);
-
-#pragma mark -
-#pragma mark dispatch_continuation_t
-
-// If dc_flags is less than 0x1000, then the object is a continuation.
-// Otherwise, the object has a private layout and memory management rules. The
-// layout until after 'do_next' must align with normal objects.
-#if DISPATCH_SIZEOF_PTR == 8
-#define DISPATCH_CONTINUATION_HEADER(x) \
-	union { \
-		const void *do_vtable; \
-		uintptr_t dc_flags; \
-	}; \
-	union { \
-		pthread_priority_t dc_priority; \
-		int dc_cache_cnt; \
-		uintptr_t dc_pad; \
-	}; \
-	struct dispatch_##x##_s *volatile do_next; \
-	struct voucher_s *dc_voucher; \
-	dispatch_function_t dc_func; \
-	void *dc_ctxt; \
-	void *dc_data; \
-	void *dc_other
-#elif OS_OBJECT_HAVE_OBJC1
-#define DISPATCH_CONTINUATION_HEADER(x) \
-	dispatch_function_t dc_func; \
-	union { \
-		pthread_priority_t dc_priority; \
-		int dc_cache_cnt; \
-		uintptr_t dc_pad; \
-	}; \
-	struct voucher_s *dc_voucher; \
-	union { \
-		const void *do_vtable; \
-		uintptr_t dc_flags; \
-	}; \
-	struct dispatch_##x##_s *volatile do_next; \
-	void *dc_ctxt; \
-	void *dc_data; \
-	void *dc_other
-#else
-#define DISPATCH_CONTINUATION_HEADER(x) \
-	union { \
-		const void *do_vtable; \
-		uintptr_t dc_flags; \
-	}; \
-	union { \
-		pthread_priority_t dc_priority; \
-		int dc_cache_cnt; \
-		uintptr_t dc_pad; \
-	}; \
-	struct voucher_s *dc_voucher; \
-	struct dispatch_##x##_s *volatile do_next; \
-	dispatch_function_t dc_func; \
-	void *dc_ctxt; \
-	void *dc_data; \
-	void *dc_other
-#endif
-#define _DISPATCH_CONTINUATION_PTRS 8
-#if DISPATCH_HW_CONFIG_UP
-// UP devices don't contend on continuations so we don't need to force them to
-// occupy a whole cacheline (which is intended to avoid contention)
-#define DISPATCH_CONTINUATION_SIZE \
-		(_DISPATCH_CONTINUATION_PTRS * DISPATCH_SIZEOF_PTR)
-#else
-#define DISPATCH_CONTINUATION_SIZE  ROUND_UP_TO_CACHELINE_SIZE( \
-		(_DISPATCH_CONTINUATION_PTRS * DISPATCH_SIZEOF_PTR))
-#endif
-#define ROUND_UP_TO_CONTINUATION_SIZE(x) \
-		(((x) + (DISPATCH_CONTINUATION_SIZE - 1u)) & \
-		~(DISPATCH_CONTINUATION_SIZE - 1u))
-
-// continuation is a dispatch_sync or dispatch_barrier_sync
-#define DC_FLAG_SYNC_WAITER				0x001ul
-// continuation acts as a barrier
-#define DC_FLAG_BARRIER					0x002ul
-// continuation resources are freed on run
-// this is set on async or for non event_handler source handlers
-#define DC_FLAG_CONSUME					0x004ul
-// continuation has a group in dc_data
-#define DC_FLAG_GROUP_ASYNC				0x008ul
-// continuation function is a block (copied in dc_ctxt)
-#define DC_FLAG_BLOCK					0x010ul
-// continuation function is a block with private data, implies BLOCK_BIT
-#define DC_FLAG_BLOCK_WITH_PRIVATE_DATA	0x020ul
-// source handler requires fetching context from source
-#define DC_FLAG_FETCH_CONTEXT			0x040ul
-// continuation is a dispatch_async_and_wait
-#define DC_FLAG_ASYNC_AND_WAIT			0x080ul
-// bit used to make sure dc_flags is never 0 for allocated continuations
-#define DC_FLAG_ALLOCATED				0x100ul
-// continuation is an internal implementation detail that should not be
-// introspected
-#define DC_FLAG_NO_INTROSPECTION		0x200ul
-
-typedef struct dispatch_continuation_s {
-	DISPATCH_CONTINUATION_HEADER(continuation);
-} *dispatch_continuation_t;
-
-dispatch_assert_aliases(dispatch_continuation_s, dispatch_object_s, do_next);
-dispatch_assert_aliases(dispatch_continuation_s, dispatch_object_s, do_vtable);
-
-typedef struct dispatch_sync_context_s {
-	struct dispatch_continuation_s _as_dc[0];
-	DISPATCH_CONTINUATION_HEADER(continuation);
-	dispatch_function_t dsc_func;
-	void *dsc_ctxt;
-	dispatch_thread_frame_s dsc_dtf;
-	dispatch_thread_event_s dsc_event;
-	dispatch_tid dsc_waiter;
-	uint8_t dsc_override_qos_floor;
-	uint8_t dsc_override_qos;
-	uint16_t dsc_autorelease : 2;
-	uint16_t dsc_wlh_was_first : 1;
-	uint16_t dsc_wlh_is_workloop : 1;
-	uint16_t dsc_waiter_needs_cancel : 1;
-	uint16_t dsc_release_storage : 1;
-#if DISPATCH_INTROSPECTION
-	uint16_t dsc_from_async : 1;
-#endif
-} *dispatch_sync_context_t;
-
-typedef struct dispatch_continuation_vtable_s {
-	_OS_OBJECT_CLASS_HEADER();
-	DISPATCH_OBJECT_VTABLE_HEADER(dispatch_continuation);
-} const *dispatch_continuation_vtable_t;
-
-#ifndef DISPATCH_CONTINUATION_CACHE_LIMIT
-#if TARGET_OS_IPHONE && !TARGET_OS_SIMULATOR
-#define DISPATCH_CONTINUATION_CACHE_LIMIT 112 // one 256k heap for 64 threads
-#define DISPATCH_CONTINUATION_CACHE_LIMIT_MEMORYPRESSURE_PRESSURE_WARN 16
-#else
-#define DISPATCH_CONTINUATION_CACHE_LIMIT 1024
-#define DISPATCH_CONTINUATION_CACHE_LIMIT_MEMORYPRESSURE_PRESSURE_WARN 128
-#endif
-#endif
-
-dispatch_continuation_t _dispatch_continuation_alloc_from_heap(void);
-void _dispatch_continuation_free_to_heap(dispatch_continuation_t c);
-void _dispatch_continuation_pop(dispatch_object_t dou,
-		dispatch_invoke_context_t dic, dispatch_invoke_flags_t flags,
-		dispatch_queue_class_t dqu);
-
-#if DISPATCH_USE_MEMORYPRESSURE_SOURCE
-extern int _dispatch_continuation_cache_limit;
-void _dispatch_continuation_free_to_cache_limit(dispatch_continuation_t c);
-#else
-#define _dispatch_continuation_cache_limit DISPATCH_CONTINUATION_CACHE_LIMIT
-#define _dispatch_continuation_free_to_cache_limit(c) \
-		_dispatch_continuation_free_to_heap(c)
-#endif
-
-#pragma mark -
-#pragma mark dispatch_continuation vtables
-
-enum {
-	_DC_USER_TYPE = 0,
-	DC_ASYNC_REDIRECT_TYPE,
-	DC_MACH_SEND_BARRRIER_DRAIN_TYPE,
-	DC_MACH_SEND_BARRIER_TYPE,
-	DC_MACH_RECV_BARRIER_TYPE,
-	DC_MACH_ASYNC_REPLY_TYPE,
-#if HAVE_PTHREAD_WORKQUEUE_QOS
-	DC_WORKLOOP_STEALING_TYPE,
-	DC_OVERRIDE_STEALING_TYPE,
-	DC_OVERRIDE_OWNING_TYPE,
-#endif
-#if HAVE_MACH
-	DC_MACH_IPC_HANDOFF_TYPE,
-#endif
-	_DC_MAX_TYPE,
-};
-
-DISPATCH_ALWAYS_INLINE
-static inline unsigned long
-dc_type(dispatch_continuation_t dc)
-{
-	return dx_type((struct dispatch_object_s *)dc);
-}
-
-extern const struct dispatch_continuation_vtable_s
-		_dispatch_continuation_vtables[_DC_MAX_TYPE];
-
-#define DC_VTABLE(name)  (&_dispatch_continuation_vtables[DC_##name##_TYPE])
-
-#define DC_VTABLE_ENTRY(name, ...)  \
-	[DC_##name##_TYPE] = { \
-		.do_type = DISPATCH_CONTINUATION_TYPE(name), \
-		__VA_ARGS__ \
-	}
-
-#pragma mark -
-#pragma mark _dispatch_set_priority_and_voucher
-#if HAVE_PTHREAD_WORKQUEUE_QOS
-
-void _dispatch_set_priority_and_mach_voucher_slow(pthread_priority_t pri,
-		mach_voucher_t kv);
-voucher_t _dispatch_set_priority_and_voucher_slow(pthread_priority_t pri,
-		voucher_t voucher, dispatch_thread_set_self_t flags);
-#else
-static inline void
-_dispatch_set_priority_and_mach_voucher_slow(pthread_priority_t pri,
-		mach_voucher_t kv)
-{
-	(void)pri; (void)kv;
-}
-#endif
-#pragma mark -
-#pragma mark dispatch_apply_t
-
-struct dispatch_apply_s {
-#if !OS_OBJECT_HAVE_OBJC1
-	dispatch_continuation_t da_dc;
-#endif
-	size_t volatile da_index, da_todo;
-	size_t da_iterations;
-#if OS_OBJECT_HAVE_OBJC1
-	dispatch_continuation_t da_dc;
-#endif
-	size_t da_nested;
-	dispatch_thread_event_s da_event;
-	dispatch_invoke_flags_t da_flags;
-	int32_t da_thr_cnt;
-};
-dispatch_static_assert(offsetof(struct dispatch_continuation_s, dc_flags) ==
-		offsetof(struct dispatch_apply_s, da_dc),
-		"These fields must alias so that leaks instruments work");
-typedef struct dispatch_apply_s *dispatch_apply_t;
-
-#pragma mark -
-#pragma mark dispatch_block_t
-
-#ifdef __BLOCKS__
-
-#define DISPATCH_BLOCK_API_MASK (0x100u - 1)
-#define DISPATCH_BLOCK_HAS_VOUCHER (1u << 31)
-#define DISPATCH_BLOCK_HAS_PRIORITY (1u << 30)
-
-#define DISPATCH_BLOCK_PRIVATE_DATA_HEADER() \
-	unsigned long dbpd_magic; \
-	dispatch_block_flags_t dbpd_flags; \
-	unsigned int volatile dbpd_atomic_flags; \
-	int volatile dbpd_performed; \
-	pthread_priority_t dbpd_priority; \
-	voucher_t dbpd_voucher; \
-	dispatch_block_t dbpd_block; \
-	dispatch_group_t dbpd_group; \
-	dispatch_queue_t dbpd_queue; \
-	mach_port_t dbpd_thread;
-
-#if !defined(__cplusplus)
-struct dispatch_block_private_data_s {
-	DISPATCH_BLOCK_PRIVATE_DATA_HEADER();
-};
-#endif
-typedef struct dispatch_block_private_data_s *dispatch_block_private_data_t;
-
-// dbpd_atomic_flags bits
-#define DBF_CANCELED 1u // block has been cancelled
-#define DBF_WAITING 2u // dispatch_block_wait has begun
-#define DBF_WAITED 4u // dispatch_block_wait has finished without timeout
-#define DBF_PERFORM 8u // dispatch_block_perform: don't group_leave
-
-#define DISPATCH_BLOCK_PRIVATE_DATA_MAGIC 0xD159B10C // 0xDISPatch_BLOCk
-
-// struct for synchronous perform: no group_leave at end of invoke
-#define DISPATCH_BLOCK_PRIVATE_DATA_PERFORM_INITIALIZER(flags, block, voucher) \
-		{ \
-			.dbpd_magic = DISPATCH_BLOCK_PRIVATE_DATA_MAGIC, \
-			.dbpd_flags = (flags), \
-			.dbpd_atomic_flags = DBF_PERFORM, \
-			.dbpd_block = (block), \
-			.dbpd_voucher = (voucher), \
-		}
-
-extern void (*const _dispatch_block_special_invoke)(void*);
-
-dispatch_block_t _dispatch_block_create(dispatch_block_flags_t flags,
-		voucher_t voucher, pthread_priority_t priority, dispatch_block_t block);
-void _dispatch_block_invoke_direct(const struct dispatch_block_private_data_s *dbcpd);
-void _dispatch_block_sync_invoke(void *block);
-
-void *_dispatch_continuation_get_function_symbol(dispatch_continuation_t dc);
-dispatch_qos_t _dispatch_continuation_init_slow(dispatch_continuation_t dc,
-		dispatch_queue_class_t dqu, dispatch_block_flags_t flags);
-
-#endif /* __BLOCKS__ */
-
-#endif
--- a/Telegram/ThirdParty/dispatch/src/semaphore.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/semaphore.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,407 +0,0 @@
-/*
- * Copyright (c) 2008-2013 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include "internal.h"
-
-DISPATCH_WEAK // rdar://problem/8503746
-intptr_t _dispatch_semaphore_signal_slow(dispatch_semaphore_t dsema);
-
-#pragma mark -
-#pragma mark dispatch_semaphore_t
-
-dispatch_semaphore_t
-dispatch_semaphore_create(intptr_t value)
-{
-	dispatch_semaphore_t dsema;
-
-	// If the internal value is negative, then the absolute of the value is
-	// equal to the number of waiting threads. Therefore it is bogus to
-	// initialize the semaphore with a negative value.
-	if (value < 0) {
-		return DISPATCH_BAD_INPUT;
-	}
-
-	dsema = _dispatch_object_alloc(DISPATCH_VTABLE(semaphore),
-			sizeof(struct dispatch_semaphore_s));
-	dsema->do_next = DISPATCH_OBJECT_LISTLESS;
-	dsema->do_targetq = _dispatch_get_default_queue(false);
-	dsema->dsema_value = value;
-	_dispatch_sema4_init(&dsema->dsema_sema, _DSEMA4_POLICY_FIFO);
-	dsema->dsema_orig = value;
-	return dsema;
-}
-
-void
-_dispatch_semaphore_dispose(dispatch_object_t dou,
-		DISPATCH_UNUSED bool *allow_free)
-{
-	dispatch_semaphore_t dsema = dou._dsema;
-
-	if (dsema->dsema_value < dsema->dsema_orig) {
-		DISPATCH_CLIENT_CRASH(dsema->dsema_orig - dsema->dsema_value,
-				"Semaphore object deallocated while in use");
-	}
-
-	_dispatch_sema4_dispose(&dsema->dsema_sema, _DSEMA4_POLICY_FIFO);
-}
-
-size_t
-_dispatch_semaphore_debug(dispatch_object_t dou, char *buf, size_t bufsiz)
-{
-	dispatch_semaphore_t dsema = dou._dsema;
-
-	size_t offset = 0;
-	offset += dsnprintf(&buf[offset], bufsiz - offset, "%s[%p] = { ",
-			_dispatch_object_class_name(dsema), dsema);
-	offset += _dispatch_object_debug_attr(dsema, &buf[offset], bufsiz - offset);
-#if USE_MACH_SEM
-	offset += dsnprintf(&buf[offset], bufsiz - offset, "port = 0x%u, ",
-			dsema->dsema_sema);
-#endif
-	offset += dsnprintf(&buf[offset], bufsiz - offset,
-			"value = %" PRIdPTR ", orig = %" PRIdPTR " }", dsema->dsema_value, dsema->dsema_orig);
-	return offset;
-}
-
-DISPATCH_NOINLINE
-intptr_t
-_dispatch_semaphore_signal_slow(dispatch_semaphore_t dsema)
-{
-	_dispatch_sema4_create(&dsema->dsema_sema, _DSEMA4_POLICY_FIFO);
-	_dispatch_sema4_signal(&dsema->dsema_sema, 1);
-	return 1;
-}
-
-intptr_t
-dispatch_semaphore_signal(dispatch_semaphore_t dsema)
-{
-	long value = os_atomic_inc2o(dsema, dsema_value, release);
-	if (likely(value > 0)) {
-		return 0;
-	}
-	if (unlikely(value == LONG_MIN)) {
-		DISPATCH_CLIENT_CRASH(value,
-				"Unbalanced call to dispatch_semaphore_signal()");
-	}
-	return _dispatch_semaphore_signal_slow(dsema);
-}
-
-DISPATCH_NOINLINE
-static intptr_t
-_dispatch_semaphore_wait_slow(dispatch_semaphore_t dsema,
-		dispatch_time_t timeout)
-{
-	long orig;
-
-	_dispatch_sema4_create(&dsema->dsema_sema, _DSEMA4_POLICY_FIFO);
-	switch (timeout) {
-	default:
-		if (!_dispatch_sema4_timedwait(&dsema->dsema_sema, timeout)) {
-			break;
-		}
-		// Try to undo what the fast path did to dsema->dsema_value
-		DISPATCH_FALLTHROUGH;
-	case DISPATCH_TIME_NOW:
-		orig = dsema->dsema_value;
-		while (orig < 0) {
-			if (os_atomic_cmpxchgvw2o(dsema, dsema_value, orig, orig + 1,
-					&orig, relaxed)) {
-				return _DSEMA4_TIMEOUT();
-			}
-		}
-		// Another thread called semaphore_signal(). Drain the wakeup.
-		DISPATCH_FALLTHROUGH;
-	case DISPATCH_TIME_FOREVER:
-		_dispatch_sema4_wait(&dsema->dsema_sema);
-		break;
-	}
-	return 0;
-}
-
-intptr_t
-dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)
-{
-	long value = os_atomic_dec2o(dsema, dsema_value, acquire);
-	if (likely(value >= 0)) {
-		return 0;
-	}
-	return _dispatch_semaphore_wait_slow(dsema, timeout);
-}
-
-#pragma mark -
-#pragma mark dispatch_group_t
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_group_t
-_dispatch_group_create_with_count(uint32_t n)
-{
-	dispatch_group_t dg = _dispatch_object_alloc(DISPATCH_VTABLE(group),
-			sizeof(struct dispatch_group_s));
-	dg->do_next = DISPATCH_OBJECT_LISTLESS;
-	dg->do_targetq = _dispatch_get_default_queue(false);
-	if (n) {
-		os_atomic_store2o(dg, dg_bits,
-				(uint32_t)-n * DISPATCH_GROUP_VALUE_INTERVAL, relaxed);
-		os_atomic_store2o(dg, do_ref_cnt, 1, relaxed); // <rdar://22318411>
-	}
-	return dg;
-}
-
-dispatch_group_t
-dispatch_group_create(void)
-{
-	return _dispatch_group_create_with_count(0);
-}
-
-dispatch_group_t
-_dispatch_group_create_and_enter(void)
-{
-	return _dispatch_group_create_with_count(1);
-}
-
-void
-_dispatch_group_dispose(dispatch_object_t dou, DISPATCH_UNUSED bool *allow_free)
-{
-	uint64_t dg_state = os_atomic_load2o(dou._dg, dg_state, relaxed);
-
-	if (unlikely((uint32_t)dg_state)) {
-		DISPATCH_CLIENT_CRASH((uintptr_t)dg_state,
-				"Group object deallocated while in use");
-	}
-}
-
-size_t
-_dispatch_group_debug(dispatch_object_t dou, char *buf, size_t bufsiz)
-{
-	dispatch_group_t dg = dou._dg;
-	uint64_t dg_state = os_atomic_load2o(dg, dg_state, relaxed);
-
-	size_t offset = 0;
-	offset += dsnprintf(&buf[offset], bufsiz - offset, "%s[%p] = { ",
-			_dispatch_object_class_name(dg), dg);
-	offset += _dispatch_object_debug_attr(dg, &buf[offset], bufsiz - offset);
-	offset += dsnprintf(&buf[offset], bufsiz - offset,
-			"count = %u, gen = %d, waiters = %d, notifs = %d }",
-			_dg_state_value(dg_state), _dg_state_gen(dg_state),
-			(bool)(dg_state & DISPATCH_GROUP_HAS_WAITERS),
-			(bool)(dg_state & DISPATCH_GROUP_HAS_NOTIFS));
-	return offset;
-}
-
-DISPATCH_NOINLINE
-static intptr_t
-_dispatch_group_wait_slow(dispatch_group_t dg, uint32_t gen,
-		dispatch_time_t timeout)
-{
-	for (;;) {
-		int rc = _dispatch_wait_on_address(&dg->dg_gen, gen, timeout, 0);
-		if (likely(gen != os_atomic_load2o(dg, dg_gen, acquire))) {
-			return 0;
-		}
-		if (rc == ETIMEDOUT) {
-			return _DSEMA4_TIMEOUT();
-		}
-	}
-}
-
-intptr_t
-dispatch_group_wait(dispatch_group_t dg, dispatch_time_t timeout)
-{
-	uint64_t old_state, new_state;
-
-	os_atomic_rmw_loop2o(dg, dg_state, old_state, new_state, relaxed, {
-		if ((old_state & DISPATCH_GROUP_VALUE_MASK) == 0) {
-			os_atomic_rmw_loop_give_up_with_fence(acquire, return 0);
-		}
-		if (unlikely(timeout == 0)) {
-			os_atomic_rmw_loop_give_up(return _DSEMA4_TIMEOUT());
-		}
-		new_state = old_state | DISPATCH_GROUP_HAS_WAITERS;
-		if (unlikely(old_state & DISPATCH_GROUP_HAS_WAITERS)) {
-			os_atomic_rmw_loop_give_up(break);
-		}
-	});
-
-	return _dispatch_group_wait_slow(dg, _dg_state_gen(new_state), timeout);
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_group_wake(dispatch_group_t dg, uint64_t dg_state, bool needs_release)
-{
-	uint16_t refs = needs_release ? 1 : 0; // <rdar://problem/22318411>
-
-	if (dg_state & DISPATCH_GROUP_HAS_NOTIFS) {
-		dispatch_continuation_t dc, next_dc, tail;
-
-		// Snapshot before anything is notified/woken <rdar://problem/8554546>
-		dc = os_mpsc_capture_snapshot(os_mpsc(dg, dg_notify), &tail);
-		do {
-			dispatch_queue_t dsn_queue = (dispatch_queue_t)dc->dc_data;
-			next_dc = os_mpsc_pop_snapshot_head(dc, tail, do_next);
-			_dispatch_continuation_async(dsn_queue, dc,
-					_dispatch_qos_from_pp(dc->dc_priority), dc->dc_flags);
-			_dispatch_release(dsn_queue);
-		} while ((dc = next_dc));
-
-		refs++;
-	}
-
-	if (dg_state & DISPATCH_GROUP_HAS_WAITERS) {
-		_dispatch_wake_by_address(&dg->dg_gen);
-	}
-
-	if (refs) _dispatch_release_n(dg, refs);
-}
-
-void
-dispatch_group_leave(dispatch_group_t dg)
-{
-	// The value is incremented on a 64bits wide atomic so that the carry for
-	// the -1 -> 0 transition increments the generation atomically.
-	uint64_t new_state, old_state = os_atomic_add_orig2o(dg, dg_state,
-			DISPATCH_GROUP_VALUE_INTERVAL, release);
-	uint32_t old_value = (uint32_t)(old_state & DISPATCH_GROUP_VALUE_MASK);
-
-	if (unlikely(old_value == DISPATCH_GROUP_VALUE_1)) {
-		old_state += DISPATCH_GROUP_VALUE_INTERVAL;
-		do {
-			new_state = old_state;
-			if ((old_state & DISPATCH_GROUP_VALUE_MASK) == 0) {
-				new_state &= ~DISPATCH_GROUP_HAS_WAITERS;
-				new_state &= ~DISPATCH_GROUP_HAS_NOTIFS;
-			} else {
-				// If the group was entered again since the atomic_add above,
-				// we can't clear the waiters bit anymore as we don't know for
-				// which generation the waiters are for
-				new_state &= ~DISPATCH_GROUP_HAS_NOTIFS;
-			}
-			if (old_state == new_state) break;
-		} while (unlikely(!os_atomic_cmpxchgv2o(dg, dg_state,
-				old_state, new_state, &old_state, relaxed)));
-		return _dispatch_group_wake(dg, old_state, true);
-	}
-
-	if (unlikely(old_value == 0)) {
-		DISPATCH_CLIENT_CRASH((uintptr_t)old_value,
-				"Unbalanced call to dispatch_group_leave()");
-	}
-}
-
-void
-dispatch_group_enter(dispatch_group_t dg)
-{
-	// The value is decremented on a 32bits wide atomic so that the carry
-	// for the 0 -> -1 transition is not propagated to the upper 32bits.
-	uint32_t old_bits = os_atomic_sub_orig2o(dg, dg_bits,
-			DISPATCH_GROUP_VALUE_INTERVAL, acquire);
-	uint32_t old_value = old_bits & DISPATCH_GROUP_VALUE_MASK;
-	if (unlikely(old_value == 0)) {
-		_dispatch_retain(dg); // <rdar://problem/22318411>
-	}
-	if (unlikely(old_value == DISPATCH_GROUP_VALUE_MAX)) {
-		DISPATCH_CLIENT_CRASH(old_bits,
-				"Too many nested calls to dispatch_group_enter()");
-	}
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_group_notify(dispatch_group_t dg, dispatch_queue_t dq,
-		dispatch_continuation_t dsn)
-{
-	uint64_t old_state, new_state;
-	dispatch_continuation_t prev;
-
-	dsn->dc_data = dq;
-	_dispatch_retain(dq);
-
-	prev = os_mpsc_push_update_tail(os_mpsc(dg, dg_notify), dsn, do_next);
-	if (os_mpsc_push_was_empty(prev)) _dispatch_retain(dg);
-	os_mpsc_push_update_prev(os_mpsc(dg, dg_notify), prev, dsn, do_next);
-	if (os_mpsc_push_was_empty(prev)) {
-		os_atomic_rmw_loop2o(dg, dg_state, old_state, new_state, release, {
-			new_state = old_state | DISPATCH_GROUP_HAS_NOTIFS;
-			if ((uint32_t)old_state == 0) {
-				os_atomic_rmw_loop_give_up({
-					return _dispatch_group_wake(dg, new_state, false);
-				});
-			}
-		});
-	}
-}
-
-DISPATCH_NOINLINE
-void
-dispatch_group_notify_f(dispatch_group_t dg, dispatch_queue_t dq, void *ctxt,
-		dispatch_function_t func)
-{
-	dispatch_continuation_t dsn = _dispatch_continuation_alloc();
-	_dispatch_continuation_init_f(dsn, dq, ctxt, func, 0, DC_FLAG_CONSUME);
-	_dispatch_group_notify(dg, dq, dsn);
-}
-
-#ifdef __BLOCKS__
-void
-dispatch_group_notify(dispatch_group_t dg, dispatch_queue_t dq,
-		dispatch_block_t db)
-{
-	dispatch_continuation_t dsn = _dispatch_continuation_alloc();
-	_dispatch_continuation_init(dsn, dq, db, 0, DC_FLAG_CONSUME);
-	_dispatch_group_notify(dg, dq, dsn);
-}
-#endif
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_continuation_group_async(dispatch_group_t dg, dispatch_queue_t dq,
-		dispatch_continuation_t dc, dispatch_qos_t qos)
-{
-	dispatch_group_enter(dg);
-	dc->dc_data = dg;
-	_dispatch_continuation_async(dq, dc, qos, dc->dc_flags);
-}
-
-DISPATCH_NOINLINE
-void
-dispatch_group_async_f(dispatch_group_t dg, dispatch_queue_t dq, void *ctxt,
-		dispatch_function_t func)
-{
-	dispatch_continuation_t dc = _dispatch_continuation_alloc();
-	uintptr_t dc_flags = DC_FLAG_CONSUME | DC_FLAG_GROUP_ASYNC;
-	dispatch_qos_t qos;
-
-	qos = _dispatch_continuation_init_f(dc, dq, ctxt, func, 0, dc_flags);
-	_dispatch_continuation_group_async(dg, dq, dc, qos);
-}
-
-#ifdef __BLOCKS__
-void
-dispatch_group_async(dispatch_group_t dg, dispatch_queue_t dq,
-		dispatch_block_t db)
-{
-	dispatch_continuation_t dc = _dispatch_continuation_alloc();
-	uintptr_t dc_flags = DC_FLAG_CONSUME | DC_FLAG_GROUP_ASYNC;
-	dispatch_qos_t qos;
-
-	qos = _dispatch_continuation_init(dc, dq, db, 0, dc_flags);
-	_dispatch_continuation_group_async(dg, dq, dc, qos);
-}
-#endif
--- a/Telegram/ThirdParty/dispatch/src/semaphore_internal.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/semaphore_internal.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,109 +0,0 @@
-/*
- * Copyright (c) 2008-2013 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-/*
- * IMPORTANT: This header file describes INTERNAL interfaces to libdispatch
- * which are subject to change in future releases of Mac OS X. Any applications
- * relying on these interfaces WILL break.
- */
-
-#ifndef __DISPATCH_SEMAPHORE_INTERNAL__
-#define __DISPATCH_SEMAPHORE_INTERNAL__
-
-struct dispatch_queue_s;
-
-DISPATCH_CLASS_DECL(semaphore, OBJECT);
-struct dispatch_semaphore_s {
-	DISPATCH_OBJECT_HEADER(semaphore);
-	intptr_t volatile dsema_value;
-	intptr_t dsema_orig;
-	_dispatch_sema4_t dsema_sema;
-};
-
-/*
- * Dispatch Group State:
- *
- * Generation (32 - 63):
- *   32 bit counter that is incremented each time the group value reaaches
- *   0 after a dispatch_group_leave. This 32bit word is used to block waiters
- *   (threads in dispatch_group_wait) in _dispatch_wait_on_address() until the
- *   generation changes.
- *
- * Value (2 - 31):
- *   30 bit value counter of the number of times the group was entered.
- *   dispatch_group_enter counts downward on 32bits, and dispatch_group_leave
- *   upward on 64bits, which causes the generation to bump each time the value
- *   reaches 0 again due to carry propagation.
- *
- * Has Notifs (1):
- *   This bit is set when the list of notifications on the group becomes non
- *   empty. It is also used as a lock as the thread that successfuly clears this
- *   bit is the thread responsible for firing the notifications.
- *
- * Has Waiters (0):
- *   This bit is set when there are waiters (threads in dispatch_group_wait)
- *   that need to be woken up the next time the value reaches 0. Waiters take
- *   a snapshot of the generation before waiting and will wait for the
- *   generation to change before they return.
- */
-#define DISPATCH_GROUP_GEN_MASK         0xffffffff00000000ULL
-#define DISPATCH_GROUP_VALUE_MASK       0x00000000fffffffcULL
-#define DISPATCH_GROUP_VALUE_INTERVAL   0x0000000000000004ULL
-#define DISPATCH_GROUP_VALUE_1          DISPATCH_GROUP_VALUE_MASK
-#define DISPATCH_GROUP_VALUE_MAX        DISPATCH_GROUP_VALUE_INTERVAL
-#define DISPATCH_GROUP_HAS_NOTIFS       0x0000000000000002ULL
-#define DISPATCH_GROUP_HAS_WAITERS      0x0000000000000001ULL
-DISPATCH_CLASS_DECL(group, OBJECT);
-struct dispatch_group_s {
-	DISPATCH_OBJECT_HEADER(group);
-	DISPATCH_UNION_LE(uint64_t volatile dg_state,
-			uint32_t dg_bits,
-			uint32_t dg_gen
-	) DISPATCH_ATOMIC64_ALIGN;
-	struct dispatch_continuation_s *volatile dg_notify_head;
-	struct dispatch_continuation_s *volatile dg_notify_tail;
-};
-
-DISPATCH_ALWAYS_INLINE
-static inline uint32_t
-_dg_state_value(uint64_t dg_state)
-{
-	return (uint32_t)(-((uint32_t)dg_state & DISPATCH_GROUP_VALUE_MASK)) >> 2;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline uint32_t
-_dg_state_gen(uint64_t dg_state)
-{
-	return (uint32_t)(dg_state >> 32);
-}
-
-dispatch_group_t _dispatch_group_create_and_enter(void);
-void _dispatch_group_dispose(dispatch_object_t dou, bool *allow_free);
-DISPATCH_COLD
-size_t _dispatch_group_debug(dispatch_object_t dou, char *buf,
-		size_t bufsiz);
-
-void _dispatch_semaphore_dispose(dispatch_object_t dou, bool *allow_free);
-DISPATCH_COLD
-size_t _dispatch_semaphore_debug(dispatch_object_t dou, char *buf,
-		size_t bufsiz);
-
-#endif
--- a/Telegram/ThirdParty/dispatch/src/shims/android_stubs.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/shims/android_stubs.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,23 +0,0 @@
-/*
- * This source file is part of the Swift.org open source project
- *
- * Copyright (c) 2015 Apple Inc. and the Swift project authors
- *
- * Licensed under Apache License v2.0 with Runtime Library Exception
- *
- * See https://swift.org/LICENSE.txt for license information
- * See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
- *
- */
-
-// forward declarations for functions we are stubbing out
-// in the intial android port.
-
-#ifndef __DISPATCH__ANDROID__STUBS__INTERNAL
-#define __DISPATCH__ANDROID__STUBS__INTERNAL
-
-#if !__has_feature(c_static_assert)
-#define _Static_assert(...)
-#endif
-
-#endif /* __DISPATCH__ANDROID__STUBS__INTERNAL */
--- a/Telegram/ThirdParty/dispatch/src/shims/atomic.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/shims/atomic.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,178 +0,0 @@
-/*
- * Copyright (c) 2008-2016 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-/*
- * IMPORTANT: This header file describes INTERNAL interfaces to libdispatch
- * which are subject to change in future releases of Mac OS X. Any applications
- * relying on these interfaces WILL break.
- */
-
-#ifndef __DISPATCH_SHIMS_ATOMIC__
-#define __DISPATCH_SHIMS_ATOMIC__
-
-#if !__has_extension(c_atomic) || !__has_include(<stdatomic.h>)
-#error libdispatch requires C11 with <stdatomic.h>
-#endif
-
-// FreeBSD only defines _Bool in C mode. In C++ mode _Bool is not being defined.
-#if defined(__cplusplus)
-#define _Bool bool
-#endif
-#if defined(__ANDROID__) && __NDK_MAJOR__ >= 23
-#include <bits/stdatomic.h>
-#else
-#include <stdatomic.h>
-#endif
-
-#define memory_order_ordered    memory_order_seq_cst
-#define memory_order_dependency memory_order_acquire
-
-#define os_atomic(type) type _Atomic
-
-#define _os_atomic_c11_atomic(p) \
-		((__typeof__(*(p)) _Atomic *)(p))
-
-// This removes the _Atomic and volatile qualifiers on the type of *p
-#define _os_atomic_basetypeof(p) \
-		__typeof__(atomic_load_explicit(_os_atomic_c11_atomic(p), memory_order_relaxed))
-
-#define os_atomic_load(p, m) \
-		atomic_load_explicit(_os_atomic_c11_atomic(p), memory_order_##m)
-#define os_atomic_store(p, v, m) \
-		atomic_store_explicit(_os_atomic_c11_atomic(p), v, memory_order_##m)
-#define os_atomic_xchg(p, v, m) \
-		atomic_exchange_explicit(_os_atomic_c11_atomic(p), v, memory_order_##m)
-#define os_atomic_cmpxchg(p, e, v, m) \
-		({ _os_atomic_basetypeof(p) _r = (e); \
-		atomic_compare_exchange_strong_explicit(_os_atomic_c11_atomic(p), \
-		&_r, v, memory_order_##m, memory_order_relaxed); })
-#define os_atomic_cmpxchgv(p, e, v, g, m) \
-		({ _os_atomic_basetypeof(p) _r = (e); _Bool _b = \
-		atomic_compare_exchange_strong_explicit(_os_atomic_c11_atomic(p), \
-		&_r, v, memory_order_##m, memory_order_relaxed); *(g) = _r; _b; })
-#define os_atomic_cmpxchgvw(p, e, v, g, m) \
-		({ _os_atomic_basetypeof(p) _r = (e); _Bool _b = \
-		atomic_compare_exchange_weak_explicit(_os_atomic_c11_atomic(p), \
-		&_r, v, memory_order_##m, memory_order_relaxed); *(g) = _r;  _b; })
-
-#define _os_atomic_c11_op(p, v, m, o, op) \
-		({ _os_atomic_basetypeof(p) _v = (v), _r = \
-		atomic_fetch_##o##_explicit(_os_atomic_c11_atomic(p), _v, \
-		memory_order_##m); (__typeof__(_r))(_r op _v); })
-#define _os_atomic_c11_op_orig(p, v, m, o, op) \
-		atomic_fetch_##o##_explicit(_os_atomic_c11_atomic(p), v, \
-		memory_order_##m)
-#define os_atomic_add(p, v, m) \
-		_os_atomic_c11_op((p), (v), m, add, +)
-#define os_atomic_add_orig(p, v, m) \
-		_os_atomic_c11_op_orig((p), (v), m, add, +)
-#define os_atomic_sub(p, v, m) \
-		_os_atomic_c11_op((p), (v), m, sub, -)
-#define os_atomic_sub_orig(p, v, m) \
-		_os_atomic_c11_op_orig((p), (v), m, sub, -)
-#define os_atomic_and(p, v, m) \
-		_os_atomic_c11_op((p), (v), m, and, &)
-#define os_atomic_and_orig(p, v, m) \
-		_os_atomic_c11_op_orig((p), (v), m, and, &)
-#define os_atomic_or(p, v, m) \
-		_os_atomic_c11_op((p), (v), m, or, |)
-#define os_atomic_or_orig(p, v, m) \
-		_os_atomic_c11_op_orig((p), (v), m, or, |)
-#define os_atomic_xor(p, v, m) \
-		_os_atomic_c11_op((p), (v), m, xor, ^)
-#define os_atomic_xor_orig(p, v, m) \
-		_os_atomic_c11_op_orig((p), (v), m, xor, ^)
-
-#define os_atomic_force_dependency_on(p, e) (p)
-#define os_atomic_load_with_dependency_on(p, e) \
-		os_atomic_load(os_atomic_force_dependency_on(p, e), relaxed)
-#define os_atomic_load_with_dependency_on2o(p, f, e) \
-		os_atomic_load_with_dependency_on(&(p)->f, e)
-
-#define os_atomic_thread_fence(m)  atomic_thread_fence(memory_order_##m)
-
-#define os_atomic_load2o(p, f, m) \
-		os_atomic_load(&(p)->f, m)
-#define os_atomic_store2o(p, f, v, m) \
-		os_atomic_store(&(p)->f, (v), m)
-#define os_atomic_xchg2o(p, f, v, m) \
-		os_atomic_xchg(&(p)->f, (v), m)
-#define os_atomic_cmpxchg2o(p, f, e, v, m) \
-		os_atomic_cmpxchg(&(p)->f, (e), (v), m)
-#define os_atomic_cmpxchgv2o(p, f, e, v, g, m) \
-		os_atomic_cmpxchgv(&(p)->f, (e), (v), (g), m)
-#define os_atomic_cmpxchgvw2o(p, f, e, v, g, m) \
-		os_atomic_cmpxchgvw(&(p)->f, (e), (v), (g), m)
-#define os_atomic_add2o(p, f, v, m) \
-		os_atomic_add(&(p)->f, (v), m)
-#define os_atomic_add_orig2o(p, f, v, m) \
-		os_atomic_add_orig(&(p)->f, (v), m)
-#define os_atomic_sub2o(p, f, v, m) \
-		os_atomic_sub(&(p)->f, (v), m)
-#define os_atomic_sub_orig2o(p, f, v, m) \
-		os_atomic_sub_orig(&(p)->f, (v), m)
-#define os_atomic_and2o(p, f, v, m) \
-		os_atomic_and(&(p)->f, (v), m)
-#define os_atomic_and_orig2o(p, f, v, m) \
-		os_atomic_and_orig(&(p)->f, (v), m)
-#define os_atomic_or2o(p, f, v, m) \
-		os_atomic_or(&(p)->f, (v), m)
-#define os_atomic_or_orig2o(p, f, v, m) \
-		os_atomic_or_orig(&(p)->f, (v), m)
-#define os_atomic_xor2o(p, f, v, m) \
-		os_atomic_xor(&(p)->f, (v), m)
-#define os_atomic_xor_orig2o(p, f, v, m) \
-		os_atomic_xor_orig(&(p)->f, (v), m)
-
-#define os_atomic_inc(p, m) \
-		os_atomic_add((p), 1, m)
-#define os_atomic_inc_orig(p, m) \
-		os_atomic_add_orig((p), 1, m)
-#define os_atomic_inc2o(p, f, m) \
-		os_atomic_add2o(p, f, 1, m)
-#define os_atomic_inc_orig2o(p, f, m) \
-		os_atomic_add_orig2o(p, f, 1, m)
-#define os_atomic_dec(p, m) \
-		os_atomic_sub((p), 1, m)
-#define os_atomic_dec_orig(p, m) \
-		os_atomic_sub_orig((p), 1, m)
-#define os_atomic_dec2o(p, f, m) \
-		os_atomic_sub2o(p, f, 1, m)
-#define os_atomic_dec_orig2o(p, f, m) \
-		os_atomic_sub_orig2o(p, f, 1, m)
-
-#define os_atomic_rmw_loop(p, ov, nv, m, ...)  ({ \
-		bool _result = false; \
-		__typeof__(p) _p = (p); \
-		ov = os_atomic_load(_p, relaxed); \
-		do { \
-			__VA_ARGS__; \
-			_result = os_atomic_cmpxchgvw(_p, ov, nv, &ov, m); \
-		} while (unlikely(!_result)); \
-		_result; \
-	})
-#define os_atomic_rmw_loop2o(p, f, ov, nv, m, ...) \
-		os_atomic_rmw_loop(&(p)->f, ov, nv, m, __VA_ARGS__)
-#define os_atomic_rmw_loop_give_up_with_fence(m, expr) \
-		({ os_atomic_thread_fence(m); expr; __builtin_unreachable(); })
-#define os_atomic_rmw_loop_give_up(expr) \
-		os_atomic_rmw_loop_give_up_with_fence(relaxed, expr)
-
-#endif // __DISPATCH_SHIMS_ATOMIC__
--- a/Telegram/ThirdParty/dispatch/src/shims/atomic_sfb.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/shims/atomic_sfb.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,108 +0,0 @@
-/*
- * Copyright (c) 2012-2013 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-/*
- * IMPORTANT: This header file describes INTERNAL interfaces to libdispatch
- * which are subject to change in future releases of Mac OS X. Any applications
- * relying on these interfaces WILL break.
- */
-
-#ifndef __DISPATCH_SHIMS_ATOMIC_SFB__
-#define __DISPATCH_SHIMS_ATOMIC_SFB__
-
-#if defined(__x86_64__) || defined(__i386__)
-
-// Returns UINT_MAX if all the bits in p were already set.
-DISPATCH_ALWAYS_INLINE
-static inline unsigned int
-os_atomic_set_first_bit(volatile unsigned long *p, unsigned int max)
-{
-	unsigned long val, bit;
-	if (max > (sizeof(val) * 8)) {
-		__asm__ (
-				 "1: \n\t"
-				 "mov	%[_p], %[_val] \n\t"
-				 "not	%[_val] \n\t"
-				 "bsf	%[_val], %[_bit] \n\t" /* val is 0 => set zf */
-				 "jz	2f \n\t"
-				 "lock \n\t"
-				 "bts	%[_bit], %[_p] \n\t" /* cf = prev bit val */
-				 "jc	1b \n\t" /* lost race, retry */
-				 "jmp	3f \n\t"
-				 "2: \n\t"
-				 "mov	%[_all_ones], %[_bit]" "\n\t"
-				 "3: \n\t"
-				 : [_p] "=m" (*p), [_val] "=&r" (val), [_bit] "=&r" (bit)
-				 : [_all_ones] "i" ((__typeof__(bit))UINT_MAX) : "memory", "cc");
-	} else {
-		__asm__ (
-				 "1: \n\t"
-				 "mov	%[_p], %[_val] \n\t"
-				 "not	%[_val] \n\t"
-				 "bsf	%[_val], %[_bit] \n\t" /* val is 0 => set zf */
-				 "jz	2f \n\t"
-				 "cmp	%[_max], %[_bit] \n\t"
-				 "jg	2f \n\t"
-				 "lock \n\t"
-				 "bts	%[_bit], %[_p] \n\t" /* cf = prev bit val */
-				 "jc	1b \n\t" /* lost race, retry */
-				 "jmp	3f \n\t"
-				 "2: \n\t"
-				 "mov	%[_all_ones], %[_bit]" "\n\t"
-				 "3: \n\t"
-				 : [_p] "=m" (*p), [_val] "=&r" (val), [_bit] "=&r" (bit)
-				 : [_all_ones] "i" ((__typeof__(bit))UINT_MAX),
-				   [_max] "g" ((__typeof__(bit))max) : "memory", "cc");
-	}
-	return (unsigned int)bit;
-}
-
-#else
-
-#if __clang__ && __clang_major__ < 5 // <rdar://problem/13833871>
-#define __builtin_ffs(x) __builtin_ffs((unsigned int)(x))
-#endif
-
-DISPATCH_ALWAYS_INLINE
-static inline unsigned int
-os_atomic_set_first_bit(volatile unsigned long *p, unsigned int max_index)
-{
-	unsigned int index;
-	unsigned long b, b_masked;
-
-	os_atomic_rmw_loop(p, b, b_masked, relaxed, {
-		// ffs returns 1 + index, or 0 if none set
-		index = (unsigned int)__builtin_ffsl((long)~b);
-		if (unlikely(index == 0)) {
-			os_atomic_rmw_loop_give_up(return UINT_MAX);
-		}
-		index--;
-		if (unlikely(index > max_index)) {
-			os_atomic_rmw_loop_give_up(return UINT_MAX);
-		}
-		b_masked = b | (1UL << index);
-	});
-
-	return index;
-}
-
-#endif
-
-#endif // __DISPATCH_SHIMS_ATOMIC_SFB__
--- a/Telegram/ThirdParty/dispatch/src/shims/generic_sys_queue.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/shims/generic_sys_queue.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,150 +0,0 @@
-/*
- * Copyright (c) 2018 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-/*
- * NOTE: This header files defines a trimmed down version of the BSD sys/queue.h
- * macros for use on platforms which do not come with a sys/queue.h file.
- */
-
-#ifndef __DISPATCH_SHIMS_SYS_QUEUE__
-#define __DISPATCH_SHIMS_SYS_QUEUE__
-
-#ifndef TRASHIT
-#define TRASHIT(elem) (elem) = NULL;
-#endif
-
-#define TAILQ_HEAD(list_name, elem_type) \
-	struct list_name { \
-		struct elem_type *tq_first; \
-		struct elem_type *tq_last; \
-	}
-
-#define TAILQ_ENTRY(elem_type) \
-	struct { \
-		struct elem_type *te_next; \
-		struct elem_type *te_prev; \
-	}
-
-#define TAILQ_INIT(list) do { \
-		(list)->tq_first = NULL; \
-		(list)->tq_last = NULL; \
-	} while (0)
-
-#define TAILQ_EMPTY(list) ((list)->tq_first == NULL)
-
-#define TAILQ_FIRST(list) ((list)->tq_first)
-
-#define TAILQ_LAST(list) ((list)->tq_last)
-
-#define TAILQ_NEXT(elem, field) ((elem)->field.te_next)
-
-#define TAILQ_PREV(elem, list, field) ((elem)->field.te_prev)
-
-#define TAILQ_FOREACH(var, list, field) \
-	for ((var) = TAILQ_FIRST(list); \
-	(var) != NULL; \
-	(var) = TAILQ_NEXT(var, field))
-
-#define TAILQ_REMOVE(list, elem, field) do { \
-		if (TAILQ_NEXT(elem, field) != NULL) { \
-			TAILQ_NEXT(elem, field)->field.te_prev = (elem)->field.te_prev; \
-		} else { \
-			(list)->tq_last = (elem)->field.te_prev; \
-		} \
-		if (TAILQ_PREV(elem, list, field) != NULL) { \
-			TAILQ_PREV(elem, list, field)->field.te_next = (elem)->field.te_next; \
-		} else { \
-			(list)->tq_first = (elem)->field.te_next; \
-		} \
-		TRASHIT((elem)->field.te_next); \
-		TRASHIT((elem)->field.te_prev); \
-	} while(0)
-
-#define TAILQ_INSERT_TAIL(list, elem, field) do { \
-		if (TAILQ_EMPTY(list)) { \
-			(list)->tq_first = (list)->tq_last = (elem); \
-			(elem)->field.te_prev = (elem)->field.te_next = NULL; \
-		} else { \
-			(elem)->field.te_next = NULL; \
-			(elem)->field.te_prev = (list)->tq_last; \
-			TAILQ_LAST(list)->field.te_next = (elem); \
-			(list)->tq_last = (elem); \
-		} \
-	} while(0)
-
-#define TAILQ_HEAD_INITIALIZER(head) \
-	{ NULL, (head).tq_first }
-
-#define TAILQ_CONCAT(head1, head2, field) do { \
-		if (!TAILQ_EMPTY(head2)) { \
-			if ((head1)->tq_last) { \
-				(head1)->tq_last->field.te_next = (head2)->tq_first; \
-			} else { \
-				(head1)->tq_first = (head2)->tq_first; \
-			} \
-			(head2)->tq_first->field.te_prev = (head1)->tq_last; \
-			(head1)->tq_last = (head2)->tq_last; \
-			TAILQ_INIT((head2)); \
-		} \
-	} while (0)
-
-#define LIST_HEAD(name, type) struct name { \
-		struct type *lh_first; \
-	}
-
-#define LIST_ENTRY(type) struct { \
-		struct type *le_next; \
-		struct type **le_prev; \
-	}
-
-#define	LIST_EMPTY(head) ((head)->lh_first == NULL)
-
-#define LIST_FIRST(head) ((head)->lh_first)
-
-#define LIST_FOREACH(var, head, field) \
-	for ((var) = LIST_FIRST((head)); \
-		(var); \
-		(var) = LIST_NEXT((var), field))
-
-#define	LIST_FOREACH_SAFE(var, head, field, tvar) \
-	for ((var) = LIST_FIRST((head)); \
-		(var) && ((tvar) = LIST_NEXT((var), field), 1); \
-		(var) = (tvar))
-
-#define	LIST_INIT(head) do { \
-	LIST_FIRST((head)) = NULL; \
-} while (0)
-
-#define LIST_NEXT(elm, field) ((elm)->field.le_next)
-
-#define LIST_REMOVE(elm, field) do { \
-		if (LIST_NEXT((elm), field) != NULL) \
-			LIST_NEXT((elm), field)->field.le_prev = (elm)->field.le_prev; \
-		*(elm)->field.le_prev = LIST_NEXT((elm), field); \
-	} while (0)
-
-#define LIST_INSERT_HEAD(head, elm, field) do { \
-		if ((LIST_NEXT((elm), field) = LIST_FIRST((head))) != NULL) \
-			LIST_FIRST((head))->field.le_prev = &LIST_NEXT((elm), field); \
-		LIST_FIRST((head)) = (elm); \
-		(elm)->field.le_prev = &LIST_FIRST((head)); \
-	} while (0)
-
-#endif // __DISPATCH_SHIMS_SYS_QUEUE__
--- a/Telegram/ThirdParty/dispatch/src/shims/generic_win_stubs.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/shims/generic_win_stubs.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,84 +0,0 @@
-#include "internal.h"
-
-typedef void (WINAPI *_precise_time_fn_t)(PULONGLONG);
-
-DISPATCH_STATIC_GLOBAL(dispatch_once_t _dispatch_precise_time_pred);
-DISPATCH_STATIC_GLOBAL(_precise_time_fn_t _dispatch_QueryInterruptTimePrecise_ptr);
-DISPATCH_STATIC_GLOBAL(_precise_time_fn_t _dispatch_QueryUnbiasedInterruptTimePrecise_ptr);
-
-typedef NTSTATUS (NTAPI *_NtQueryInformationFile_fn_t)(HANDLE FileHandle,
-		PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length,
-		FILE_INFORMATION_CLASS FileInformationClass);
-
-DISPATCH_STATIC_GLOBAL(dispatch_once_t _dispatch_ntdll_pred);
-DISPATCH_STATIC_GLOBAL(_NtQueryInformationFile_fn_t _dispatch_NtQueryInformationFile_ptr);
-
-bool
-_dispatch_handle_is_socket(HANDLE hFile)
-{
-	// GetFileType() returns FILE_TYPE_PIPE for both pipes and sockets. We can
-	// disambiguate by checking if PeekNamedPipe() fails with
-	// ERROR_INVALID_FUNCTION.
-	if (GetFileType(hFile) == FILE_TYPE_PIPE &&
-			!PeekNamedPipe(hFile, NULL, 0, NULL, NULL, NULL)) {
-		return GetLastError() == ERROR_INVALID_FUNCTION;
-	}
-	return false;
-}
-
-static void
-_dispatch_init_precise_time(void *context DISPATCH_UNUSED)
-{
-	HMODULE kernelbase = LoadLibraryW(L"KernelBase.dll");
-	if (!kernelbase) {
-		DISPATCH_INTERNAL_CRASH(0, "failed to load KernelBase.dll");
-	}
-	_dispatch_QueryInterruptTimePrecise_ptr = (_precise_time_fn_t)
-			GetProcAddress(kernelbase, "QueryInterruptTimePrecise");
-	_dispatch_QueryUnbiasedInterruptTimePrecise_ptr = (_precise_time_fn_t)
-			GetProcAddress(kernelbase, "QueryUnbiasedInterruptTimePrecise");
-	if (!_dispatch_QueryInterruptTimePrecise_ptr) {
-		DISPATCH_INTERNAL_CRASH(0, "could not locate QueryInterruptTimePrecise");
-	}
-	if (!_dispatch_QueryUnbiasedInterruptTimePrecise_ptr) {
-		DISPATCH_INTERNAL_CRASH(0, "could not locate QueryUnbiasedInterruptTimePrecise");
-	}
-}
-
-void
-_dispatch_QueryInterruptTimePrecise(PULONGLONG lpInterruptTimePrecise)
-{
-	dispatch_once_f(&_dispatch_precise_time_pred, NULL, _dispatch_init_precise_time);
-	return _dispatch_QueryInterruptTimePrecise_ptr(lpInterruptTimePrecise);
-}
-
-void
-_dispatch_QueryUnbiasedInterruptTimePrecise(PULONGLONG lpUnbiasedInterruptTimePrecise)
-{
-	dispatch_once_f(&_dispatch_precise_time_pred, NULL, _dispatch_init_precise_time);
-	return _dispatch_QueryUnbiasedInterruptTimePrecise_ptr(lpUnbiasedInterruptTimePrecise);
-}
-
-static void
-_dispatch_init_ntdll(void *context DISPATCH_UNUSED)
-{
-	HMODULE ntdll = LoadLibraryW(L"ntdll.dll");
-	if (!ntdll) {
-		// ntdll is not required.
-		return;
-	}
-	_dispatch_NtQueryInformationFile_ptr = (_NtQueryInformationFile_fn_t)
-			GetProcAddress(ntdll, "NtQueryInformationFile");
-}
-
-NTSTATUS _dispatch_NtQueryInformationFile(HANDLE FileHandle,
-		PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length,
-		FILE_INFORMATION_CLASS FileInformationClass)
-{
-	dispatch_once_f(&_dispatch_ntdll_pred, NULL, _dispatch_init_ntdll);
-	if (!_dispatch_NtQueryInformationFile_ptr) {
-		return STATUS_NOT_SUPPORTED;
-	}
-	return _dispatch_NtQueryInformationFile_ptr(FileHandle, IoStatusBlock,
-			FileInformation, Length, FileInformationClass);
-}
--- a/Telegram/ThirdParty/dispatch/src/shims/generic_win_stubs.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/shims/generic_win_stubs.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,73 +0,0 @@
-
-#ifndef __DISPATCH__STUBS__INTERNAL
-#define __DISPATCH__STUBS__INTERNAL
-
-#include <stdint.h>
-
-#include <winsock2.h>
-#include <Windows.h>
-#include <crtdbg.h>
-#include <ntstatus.h>
-#include <Shlwapi.h>
-#include <winternl.h>
-
-#include <io.h>
-#include <process.h>
-
-/*
- * Stub out defines for missing types
- */
-
-typedef __typeof__(_Generic((__SIZE_TYPE__)0,                                  \
-			    unsigned long long int : (long long int)0,         \
-			    unsigned long int : (long int)0,                   \
-			    unsigned int : (int)0,                             \
-			    unsigned short : (short)0,                         \
-			    unsigned char : (signed char)0)) ssize_t;
-
-#define S_ISDIR(mode)  (((mode) & S_IFMT) == S_IFDIR)
-#define S_ISFIFO(mode) ((mode) & _S_IFIFO)
-#define S_ISREG(mode)  ((mode) & _S_IFREG)
-#define S_ISSOCK(mode) 0
-
-#define O_NONBLOCK 04000
-
-#define bzero(ptr,len) memset((ptr), 0, (len))
-
-// Report when an unported code path executes.
-#define WIN_PORT_ERROR() \
-		_RPTF1(_CRT_ASSERT, "WIN_PORT_ERROR in %s", __FUNCTION__)
-
-#define strcasecmp _stricmp
-
-bool _dispatch_handle_is_socket(HANDLE hFile);
-
-/*
- * Wrappers for dynamically loaded Windows APIs
- */
-
-void _dispatch_QueryInterruptTimePrecise(PULONGLONG lpInterruptTimePrecise);
-void _dispatch_QueryUnbiasedInterruptTimePrecise(PULONGLONG lpUnbiasedInterruptTimePrecise);
-
-enum {
-	FilePipeLocalInformation = 24,
-};
-
-typedef struct _FILE_PIPE_LOCAL_INFORMATION {
-	ULONG NamedPipeType;
-	ULONG NamedPipeConfiguration;
-	ULONG MaximumInstances;
-	ULONG CurrentInstances;
-	ULONG InboundQuota;
-	ULONG ReadDataAvailable;
-	ULONG OutboundQuota;
-	ULONG WriteQuotaAvailable;
-	ULONG NamedPipeState;
-	ULONG NamedPipeEnd;
-} FILE_PIPE_LOCAL_INFORMATION, *PFILE_PIPE_LOCAL_INFORMATION;
-
-NTSTATUS _dispatch_NtQueryInformationFile(HANDLE FileHandle,
-		PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length,
-		FILE_INFORMATION_CLASS FileInformationClass);
-
-#endif
--- a/Telegram/ThirdParty/dispatch/src/shims/getprogname.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/shims/getprogname.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,72 +0,0 @@
-/*
- * Copyright (c) 2009-2010 Mark Heily <mark@heily.com>
- * All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include "getprogname.h"
-
-#if !HAVE_GETPROGNAME
-
-#if defined(_WIN32)
-#define WIN32_LEAN_AND_MEAN
-#ifndef _WIN32_WINNT
-#define _WIN32_WINNT 0x0600
-#endif /* _WIN32_WINNT */
-#include <windows.h>
-#include <stdlib.h>
-
-static INIT_ONCE getprogname_init_once = INIT_ONCE_STATIC_INIT;
-static TCHAR progname[_MAX_FNAME];
-
-static BOOL CALLBACK
-getprogname_init_once_handler(PINIT_ONCE InitOnce, PVOID Parameter,
-	PVOID *lpContext)
-{
-	TCHAR path[MAX_PATH];
-	DWORD length = GetModuleFileName(NULL, path, sizeof(path));
-	
-	if (length < 0) {
-		progname[0] = '\0';
-		return TRUE;
-	} else {
-		const char *filename;
-		
-		path[MAX_PATH - 1] = '\0';
-		filename = strrchr(path, '\\');
-		if (filename != NULL) {
-			filename++;
-		} else {
-			filename = path;
-		}
-		strcpy_s(progname, sizeof(progname), filename);
-		return TRUE;
-	}
-}
-
-const char *
-getprogname(void)
-{
-	(void)InitOnceExecuteOnce(&getprogname_init_once,
-			getprogname_init_once_handler,
-			NULL,
-			NULL);
-	return progname;
-}
-#endif /* _WIN32 */
-#endif /* HAVE_GETPROGNAME */
--- a/Telegram/ThirdParty/dispatch/src/shims/getprogname.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/shims/getprogname.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,51 +0,0 @@
-/*
- * Copyright (c) 2009-2010 Mark Heily <mark@heily.com>
- * All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include <errno.h>
-
-#ifndef __DISPATCH_SHIMS_GETPROGNAME__
-#define __DISPATCH_SHIMS_GETPROGNAME__
-
-#if !HAVE_GETPROGNAME
-
-#ifdef __ANDROID__
-extern const char *__progname;
-#endif /* __ANDROID */
-
-#if defined(_WIN32)
-const char *getprogname(void);
-#else
-
-static inline char *
-getprogname(void)
-{
-# if HAVE_DECL_PROGRAM_INVOCATION_SHORT_NAME
-	return program_invocation_short_name;
-# elif defined(__ANDROID__)
-	return __progname;
-# else
-#   error getprogname(3) is not available on this platform
-# endif
-}
-#endif /* _WIN32 */
-#endif /* HAVE_GETPROGNAME */
-
-#endif /* __DISPATCH_SHIMS_GETPROGNAME__ */
--- a/Telegram/ThirdParty/dispatch/src/shims/hw_config.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/shims/hw_config.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,235 +0,0 @@
-/*
- * Copyright (c) 2011-2013 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-/*
- * IMPORTANT: This header file describes INTERNAL interfaces to libdispatch
- * which are subject to change in future releases of Mac OS X. Any applications
- * relying on these interfaces WILL break.
- */
-
-#ifndef __DISPATCH_SHIMS_HW_CONFIG__
-#define __DISPATCH_SHIMS_HW_CONFIG__
-
-#ifdef __SIZEOF_POINTER__
-#define DISPATCH_SIZEOF_PTR __SIZEOF_POINTER__
-#elif defined(_WIN64)
-#define DISPATCH_SIZEOF_PTR 8
-#elif defined(_WIN32)
-#define DISPATCH_SIZEOF_PTR 4
-#elif defined(_MSC_VER)
-#error "could not determine pointer size as a constant int for MSVC"
-#elif defined(__LP64__) || defined(__LLP64__)
-#define DISPATCH_SIZEOF_PTR 8
-#elif defined(__ILP32__)
-#define DISPATCH_SIZEOF_PTR 4
-#else
-#error "could not determine pointer size as a constant int"
-#endif // __SIZEOF_POINTER__
-
-#define DISPATCH_CACHELINE_SIZE 64u
-#define ROUND_UP_TO_CACHELINE_SIZE(x) \
-		(((x) + (DISPATCH_CACHELINE_SIZE - 1u)) & \
-		~(DISPATCH_CACHELINE_SIZE - 1u))
-#define DISPATCH_CACHELINE_ALIGN \
-		__attribute__((__aligned__(DISPATCH_CACHELINE_SIZE)))
-
-typedef enum {
-	_dispatch_hw_config_logical_cpus,
-	_dispatch_hw_config_physical_cpus,
-	_dispatch_hw_config_active_cpus,
-} _dispatch_hw_config_t;
-
-#if !defined(DISPATCH_HAVE_HW_CONFIG_COMMPAGE) && \
-		defined(_COMM_PAGE_LOGICAL_CPUS) && \
-		defined(_COMM_PAGE_PHYSICAL_CPUS) && defined(_COMM_PAGE_ACTIVE_CPUS)
-#define DISPATCH_HAVE_HW_CONFIG_COMMPAGE 1
-#endif
-
-#if DISPATCH_HAVE_HW_CONFIG_COMMPAGE
-
-DISPATCH_ALWAYS_INLINE
-static inline uint32_t
-_dispatch_hw_get_config(_dispatch_hw_config_t c)
-{
-	uintptr_t p;
-	switch (c) {
-	case _dispatch_hw_config_logical_cpus:
-		p =  _COMM_PAGE_LOGICAL_CPUS; break;
-	case _dispatch_hw_config_physical_cpus:
-		p = _COMM_PAGE_PHYSICAL_CPUS; break;
-	case _dispatch_hw_config_active_cpus:
-		p = _COMM_PAGE_ACTIVE_CPUS; break;
-	}
-	return *(uint8_t*)p;
-}
-
-#define dispatch_hw_config(c) \
-		_dispatch_hw_get_config(_dispatch_hw_config_##c)
-
-#define DISPATCH_HW_CONFIG()
-#define _dispatch_hw_config_init()
-
-#else // DISPATCH_HAVE_HW_CONFIG_COMMPAGE
-
-extern struct _dispatch_hw_configs_s {
-	uint32_t logical_cpus;
-	uint32_t physical_cpus;
-	uint32_t active_cpus;
-} _dispatch_hw_config;
-
-#define DISPATCH_HW_CONFIG() struct _dispatch_hw_configs_s _dispatch_hw_config
-#define dispatch_hw_config(c) (_dispatch_hw_config.c)
-
-DISPATCH_ALWAYS_INLINE
-static inline uint32_t
-_dispatch_hw_get_config(_dispatch_hw_config_t c)
-{
-	uint32_t val = 1;
-#if defined(__linux__) && HAVE_SYSCONF
-	switch (c) {
-	case _dispatch_hw_config_logical_cpus:
-	case _dispatch_hw_config_physical_cpus:
-		return (uint32_t)sysconf(_SC_NPROCESSORS_CONF);
-	case _dispatch_hw_config_active_cpus:
-		{
-#ifdef __USE_GNU
-			// Prefer pthread_getaffinity_np because it considers
-			// scheduler cpu affinity.  This matters if the program
-			// is restricted to a subset of the online cpus (eg via numactl).
-			cpu_set_t cpuset;
-			if (pthread_getaffinity_np(pthread_self(), sizeof(cpu_set_t), &cpuset) == 0)
-				return (uint32_t)CPU_COUNT(&cpuset);
-#endif
-			return (uint32_t)sysconf(_SC_NPROCESSORS_ONLN);
-		}
-	}
-#elif defined(_WIN32)
-	PSYSTEM_LOGICAL_PROCESSOR_INFORMATION slpiInfo = NULL;
-	PSYSTEM_LOGICAL_PROCESSOR_INFORMATION slpiCurrent = NULL;
-	DWORD dwProcessorLogicalCount = 0;
-	DWORD dwProcessorPhysicalCount = 0;
-	DWORD dwSize = 0;
-
-	while (true) {
-		DWORD dwResult;
-
-		if (GetLogicalProcessorInformation(slpiInfo, &dwSize))
-			break;
-
-		dwResult = GetLastError();
-
-		if (slpiInfo)
-			free(slpiInfo);
-
-		if (dwResult == ERROR_INSUFFICIENT_BUFFER) {
-			slpiInfo = (PSYSTEM_LOGICAL_PROCESSOR_INFORMATION)malloc(dwSize);
-			dispatch_assert(slpiInfo);
-		} else {
-			slpiInfo = NULL;
-			dwSize = 0;
-			break;
-		}
-	}
-
-	for (slpiCurrent = slpiInfo;
-	     dwSize >= sizeof(SYSTEM_LOGICAL_PROCESSOR_INFORMATION);
-	     slpiCurrent++, dwSize -= sizeof(SYSTEM_LOGICAL_PROCESSOR_INFORMATION)) {
-		switch (slpiCurrent->Relationship) {
-		case RelationProcessorCore:
-			++dwProcessorPhysicalCount;
-			dwProcessorLogicalCount += __popcnt64(slpiCurrent->ProcessorMask);
-			break;
-#if defined(DISPATCH_HAVE_EXTENDED_SLPI_20348)
-		case RelationProcessorDie:
-#endif
-		case RelationProcessorPackage:
-		case RelationNumaNode:
-#if defined(DISPATCH_HAVE_EXTENDED_SLPI_20348)
-		case RelationNumaNodeEx:
-#endif
-		case RelationCache:
-		case RelationGroup:
-#if defined(DISPATCH_HAVE_EXTENDED_SLPI_22000)
-		case RelationProcessorModule:
-#endif
-		case RelationAll:
-			break;
-		}
-	}
-
-	free(slpiInfo);
-
-	switch (c) {
-	case _dispatch_hw_config_logical_cpus:
-	case _dispatch_hw_config_active_cpus:
-		return dwProcessorLogicalCount;
-	case _dispatch_hw_config_physical_cpus:
-		return dwProcessorPhysicalCount;
-	}
-#else
-	const char *name = NULL;
-	int r;
-#if defined(__APPLE__)
-	switch (c) {
-	case _dispatch_hw_config_logical_cpus:
-		name = "hw.logicalcpu_max"; break;
-	case _dispatch_hw_config_physical_cpus:
-		name = "hw.physicalcpu_max"; break;
-	case _dispatch_hw_config_active_cpus:
-		name = "hw.activecpu"; break;
-	}
-#elif defined(__FreeBSD__)
-	(void)c; name = "kern.smp.cpus";
-#elif defined(__OpenBSD__)
-	(void)c;
-#endif
-	if (name) {
-		size_t valsz = sizeof(val);
-#if !defined(__OpenBSD__)
-		r = sysctlbyname(name, &val, &valsz, NULL, 0);
-		(void)dispatch_assume_zero(r);
-#endif
-		dispatch_assert(valsz == sizeof(uint32_t));
-	} else {
-#if HAVE_SYSCONF && defined(_SC_NPROCESSORS_ONLN)
-		r = (int)sysconf(_SC_NPROCESSORS_ONLN);
-		if (r > 0) val = (uint32_t)r;
-#endif
-	}
-#endif
-	return val;
-}
-
-#define dispatch_hw_config_init(c) \
-		_dispatch_hw_get_config(_dispatch_hw_config_##c)
-
-static inline void
-_dispatch_hw_config_init(void)
-{
-	dispatch_hw_config(logical_cpus) = dispatch_hw_config_init(logical_cpus);
-	dispatch_hw_config(physical_cpus) = dispatch_hw_config_init(physical_cpus);
-	dispatch_hw_config(active_cpus) = dispatch_hw_config_init(active_cpus);
-}
-
-#undef dispatch_hw_config_init
-
-#endif // DISPATCH_HAVE_HW_CONFIG_COMMPAGE
-
-#endif /* __DISPATCH_SHIMS_HW_CONFIG__ */
--- a/Telegram/ThirdParty/dispatch/src/shims/lock.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/shims/lock.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,722 +0,0 @@
-/*
- * Copyright (c) 2016 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include "internal.h"
-
-#if TARGET_OS_MAC
-dispatch_static_assert(DLOCK_LOCK_DATA_CONTENTION ==
-		ULF_WAIT_WORKQ_DATA_CONTENTION);
-
-#if !HAVE_UL_UNFAIR_LOCK
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_thread_switch(dispatch_lock value, dispatch_lock_options_t flags,
-		uint32_t timeout)
-{
-	int option;
-	if (flags & DLOCK_LOCK_DATA_CONTENTION) {
-		option = SWITCH_OPTION_OSLOCK_DEPRESS;
-	} else {
-		option = SWITCH_OPTION_DEPRESS;
-	}
-	thread_switch(_dispatch_lock_owner(value), option, timeout);
-}
-#endif // HAVE_UL_UNFAIR_LOCK
-#endif
-
-#if defined(_WIN32)
-#if !HAVE_UL_UNFAIR_LOCK
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_thread_switch(dispatch_lock value, dispatch_lock_options_t flags,
-		uint32_t timeout)
-{
-	(void)value;
-	(void)flags;
-	(void)timeout;
-	SwitchToThread();
-}
-#endif
-#endif
-
-#pragma mark - semaphores
-
-#if USE_MACH_SEM
-#if __has_include(<os/semaphore_private.h>)
-#include <os/semaphore_private.h>
-#define DISPATCH_USE_OS_SEMAPHORE_CACHE 1
-#else
-#define DISPATCH_USE_OS_SEMAPHORE_CACHE 0
-#endif
-
-#define DISPATCH_SEMAPHORE_VERIFY_KR(x) do { \
-		DISPATCH_VERIFY_MIG(x); \
-		if (unlikely((x) == KERN_INVALID_NAME)) { \
-			DISPATCH_CLIENT_CRASH((x), \
-				"Use-after-free of dispatch_semaphore_t or dispatch_group_t"); \
-		} else if (unlikely(x)) { \
-			DISPATCH_INTERNAL_CRASH((x), "mach semaphore API failure"); \
-		} \
-	} while (0)
-
-void
-_dispatch_sema4_create_slow(_dispatch_sema4_t *s4, int policy)
-{
-	semaphore_t tmp = MACH_PORT_NULL;
-
-	_dispatch_fork_becomes_unsafe();
-
-	// lazily allocate the semaphore port
-
-	// Someday:
-	// 1) Switch to a doubly-linked FIFO in user-space.
-	// 2) User-space timers for the timeout.
-
-#if DISPATCH_USE_OS_SEMAPHORE_CACHE
-	if (policy == _DSEMA4_POLICY_FIFO) {
-		tmp = (_dispatch_sema4_t)os_get_cached_semaphore();
-		if (!os_atomic_cmpxchg(s4, MACH_PORT_NULL, tmp, relaxed)) {
-			os_put_cached_semaphore((os_semaphore_t)tmp);
-		}
-		return;
-	}
-#endif
-
-	kern_return_t kr = semaphore_create(mach_task_self(), &tmp, policy, 0);
-	DISPATCH_SEMAPHORE_VERIFY_KR(kr);
-
-	if (!os_atomic_cmpxchg(s4, MACH_PORT_NULL, tmp, relaxed)) {
-		kr = semaphore_destroy(mach_task_self(), tmp);
-		DISPATCH_SEMAPHORE_VERIFY_KR(kr);
-	}
-}
-
-void
-_dispatch_sema4_dispose_slow(_dispatch_sema4_t *sema, int policy)
-{
-	semaphore_t sema_port = *sema;
-	*sema = MACH_PORT_DEAD;
-#if DISPATCH_USE_OS_SEMAPHORE_CACHE
-	if (policy == _DSEMA4_POLICY_FIFO) {
-		return os_put_cached_semaphore((os_semaphore_t)sema_port);
-	}
-#endif
-	kern_return_t kr = semaphore_destroy(mach_task_self(), sema_port);
-	DISPATCH_SEMAPHORE_VERIFY_KR(kr);
-}
-
-void
-_dispatch_sema4_signal(_dispatch_sema4_t *sema, long count)
-{
-	do {
-		kern_return_t kr = semaphore_signal(*sema);
-		DISPATCH_SEMAPHORE_VERIFY_KR(kr);
-	} while (--count);
-}
-
-void
-_dispatch_sema4_wait(_dispatch_sema4_t *sema)
-{
-	kern_return_t kr;
-	do {
-		kr = semaphore_wait(*sema);
-	} while (kr == KERN_ABORTED);
-	DISPATCH_SEMAPHORE_VERIFY_KR(kr);
-}
-
-bool
-_dispatch_sema4_timedwait(_dispatch_sema4_t *sema, dispatch_time_t timeout)
-{
-	mach_timespec_t _timeout;
-	kern_return_t kr;
-
-	do {
-		uint64_t nsec = _dispatch_timeout(timeout);
-		_timeout.tv_sec = (__typeof__(_timeout.tv_sec))(nsec / NSEC_PER_SEC);
-		_timeout.tv_nsec = (__typeof__(_timeout.tv_nsec))(nsec % NSEC_PER_SEC);
-		kr = semaphore_timedwait(*sema, _timeout);
-	} while (unlikely(kr == KERN_ABORTED));
-
-	if (kr == KERN_OPERATION_TIMED_OUT) {
-		return true;
-	}
-	DISPATCH_SEMAPHORE_VERIFY_KR(kr);
-	return false;
-}
-#elif USE_POSIX_SEM
-#define DISPATCH_SEMAPHORE_VERIFY_RET(x) do { \
-		if (unlikely((x) == -1)) { \
-			DISPATCH_INTERNAL_CRASH(errno, "POSIX semaphore API failure"); \
-		} \
-	} while (0)
-
-void
-_dispatch_sema4_init(_dispatch_sema4_t *sema, int policy DISPATCH_UNUSED)
-{
-	int rc = sem_init(sema, 0, 0);
-	DISPATCH_SEMAPHORE_VERIFY_RET(rc);
-}
-
-void
-_dispatch_sema4_dispose_slow(_dispatch_sema4_t *sema, int policy DISPATCH_UNUSED)
-{
-	int rc = sem_destroy(sema);
-	DISPATCH_SEMAPHORE_VERIFY_RET(rc);
-}
-
-void
-_dispatch_sema4_signal(_dispatch_sema4_t *sema, long count)
-{
-	do {
-		int ret = sem_post(sema);
-		DISPATCH_SEMAPHORE_VERIFY_RET(ret);
-	} while (--count);
-}
-
-void
-_dispatch_sema4_wait(_dispatch_sema4_t *sema)
-{
-	int ret = 0;
-	do {
-		ret = sem_wait(sema);
-	} while (ret == -1 && errno == EINTR);
-	DISPATCH_SEMAPHORE_VERIFY_RET(ret);
-}
-
-bool
-_dispatch_sema4_timedwait(_dispatch_sema4_t *sema, dispatch_time_t timeout)
-{
-	struct timespec _timeout;
-	int ret;
-
-	do {
-		uint64_t nsec = _dispatch_time_nanoseconds_since_epoch(timeout);
-		_timeout.tv_sec = (__typeof__(_timeout.tv_sec))(nsec / NSEC_PER_SEC);
-		_timeout.tv_nsec = (__typeof__(_timeout.tv_nsec))(nsec % NSEC_PER_SEC);
-		ret = sem_timedwait(sema, &_timeout);
-	} while (unlikely(ret == -1 && errno == EINTR));
-
-	if (ret == -1 && errno == ETIMEDOUT) {
-		return true;
-	}
-	DISPATCH_SEMAPHORE_VERIFY_RET(ret);
-	return false;
-}
-#elif USE_WIN32_SEM
-// rdar://problem/8428132
-static DWORD best_resolution = 1; // 1ms
-
-static DWORD
-_push_timer_resolution(DWORD ms)
-{
-	MMRESULT res;
-	static dispatch_once_t once;
-
-	if (ms > 16) {
-		// only update timer resolution if smaller than default 15.6ms
-		// zero means not updated
-		return 0;
-	}
-
-	// aim for the best resolution we can accomplish
-	dispatch_once(&once, ^{
-		TIMECAPS tc;
-		if (timeGetDevCaps(&tc, sizeof(tc)) == MMSYSERR_NOERROR) {
-			best_resolution = min(max(tc.wPeriodMin, best_resolution),
-					tc.wPeriodMax);
-		}
-	});
-
-	res = timeBeginPeriod(best_resolution);
-	if (res == TIMERR_NOERROR) {
-		return best_resolution;
-	}
-	// zero means not updated
-	return 0;
-}
-
-// match ms parameter to result from _push_timer_resolution
-DISPATCH_ALWAYS_INLINE
-static inline void
-_pop_timer_resolution(DWORD ms)
-{
-	if (ms) timeEndPeriod(ms);
-}
-
-void _dispatch_sema4_init(_dispatch_sema4_t *sema, int policy DISPATCH_UNUSED)
-{
-	HANDLE tmp;
-
-	// lazily allocate the semaphore port
-
-	while (!dispatch_assume(tmp = CreateSemaphore(NULL, 0, LONG_MAX, NULL))) {
-		_dispatch_temporary_resource_shortage();
-	}
-
-	if (!os_atomic_cmpxchg(sema, 0, tmp, relaxed)) {
-		CloseHandle(tmp);
-	}
-}
-
-void
-_dispatch_sema4_dispose_slow(_dispatch_sema4_t *sema, int policy DISPATCH_UNUSED)
-{
-	HANDLE sema_handle = *sema;
-	CloseHandle(sema_handle);
-	*sema = 0;
-}
-
-void
-_dispatch_sema4_signal(_dispatch_sema4_t *sema, long count)
-{
-	int ret = ReleaseSemaphore(*sema, count, NULL);
-	dispatch_assume(ret);
-}
-
-void
-_dispatch_sema4_wait(_dispatch_sema4_t *sema)
-{
-	WaitForSingleObject(*sema, INFINITE);
-}
-
-bool
-_dispatch_sema4_timedwait(_dispatch_sema4_t *sema, dispatch_time_t timeout)
-{
-	uint64_t nsec;
-	DWORD msec;
-	DWORD resolution;
-	DWORD wait_result;
-
-	nsec = _dispatch_timeout(timeout);
-	msec = (DWORD)(nsec / (uint64_t)1000000);
-	resolution = _push_timer_resolution(msec);
-	wait_result = WaitForSingleObject(*sema, msec);
-	_pop_timer_resolution(resolution);
-	return wait_result == WAIT_TIMEOUT;
-}
-#else
-#error "port has to implement _dispatch_sema4_t"
-#endif
-
-#pragma mark - ulock wrappers
-#if HAVE_UL_COMPARE_AND_WAIT || HAVE_UL_UNFAIR_LOCK
-
-// returns 0, ETIMEDOUT, ENOTEMPTY, EFAULT, EINTR
-static int
-_dlock_wait(uint32_t *uaddr, uint32_t val, uint32_t timeout, uint32_t flags)
-{
-	for (;;) {
-		int rc = __ulock_wait(flags | ULF_NO_ERRNO, uaddr, val, timeout);
-		if (rc > 0) {
-			return ENOTEMPTY;
-		}
-		switch (-rc) {
-		case 0:
-			return 0;
-		case EINTR:
-			/*
-			 * if we have a timeout, we need to return for the caller to
-			 * recompute the new deadline, else just go back to wait.
-			 */
-			if (timeout == 0) {
-				continue;
-			}
-			DISPATCH_FALLTHROUGH;
-		case ETIMEDOUT:
-		case EFAULT:
-			return -rc;
-		default:
-			DISPATCH_INTERNAL_CRASH(-rc, "ulock_wait() failed");
-		}
-	}
-}
-
-static void
-_dlock_wake(uint32_t *uaddr, uint32_t flags)
-{
-	int rc = __ulock_wake(flags | ULF_NO_ERRNO, uaddr, 0);
-	if (rc == 0 || rc == -ENOENT) return;
-	DISPATCH_INTERNAL_CRASH(-rc, "ulock_wake() failed");
-}
-
-#endif // HAVE_UL_COMPARE_AND_WAIT || HAVE_UL_UNFAIR_LOCK
-#if HAVE_UL_COMPARE_AND_WAIT
-
-static int
-_dispatch_ulock_wait(uint32_t *uaddr, uint32_t val, uint32_t timeout,
-		uint32_t flags)
-{
-	return _dlock_wait(uaddr, val, timeout, flags | UL_COMPARE_AND_WAIT);
-}
-
-static void
-_dispatch_ulock_wake(uint32_t *uaddr, uint32_t flags)
-{
-	return _dlock_wake(uaddr, flags | UL_COMPARE_AND_WAIT);
-}
-
-#endif // HAVE_UL_COMPARE_AND_WAIT
-#if HAVE_UL_UNFAIR_LOCK
-
-static int
-_dispatch_unfair_lock_wait(uint32_t *uaddr, uint32_t val, uint32_t timeout,
-		dispatch_lock_options_t flags)
-{
-	return _dlock_wait(uaddr, val, timeout, flags | UL_UNFAIR_LOCK);
-}
-
-static void
-_dispatch_unfair_lock_wake(uint32_t *uaddr, uint32_t flags)
-{
-	return _dlock_wake(uaddr, flags | UL_UNFAIR_LOCK);
-}
-
-#endif // HAVE_UL_UNFAIR_LOCK
-#pragma mark - futex wrappers
-#if HAVE_FUTEX
-#include <sys/time.h>
-#ifdef __ANDROID__
-#include <sys/syscall.h>
-#else
-#include <syscall.h>
-#endif /* __ANDROID__ */
-
-DISPATCH_ALWAYS_INLINE
-static inline int
-_dispatch_futex(uint32_t *uaddr, int op, uint32_t val,
-		const struct timespec *timeout, uint32_t *uaddr2, uint32_t val3,
-		int opflags)
-{
-	return (int)syscall(SYS_futex, uaddr, op | opflags, val, timeout, uaddr2, val3);
-}
-
-// returns 0, ETIMEDOUT, EFAULT, EINTR, EWOULDBLOCK
-DISPATCH_ALWAYS_INLINE
-static inline int
-_futex_blocking_op(uint32_t *uaddr, int futex_op, uint32_t val,
-		const struct timespec *timeout, int flags)
-{
-	for (;;) {
-		int rc = _dispatch_futex(uaddr, futex_op, val, timeout, NULL, 0, flags);
-		if (!rc) {
-			return 0;
-		}
-		switch (errno) {
-		case EINTR:
-			/*
-			 * if we have a timeout, we need to return for the caller to
-			 * recompute the new deadline, else just go back to wait.
-			 */
-			if (timeout == 0) {
-				continue;
-			}
-			DISPATCH_FALLTHROUGH;
-		case ETIMEDOUT:
-		case EFAULT:
-		case EWOULDBLOCK:
-			return errno;
-		default:
-			DISPATCH_INTERNAL_CRASH(errno, "_futex_op() failed");
-		}
-	}
-}
-
-static int
-_dispatch_futex_wait(uint32_t *uaddr, uint32_t val,
-		const struct timespec *timeout, int opflags)
-{
-	return _futex_blocking_op(uaddr, FUTEX_WAIT, val, timeout, opflags);
-}
-
-static void
-_dispatch_futex_wake(uint32_t *uaddr, int wake, int opflags)
-{
-	int rc = _dispatch_futex(uaddr, FUTEX_WAKE, (uint32_t)wake, NULL, NULL, 0,
-			opflags);
-	if (rc >= 0 || errno == ENOENT) return;
-	DISPATCH_INTERNAL_CRASH(errno, "_dlock_wake() failed");
-}
-
-static void
-_dispatch_futex_lock_pi(uint32_t *uaddr, struct timespec *timeout, int detect,
-	      int opflags)
-{
-	int err = _futex_blocking_op(uaddr, FUTEX_LOCK_PI, (uint32_t)detect,
-			timeout, opflags);
-	if (err == 0) return;
-	DISPATCH_CLIENT_CRASH(err, "futex_lock_pi() failed");
-}
-
-static void
-_dispatch_futex_unlock_pi(uint32_t *uaddr, int opflags)
-{
-	int rc = _dispatch_futex(uaddr, FUTEX_UNLOCK_PI, 0, NULL, NULL, 0, opflags);
-	if (rc == 0) return;
-	DISPATCH_CLIENT_CRASH(errno, "futex_unlock_pi() failed");
-}
-
-#endif
-#pragma mark - wait for address
-
-int
-_dispatch_wait_on_address(uint32_t volatile *_address, uint32_t value,
-		dispatch_time_t timeout, dispatch_lock_options_t flags)
-{
-	uint32_t *address = (uint32_t *)_address;
-	uint64_t nsecs = _dispatch_timeout(timeout);
-	if (nsecs == 0) {
-		return ETIMEDOUT;
-	}
-#if HAVE_UL_COMPARE_AND_WAIT
-	uint64_t usecs = 0;
-	int rc;
-	if (nsecs == DISPATCH_TIME_FOREVER) {
-		return _dispatch_ulock_wait(address, value, 0, flags);
-	}
-	do {
-		usecs = howmany(nsecs, NSEC_PER_USEC);
-		if (usecs > UINT32_MAX) usecs = UINT32_MAX;
-		rc = _dispatch_ulock_wait(address, value, (uint32_t)usecs, flags);
-	} while (usecs == UINT32_MAX && rc == ETIMEDOUT &&
-			(nsecs = _dispatch_timeout(timeout)) != 0);
-	return rc;
-#elif HAVE_FUTEX
-	(void)flags;
-	if (nsecs != DISPATCH_TIME_FOREVER) {
-		struct timespec ts = {
-			.tv_sec = (__typeof__(ts.tv_sec))(nsecs / NSEC_PER_SEC),
-			.tv_nsec = (__typeof__(ts.tv_nsec))(nsecs % NSEC_PER_SEC),
-		};
-		return _dispatch_futex_wait(address, value, &ts, FUTEX_PRIVATE_FLAG);
-	}
-	return _dispatch_futex_wait(address, value, NULL, FUTEX_PRIVATE_FLAG);
-#elif defined(_WIN32)
-	// Round up to the nearest ms as `WaitOnAddress` takes a timeout in ms.
-	// Integral division will truncate, so make sure that we do the roundup.
-	DWORD dwMilliseconds =
-		nsecs == DISPATCH_TIME_FOREVER
-			? INFINITE : ((nsecs + 1000000) / 1000000);
-	if (dwMilliseconds == 0) return ETIMEDOUT;
-	return WaitOnAddress(address, &value, sizeof(value), dwMilliseconds) == TRUE;
-#else
-#error _dispatch_wait_on_address unimplemented for this platform
-#endif
-}
-
-void
-_dispatch_wake_by_address(uint32_t volatile *address)
-{
-#if HAVE_UL_COMPARE_AND_WAIT
-	_dispatch_ulock_wake((uint32_t *)address, ULF_WAKE_ALL);
-#elif HAVE_FUTEX
-	_dispatch_futex_wake((uint32_t *)address, INT_MAX, FUTEX_PRIVATE_FLAG);
-#elif defined(_WIN32)
-	WakeByAddressAll((uint32_t *)address);
-#else
-	(void)address;
-#endif
-}
-
-#pragma mark - thread event
-
-void
-_dispatch_thread_event_signal_slow(dispatch_thread_event_t dte)
-{
-#if HAVE_UL_COMPARE_AND_WAIT
-	_dispatch_ulock_wake(&dte->dte_value, 0);
-#elif HAVE_FUTEX
-	_dispatch_futex_wake(&dte->dte_value, 1, FUTEX_PRIVATE_FLAG);
-#else
-	_dispatch_sema4_signal(&dte->dte_sema, 1);
-#endif
-}
-
-void
-_dispatch_thread_event_wait_slow(dispatch_thread_event_t dte)
-{
-#if HAVE_UL_COMPARE_AND_WAIT || HAVE_FUTEX
-	for (;;) {
-		uint32_t value = os_atomic_load(&dte->dte_value, acquire);
-		if (likely(value == 0)) return;
-		if (unlikely(value != UINT32_MAX)) {
-			DISPATCH_CLIENT_CRASH(value, "Corrupt thread event value");
-		}
-#if HAVE_UL_COMPARE_AND_WAIT
-		int rc = _dispatch_ulock_wait(&dte->dte_value, UINT32_MAX, 0, 0);
-		dispatch_assert(rc == 0 || rc == EFAULT || rc == EINTR);
-#elif HAVE_FUTEX
-		_dispatch_futex_wait(&dte->dte_value, UINT32_MAX,
-				NULL, FUTEX_PRIVATE_FLAG);
-#endif
-	}
-#else
-	_dispatch_sema4_wait(&dte->dte_sema);
-#endif
-}
-
-#pragma mark - unfair lock
-
-#if HAVE_UL_UNFAIR_LOCK
-void
-_dispatch_unfair_lock_lock_slow(dispatch_unfair_lock_t dul,
-		dispatch_lock_options_t flags)
-{
-	dispatch_lock value_self = _dispatch_lock_value_for_self();
-	dispatch_lock old_value, new_value, next = value_self;
-	int rc;
-
-	for (;;) {
-		os_atomic_rmw_loop(&dul->dul_lock, old_value, new_value, acquire, {
-			if (likely(!_dispatch_lock_is_locked(old_value))) {
-				new_value = next;
-			} else {
-				new_value = old_value | DLOCK_WAITERS_BIT;
-				if (new_value == old_value) os_atomic_rmw_loop_give_up(break);
-			}
-		});
-		if (unlikely(_dispatch_lock_is_locked_by(old_value, value_self))) {
-			DISPATCH_CLIENT_CRASH(0, "trying to lock recursively");
-		}
-		if (new_value == next) {
-			return;
-		}
-		rc = _dispatch_unfair_lock_wait(&dul->dul_lock, new_value, 0, flags);
-		if (rc == ENOTEMPTY) {
-			next = value_self | DLOCK_WAITERS_BIT;
-		} else {
-			next = value_self;
-		}
-	}
-}
-#elif HAVE_FUTEX
-void
-_dispatch_unfair_lock_lock_slow(dispatch_unfair_lock_t dul,
-		dispatch_lock_options_t flags)
-{
-	(void)flags;
-	_dispatch_futex_lock_pi(&dul->dul_lock, NULL, 1, FUTEX_PRIVATE_FLAG);
-}
-#else
-void
-_dispatch_unfair_lock_lock_slow(dispatch_unfair_lock_t dul,
-		dispatch_lock_options_t flags)
-{
-	dispatch_lock cur, self = _dispatch_lock_value_for_self();
-	uint32_t timeout = 1;
-
-	while (unlikely(!os_atomic_cmpxchgv(&dul->dul_lock,
-			DLOCK_OWNER_NULL, self, &cur, acquire))) {
-		if (unlikely(_dispatch_lock_is_locked_by(cur, self))) {
-			DISPATCH_CLIENT_CRASH(0, "trying to lock recursively");
-		}
-		_dispatch_thread_switch(cur, flags, timeout++);
-	}
-}
-#endif
-
-void
-_dispatch_unfair_lock_unlock_slow(dispatch_unfair_lock_t dul, dispatch_lock cur)
-{
-	if (unlikely(!_dispatch_lock_is_locked_by_self(cur))) {
-		DISPATCH_CLIENT_CRASH(cur, "lock not owned by current thread");
-	}
-
-#if HAVE_UL_UNFAIR_LOCK
-	if (_dispatch_lock_has_waiters(cur)) {
-		_dispatch_unfair_lock_wake(&dul->dul_lock, 0);
-	}
-#elif HAVE_FUTEX
-	// futex_unlock_pi() handles both OWNER_DIED which we abuse & WAITERS
-	_dispatch_futex_unlock_pi(&dul->dul_lock, FUTEX_PRIVATE_FLAG);
-#else
-	(void)dul;
-#endif
-}
-
-#pragma mark - gate lock
-
-void
-_dispatch_once_wait(dispatch_once_gate_t dgo)
-{
-	dispatch_lock self = _dispatch_lock_value_for_self();
-	uintptr_t old_v, new_v;
-#if HAVE_UL_UNFAIR_LOCK || HAVE_FUTEX
-	dispatch_lock *lock = &dgo->dgo_gate.dgl_lock;
-#endif
-	uint32_t timeout = 1;
-
-	for (;;) {
-		os_atomic_rmw_loop(&dgo->dgo_once, old_v, new_v, relaxed, {
-			if (likely(old_v == DLOCK_ONCE_DONE)) {
-				os_atomic_rmw_loop_give_up(return);
-			}
-#if DISPATCH_ONCE_USE_QUIESCENT_COUNTER
-			if (DISPATCH_ONCE_IS_GEN(old_v)) {
-				os_atomic_rmw_loop_give_up({
-					os_atomic_thread_fence(acquire);
-					return _dispatch_once_mark_done_if_quiesced(dgo, old_v);
-				});
-			}
-#endif
-			new_v = old_v | (uintptr_t)DLOCK_WAITERS_BIT;
-			if (new_v == old_v) os_atomic_rmw_loop_give_up(break);
-		});
-		if (unlikely(_dispatch_lock_is_locked_by((dispatch_lock)old_v, self))) {
-			DISPATCH_CLIENT_CRASH(0, "trying to lock recursively");
-		}
-#if HAVE_UL_UNFAIR_LOCK
-		_dispatch_unfair_lock_wait(lock, (dispatch_lock)new_v, 0,
-				DLOCK_LOCK_NONE);
-#elif HAVE_FUTEX
-		_dispatch_futex_wait(lock, (dispatch_lock)new_v, NULL,
-				FUTEX_PRIVATE_FLAG);
-#else
-		_dispatch_thread_switch(new_v, 0, timeout++);
-#endif
-		(void)timeout;
-	}
-}
-
-void
-_dispatch_gate_broadcast_slow(dispatch_gate_t dgl, dispatch_lock cur)
-{
-	if (unlikely(!_dispatch_lock_is_locked_by_self(cur))) {
-		DISPATCH_CLIENT_CRASH(cur, "lock not owned by current thread");
-	}
-
-#if HAVE_UL_UNFAIR_LOCK
-	_dispatch_unfair_lock_wake(&dgl->dgl_lock, ULF_WAKE_ALL);
-#elif HAVE_FUTEX
-	_dispatch_futex_wake(&dgl->dgl_lock, INT_MAX, FUTEX_PRIVATE_FLAG);
-#else
-	(void)dgl;
-#endif
-}
-
-#if TARGET_OS_MAC
-
-void
-_dispatch_firehose_gate_wait(dispatch_gate_t dgl, uint32_t owner,
-		uint32_t flags)
-{
-	_dispatch_unfair_lock_wait(&dgl->dgl_lock, owner, 0, flags);
-}
-
-#endif
--- a/Telegram/ThirdParty/dispatch/src/shims/lock.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/shims/lock.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,705 +0,0 @@
-/*
- * Copyright (c) 2016 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-/*
- * IMPORTANT: This header file describes INTERNAL interfaces to libdispatch
- * which are subject to change in future releases of Mac OS X. Any applications
- * relying on these interfaces WILL break.
- */
-
-#ifndef __DISPATCH_SHIMS_LOCK__
-#define __DISPATCH_SHIMS_LOCK__
-
-#pragma mark - platform macros
-
-DISPATCH_ENUM(dispatch_lock_options, uint32_t,
-	DLOCK_LOCK_NONE				= 0x00000000,
-	DLOCK_LOCK_DATA_CONTENTION  = 0x00010000,
-);
-
-#if TARGET_OS_MAC
-
-typedef mach_port_t dispatch_tid;
-typedef uint32_t dispatch_lock;
-
-#define DLOCK_OWNER_MASK			((dispatch_lock)0xfffffffc)
-#define DLOCK_WAITERS_BIT			((dispatch_lock)0x00000001)
-#define DLOCK_FAILED_TRYLOCK_BIT	((dispatch_lock)0x00000002)
-
-#define DLOCK_OWNER_NULL			((dispatch_tid)MACH_PORT_NULL)
-#define _dispatch_tid_self()		((dispatch_tid)_dispatch_thread_port())
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_tid
-_dispatch_lock_owner(dispatch_lock lock_value)
-{
-	if (lock_value & DLOCK_OWNER_MASK) {
-		return lock_value | DLOCK_WAITERS_BIT | DLOCK_FAILED_TRYLOCK_BIT;
-	}
-	return DLOCK_OWNER_NULL;
-}
-
-#elif defined(__linux__)
-
-#include <linux/futex.h>
-#include <unistd.h>
-#include <sys/syscall.h>   /* For SYS_xxx definitions */
-
-typedef uint32_t dispatch_tid;
-typedef uint32_t dispatch_lock;
-
-#define DLOCK_OWNER_MASK			((dispatch_lock)FUTEX_TID_MASK)
-#define DLOCK_WAITERS_BIT			((dispatch_lock)FUTEX_WAITERS)
-#define DLOCK_FAILED_TRYLOCK_BIT	((dispatch_lock)FUTEX_OWNER_DIED)
-
-#define DLOCK_OWNER_NULL			((dispatch_tid)0)
-#define _dispatch_tid_self()        ((dispatch_tid)(_dispatch_get_tsd_base()->tid))
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_tid
-_dispatch_lock_owner(dispatch_lock lock_value)
-{
-	return lock_value & DLOCK_OWNER_MASK;
-}
-
-#elif defined(_WIN32)
-
-#include <Windows.h>
-
-typedef DWORD dispatch_tid;
-typedef uint32_t dispatch_lock;
-
-#define DLOCK_OWNER_NULL			((dispatch_tid)0)
-#define DLOCK_OWNER_MASK			((dispatch_lock)0xfffffffc)
-#define DLOCK_WAITERS_BIT			((dispatch_lock)0x00000001)
-#define DLOCK_FAILED_TRYLOCK_BIT		((dispatch_lock)0x00000002)
-
-#define _dispatch_tid_self()		((dispatch_tid)(_dispatch_get_tsd_base()->tid << 2))
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_tid
-_dispatch_lock_owner(dispatch_lock lock_value)
-{
-	return lock_value & DLOCK_OWNER_MASK;
-}
-
-#else
-#  error define _dispatch_lock encoding scheme for your platform here
-#endif
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_lock
-_dispatch_lock_value_from_tid(dispatch_tid tid)
-{
-	return tid & DLOCK_OWNER_MASK;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_lock
-_dispatch_lock_value_for_self(void)
-{
-	return _dispatch_lock_value_from_tid(_dispatch_tid_self());
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dispatch_lock_is_locked(dispatch_lock lock_value)
-{
-	// equivalent to _dispatch_lock_owner(lock_value) == 0
-	return (lock_value & DLOCK_OWNER_MASK) != 0;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dispatch_lock_is_locked_by(dispatch_lock lock_value, dispatch_tid tid)
-{
-	// equivalent to _dispatch_lock_owner(lock_value) == tid
-	return ((lock_value ^ tid) & DLOCK_OWNER_MASK) == 0;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dispatch_lock_is_locked_by_self(dispatch_lock lock_value)
-{
-	// equivalent to _dispatch_lock_owner(lock_value) == tid
-	return ((lock_value ^ _dispatch_tid_self()) & DLOCK_OWNER_MASK) == 0;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dispatch_lock_has_waiters(dispatch_lock lock_value)
-{
-	return (lock_value & DLOCK_WAITERS_BIT);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dispatch_lock_has_failed_trylock(dispatch_lock lock_value)
-{
-	return (lock_value & DLOCK_FAILED_TRYLOCK_BIT);
-}
-
-#if __has_include(<sys/ulock.h>)
-#include <sys/ulock.h>
-#ifdef UL_COMPARE_AND_WAIT
-#define HAVE_UL_COMPARE_AND_WAIT 1
-#endif
-#ifdef UL_UNFAIR_LOCK
-#define HAVE_UL_UNFAIR_LOCK 1
-#endif
-#endif
-
-#ifndef HAVE_FUTEX
-#ifdef __linux__
-#define HAVE_FUTEX 1
-#else
-#define HAVE_FUTEX 0
-#endif
-#endif // HAVE_FUTEX
-
-#if defined(__x86_64__) || defined(__i386__) || defined(__s390x__)
-#define DISPATCH_ONCE_USE_QUIESCENT_COUNTER 0
-#elif __APPLE__
-#define DISPATCH_ONCE_USE_QUIESCENT_COUNTER 1
-#else
-#define DISPATCH_ONCE_USE_QUIESCENT_COUNTER 0
-#endif
-
-#pragma mark - semaphores
-
-#if USE_MACH_SEM
-
-typedef semaphore_t _dispatch_sema4_t;
-#define _DSEMA4_POLICY_FIFO  SYNC_POLICY_FIFO
-#define _DSEMA4_POLICY_LIFO  SYNC_POLICY_LIFO
-#define _DSEMA4_TIMEOUT() KERN_OPERATION_TIMED_OUT
-
-#define _dispatch_sema4_init(sema, policy) (void)(*(sema) = MACH_PORT_NULL)
-#define _dispatch_sema4_is_created(sema)   (*(sema) != MACH_PORT_NULL)
-void _dispatch_sema4_create_slow(_dispatch_sema4_t *sema, int policy);
-
-#elif USE_POSIX_SEM
-
-typedef sem_t _dispatch_sema4_t;
-#define _DSEMA4_POLICY_FIFO 0
-#define _DSEMA4_POLICY_LIFO 0
-#define _DSEMA4_TIMEOUT() ((errno) = ETIMEDOUT, -1)
-
-void _dispatch_sema4_init(_dispatch_sema4_t *sema, int policy);
-#define _dispatch_sema4_is_created(sema) ((void)sema, 1)
-#define _dispatch_sema4_create_slow(sema, policy) ((void)sema, (void)policy)
-
-#elif USE_WIN32_SEM
-
-typedef HANDLE _dispatch_sema4_t;
-#define _DSEMA4_POLICY_FIFO 0
-#define _DSEMA4_POLICY_LIFO 0
-#define _DSEMA4_TIMEOUT() ((errno) = ETIMEDOUT, -1)
-
-void _dispatch_sema4_init(_dispatch_sema4_t *sema, int policy);
-#define _dispatch_sema4_is_created(sema)   ((void)sema, 1)
-#define _dispatch_sema4_create_slow(sema, policy) ((void)sema, (void)policy)
-
-#else
-#error "port has to implement _dispatch_sema4_t"
-#endif
-
-void _dispatch_sema4_dispose_slow(_dispatch_sema4_t *sema, int policy);
-void _dispatch_sema4_signal(_dispatch_sema4_t *sema, long count);
-void _dispatch_sema4_wait(_dispatch_sema4_t *sema);
-bool _dispatch_sema4_timedwait(_dispatch_sema4_t *sema, dispatch_time_t timeout);
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_sema4_create(_dispatch_sema4_t *sema, int policy)
-{
-	if (!_dispatch_sema4_is_created(sema)) {
-		_dispatch_sema4_create_slow(sema, policy);
-	}
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_sema4_dispose(_dispatch_sema4_t *sema, int policy)
-{
-	if (_dispatch_sema4_is_created(sema)) {
-		_dispatch_sema4_dispose_slow(sema, policy);
-	}
-}
-
-#pragma mark - compare and wait
-
-DISPATCH_NOT_TAIL_CALLED
-int _dispatch_wait_on_address(uint32_t volatile *address, uint32_t value,
-		dispatch_time_t timeout, dispatch_lock_options_t flags);
-void _dispatch_wake_by_address(uint32_t volatile *address);
-
-#pragma mark - thread event
-/**
- * @typedef dispatch_thread_event_t
- *
- * @abstract
- * Dispatch Thread Events are used for one-time synchronization between threads.
- *
- * @discussion
- * Dispatch Thread Events are cheap synchronization points used when a thread
- * needs to block until a certain event has happened. Dispatch Thread Event
- * must be initialized and destroyed with _dispatch_thread_event_init() and
- * _dispatch_thread_event_destroy().
- *
- * A Dispatch Thread Event must be waited on and signaled exactly once between
- * initialization and destruction. These objects are simpler than semaphores
- * and do not support being signaled and waited on an arbitrary number of times.
- *
- * This locking primitive has no notion of ownership
- */
-typedef struct dispatch_thread_event_s {
-#if HAVE_UL_COMPARE_AND_WAIT || HAVE_FUTEX
-	// 1 means signalled but not waited on yet
-	// UINT32_MAX means waited on, but not signalled yet
-	// 0 is the initial and final state
-	uint32_t dte_value;
-#else
-	_dispatch_sema4_t dte_sema;
-#endif
-} dispatch_thread_event_s, *dispatch_thread_event_t;
-
-DISPATCH_NOT_TAIL_CALLED
-void _dispatch_thread_event_wait_slow(dispatch_thread_event_t);
-void _dispatch_thread_event_signal_slow(dispatch_thread_event_t);
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_thread_event_init(dispatch_thread_event_t dte)
-{
-#if HAVE_UL_COMPARE_AND_WAIT || HAVE_FUTEX
-	dte->dte_value = 0;
-#else
-	_dispatch_sema4_init(&dte->dte_sema, _DSEMA4_POLICY_FIFO);
-#endif
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_thread_event_signal(dispatch_thread_event_t dte)
-{
-#if HAVE_UL_COMPARE_AND_WAIT || HAVE_FUTEX
-	if (os_atomic_inc_orig(&dte->dte_value, release) == 0) {
-		// 0 -> 1 transition doesn't need a signal
-		// force a wake even when the value is corrupt,
-		// waiters do the validation
-		return;
-	}
-#else
-	// fallthrough
-#endif
-	_dispatch_thread_event_signal_slow(dte);
-}
-
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_thread_event_wait(dispatch_thread_event_t dte)
-{
-#if HAVE_UL_COMPARE_AND_WAIT || HAVE_FUTEX
-	if (os_atomic_dec(&dte->dte_value, acquire) == 0) {
-		// 1 -> 0 is always a valid transition, so we can return
-		// for any other value, take the slow path which checks it's not corrupt
-		return;
-	}
-#else
-	// fallthrough
-#endif
-	_dispatch_thread_event_wait_slow(dte);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_thread_event_destroy(dispatch_thread_event_t dte)
-{
-#if HAVE_UL_COMPARE_AND_WAIT || HAVE_FUTEX
-	// nothing to do
-	dispatch_assert(dte->dte_value == 0);
-#else
-	_dispatch_sema4_dispose(&dte->dte_sema, _DSEMA4_POLICY_FIFO);
-#endif
-}
-
-#pragma mark - unfair lock
-
-typedef struct dispatch_unfair_lock_s {
-	dispatch_lock dul_lock;
-} dispatch_unfair_lock_s, *dispatch_unfair_lock_t;
-
-DISPATCH_NOT_TAIL_CALLED
-void _dispatch_unfair_lock_lock_slow(dispatch_unfair_lock_t l,
-		dispatch_lock_options_t options);
-void _dispatch_unfair_lock_unlock_slow(dispatch_unfair_lock_t l,
-		dispatch_lock tid_cur);
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_unfair_lock_lock(dispatch_unfair_lock_t l)
-{
-	dispatch_lock value_self = _dispatch_lock_value_for_self();
-	if (likely(os_atomic_cmpxchg(&l->dul_lock,
-			DLOCK_OWNER_NULL, value_self, acquire))) {
-		return;
-	}
-	return _dispatch_unfair_lock_lock_slow(l, DLOCK_LOCK_DATA_CONTENTION);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dispatch_unfair_lock_trylock(dispatch_unfair_lock_t l, dispatch_tid *owner)
-{
-	dispatch_lock value_self = _dispatch_lock_value_for_self();
-	dispatch_lock old_value, new_value;
-
-	os_atomic_rmw_loop(&l->dul_lock, old_value, new_value, acquire, {
-		if (likely(!_dispatch_lock_is_locked(old_value))) {
-			new_value = value_self;
-		} else {
-			new_value = old_value | DLOCK_FAILED_TRYLOCK_BIT;
-		}
-	});
-	if (owner) *owner = _dispatch_lock_owner(new_value);
-	return !_dispatch_lock_is_locked(old_value);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dispatch_unfair_lock_tryunlock(dispatch_unfair_lock_t l)
-{
-	dispatch_lock old_value, new_value;
-
-	os_atomic_rmw_loop(&l->dul_lock, old_value, new_value, release, {
-		if (unlikely(old_value & DLOCK_FAILED_TRYLOCK_BIT)) {
-			new_value = old_value ^ DLOCK_FAILED_TRYLOCK_BIT;
-		} else {
-			new_value = DLOCK_OWNER_NULL;
-		}
-	});
-	if (unlikely(new_value)) {
-		// unlock failed, renew the lock, which needs an acquire barrier
-		os_atomic_thread_fence(acquire);
-		return false;
-	}
-	if (unlikely(_dispatch_lock_has_waiters(old_value))) {
-		_dispatch_unfair_lock_unlock_slow(l, old_value);
-	}
-	return true;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dispatch_unfair_lock_unlock_had_failed_trylock(dispatch_unfair_lock_t l)
-{
-	dispatch_lock cur, value_self = _dispatch_lock_value_for_self();
-#if HAVE_FUTEX
-	if (likely(os_atomic_cmpxchgv(&l->dul_lock,
-			value_self, DLOCK_OWNER_NULL, &cur, release))) {
-		return false;
-	}
-#else
-	cur = os_atomic_xchg(&l->dul_lock, DLOCK_OWNER_NULL, release);
-	if (likely(cur == value_self)) return false;
-#endif
-	_dispatch_unfair_lock_unlock_slow(l, cur);
-	return _dispatch_lock_has_failed_trylock(cur);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_unfair_lock_unlock(dispatch_unfair_lock_t l)
-{
-	(void)_dispatch_unfair_lock_unlock_had_failed_trylock(l);
-}
-
-#pragma mark - gate lock
-
-#define DLOCK_GATE_UNLOCKED	((dispatch_lock)0)
-
-#define DLOCK_ONCE_UNLOCKED	((uintptr_t)0)
-#define DLOCK_ONCE_DONE		(~(uintptr_t)0)
-
-typedef struct dispatch_gate_s {
-	dispatch_lock dgl_lock;
-} dispatch_gate_s, *dispatch_gate_t;
-
-typedef struct dispatch_once_gate_s {
-	union {
-		dispatch_gate_s dgo_gate;
-		uintptr_t dgo_once;
-	};
-} dispatch_once_gate_s, *dispatch_once_gate_t;
-
-#if DISPATCH_ONCE_USE_QUIESCENT_COUNTER
-#define DISPATCH_ONCE_MAKE_GEN(gen)  (((gen) << 2) + DLOCK_FAILED_TRYLOCK_BIT)
-#define DISPATCH_ONCE_IS_GEN(gen)    (((gen) & 3) == DLOCK_FAILED_TRYLOCK_BIT)
-
-/*
- * the _COMM_PAGE_CPU_QUIESCENT_COUNTER value is incremented every time
- * all CPUs have performed a context switch.
- *
- * A counter update algorithm is:
- *
- *     // atomic_or acq_rel is marked as ======== below
- *     if (atomic_or(&mask, acq_rel) == full_mask) {
- *
- *         tmp = atomic_load(&generation, relaxed);
- *         atomic_store(&generation, gen + 1, relaxed);
- *
- *         // atomic_store release is marked as -------- below
- *         atomic_store(&mask, 0, release);
- *     }
- *
- * This enforces boxes delimited by the acq_rel/release barriers to only be able
- * to observe two possible values for the counter which have been marked below.
- *
- * Lemma 1
- * ~~~~~~~
- *
- * Between two acq_rel barriers, a thread can only observe two possible values
- * of the generation counter G maintained by the kernel.
- *
- * The Figure below, adds the happens-before-relationships and assertions:
- *
- * |     Thread A     |     Thread B     |     Thread C     |
- * |                  |                  |                  |
- * |==================|                  |                  |
- * |      G = N       |                  |                  |
- * |------------------|--------.         |                  |
- * |                  |        |         |                  |
- * |                  |        v         |                  |
- * |                  |==================|                  |
- * |                  |  assert(G >= N)  |                  |
- * |                  |                  |                  |
- * |                  |                  |                  |
- * |                  |                  |                  |
- * |                  |  assert(G < N+2) |                  |
- * |                  |==================|--------.         |
- * |                  |                  |        |         |
- * |                  |                  |        v         |
- * |                  |                  |==================|
- * |                  |                  |      G = N + 2   |
- * |                  |                  |------------------|
- * |                  |                  |                  |
- *
- *
- * This allows us to name the area delimited by two consecutive acq_rel
- * barriers { N, N+1 } after the two possible values of G they can observe,
- * which we'll use from now on.
- *
- *
- * Lemma 2
- * ~~~~~~~
- *
- * Any operation that a thread does while observing G in { N-2, N-1 } will be
- * visible to a thread that can observe G in { N, N + 1 }.
- *
- * Any operation that a thread does while observing G in { N, N + 1 } cannot
- * possibly be visible to a thread observing G in { N-2, N-1 }
- *
- * This is a corollary of Lemma 1: the only possibility is for the update
- * of G to N to have happened between two acq_rel barriers of the considered
- * threads.
- *
- * Below is a figure of why instantiated with N = 2
- *
- * |     Thread A     |     Thread B     |     Thread C     |
- * |                  |                  |                  |
- * |   G ∈ { 0, 1 }   |                  |                  |
- * |                  |                  |                  |
- * |                  |                  |                  |
- * |   store(X, 1)    |                  |                  |
- * |   assert(!Z)     |                  |                  |
- * |                  |                  |                  |
- * |==================|--------.         |                  |
- * |   G ∈ { 1, 2 }   |        |         |                  |
- * |                  |        v         |                  |
- * |                  |==================|--------.         |
- * |                  |      G = 2       |        |         |
- * |                  |------------------|        |         |
- * |                  |                  |        |         |
- * |                  |                  |        v         |
- * |                  |                  |==================|
- * |                  |                  |   G ∈ { 2, 3 }   |
- * |                  |                  |                  |
- * |                  |                  |                  |
- * |                  |                  |   store(Z, 1)    |
- * |                  |                  |   assert(X)      |
- * |                  |                  |                  |
- * |                  |                  |                  |
- *
- *
- * Theorem
- * ~~~~~~~
- *
- * The optimal number of increments to observe for the dispatch once algorithm
- * to be safe is 4.
- *
- * Proof (correctness):
- *
- *  Consider a dispatch once initializer thread in its { N, N+1 } "zone".
- *
- *  Per Lemma 2, any observer thread in its { N+2, N+3 } zone will see the
- *  effect of the dispatch once initialization.
- *
- *  Per Lemma 2, when the DONE transition happens in a thread zone { N+3, N+4 },
- *  then threads can observe this transition in their { N+2, N+3 } zone at the
- *  earliest.
- *
- *  Hence for an initializer bracket of { N, N+1 }, the first safe bracket for
- *  the DONE transition is { N+3, N+4 }.
- *
- *
- * Proof (optimal):
- *
- *  The following ordering is possible if waiting only for three periods:
- *
- * |     Thread A     |     Thread B     |     Thread C     |
- * |                  |                  |                  |
- * |                  |                  |                  |
- * |                  |                  |==================|
- * |                  |                  |   G ∈ { 1, 2 }   |
- * |                  |                  |                  |
- * |                  |                  |                  |
- * |                  |                  |  R(once == -1) <-+--.
- * |                  |                  |                  |  |
- * |           -------+------------------+---------.        |  |
- * |                  |                  |         |        |  |
- * |  W(global, 42)   |                  |         |        |  |
- * |  WRel(once, G:0) |                  |         |        |  |
- * |                  |                  |         |        |  |
- * |                  |                  |         v        |  |
- * |                  |                  |   R(global == 0) |  |
- * |                  |                  |                  |  |
- * |                  |                  |                  |  |
- * |==================|                  |                  |  |
- * |   G ∈ { 1, 2 }   |                  |                  |  |
- * |                  |==================|                  |  |
- * |                  |      G = 2       |                  |  |
- * |                  |------------------|                  |  |
- * |                  |                  |                  |  |
- * |==================|                  |                  |  |
- * |   G ∈ { 2, 3 }   |                  |                  |  |
- * |                  |                  |                  |  |
- * |                  |                  |                  |  |
- * |   W(once, -1) ---+------------------+------------------+--'
- * |                  |                  |                  |
- * |                  |                  |==================|
- * |                  |                  |   G ∈ { 2, 3 }   |
- * |                  |                  |                  |
- *
- */
-#define DISPATCH_ONCE_GEN_SAFE_DELTA  (4 << 2)
-
-DISPATCH_ALWAYS_INLINE
-static inline uintptr_t
-_dispatch_once_generation(void)
-{
-	uintptr_t value;
-	value = *(volatile uintptr_t *)_COMM_PAGE_CPU_QUIESCENT_COUNTER;
-	return (uintptr_t)DISPATCH_ONCE_MAKE_GEN(value);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline uintptr_t
-_dispatch_once_mark_quiescing(dispatch_once_gate_t dgo)
-{
-	return os_atomic_xchg(&dgo->dgo_once, _dispatch_once_generation(), release);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_once_mark_done_if_quiesced(dispatch_once_gate_t dgo, uintptr_t gen)
-{
-	if (_dispatch_once_generation() - gen >= DISPATCH_ONCE_GEN_SAFE_DELTA) {
-		/*
-		 * See explanation above, when the quiescing counter approach is taken
-		 * then this store needs only to be relaxed as it is used as a witness
-		 * that the required barriers have happened.
-		 */
-		os_atomic_store(&dgo->dgo_once, DLOCK_ONCE_DONE, relaxed);
-	}
-}
-#else
-DISPATCH_ALWAYS_INLINE
-static inline uintptr_t
-_dispatch_once_mark_done(dispatch_once_gate_t dgo)
-{
-	return os_atomic_xchg(&dgo->dgo_once, DLOCK_ONCE_DONE, release);
-}
-#endif // DISPATCH_ONCE_USE_QUIESCENT_COUNTER
-
-void _dispatch_once_wait(dispatch_once_gate_t l);
-void _dispatch_gate_broadcast_slow(dispatch_gate_t l, dispatch_lock tid_cur);
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dispatch_gate_tryenter(dispatch_gate_t l)
-{
-	return os_atomic_cmpxchg(&l->dgl_lock, DLOCK_GATE_UNLOCKED,
-			_dispatch_lock_value_for_self(), acquire);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_gate_broadcast(dispatch_gate_t l)
-{
-	dispatch_lock cur, value_self = _dispatch_lock_value_for_self();
-	cur = os_atomic_xchg(&l->dgl_lock, DLOCK_GATE_UNLOCKED, release);
-	if (likely(cur == value_self)) return;
-	_dispatch_gate_broadcast_slow(l, cur);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dispatch_once_gate_tryenter(dispatch_once_gate_t l)
-{
-	return os_atomic_cmpxchg(&l->dgo_once, DLOCK_ONCE_UNLOCKED,
-			(uintptr_t)_dispatch_lock_value_for_self(), relaxed);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_once_gate_broadcast(dispatch_once_gate_t l)
-{
-	dispatch_lock value_self = _dispatch_lock_value_for_self();
-	uintptr_t v;
-#if DISPATCH_ONCE_USE_QUIESCENT_COUNTER
-	v = _dispatch_once_mark_quiescing(l);
-#else
-	v = _dispatch_once_mark_done(l);
-#endif
-	if (likely((dispatch_lock)v == value_self)) return;
-	_dispatch_gate_broadcast_slow(&l->dgo_gate, (dispatch_lock)v);
-}
-
-#if TARGET_OS_MAC
-
-DISPATCH_NOT_TAIL_CALLED
-void _dispatch_firehose_gate_wait(dispatch_gate_t l, uint32_t owner,
-		uint32_t flags);
-
-#endif // TARGET_OS_MAC
-
-#endif // __DISPATCH_SHIMS_LOCK__
--- a/Telegram/ThirdParty/dispatch/src/shims/mach.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/shims/mach.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,45 +0,0 @@
-/*
- * Copyright (c) 2018 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#ifndef __DISPATCH_SHIMS_MACH__
-#define __DISPATCH_SHIMS_MACH__
-
-/*
- * Stub out defines for some mach types and related macros
- */
-
-typedef uint32_t mach_port_t;
-
-#define  MACH_PORT_NULL (0)
-#define  MACH_PORT_DEAD (-1)
-
-typedef uint32_t mach_error_t;
-
-typedef uint32_t mach_msg_return_t;
-
-typedef uint32_t mach_msg_bits_t;
-
-typedef void *dispatch_mach_msg_t;
-
-typedef uint64_t firehose_activity_id_t;
-
-typedef void *mach_msg_header_t;
-
-#endif
--- a/Telegram/ThirdParty/dispatch/src/shims/perfmon.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/shims/perfmon.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,99 +0,0 @@
-/*
- * Copyright (c) 2008-2013 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-/*
- * IMPORTANT: This header file describes INTERNAL interfaces to libdispatch
- * which are subject to change in future releases of Mac OS X. Any applications
- * relying on these interfaces WILL break.
- */
-
-#ifndef __DISPATCH_SHIMS_PERFMON__
-#define __DISPATCH_SHIMS_PERFMON__
-
-#if DISPATCH_PERF_MON
-#if DISPATCH_INTROSPECTION
-#error invalid configuration
-#endif
-
-typedef enum {
-	perfmon_thread_no_trace = 0,
-	perfmon_thread_event_no_steal,	// 1) Event threads that couldn't steal
-	perfmon_thread_event_steal,		// 2) Event threads failing to steal very late
-	perfmon_thread_worker_non_oc,	// 3) Non overcommit threads finding
-									//		nothing on the root queues
-	perfmon_thread_worker_oc,		// 4) Overcommit thread finding nothing to do
-	perfmon_thread_manager,
-} perfmon_thread_type;
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_perfmon_workitem_inc(void)
-{
-	unsigned long cnt;
-	cnt = (unsigned long)_dispatch_thread_getspecific(dispatch_bcounter_key);
-	_dispatch_thread_setspecific(dispatch_bcounter_key, (void *)++cnt);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_perfmon_workitem_dec(void)
-{
-	unsigned long cnt;
-	cnt = (unsigned long)_dispatch_thread_getspecific(dispatch_bcounter_key);
-	_dispatch_thread_setspecific(dispatch_bcounter_key, (void *)--cnt);
-}
-
-#define DISPATCH_PERF_MON_ARGS_PROTO  , uint64_t perfmon_start
-#define DISPATCH_PERF_MON_ARGS        , perfmon_start
-#define DISPATCH_PERF_MON_VAR         uint64_t perfmon_start;
-#define DISPATCH_PERF_MON_VAR_INIT    uint64_t perfmon_start = 0;
-
-#define _dispatch_perfmon_start_impl(trace) ({ \
-		if (trace) _dispatch_ktrace0(DISPATCH_PERF_MON_worker_thread_start); \
-		perfmon_start = _dispatch_uptime(); \
-	})
-#define _dispatch_perfmon_start() \
-		DISPATCH_PERF_MON_VAR _dispatch_perfmon_start_impl(true)
-#define _dispatch_perfmon_start_notrace() \
-		DISPATCH_PERF_MON_VAR _dispatch_perfmon_start_impl(false)
-#define _dispatch_perfmon_end(thread_type) \
-		_dispatch_queue_merge_stats(perfmon_start, true, thread_type)
-#define _dispatch_perfmon_end_notrace() \
-		_dispatch_queue_merge_stats(perfmon_start, false, perfmon_thread_no_trace)
-
-void _dispatch_queue_merge_stats(uint64_t start, bool trace, perfmon_thread_type type);
-
-#else
-
-#define DISPATCH_PERF_MON_ARGS_PROTO
-#define DISPATCH_PERF_MON_ARGS
-#define DISPATCH_PERF_MON_VAR
-#define DISPATCH_PERF_MON_VAR_INIT
-#define _dispatch_perfmon_workitem_inc()
-#define _dispatch_perfmon_workitem_dec()
-#define _dispatch_perfmon_start_impl(trace)
-#define _dispatch_perfmon_start()
-#define _dispatch_perfmon_end(thread_type)
-#define _dispatch_perfmon_start_notrace()
-#define _dispatch_perfmon_end_notrace()
-
-#endif // DISPATCH_PERF_MON
-
-#endif
--- a/Telegram/ThirdParty/dispatch/src/shims/priority.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/shims/priority.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,340 +0,0 @@
-/*
- * Copyright (c) 2008-2016 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-/*
- * IMPORTANT: This header file describes INTERNAL interfaces to libdispatch
- * which are subject to change in future releases of Mac OS X. Any applications
- * relying on these interfaces WILL break.
- */
-
-#ifndef __DISPATCH_SHIMS_PRIORITY__
-#define __DISPATCH_SHIMS_PRIORITY__
-
-#if HAVE_PTHREAD_QOS_H && __has_include(<pthread/qos_private.h>)
-#include <pthread/qos.h>
-#include <pthread/qos_private.h>
-#ifndef _PTHREAD_PRIORITY_OVERCOMMIT_FLAG
-#define _PTHREAD_PRIORITY_OVERCOMMIT_FLAG 0x80000000
-#endif
-#ifndef _PTHREAD_PRIORITY_SCHED_PRI_FLAG
-#define _PTHREAD_PRIORITY_SCHED_PRI_FLAG 0x20000000
-#endif
-#ifndef _PTHREAD_PRIORITY_FALLBACK_FLAG
-#define _PTHREAD_PRIORITY_FALLBACK_FLAG 0x04000000
-#endif
-#ifndef _PTHREAD_PRIORITY_EVENT_MANAGER_FLAG
-#define _PTHREAD_PRIORITY_EVENT_MANAGER_FLAG 0x02000000
-#endif
-#ifndef _PTHREAD_PRIORITY_NEEDS_UNBIND_FLAG
-#define _PTHREAD_PRIORITY_NEEDS_UNBIND_FLAG 0x01000000
-#endif
-#else // HAVE_PTHREAD_QOS_H
-OS_ENUM(qos_class, unsigned int,
-	QOS_CLASS_USER_INTERACTIVE = 0x21,
-	QOS_CLASS_USER_INITIATED = 0x19,
-	QOS_CLASS_DEFAULT = 0x15,
-	QOS_CLASS_UTILITY = 0x11,
-	QOS_CLASS_BACKGROUND = 0x09,
-	QOS_CLASS_MAINTENANCE = 0x05,
-	QOS_CLASS_UNSPECIFIED = 0x00,
-);
-typedef unsigned long pthread_priority_t;
-#define QOS_MIN_RELATIVE_PRIORITY (-15)
-#define _PTHREAD_PRIORITY_FLAGS_MASK (~0xffffff)
-#define _PTHREAD_PRIORITY_QOS_CLASS_MASK 0x00ffff00
-#define _PTHREAD_PRIORITY_QOS_CLASS_SHIFT (8ull)
-#define _PTHREAD_PRIORITY_PRIORITY_MASK 0x000000ff
-#define _PTHREAD_PRIORITY_OVERCOMMIT_FLAG 0x80000000
-#define _PTHREAD_PRIORITY_SCHED_PRI_FLAG 0x20000000
-#define _PTHREAD_PRIORITY_FALLBACK_FLAG 0x04000000
-#define _PTHREAD_PRIORITY_EVENT_MANAGER_FLAG 0x02000000
-#define _PTHREAD_PRIORITY_NEEDS_UNBIND_FLAG 0x01000000
-#define _PTHREAD_PRIORITY_ENFORCE_FLAG  0x10000000
-
-#endif // HAVE_PTHREAD_QOS_H
-
-#if !defined(POLICY_RR) && defined(SCHED_RR)
-#define POLICY_RR SCHED_RR
-#endif // !defined(POLICY_RR) && defined(SCHED_RR)
-
-typedef uint32_t dispatch_qos_t;
-typedef uint32_t dispatch_priority_t;
-
-#define DISPATCH_QOS_UNSPECIFIED        ((dispatch_qos_t)0)
-#define DISPATCH_QOS_MAINTENANCE        ((dispatch_qos_t)1)
-#define DISPATCH_QOS_BACKGROUND         ((dispatch_qos_t)2)
-#define DISPATCH_QOS_UTILITY            ((dispatch_qos_t)3)
-#define DISPATCH_QOS_DEFAULT            ((dispatch_qos_t)4)
-#define DISPATCH_QOS_USER_INITIATED     ((dispatch_qos_t)5)
-#define DISPATCH_QOS_USER_INTERACTIVE   ((dispatch_qos_t)6)
-#define DISPATCH_QOS_MIN                DISPATCH_QOS_MAINTENANCE
-#define DISPATCH_QOS_MAX                DISPATCH_QOS_USER_INTERACTIVE
-#define DISPATCH_QOS_SATURATED          ((dispatch_qos_t)15)
-
-#define DISPATCH_QOS_NBUCKETS           (DISPATCH_QOS_MAX - DISPATCH_QOS_MIN + 1)
-#define DISPATCH_QOS_BUCKET(qos)        ((int)((qos) - DISPATCH_QOS_MIN))
-#define DISPATCH_QOS_FOR_BUCKET(bucket) ((dispatch_qos_t)((uint32_t)bucket + DISPATCH_QOS_MIN))
-
-#define DISPATCH_PRIORITY_RELPRI_MASK        ((dispatch_priority_t)0x000000ff)
-#define DISPATCH_PRIORITY_RELPRI_SHIFT       0
-#define DISPATCH_PRIORITY_QOS_MASK           ((dispatch_priority_t)0x00000f00)
-#define DISPATCH_PRIORITY_QOS_SHIFT          8
-#define DISPATCH_PRIORITY_REQUESTED_MASK     ((dispatch_priority_t)0x00000fff)
-#define DISPATCH_PRIORITY_FALLBACK_QOS_MASK  ((dispatch_priority_t)0x0000f000)
-#define DISPATCH_PRIORITY_FALLBACK_QOS_SHIFT 12
-#define DISPATCH_PRIORITY_OVERRIDE_MASK      ((dispatch_priority_t)0x000f0000)
-#define DISPATCH_PRIORITY_OVERRIDE_SHIFT     16
-#define DISPATCH_PRIORITY_FLAGS_MASK         ((dispatch_priority_t)0xff000000)
-
-#define DISPATCH_PRIORITY_SATURATED_OVERRIDE DISPATCH_PRIORITY_OVERRIDE_MASK
-
-#define DISPATCH_PRIORITY_FLAG_OVERCOMMIT    ((dispatch_priority_t)0x80000000) // _PTHREAD_PRIORITY_OVERCOMMIT_FLAG
-#define DISPATCH_PRIORITY_FLAG_FALLBACK      ((dispatch_priority_t)0x04000000) // _PTHREAD_PRIORITY_FALLBACK_FLAG
-#define DISPATCH_PRIORITY_FLAG_MANAGER       ((dispatch_priority_t)0x02000000) // _PTHREAD_PRIORITY_EVENT_MANAGER_FLAG
-#define DISPATCH_PRIORITY_PTHREAD_PRIORITY_FLAGS_MASK \
-		(DISPATCH_PRIORITY_FLAG_OVERCOMMIT | DISPATCH_PRIORITY_FLAG_FALLBACK | \
-		DISPATCH_PRIORITY_FLAG_MANAGER)
-
-// not passed to pthread
-#define DISPATCH_PRIORITY_FLAG_FLOOR         ((dispatch_priority_t)0x40000000) // _PTHREAD_PRIORITY_INHERIT_FLAG
-#define DISPATCH_PRIORITY_FLAG_ENFORCE       ((dispatch_priority_t)0x10000000) // _PTHREAD_PRIORITY_ENFORCE_FLAG
-#define DISPATCH_PRIORITY_FLAG_INHERITED     ((dispatch_priority_t)0x20000000)
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dispatch_qos_class_valid(qos_class_t cls, int relpri)
-{
-	switch ((unsigned int)cls) {
-	case QOS_CLASS_MAINTENANCE:
-	case QOS_CLASS_BACKGROUND:
-	case QOS_CLASS_UTILITY:
-	case QOS_CLASS_DEFAULT:
-	case QOS_CLASS_USER_INITIATED:
-	case QOS_CLASS_USER_INTERACTIVE:
-	case QOS_CLASS_UNSPECIFIED:
-		break;
-	default:
-		return false;
-	}
-	return QOS_MIN_RELATIVE_PRIORITY <= relpri && relpri <= 0;
-}
-
-#pragma mark dispatch_qos
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_qos_t
-_dispatch_qos_from_qos_class(qos_class_t cls)
-{
-	switch ((unsigned int)cls) {
-	case QOS_CLASS_USER_INTERACTIVE: return DISPATCH_QOS_USER_INTERACTIVE;
-	case QOS_CLASS_USER_INITIATED:   return DISPATCH_QOS_USER_INITIATED;
-	case QOS_CLASS_DEFAULT:          return DISPATCH_QOS_DEFAULT;
-	case QOS_CLASS_UTILITY:          return DISPATCH_QOS_UTILITY;
-	case QOS_CLASS_BACKGROUND:       return DISPATCH_QOS_BACKGROUND;
-	case QOS_CLASS_MAINTENANCE:      return DISPATCH_QOS_MAINTENANCE;
-	default: return DISPATCH_QOS_UNSPECIFIED;
-	}
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline qos_class_t
-_dispatch_qos_to_qos_class(dispatch_qos_t qos)
-{
-	switch (qos) {
-	case DISPATCH_QOS_USER_INTERACTIVE: return QOS_CLASS_USER_INTERACTIVE;
-	case DISPATCH_QOS_USER_INITIATED:   return QOS_CLASS_USER_INITIATED;
-	case DISPATCH_QOS_DEFAULT:          return QOS_CLASS_DEFAULT;
-	case DISPATCH_QOS_UTILITY:          return QOS_CLASS_UTILITY;
-	case DISPATCH_QOS_BACKGROUND:       return QOS_CLASS_BACKGROUND;
-	case DISPATCH_QOS_MAINTENANCE:      return (qos_class_t)QOS_CLASS_MAINTENANCE;
-	default: return QOS_CLASS_UNSPECIFIED;
-	}
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_qos_t
-_dispatch_qos_from_queue_priority(intptr_t priority)
-{
-	switch (priority) {
-	case DISPATCH_QUEUE_PRIORITY_BACKGROUND:      return DISPATCH_QOS_BACKGROUND;
-	case DISPATCH_QUEUE_PRIORITY_NON_INTERACTIVE: return DISPATCH_QOS_UTILITY;
-	case DISPATCH_QUEUE_PRIORITY_LOW:             return DISPATCH_QOS_UTILITY;
-	case DISPATCH_QUEUE_PRIORITY_DEFAULT:         return DISPATCH_QOS_DEFAULT;
-	case DISPATCH_QUEUE_PRIORITY_HIGH:            return DISPATCH_QOS_USER_INITIATED;
-	default: return _dispatch_qos_from_qos_class((qos_class_t)priority);
-	}
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_qos_t
-_dispatch_qos_from_pp(pthread_priority_t pp)
-{
-	pp &= _PTHREAD_PRIORITY_QOS_CLASS_MASK;
-	pp >>= _PTHREAD_PRIORITY_QOS_CLASS_SHIFT;
-	return (dispatch_qos_t)__builtin_ffs((int)pp);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_qos_t
-_dispatch_qos_from_pp_unsafe(pthread_priority_t pp)
-{
-	// this assumes we know there is a QOS and pp has been masked off properly
-	pp >>= _PTHREAD_PRIORITY_QOS_CLASS_SHIFT;
-	DISPATCH_COMPILER_CAN_ASSUME(pp);
-	return (dispatch_qos_t)__builtin_ffs((int)pp);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline pthread_priority_t
-_dispatch_qos_to_pp(dispatch_qos_t qos)
-{
-	pthread_priority_t pp;
-	pp = 1ul << ((qos - 1) + _PTHREAD_PRIORITY_QOS_CLASS_SHIFT);
-	return pp | _PTHREAD_PRIORITY_PRIORITY_MASK;
-}
-
-// including maintenance
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dispatch_qos_is_background(dispatch_qos_t qos)
-{
-	return qos && qos <= DISPATCH_QOS_BACKGROUND;
-}
-
-#pragma mark dispatch_priority
-
-#define _dispatch_priority_make(qos, relpri) \
-	(qos ? ((((qos) << DISPATCH_PRIORITY_QOS_SHIFT) & DISPATCH_PRIORITY_QOS_MASK) | \
-	 ((dispatch_priority_t)(relpri - 1) & DISPATCH_PRIORITY_RELPRI_MASK)) : 0)
-
-#define _dispatch_priority_make_override(qos) \
-	(((qos) << DISPATCH_PRIORITY_OVERRIDE_SHIFT) & \
-	 DISPATCH_PRIORITY_OVERRIDE_MASK)
-
-#define _dispatch_priority_make_floor(qos) \
-	(qos ? (_dispatch_priority_make(qos) | DISPATCH_PRIORITY_FLAG_FLOOR) : 0)
-
-#define _dispatch_priority_make_fallback(qos) \
-	(qos ? ((((qos) << DISPATCH_PRIORITY_FALLBACK_QOS_SHIFT) & \
-	 DISPATCH_PRIORITY_FALLBACK_QOS_MASK) | DISPATCH_PRIORITY_FLAG_FALLBACK) : 0)
-
-DISPATCH_ALWAYS_INLINE
-static inline int
-_dispatch_priority_relpri(dispatch_priority_t dbp)
-{
-	if (dbp & DISPATCH_PRIORITY_QOS_MASK) {
-		return (int8_t)(dbp & DISPATCH_PRIORITY_RELPRI_MASK) + 1;
-	}
-	return 0;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_qos_t
-_dispatch_priority_qos(dispatch_priority_t dbp)
-{
-	dbp &= DISPATCH_PRIORITY_QOS_MASK;
-	return dbp >> DISPATCH_PRIORITY_QOS_SHIFT;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_qos_t
-_dispatch_priority_fallback_qos(dispatch_priority_t dbp)
-{
-	dbp &= DISPATCH_PRIORITY_FALLBACK_QOS_MASK;
-	return dbp >> DISPATCH_PRIORITY_FALLBACK_QOS_SHIFT;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_qos_t
-_dispatch_priority_override_qos(dispatch_priority_t dbp)
-{
-	dbp &= DISPATCH_PRIORITY_OVERRIDE_MASK;
-	return dbp >> DISPATCH_PRIORITY_OVERRIDE_SHIFT;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dispatch_queue_priority_manually_selected(dispatch_priority_t pri)
-{
-	return !(pri & DISPATCH_PRIORITY_FLAG_INHERITED) &&
-			(pri & (DISPATCH_PRIORITY_FLAG_FALLBACK |
-			DISPATCH_PRIORITY_FLAG_FLOOR |
-			DISPATCH_PRIORITY_REQUESTED_MASK));
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_priority_t
-_dispatch_priority_from_pp_impl(pthread_priority_t pp, bool keep_flags)
-{
-	dispatch_assert(!(pp & _PTHREAD_PRIORITY_SCHED_PRI_FLAG));
-
-	dispatch_priority_t dbp;
-	if (keep_flags) {
-		dbp = pp & (DISPATCH_PRIORITY_PTHREAD_PRIORITY_FLAGS_MASK |
-				DISPATCH_PRIORITY_RELPRI_MASK);
-	} else {
-		dbp = pp & DISPATCH_PRIORITY_RELPRI_MASK;
-	}
-
-	dbp |= _dispatch_qos_from_pp(pp) << DISPATCH_PRIORITY_QOS_SHIFT;
-	return dbp;
-}
-#define _dispatch_priority_from_pp(pp) \
-		_dispatch_priority_from_pp_impl(pp, true)
-#define _dispatch_priority_from_pp_strip_flags(pp) \
-		_dispatch_priority_from_pp_impl(pp, false)
-
-#define DISPATCH_PRIORITY_TO_PP_STRIP_FLAGS     0x1
-#define DISPATCH_PRIORITY_TO_PP_PREFER_FALLBACK 0x2
-
-DISPATCH_ALWAYS_INLINE
-static inline pthread_priority_t
-_dispatch_priority_to_pp_strip_flags(dispatch_priority_t dbp)
-{
-	pthread_priority_t pp = dbp & DISPATCH_PRIORITY_RELPRI_MASK;
-	dispatch_qos_t qos = _dispatch_priority_qos(dbp);
-	if (qos) {
-		pp |= (1ul << ((qos - 1) + _PTHREAD_PRIORITY_QOS_CLASS_SHIFT));
-	}
-	return pp;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline pthread_priority_t
-_dispatch_priority_to_pp_prefer_fallback(dispatch_priority_t dbp)
-{
-	pthread_priority_t pp;
-	dispatch_qos_t qos;
-
-	if (dbp & DISPATCH_PRIORITY_FLAG_FALLBACK) {
-		pp = dbp & DISPATCH_PRIORITY_PTHREAD_PRIORITY_FLAGS_MASK;
-		pp |= _PTHREAD_PRIORITY_PRIORITY_MASK;
-		qos = _dispatch_priority_fallback_qos(dbp);
-	} else {
-		pp = dbp & (DISPATCH_PRIORITY_PTHREAD_PRIORITY_FLAGS_MASK |
-				DISPATCH_PRIORITY_RELPRI_MASK);
-		qos = _dispatch_priority_qos(dbp);
-		if (unlikely(!qos)) return pp;
-	}
-
-	return pp | (1ul << ((qos - 1) + _PTHREAD_PRIORITY_QOS_CLASS_SHIFT));
-}
-
-#endif // __DISPATCH_SHIMS_PRIORITY__
--- a/Telegram/ThirdParty/dispatch/src/shims/target.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/shims/target.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,61 +0,0 @@
-/*
- * Copyright (c) 2018 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-/*
- * IMPORTANT: This header file describes INTERNAL interfaces to libdispatch
- * which are subject to change in future releases of Mac OS X. Any applications
- * relying on these interfaces WILL break.
- */
-
-// These are the portable dispatch version requirements macros, isolated from
-// the rest of the C internal headers to be suitable for inclusion in MIG defs,
-// asm, etc.
-
-#ifndef __DISPATCH_SHIMS_TARGET__
-#define __DISPATCH_SHIMS_TARGET__
-
-#ifdef __APPLE__
-#include <Availability.h>
-#include <TargetConditionals.h>
-
-#if TARGET_OS_OSX
-#  define DISPATCH_MIN_REQUIRED_OSX_AT_LEAST(x) \
-		(__MAC_OS_X_VERSION_MIN_REQUIRED >= (x))
-#  if !DISPATCH_MIN_REQUIRED_OSX_AT_LEAST(101200)
-#    error "OS X hosts older than OS X 10.12 aren't supported anymore"
-#  endif // !DISPATCH_MIN_REQUIRED_OSX_AT_LEAST(101200)
-#elif TARGET_OS_SIMULATOR
-#  define DISPATCH_MIN_REQUIRED_OSX_AT_LEAST(x) \
-		(IPHONE_SIMULATOR_HOST_MIN_VERSION_REQUIRED >= (x))
-#  if !DISPATCH_MIN_REQUIRED_OSX_AT_LEAST(101200)
-#    error "Simulator hosts older than OS X 10.12 aren't supported anymore"
-#  endif // !DISPATCH_MIN_REQUIRED_OSX_AT_LEAST(101200)
-#else
-#  define DISPATCH_MIN_REQUIRED_OSX_AT_LEAST(x) 1
-#  if __IPHONE_OS_VERSION_MIN_REQUIRED < 90000
-#    error "iOS hosts older than iOS 9.0 aren't supported anymore"
-#  endif
-#endif
-
-#else // !__APPLE__
-#define DISPATCH_MIN_REQUIRED_OSX_AT_LEAST(x) 0
-#endif // !__APPLE__
-
-#endif // __DISPATCH_SHIMS_TARGET__
--- a/Telegram/ThirdParty/dispatch/src/shims/time.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/shims/time.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,300 +0,0 @@
-/*
- * Copyright (c) 2008-2013 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-/*
- * IMPORTANT: This header file describes INTERNAL interfaces to libdispatch
- * which are subject to change in future releases of Mac OS X. Any applications
- * relying on these interfaces WILL break.
- */
-
-#ifndef __DISPATCH_SHIMS_TIME__
-#define __DISPATCH_SHIMS_TIME__
-
-#ifndef __DISPATCH_INDIRECT__
-#error "Please #include <dispatch/dispatch.h> instead of this file directly."
-#endif
-
-#if defined(_WIN32)
-static inline unsigned int
-sleep(unsigned int seconds)
-{
-	Sleep(seconds * 1000); // milliseconds
-	return 0;
-}
-#endif
-
-typedef enum {
-	DISPATCH_CLOCK_UPTIME,
-	DISPATCH_CLOCK_MONOTONIC,
-	DISPATCH_CLOCK_WALL,
-#define DISPATCH_CLOCK_COUNT  (DISPATCH_CLOCK_WALL + 1)
-} dispatch_clock_t;
-
-void _dispatch_time_init(void);
-
-#if defined(__i386__) || defined(__x86_64__) || !HAVE_MACH_ABSOLUTE_TIME
-#define DISPATCH_TIME_UNIT_USES_NANOSECONDS 1
-#else
-#define DISPATCH_TIME_UNIT_USES_NANOSECONDS 0
-#endif
-
-#if DISPATCH_TIME_UNIT_USES_NANOSECONDS
-// x86 currently implements mach time in nanoseconds
-// this is NOT likely to change
-DISPATCH_ALWAYS_INLINE
-static inline uint64_t
-_dispatch_time_mach2nano(uint64_t machtime)
-{
-	return machtime;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline uint64_t
-_dispatch_time_nano2mach(uint64_t nsec)
-{
-	return nsec;
-}
-#else
-#define DISPATCH_USE_HOST_TIME 1
-extern uint64_t (*_dispatch_host_time_mach2nano)(uint64_t machtime);
-extern uint64_t (*_dispatch_host_time_nano2mach)(uint64_t nsec);
-static inline uint64_t
-_dispatch_time_mach2nano(uint64_t machtime)
-{
-	return _dispatch_host_time_mach2nano(machtime);
-}
-
-static inline uint64_t
-_dispatch_time_nano2mach(uint64_t nsec)
-{
-	return _dispatch_host_time_nano2mach(nsec);
-}
-#endif // DISPATCH_USE_HOST_TIME
-
-/* XXXRW: Some kind of overflow detection needed? */
-#define _dispatch_timespec_to_nano(ts) \
-		((uint64_t)(ts).tv_sec * NSEC_PER_SEC + (uint64_t)(ts).tv_nsec)
-#define _dispatch_timeval_to_nano(tv) \
-		((uint64_t)(tv).tv_sec * NSEC_PER_SEC + \
-				(uint64_t)(tv).tv_usec * NSEC_PER_USEC)
-
-static inline uint64_t
-_dispatch_get_nanoseconds(void)
-{
-	dispatch_static_assert(sizeof(NSEC_PER_SEC) == 8);
-	dispatch_static_assert(sizeof(USEC_PER_SEC) == 8);
-
-#if TARGET_OS_MAC
-	return clock_gettime_nsec_np(CLOCK_REALTIME);
-#elif HAVE_DECL_CLOCK_REALTIME
-	struct timespec ts;
-	dispatch_assume_zero(clock_gettime(CLOCK_REALTIME, &ts));
-	return _dispatch_timespec_to_nano(ts);
-#elif defined(_WIN32)
-	static const uint64_t kNTToUNIXBiasAdjustment = 11644473600 * NSEC_PER_SEC;
-	// FILETIME is 100-nanosecond intervals since January 1, 1601 (UTC).
-	FILETIME ft;
-	ULARGE_INTEGER li;
-	GetSystemTimePreciseAsFileTime(&ft);
-	li.LowPart = ft.dwLowDateTime;
-	li.HighPart = ft.dwHighDateTime;
-	return li.QuadPart * 100ull - kNTToUNIXBiasAdjustment;
-#else
-	struct timeval tv;
-	dispatch_assert_zero(gettimeofday(&tv, NULL));
-	return _dispatch_timeval_to_nano(tv);
-#endif
-}
-
-/* On the use of clock sources in the CLOCK_MONOTONIC family
- *
- * The code below requires monotonic clock sources that only tick
- * while the machine is running.
- *
- * Per POSIX, the CLOCK_MONOTONIC family is supposed to tick during
- * machine sleep; this is not the case on Linux, and that behavior
- * became part of the Linux ABI.
- *
- * Using the CLOCK_MONOTONIC family on POSIX-compliant platforms
- * will lead to bugs, hence its use is restricted to Linux.
- */
-
-static inline uint64_t
-_dispatch_uptime(void)
-{
-#if HAVE_MACH_ABSOLUTE_TIME
-	return mach_absolute_time();
-#elif HAVE_DECL_CLOCK_MONOTONIC && defined(__linux__)
-	struct timespec ts;
-	dispatch_assume_zero(clock_gettime(CLOCK_MONOTONIC, &ts));
-	return _dispatch_timespec_to_nano(ts);
-#elif HAVE_DECL_CLOCK_UPTIME && !defined(__linux__)
-	struct timespec ts;
-	dispatch_assume_zero(clock_gettime(CLOCK_UPTIME, &ts));
-	return _dispatch_timespec_to_nano(ts);
-#elif defined(_WIN32)
-	ULONGLONG ullUnbiasedTime;
-	_dispatch_QueryUnbiasedInterruptTimePrecise(&ullUnbiasedTime);
-	return ullUnbiasedTime * 100;
-#else
-#error platform needs to implement _dispatch_uptime()
-#endif
-}
-
-static inline uint64_t
-_dispatch_monotonic_time(void)
-{
-#if HAVE_MACH_ABSOLUTE_TIME
-	return mach_continuous_time();
-#elif defined(__linux__)
-	struct timespec ts;
-	dispatch_assume_zero(clock_gettime(CLOCK_BOOTTIME, &ts));
-	return _dispatch_timespec_to_nano(ts);
-#elif HAVE_DECL_CLOCK_MONOTONIC
-	struct timespec ts;
-	dispatch_assume_zero(clock_gettime(CLOCK_MONOTONIC, &ts));
-	return _dispatch_timespec_to_nano(ts);
-#elif defined(_WIN32)
-	ULONGLONG ullTime;
-	_dispatch_QueryInterruptTimePrecise(&ullTime);
-	return ullTime * 100ull;
-#else
-#error platform needs to implement _dispatch_monotonic_time()
-#endif
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline uint64_t
-_dispatch_approximate_time(void)
-{
-#if HAVE_MACH_APPROXIMATE_TIME
-	return mach_approximate_time();
-#elif HAVE_DECL_CLOCK_MONOTONIC_COARSE && defined(__linux__)
-	struct timespec ts;
-	dispatch_assume_zero(clock_gettime(CLOCK_MONOTONIC_COARSE, &ts));
-	return _dispatch_timespec_to_nano(ts);
-#elif HAVE_DECL_CLOCK_UPTIME_FAST && !defined(__linux__)
-	struct timespec ts;
-	dispatch_assume_zero(clock_gettime(CLOCK_UPTIME_FAST, &ts));
-	return _dispatch_timespec_to_nano(ts);
-#else
-	return _dispatch_uptime();
-#endif
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline uint64_t
-_dispatch_time_now(dispatch_clock_t clock)
-{
-	switch (clock) {
-	case DISPATCH_CLOCK_UPTIME:
-		return _dispatch_uptime();
-	case DISPATCH_CLOCK_MONOTONIC:
-		return _dispatch_monotonic_time();
-	case DISPATCH_CLOCK_WALL:
-		return _dispatch_get_nanoseconds();
-	}
-	__builtin_unreachable();
-}
-
-typedef struct {
-	uint64_t nows[DISPATCH_CLOCK_COUNT];
-} dispatch_clock_now_cache_s, *dispatch_clock_now_cache_t;
-
-DISPATCH_ALWAYS_INLINE
-static inline uint64_t
-_dispatch_time_now_cached(dispatch_clock_t clock,
-		dispatch_clock_now_cache_t cache)
-{
-	if (likely(cache->nows[clock])) {
-		return cache->nows[clock];
-	}
-#if TARGET_OS_MAC
-	struct timespec ts;
-	mach_get_times(&cache->nows[DISPATCH_CLOCK_UPTIME],
-			&cache->nows[DISPATCH_CLOCK_MONOTONIC], &ts);
-	cache->nows[DISPATCH_CLOCK_WALL] = _dispatch_timespec_to_nano(ts);
-#else
-	cache->nows[clock] = _dispatch_time_now(clock);
-#endif
-	return cache->nows[clock];
-}
-
-// Encoding of dispatch_time_t:
-// 1. Wall time has the top two bits set; negate to get the actual value.
-// 2. Absolute time has the top two bits clear and is the actual value.
-// 3. Continuous time has bit 63 set and bit 62 clear. Clear bit 63 to get the
-// actual value.
-// 4. "Forever" and "now" are encoded as ~0ULL and 0ULL respectively.
-//
-// The consequence of all this is that we can't have an actual time value that
-// is >= 0x4000000000000000. Larger values always get silently converted to
-// DISPATCH_TIME_FOREVER because the APIs that return time values have no way to
-// indicate a range error.
-#define DISPATCH_UP_OR_MONOTONIC_TIME_MASK	(1ULL << 63)
-#define DISPATCH_WALLTIME_MASK	(1ULL << 62)
-#define DISPATCH_TIME_MAX_VALUE (DISPATCH_WALLTIME_MASK - 1)
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_time_to_clock_and_value(dispatch_time_t time,
-		dispatch_clock_t *clock, uint64_t *value)
-{
-	uint64_t actual_value;
-	if ((int64_t)time < 0) {
-		// Wall time or mach continuous time
-		if (time & DISPATCH_WALLTIME_MASK) {
-			// Wall time (value 11 in bits 63, 62)
-			*clock = DISPATCH_CLOCK_WALL;
-			actual_value = time == DISPATCH_WALLTIME_NOW ?
-					_dispatch_get_nanoseconds() : (uint64_t)-time;
-		} else {
-			// Continuous time (value 10 in bits 63, 62).
-			*clock = DISPATCH_CLOCK_MONOTONIC;
-			actual_value = time & ~DISPATCH_UP_OR_MONOTONIC_TIME_MASK;
-		}
-	} else {
-		*clock = DISPATCH_CLOCK_UPTIME;
-		actual_value = time;
-	}
-
-	// Range-check the value before returning.
-	*value = actual_value > DISPATCH_TIME_MAX_VALUE ? DISPATCH_TIME_FOREVER
-			: actual_value;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_time_t
-_dispatch_clock_and_value_to_time(dispatch_clock_t clock, uint64_t value)
-{
-	if (value >= DISPATCH_TIME_MAX_VALUE) {
-		return DISPATCH_TIME_FOREVER;
-	}
-	switch (clock) {
-	case DISPATCH_CLOCK_WALL:
-		return -value;
-	case DISPATCH_CLOCK_UPTIME:
-		return value;
-	case DISPATCH_CLOCK_MONOTONIC:
-		return value | DISPATCH_UP_OR_MONOTONIC_TIME_MASK;
-	}
-	__builtin_unreachable();
-}
-#endif // __DISPATCH_SHIMS_TIME__
--- a/Telegram/ThirdParty/dispatch/src/shims/tsd.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/shims/tsd.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,370 +0,0 @@
-/*
- * Copyright (c) 2008-2013 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-/*
- * IMPORTANT: This header file describes INTERNAL interfaces to libdispatch
- * which are subject to change in future releases of Mac OS X. Any applications
- * relying on these interfaces WILL break.
- */
-
-#ifndef __DISPATCH_SHIMS_TSD__
-#define __DISPATCH_SHIMS_TSD__
-
-#if HAVE_PTHREAD_MACHDEP_H
-#include <pthread_machdep.h>
-#endif
-
-#define DISPATCH_TSD_INLINE DISPATCH_ALWAYS_INLINE_NDEBUG
-
-#if USE_APPLE_TSD_OPTIMIZATIONS && HAVE_PTHREAD_KEY_INIT_NP && \
-	!defined(DISPATCH_USE_DIRECT_TSD)
-#define DISPATCH_USE_DIRECT_TSD 1
-#if __has_include(<os/tsd.h>)
-#include <os/tsd.h>
-#endif
-
-#if !defined(OS_GS_RELATIVE) && (defined(__i386__) || defined(__x86_64__))
-#define OS_GS_RELATIVE __attribute__((address_space(256)))
-#endif
-
-#ifdef _os_tsd_get_base
-#ifdef OS_GS_RELATIVE
-typedef long dispatch_tsd_pair_t \
-		__attribute__((vector_size(sizeof(long) * 2), aligned(sizeof(long))));
-#define _os_tsd_get_pair_address(k) \
-	(dispatch_tsd_pair_t OS_GS_RELATIVE *)((k) * sizeof(long))
-#else
-typedef struct { void *a; void *b; } dispatch_tsd_pair_t;
-#define _os_tsd_get_pair_address(k) \
-	(dispatch_tsd_pair_t *)(_os_tsd_get_base() + (k))
-#endif
-#endif // _os_tsd_get_base
-#endif
-
-#if defined(_WIN32)
-#define DISPATCH_TSD_DTOR_CC __stdcall
-#else
-#define DISPATCH_TSD_DTOR_CC
-#endif
-
-#if DISPATCH_USE_DIRECT_TSD
-#ifndef __TSD_THREAD_QOS_CLASS
-#define __TSD_THREAD_QOS_CLASS 4
-#endif
-#ifndef __TSD_RETURN_TO_KERNEL
-#define __TSD_RETURN_TO_KERNEL 5
-#endif
-#ifndef __TSD_MACH_SPECIAL_REPLY
-#define __TSD_MACH_SPECIAL_REPLY 8
-#endif
-
-
-static const unsigned long dispatch_priority_key	= __TSD_THREAD_QOS_CLASS;
-static const unsigned long dispatch_r2k_key			= __TSD_RETURN_TO_KERNEL;
-
-// dispatch_queue_key & dispatch_frame_key need to be contiguous
-// in that order, and queue_key to be an even number
-static const unsigned long dispatch_queue_key		= __PTK_LIBDISPATCH_KEY0;
-static const unsigned long dispatch_frame_key		= __PTK_LIBDISPATCH_KEY1;
-static const unsigned long dispatch_cache_key		= __PTK_LIBDISPATCH_KEY2;
-static const unsigned long dispatch_context_key		= __PTK_LIBDISPATCH_KEY3;
-static const unsigned long dispatch_pthread_root_queue_observer_hooks_key =
-		__PTK_LIBDISPATCH_KEY4;
-static const unsigned long dispatch_basepri_key     = __PTK_LIBDISPATCH_KEY5;
-#if DISPATCH_INTROSPECTION
-static const unsigned long dispatch_introspection_key = __PTK_LIBDISPATCH_KEY6;
-#elif DISPATCH_PERF_MON
-static const unsigned long dispatch_bcounter_key	= __PTK_LIBDISPATCH_KEY6;
-#endif
-static const unsigned long dispatch_wlh_key			= __PTK_LIBDISPATCH_KEY7;
-static const unsigned long dispatch_voucher_key		= __PTK_LIBDISPATCH_KEY8;
-static const unsigned long dispatch_deferred_items_key = __PTK_LIBDISPATCH_KEY9;
-
-DISPATCH_TSD_INLINE
-static inline void
-_dispatch_thread_key_create(const unsigned long *k, void (*d)(void *))
-{
-	if (!*k || !d) return;
-	dispatch_assert_zero(pthread_key_init_np((int)*k, d));
-}
-#elif DISPATCH_USE_THREAD_LOCAL_STORAGE
-
-#if defined(_WIN32)
-
-DISPATCH_TSD_INLINE
-static inline void
-_dispatch_thread_key_create(DWORD *k, void (DISPATCH_TSD_DTOR_CC *d)(void *))
-{
-	*k = FlsAlloc(d);
-	dispatch_assert(*k != FLS_OUT_OF_INDEXES);
-}
-
-extern DWORD __dispatch_tsd_key;
-
-#else
-
-DISPATCH_TSD_INLINE
-static inline void
-_dispatch_thread_key_create(pthread_key_t *k, void (DISPATCH_TSD_DTOR_CC *d)(void *))
-{
-	dispatch_assert_zero(pthread_key_create(k, d));
-}
-
-extern pthread_key_t __dispatch_tsd_key;
-
-#endif
-
-struct dispatch_tsd {
-#if defined(_WIN32)
-	DWORD tid;
-#else
-	pid_t tid;
-#endif
-	void *dispatch_queue_key;
-	void *dispatch_frame_key;
-	void *dispatch_cache_key;
-	void *dispatch_context_key;
-	void *dispatch_pthread_root_queue_observer_hooks_key;
-	void *dispatch_basepri_key;
-#if DISPATCH_INTROSPECTION
-	void *dispatch_introspection_key;
-#elif DISPATCH_PERF_MON
-	void *dispatch_bcounter_key;
-#endif
-	void *dispatch_priority_key;
-	void *dispatch_r2k_key;
-	void *dispatch_wlh_key;
-	void *dispatch_voucher_key;
-	void *dispatch_deferred_items_key;
-};
-
-extern _Thread_local struct dispatch_tsd __dispatch_tsd;
-
-extern void libdispatch_tsd_init(void);
-extern void DISPATCH_TSD_DTOR_CC _libdispatch_tsd_cleanup(void *ctx);
-
-DISPATCH_ALWAYS_INLINE
-static inline struct dispatch_tsd *
-_dispatch_get_tsd_base(void)
-{
-	if (unlikely(__dispatch_tsd.tid == 0)) {
-		libdispatch_tsd_init();
-	}
-	OS_COMPILER_CAN_ASSUME(__dispatch_tsd.tid != 0);
-	return &__dispatch_tsd;
-}
-
-#define _dispatch_thread_getspecific(key) \
-	(_dispatch_get_tsd_base()->key)
-#define _dispatch_thread_setspecific(key, value) \
-	(void)(_dispatch_get_tsd_base()->key = (value))
-
-#define _dispatch_thread_getspecific_pair(k1, p1, k2, p2) \
-	( *(p1) = _dispatch_thread_getspecific(k1), \
-	  *(p2) = _dispatch_thread_getspecific(k2) )
-
-#define _dispatch_thread_getspecific_packed_pair(k1, k2, p) \
-	( (p)[0] = _dispatch_thread_getspecific(k1), \
-	  (p)[1] = _dispatch_thread_getspecific(k2) )
-
-#define _dispatch_thread_setspecific_pair(k1, p1, k2, p2) \
-	( _dispatch_thread_setspecific(k1,p1), \
-	  _dispatch_thread_setspecific(k2,p2) )
-
-#define _dispatch_thread_setspecific_packed_pair(k1, k2, p) \
-	( _dispatch_thread_setspecific(k1,(p)[0]), \
-	  _dispatch_thread_setspecific(k2,(p)[1]) )
-
-#else
-extern pthread_key_t dispatch_priority_key;
-extern pthread_key_t dispatch_r2k_key;
-extern pthread_key_t dispatch_queue_key;
-extern pthread_key_t dispatch_frame_key;
-extern pthread_key_t dispatch_cache_key;
-extern pthread_key_t dispatch_context_key;
-extern pthread_key_t dispatch_pthread_root_queue_observer_hooks_key;
-extern pthread_key_t dispatch_basepri_key;
-#if DISPATCH_INTROSPECTION
-extern pthread_key_t dispatch_introspection_key;
-#elif DISPATCH_PERF_MON
-extern pthread_key_t dispatch_bcounter_key;
-#endif
-extern pthread_key_t dispatch_wlh_key;
-extern pthread_key_t dispatch_voucher_key;
-extern pthread_key_t dispatch_deferred_items_key;
-
-DISPATCH_TSD_INLINE
-static inline void
-_dispatch_thread_key_create(pthread_key_t *k, void (*d)(void *))
-{
-	dispatch_assert_zero(pthread_key_create(k, d));
-}
-#endif
-
-#ifndef DISPATCH_USE_THREAD_LOCAL_STORAGE
-DISPATCH_TSD_INLINE
-static inline void
-_dispatch_thread_setspecific(pthread_key_t k, void *v)
-{
-#if DISPATCH_USE_DIRECT_TSD
-	if (_pthread_has_direct_tsd()) {
-		(void)_pthread_setspecific_direct(k, v);
-	} else {
-#if TARGET_OS_SIMULATOR
-		(void)_pthread_setspecific_static(k, v); // rdar://26058142
-#else
-		__builtin_trap(); // unreachable
-#endif
-	}
-	return;
-#endif
-	dispatch_assert_zero(pthread_setspecific(k, v));
-}
-
-DISPATCH_TSD_INLINE
-static inline void *
-_dispatch_thread_getspecific(pthread_key_t k)
-{
-#if DISPATCH_USE_DIRECT_TSD
-	if (_pthread_has_direct_tsd()) {
-		return _pthread_getspecific_direct(k);
-	}
-#endif
-	return pthread_getspecific(k);
-}
-
-// this is used when loading a pair at once and the caller will want to
-// look at each component individually.
-// some platforms can load a pair of pointers efficiently that way (like arm)
-// intel doesn't, hence this degrades to two loads on intel
-DISPATCH_TSD_INLINE
-static inline void
-_dispatch_thread_getspecific_pair(pthread_key_t k1, void **p1,
-		pthread_key_t k2, void **p2)
-{
-	*p1 = _dispatch_thread_getspecific(k1);
-	*p2 = _dispatch_thread_getspecific(k2);
-}
-
-// this is used for save/restore purposes
-// and the caller doesn't need to look at a specific component
-// this does SSE on intel, and SSE is bad at breaking/assembling components
-DISPATCH_TSD_INLINE
-static inline void
-_dispatch_thread_getspecific_packed_pair(pthread_key_t k1, pthread_key_t k2,
-		void **p)
-{
-#if DISPATCH_USE_DIRECT_TSD && defined(_os_tsd_get_pair_address)
-	dispatch_assert(k2 == k1 + 1);
-	if (_pthread_has_direct_tsd()) {
-		*(dispatch_tsd_pair_t *)p = *_os_tsd_get_pair_address(k1);
-		return;
-	}
-#endif
-	p[0] = _dispatch_thread_getspecific(k1);
-	p[1] = _dispatch_thread_getspecific(k2);
-}
-
-// this is used when storing a pair at once from separated components
-// some platforms can store a pair of pointers efficiently that way (like arm)
-// intel doesn't, hence this degrades to two stores on intel
-DISPATCH_TSD_INLINE
-static inline void
-_dispatch_thread_setspecific_pair(pthread_key_t k1, void *p1,
-		pthread_key_t k2, void *p2)
-{
-	_dispatch_thread_setspecific(k1, p1);
-	_dispatch_thread_setspecific(k2, p2);
-}
-
-// this is used for save/restore purposes
-// and the caller doesn't need to look at a specific component
-// this does SSE on intel, and SSE is bad at breaking/assembling components
-DISPATCH_TSD_INLINE
-static inline void
-_dispatch_thread_setspecific_packed_pair(pthread_key_t k1, pthread_key_t k2,
-		void **p)
-{
-#if DISPATCH_USE_DIRECT_TSD && defined(_os_tsd_get_pair_address)
-	dispatch_assert(k2 == k1 + 1);
-	if (_pthread_has_direct_tsd()) {
-		*_os_tsd_get_pair_address(k1) = *(dispatch_tsd_pair_t *)p;
-		return;
-	}
-#endif
-	_dispatch_thread_setspecific(k1, p[0]);
-	_dispatch_thread_setspecific(k2, p[1]);
-}
-#endif
-
-#if defined(_WIN32)
-#define _dispatch_thread_self() ((uintptr_t)GetCurrentThreadId())
-#else
-#if DISPATCH_USE_DIRECT_TSD
-#define _dispatch_thread_self() ((uintptr_t)_dispatch_thread_getspecific( \
-		_PTHREAD_TSD_SLOT_PTHREAD_SELF))
-#else
-#define _dispatch_thread_self() ((uintptr_t)pthread_self())
-#endif
-#endif
-
-#if defined(_WIN32)
-#define _dispatch_thread_port() ((mach_port_t)0)
-#elif !DISPATCH_USE_THREAD_LOCAL_STORAGE
-#if DISPATCH_USE_DIRECT_TSD
-#define _dispatch_thread_port() ((mach_port_t)(uintptr_t)\
-		_dispatch_thread_getspecific(_PTHREAD_TSD_SLOT_MACH_THREAD_SELF))
-#else
-#define _dispatch_thread_port() pthread_mach_thread_np(_dispatch_thread_self())
-#endif
-#endif
-
-#if HAVE_MACH
-#define _dispatch_get_thread_mig_reply_port() ((mach_port_t)(uintptr_t) \
-		_dispatch_thread_getspecific(_PTHREAD_TSD_SLOT_MIG_REPLY))
-#define _dispatch_set_thread_mig_reply_port(p) ( \
-		_dispatch_thread_setspecific(_PTHREAD_TSD_SLOT_MIG_REPLY, \
-		(void*)(uintptr_t)(p)))
-#define _dispatch_get_thread_special_reply_port() ((mach_port_t)(uintptr_t) \
-		_dispatch_thread_getspecific(__TSD_MACH_SPECIAL_REPLY))
-#define _dispatch_set_thread_special_reply_port(p) ( \
-		_dispatch_thread_setspecific(__TSD_MACH_SPECIAL_REPLY, \
-		(void*)(uintptr_t)(p)))
-#endif
-
-DISPATCH_TSD_INLINE DISPATCH_CONST
-static inline unsigned int
-_dispatch_cpu_number(void)
-{
-#if __has_include(<os/tsd.h>)
-	return _os_cpu_number();
-#elif defined(__x86_64__) || defined(__i386__)
-	struct { uintptr_t p1, p2; } p;
-	__asm__("sidt %[p]" : [p] "=&m" (p));
-	return (unsigned int)(p.p1 & 0xfff);
-#else
-	// Not yet implemented.
-	return 0;
-#endif
-}
-
-#undef DISPATCH_TSD_INLINE
-
-#endif
--- a/Telegram/ThirdParty/dispatch/src/shims/yield.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/shims/yield.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,66 +0,0 @@
-/*
- * Copyright (c) 2018 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include "internal.h"
-
-DISPATCH_NOINLINE
-static void *
-__DISPATCH_WAIT_FOR_ENQUEUER__(void **ptr)
-{
-	int spins = 0;
-        // Different platforms may expand `_dispatch_preemption_yield` to a
-        // no-op, but `(void)++spins` is not considered a use like
-        // `(void)spins` is. Add a use to avoid unused var warnings.
-        (void)spins;
-
-	void *value;
-	while ((value = os_atomic_load(ptr, relaxed)) == NULL) {
-		_dispatch_preemption_yield(++spins);
-	}
-	return value;
-}
-
-void *
-_dispatch_wait_for_enqueuer(void **ptr)
-{
-#if !DISPATCH_HW_CONFIG_UP
-#if (defined(__arm__) && defined(__APPLE__)) || defined(__arm64__)
-	int spins = DISPATCH_WAIT_SPINS_WFE;
-	void *value;
-	while (unlikely(spins-- > 0)) {
-		if (likely(value = __builtin_arm_ldrex(ptr))) {
-			__builtin_arm_clrex();
-			return value;
-		}
-		__builtin_arm_wfe();
-	}
-#else
-	int spins = DISPATCH_WAIT_SPINS;
-	void *value;
-	while (unlikely(spins-- > 0)) {
-		if (likely(value = os_atomic_load(ptr, relaxed))) {
-			return value;
-		}
-		dispatch_hardware_pause();
-	}
-#endif
-#endif // DISPATCH_HW_CONFIG_UP
-	return __DISPATCH_WAIT_FOR_ENQUEUER__(ptr);
-}
--- a/Telegram/ThirdParty/dispatch/src/shims/yield.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/shims/yield.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,194 +0,0 @@
-/*
- * Copyright (c) 2013 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-/*
- * IMPORTANT: This header file describes INTERNAL interfaces to libdispatch
- * which are subject to change in future releases of Mac OS X. Any applications
- * relying on these interfaces WILL break.
- */
-
-#ifndef __DISPATCH_SHIMS_YIELD__
-#define __DISPATCH_SHIMS_YIELD__
-
-#pragma mark -
-#pragma mark _dispatch_wait_until
-
-// _dispatch_wait_until() is used for cases when we're waiting on a thread to
-// finish a critical section that is a few instructions long and cannot fail
-// (IOW has a guarantee of making forward progress).
-//
-// Using _dispatch_wait_until() has two implications:
-// - there's a single waiter for the specified condition,
-// - the thing it is waiting on has a strong guarantee of forward progress
-//   toward resolving the condition.
-//
-// For these reasons, we spin shortly for the likely case when the other thread
-// is on core and we just caught it in the inconsistency window. If the
-// condition we're waiting for doesn't resolve quickly, then we yield because
-// it's very likely the other thread that can unblock us is preempted, and we
-// need to wait for it to be scheduled again.
-//
-// Its typical client is the enqueuer/dequeuer starvation issue for the dispatch
-// enqueue algorithm where there is typically a 1-10 instruction gap between the
-// exchange at the tail and setting the head/prev pointer.
-#if DISPATCH_HW_CONFIG_UP
-#define _dispatch_wait_until(c) ({ \
-		__typeof__(c) _c; \
-		int _spins = 0; \
-		for (;;) { \
-			if (likely(_c = (c))) break; \
-			_spins++; \
-			_dispatch_preemption_yield(_spins); \
-		} \
-		_c; })
-#else
-#ifndef DISPATCH_WAIT_SPINS_WFE
-#define DISPATCH_WAIT_SPINS_WFE 10
-#endif
-#ifndef DISPATCH_WAIT_SPINS // <rdar://problem/15440575>
-#define DISPATCH_WAIT_SPINS 1024
-#endif
-#define _dispatch_wait_until(c) ({ \
-		__typeof__(c) _c; \
-		int _spins = -(DISPATCH_WAIT_SPINS); \
-		for (;;) { \
-			if (likely(_c = (c))) break; \
-			if (unlikely(_spins++ >= 0)) { \
-				_dispatch_preemption_yield(_spins); \
-			} else { \
-				dispatch_hardware_pause(); \
-			} \
-		} \
-		_c; })
-#endif
-
-DISPATCH_NOT_TAIL_CALLED DISPATCH_EXPORT
-void *_dispatch_wait_for_enqueuer(void **ptr);
-
-#pragma mark -
-#pragma mark _dispatch_contention_wait_until
-
-#if DISPATCH_HW_CONFIG_UP
-#define _dispatch_contention_wait_until(c) false
-#else
-#ifndef DISPATCH_CONTENTION_SPINS_MAX
-#define DISPATCH_CONTENTION_SPINS_MAX (128 - 1)
-#endif
-#ifndef DISPATCH_CONTENTION_SPINS_MIN
-#define DISPATCH_CONTENTION_SPINS_MIN (32 - 1)
-#endif
-#if TARGET_OS_IPHONE && !TARGET_OS_SIMULATOR
-#define _dispatch_contention_spins() \
-		((DISPATCH_CONTENTION_SPINS_MIN) + ((DISPATCH_CONTENTION_SPINS_MAX) - \
-		(DISPATCH_CONTENTION_SPINS_MIN)) / 2)
-#elif defined(_WIN32)
-// Use randomness to prevent threads from resonating at the same frequency and
-// permanently contending. Windows doesn't provide rand_r(), so use a simple
-// LCG. (msvcrt has rand_s(), but its security guarantees aren't optimal here.)
-#define _dispatch_contention_spins() ({ \
-		static os_atomic(unsigned int) _seed = 1; \
-		unsigned int _next = os_atomic_load(&_seed, relaxed); \
-		os_atomic_store(&_seed, _next * 1103515245 + 12345, relaxed); \
-		((_next >> 24) & (DISPATCH_CONTENTION_SPINS_MAX)) | \
-				(DISPATCH_CONTENTION_SPINS_MIN); })
-#else
-// Use randomness to prevent threads from resonating at the same
-// frequency and permanently contending.
-#define _dispatch_contention_spins() ({ \
-		((unsigned int)rand() & (DISPATCH_CONTENTION_SPINS_MAX)) | \
-				(DISPATCH_CONTENTION_SPINS_MIN); })
-#endif
-#define _dispatch_contention_wait_until(c) ({ \
-		bool _out = false; \
-		unsigned int _spins = _dispatch_contention_spins(); \
-		while (_spins--) { \
-			dispatch_hardware_pause(); \
-			if (likely(_out = (c))) break; \
-		}; _out; })
-#endif
-
-#pragma mark -
-#pragma mark dispatch_hardware_pause
-
-#if defined(__x86_64__) || defined(__i386__)
-#define dispatch_hardware_pause() __asm__("pause")
-#elif (defined(__arm__) && defined(_ARM_ARCH_7) && defined(__thumb__)) || \
-		defined(__arm64__)
-#define dispatch_hardware_pause() __asm__("yield")
-#define dispatch_hardware_wfe()   __asm__("wfe")
-#else
-#define dispatch_hardware_pause() __asm__("")
-#endif
-
-#pragma mark -
-#pragma mark _dispatch_preemption_yield
-
-#if HAVE_MACH
-#if defined(SWITCH_OPTION_OSLOCK_DEPRESS)
-#define DISPATCH_YIELD_THREAD_SWITCH_OPTION SWITCH_OPTION_OSLOCK_DEPRESS
-#else
-#define DISPATCH_YIELD_THREAD_SWITCH_OPTION SWITCH_OPTION_DEPRESS
-#endif
-#define _dispatch_preemption_yield(n) thread_switch(MACH_PORT_NULL, \
-		DISPATCH_YIELD_THREAD_SWITCH_OPTION, (mach_msg_timeout_t)(n))
-#define _dispatch_preemption_yield_to(th, n) thread_switch(th, \
-		DISPATCH_YIELD_THREAD_SWITCH_OPTION, (mach_msg_timeout_t)(n))
-#elif HAVE_PTHREAD_YIELD_NP
-#define _dispatch_preemption_yield(n) { (void)n; pthread_yield_np(); }
-#define _dispatch_preemption_yield_to(th, n) { (void)n; pthread_yield_np(); }
-#elif defined(_WIN32)
-#define _dispatch_preemption_yield(n) { (void)n; Sleep(0); }
-#define _dispatch_preemption_yield_to(th, n) { (void)n; Sleep(0); }
-#else
-#define _dispatch_preemption_yield(n) { (void)n; sched_yield(); }
-#define _dispatch_preemption_yield_to(th, n) { (void)n; sched_yield(); }
-#endif // HAVE_MACH
-
-#pragma mark -
-#pragma mark _dispatch_contention_usleep
-
-#ifndef DISPATCH_CONTENTION_USLEEP_START
-#if defined(_WIN32)
-#define DISPATCH_CONTENTION_USLEEP_START 1000   // Must be >= 1ms for Sleep()
-#else
-#define DISPATCH_CONTENTION_USLEEP_START 500
-#endif
-#endif
-#ifndef DISPATCH_CONTENTION_USLEEP_MAX
-#define DISPATCH_CONTENTION_USLEEP_MAX 100000
-#endif
-
-#if HAVE_MACH
-#if defined(SWITCH_OPTION_DISPATCH_CONTENTION)
-#define _dispatch_contention_usleep(u) thread_switch(MACH_PORT_NULL, \
-		SWITCH_OPTION_DISPATCH_CONTENTION, (u))
-#else
-#define _dispatch_contention_usleep(u) thread_switch(MACH_PORT_NULL, \
-		SWITCH_OPTION_WAIT, (((u)-1)/1000)+1)
-#endif
-#else
-#if defined(_WIN32)
-#define _dispatch_contention_usleep(u) Sleep((u) / 1000)
-#else
-#define _dispatch_contention_usleep(u) usleep((u))
-#endif
-#endif // HAVE_MACH
-
-#endif // __DISPATCH_SHIMS_YIELD__
--- a/Telegram/ThirdParty/dispatch/src/shims.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/shims.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,35 +0,0 @@
-/*
- * Copyright (c) 2013-2016 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include "internal.h"
-#include "shims.h"
-
-#if !HAVE_STRLCPY
-size_t strlcpy(char *dst, const char *src, size_t size)
-{
-	size_t res = strlen(dst) + strlen(src) + 1;
-	if (size > 0) {
-		size_t n = size - 1;
-		strncpy(dst, src, n);
-		dst[n] = 0;
-	}
-	return res;
-}
-#endif
--- a/Telegram/ThirdParty/dispatch/src/shims.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/shims.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,289 +0,0 @@
-/*
- * Copyright (c) 2008-2013 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-/*
- * IMPORTANT: This header file describes INTERNAL interfaces to libdispatch
- * which are subject to change in future releases of Mac OS X. Any applications
- * relying on these interfaces WILL break.
- */
-
-#ifndef __DISPATCH_OS_SHIMS__
-#define __DISPATCH_OS_SHIMS__
-
-#if !defined(_WIN32)
-#include <pthread.h>
-#else // defined(_WIN32)
-#include "shims/generic_win_stubs.h"
-#endif // defined(_WIN32)
-
-#if defined(_WIN32) || defined(__linux__)
-#include "shims/generic_sys_queue.h"
-#endif
-
-#ifdef __ANDROID__
-#include "shims/android_stubs.h"
-#endif // __ANDROID__
-
-#if !HAVE_MACH
-#include "shims/mach.h"
-#endif
-#include "shims/target.h"
-
-#if DISPATCH_USE_INTERNAL_WORKQUEUE
-#include "event/workqueue_internal.h"
-#elif HAVE_PTHREAD_WORKQUEUES
-#include <pthread/workqueue_private.h>
-#else
-#error Unsupported configuration
-#endif
-
-#ifndef DISPATCH_WORKQ_MAX_PTHREAD_COUNT
-#define DISPATCH_WORKQ_MAX_PTHREAD_COUNT 255
-#endif
-
-#include "shims/hw_config.h"
-#include "shims/priority.h"
-
-#if HAVE_PTHREAD_NP_H
-#include <pthread_np.h>
-#endif
-
-#if __has_include(<pthread/private.h>)
-#include <pthread/private.h>
-#endif
-
-#if !HAVE_DECL_FD_COPY
-#define FD_COPY(f, t) (void)(*(t) = *(f))
-#endif
-
-#if HAVE_STRLCPY
-#include <string.h>
-#else // that is, if !HAVE_STRLCPY
-
-size_t strlcpy(char *dst, const char *src, size_t size);
-
-#endif // HAVE_STRLCPY
-
-#ifndef TAILQ_FOREACH_SAFE
-#define TAILQ_FOREACH_SAFE(var, head, field, temp)                         \
-	for ((var) = TAILQ_FIRST((head));                                      \
-		(var) && ((temp) = TAILQ_NEXT((var), field), 1); (var) = (temp))
-#endif
-
-#if PTHREAD_WORKQUEUE_SPI_VERSION < 20140716
-static inline int
-_pthread_workqueue_override_start_direct(mach_port_t thread,
-		pthread_priority_t priority)
-{
-	(void)thread; (void)priority;
-	return 0;
-}
-#endif // PTHREAD_WORKQUEUE_SPI_VERSION < 20140716
-
-#if PTHREAD_WORKQUEUE_SPI_VERSION < 20150319
-static inline int
-_pthread_workqueue_override_start_direct_check_owner(mach_port_t thread,
-		pthread_priority_t priority, mach_port_t *ulock_addr)
-{
-	(void)ulock_addr;
-	return _pthread_workqueue_override_start_direct(thread, priority);
-}
-#endif // PTHREAD_WORKQUEUE_SPI_VERSION < 20150319
-
-#if PTHREAD_WORKQUEUE_SPI_VERSION < 20140707
-static inline int
-_pthread_override_qos_class_start_direct(mach_port_t thread,
-		pthread_priority_t priority)
-{
-	(void)thread; (void)priority;
-	return 0;
-}
-
-static inline int
-_pthread_override_qos_class_end_direct(mach_port_t thread)
-{
-	(void)thread;
-	return 0;
-}
-#endif // PTHREAD_WORKQUEUE_SPI_VERSION < 20140707
-
-#if PTHREAD_WORKQUEUE_SPI_VERSION < 20150325
-static inline int
-_pthread_qos_override_start_direct(mach_port_t thread,
-		pthread_priority_t priority, void *resource)
-{
-	(void)resource;
-	return _pthread_override_qos_class_start_direct(thread, priority);
-}
-
-static inline int
-_pthread_qos_override_end_direct(mach_port_t thread, void *resource)
-{
-	(void)resource;
-	return _pthread_override_qos_class_end_direct(thread);
-}
-#endif // PTHREAD_WORKQUEUE_SPI_VERSION < 20150325
-
-#if PTHREAD_WORKQUEUE_SPI_VERSION < 20160427
-#define _PTHREAD_SET_SELF_WQ_KEVENT_UNBIND 0
-#endif
-
-#if PTHREAD_WORKQUEUE_SPI_VERSION < 20160427
-static inline bool
-_pthread_workqueue_should_narrow(pthread_priority_t priority)
-{
-	(void)priority;
-	return false;
-}
-#endif
-
-#if HAVE_PTHREAD_QOS_H && __has_include(<pthread/qos_private.h>) && \
-		defined(PTHREAD_MAX_PARALLELISM_PHYSICAL) && \
-		DISPATCH_HAVE_HW_CONFIG_COMMPAGE && \
-		DISPATCH_MIN_REQUIRED_OSX_AT_LEAST(101300)
-#define DISPATCH_USE_PTHREAD_QOS_MAX_PARALLELISM 1
-#define DISPATCH_MAX_PARALLELISM_PHYSICAL PTHREAD_MAX_PARALLELISM_PHYSICAL
-#else
-#define DISPATCH_MAX_PARALLELISM_PHYSICAL 0x1
-#endif
-#define DISPATCH_MAX_PARALLELISM_ACTIVE 0x2
-_Static_assert(!(DISPATCH_MAX_PARALLELISM_PHYSICAL &
-		DISPATCH_MAX_PARALLELISM_ACTIVE), "Overlapping parallelism flags");
-
-DISPATCH_ALWAYS_INLINE
-static inline uint32_t
-_dispatch_qos_max_parallelism(dispatch_qos_t qos, unsigned long flags)
-{
-	uint32_t p;
-	int r = 0;
-
-	if (qos) {
-#if DISPATCH_USE_PTHREAD_QOS_MAX_PARALLELISM
-		r = pthread_qos_max_parallelism(_dispatch_qos_to_qos_class(qos),
-				flags & PTHREAD_MAX_PARALLELISM_PHYSICAL);
-#endif
-	}
-	if (likely(r > 0)) {
-		p = (uint32_t)r;
-	} else {
-		p = (flags & DISPATCH_MAX_PARALLELISM_PHYSICAL) ?
-				dispatch_hw_config(physical_cpus) :
-				dispatch_hw_config(logical_cpus);
-	}
-	if (flags & DISPATCH_MAX_PARALLELISM_ACTIVE) {
-		uint32_t active_cpus = dispatch_hw_config(active_cpus);
-		if ((flags & DISPATCH_MAX_PARALLELISM_PHYSICAL) &&
-				active_cpus < dispatch_hw_config(logical_cpus)) {
-			active_cpus /= dispatch_hw_config(logical_cpus) /
-					dispatch_hw_config(physical_cpus);
-		}
-		if (active_cpus < p) p = active_cpus;
-	}
-	return p;
-}
-
-#if !HAVE_NORETURN_BUILTIN_TRAP
-/*
- * XXXRW: Work-around for possible clang bug in which __builtin_trap() is not
- * marked noreturn, leading to a build error as dispatch_main() *is* marked
- * noreturn. Mask by marking __builtin_trap() as noreturn locally.
- */
-DISPATCH_NORETURN
-void __builtin_trap(void);
-#endif
-
-#if DISPATCH_HW_CONFIG_UP
-#define OS_ATOMIC_UP 1
-#else
-#define OS_ATOMIC_UP 0
-#endif
-
-
-#ifndef __OS_INTERNAL_ATOMIC__
-#include "shims/atomic.h"
-#endif
-#define DISPATCH_ATOMIC64_ALIGN  __attribute__((aligned(8)))
-
-#include "shims/atomic_sfb.h"
-#include "shims/tsd.h"
-#include "shims/yield.h"
-#include "shims/lock.h"
-
-#include "shims/perfmon.h"
-
-#include "shims/getprogname.h"
-#include "shims/time.h"
-
-#if __has_include(<os/overflow.h>)
-#include <os/overflow.h>
-#elif __has_builtin(__builtin_add_overflow)
-#define os_add_overflow(a, b, c) __builtin_add_overflow(a, b, c)
-#define os_sub_overflow(a, b, c) __builtin_sub_overflow(a, b, c)
-#define os_mul_overflow(a, b, c) __builtin_mul_overflow(a, b, c)
-#else
-#error unsupported compiler
-#endif
-
-#ifndef os_mul_and_add_overflow
-#define os_mul_and_add_overflow(a, x, b, res) __extension__({ \
-	__typeof(*(res)) _tmp; \
-	bool _s, _t; \
-	_s = os_mul_overflow((a), (x), &_tmp); \
-	_t = os_add_overflow((b), _tmp, (res)); \
-	_s | _t; \
-})
-#endif
-
-
-#if __has_feature(c_static_assert)
-#define __dispatch_is_array(x) \
-	_Static_assert(!__builtin_types_compatible_p(__typeof__((x)[0]) *, __typeof__(x)), \
-				#x " isn't an array")
-#define countof(x) \
-	({ __dispatch_is_array(x); sizeof(x) / sizeof((x)[0]); })
-#else
-#define countof(x) (sizeof(x) / sizeof(x[0]))
-#endif
-
-DISPATCH_ALWAYS_INLINE
-static inline void *
-_dispatch_mempcpy(void *ptr, const void *data, size_t len)
-{
-	memcpy(ptr, data, len);
-	return (char *)ptr + len;
-}
-#define _dispatch_memappend(ptr, e) \
-	_dispatch_mempcpy(ptr, e, sizeof(*(e)))
-
-#ifdef __APPLE__
-// Clear the stack before calling long-running thread-handler functions that
-// never return (and don't take arguments), to facilitate leak detection and
-// provide cleaner backtraces. <rdar://problem/9050566>
-#define _dispatch_clear_stack(s) do { \
-		void *a[(s)/sizeof(void*) ? (s)/sizeof(void*) : 1]; \
-		a[0] = pthread_get_stackaddr_np(pthread_self()); \
-		void* volatile const p = (void*)&a[1]; /* <rdar://32604885> */ \
-		bzero((void*)p, (size_t)(a[0] - (void*)&a[1])); \
-	} while (0)
-#else
-#define _dispatch_clear_stack(s)
-#endif
-
-#endif
--- a/Telegram/ThirdParty/dispatch/src/source.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/source.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,1440 +0,0 @@
-/*
- * Copyright (c) 2008-2016 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include "internal.h"
-
-static void _dispatch_source_handler_free(dispatch_source_refs_t ds, long kind);
-
-#pragma mark -
-#pragma mark dispatch_source_t
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_continuation_t
-_dispatch_source_get_handler(dispatch_source_refs_t dr, long kind)
-{
-	return os_atomic_load(&dr->ds_handler[kind], relaxed);
-}
-#define _dispatch_source_get_event_handler(dr) \
-		_dispatch_source_get_handler(dr, DS_EVENT_HANDLER)
-#define _dispatch_source_get_cancel_handler(dr) \
-		_dispatch_source_get_handler(dr, DS_CANCEL_HANDLER)
-#define _dispatch_source_get_registration_handler(dr) \
-		_dispatch_source_get_handler(dr, DS_REGISTN_HANDLER)
-
-dispatch_source_t
-dispatch_source_create(dispatch_source_type_t dst, uintptr_t handle,
-		uintptr_t mask, dispatch_queue_t dq)
-{
-	dispatch_source_refs_t dr;
-	dispatch_source_t ds;
-
-	dr = dux_create(dst, handle, mask)._dr;
-	if (unlikely(!dr)) {
-		return DISPATCH_BAD_INPUT;
-	}
-
-	ds = _dispatch_queue_alloc(source,
-			dux_type(dr)->dst_strict ? DSF_STRICT : DQF_MUTABLE, 1,
-			DISPATCH_QUEUE_INACTIVE | DISPATCH_QUEUE_ROLE_INNER)._ds;
-	ds->dq_label = "source";
-	ds->ds_refs = dr;
-	dr->du_owner_wref = _dispatch_ptr2wref(ds);
-
-	if (unlikely(!dq)) {
-		dq = _dispatch_get_default_queue(true);
-	} else {
-		_dispatch_retain((dispatch_queue_t _Nonnull)dq);
-	}
-	ds->do_targetq = dq;
-	if (dr->du_is_timer && (dr->du_timer_flags & DISPATCH_TIMER_INTERVAL)) {
-		dispatch_source_set_timer(ds, DISPATCH_TIME_NOW, handle, UINT64_MAX);
-	}
-	_dispatch_object_debug(ds, "%s", __func__);
-	return ds;
-}
-
-void
-_dispatch_source_dispose(dispatch_source_t ds, bool *allow_free)
-{
-	_dispatch_object_debug(ds, "%s", __func__);
-
-	_dispatch_trace_source_dispose(ds);
-	_dispatch_source_handler_free(ds->ds_refs, DS_REGISTN_HANDLER);
-	_dispatch_source_handler_free(ds->ds_refs, DS_EVENT_HANDLER);
-	_dispatch_source_handler_free(ds->ds_refs, DS_CANCEL_HANDLER);
-	_dispatch_unote_dispose(ds->ds_refs);
-	ds->ds_refs = NULL;
-	_dispatch_lane_class_dispose(ds, allow_free);
-}
-
-void
-_dispatch_source_xref_dispose(dispatch_source_t ds)
-{
-	dispatch_queue_flags_t dqf = _dispatch_queue_atomic_flags(ds);
-	if (unlikely((dqf & DSF_STRICT) && !(dqf & DSF_CANCELED) &&
-			_dispatch_source_get_cancel_handler(ds->ds_refs))) {
-		DISPATCH_CLIENT_CRASH(ds, "Release of a source that has not been "
-				"cancelled, but has a mandatory cancel handler");
-	}
-	dx_wakeup(ds, 0, DISPATCH_WAKEUP_MAKE_DIRTY);
-}
-
-intptr_t
-dispatch_source_testcancel(dispatch_source_t ds)
-{
-	return (bool)(ds->dq_atomic_flags & DSF_CANCELED);
-}
-
-uintptr_t
-dispatch_source_get_mask(dispatch_source_t ds)
-{
-	dispatch_source_refs_t dr = ds->ds_refs;
-	if (ds->dq_atomic_flags & DSF_CANCELED) {
-		return 0;
-	}
-#if DISPATCH_USE_MEMORYSTATUS
-	if (dr->du_vmpressure_override) {
-		return NOTE_VM_PRESSURE;
-	}
-#if TARGET_OS_SIMULATOR
-	if (dr->du_memorypressure_override) {
-		return NOTE_MEMORYSTATUS_PRESSURE_WARN;
-	}
-#endif
-#endif // DISPATCH_USE_MEMORYSTATUS
-	if (dr->du_is_timer) {
-		return dr->du_timer_flags;
-	}
-	return dr->du_fflags;
-}
-
-uintptr_t
-dispatch_source_get_handle(dispatch_source_t ds)
-{
-	dispatch_source_refs_t dr = ds->ds_refs;
-#if TARGET_OS_SIMULATOR
-	if (dr->du_memorypressure_override) {
-		return 0;
-	}
-#endif
-	if (dr->du_filter == DISPATCH_EVFILT_TIMER_WITH_CLOCK) {
-		switch (_dispatch_timer_flags_to_clock(dr->du_timer_flags)) {
-		case DISPATCH_CLOCK_UPTIME: return DISPATCH_CLOCKID_UPTIME;
-		case DISPATCH_CLOCK_MONOTONIC: return DISPATCH_CLOCKID_MONOTONIC;
-		case DISPATCH_CLOCK_WALL: return DISPATCH_CLOCKID_WALLTIME;
-		}
-	}
-	return dr->du_ident;
-}
-
-uintptr_t
-dispatch_source_get_data(dispatch_source_t ds)
-{
-	dispatch_source_refs_t dr = ds->ds_refs;
-#if DISPATCH_USE_MEMORYSTATUS
-	if (dr->du_vmpressure_override) {
-		return NOTE_VM_PRESSURE;
-	}
-#if TARGET_OS_SIMULATOR
-	if (dr->du_memorypressure_override) {
-		return NOTE_MEMORYSTATUS_PRESSURE_WARN;
-	}
-#endif
-#endif // DISPATCH_USE_MEMORYSTATUS
-	uint64_t value = os_atomic_load2o(dr, ds_data, relaxed);
-	return (unsigned long)(dr->du_has_extended_status ?
-			DISPATCH_SOURCE_GET_DATA(value) : value);
-}
-
-size_t
-dispatch_source_get_extended_data(dispatch_source_t ds,
-		dispatch_source_extended_data_t edata, size_t size)
-{
-	dispatch_source_refs_t dr = ds->ds_refs;
-	size_t target_size = MIN(size,
-		sizeof(struct dispatch_source_extended_data_s));
-	if (size > 0) {
-		unsigned long data, status = 0;
-		if (dr->du_has_extended_status) {
-			uint64_t combined = os_atomic_load(&dr->ds_data, relaxed);
-			data = DISPATCH_SOURCE_GET_DATA(combined);
-			status = DISPATCH_SOURCE_GET_STATUS(combined);
-		} else {
-			data = dispatch_source_get_data(ds);
-		}
-		if (size >= offsetof(struct dispatch_source_extended_data_s, data)
-				+ sizeof(edata->data)) {
-			edata->data = data;
-		}
-		if (size >= offsetof(struct dispatch_source_extended_data_s, status)
-				+ sizeof(edata->status)) {
-			edata->status = status;
-		}
-		if (size > sizeof(struct dispatch_source_extended_data_s)) {
-			memset(
-				(char *)edata + sizeof(struct dispatch_source_extended_data_s),
-				0, size - sizeof(struct dispatch_source_extended_data_s));
-		}
-	}
-	return target_size;
-}
-
-void
-dispatch_source_merge_data(dispatch_source_t ds, uintptr_t val)
-{
-	dispatch_queue_flags_t dqf = _dispatch_queue_atomic_flags(ds);
-	dispatch_source_refs_t dr = ds->ds_refs;
-
-	if (unlikely(dqf & (DSF_CANCELED | DQF_RELEASED))) {
-		return;
-	}
-
-	switch (dr->du_filter) {
-	case DISPATCH_EVFILT_CUSTOM_ADD:
-		os_atomic_add2o(dr, ds_pending_data, val, relaxed);
-		break;
-	case DISPATCH_EVFILT_CUSTOM_OR:
-		os_atomic_or2o(dr, ds_pending_data, val, relaxed);
-		break;
-	case DISPATCH_EVFILT_CUSTOM_REPLACE:
-		os_atomic_store2o(dr, ds_pending_data, val, relaxed);
-		break;
-	default:
-		DISPATCH_CLIENT_CRASH(dr->du_filter, "Invalid source type");
-	}
-
-	dx_wakeup(ds, 0, DISPATCH_WAKEUP_MAKE_DIRTY);
-}
-
-#pragma mark -
-#pragma mark dispatch_source_handler
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_continuation_t
-_dispatch_source_handler_alloc(dispatch_source_t ds, void *func, uintptr_t kind,
-		bool is_block)
-{
-	// sources don't propagate priority by default
-	const dispatch_block_flags_t flags =
-			DISPATCH_BLOCK_HAS_PRIORITY | DISPATCH_BLOCK_NO_VOUCHER;
-	dispatch_continuation_t dc = _dispatch_continuation_alloc();
-	if (func) {
-		uintptr_t dc_flags = 0;
-
-		if (kind != DS_EVENT_HANDLER) {
-			dc_flags |= DC_FLAG_CONSUME;
-		}
-		if (is_block) {
-#ifdef __BLOCKS__
-			_dispatch_continuation_init(dc, ds, func, flags, dc_flags);
-#endif /* __BLOCKS__ */
-		} else {
-			dc_flags |= DC_FLAG_FETCH_CONTEXT;
-			_dispatch_continuation_init_f(dc, ds, ds->do_ctxt, func, flags,
-					dc_flags);
-		}
-	} else {
-		dc->dc_flags = DC_FLAG_ALLOCATED;
-		dc->dc_func = NULL;
-	}
-	return dc;
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_source_handler_dispose(dispatch_continuation_t dc)
-{
-#ifdef __BLOCKS__
-	if (dc->dc_flags & DC_FLAG_BLOCK) {
-		Block_release(dc->dc_ctxt);
-	}
-#endif /* __BLOCKS__ */
-	if (dc->dc_voucher) {
-		_voucher_release(dc->dc_voucher);
-		dc->dc_voucher = VOUCHER_INVALID;
-	}
-	_dispatch_continuation_free(dc);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_continuation_t
-_dispatch_source_handler_take(dispatch_source_refs_t dr, long kind)
-{
-	return os_atomic_xchg(&dr->ds_handler[kind], NULL, relaxed);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_source_handler_free(dispatch_source_refs_t dr, long kind)
-{
-	dispatch_continuation_t dc = _dispatch_source_handler_take(dr, kind);
-	if (dc) _dispatch_source_handler_dispose(dc);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_source_handler_replace(dispatch_source_t ds, uintptr_t kind,
-		dispatch_continuation_t dc)
-{
-	if (!dc->dc_func) {
-		_dispatch_continuation_free(dc);
-		dc = NULL;
-	} else if (dc->dc_flags & DC_FLAG_FETCH_CONTEXT) {
-		dc->dc_ctxt = ds->do_ctxt;
-	}
-	dc = os_atomic_xchg(&ds->ds_refs->ds_handler[kind], dc, release);
-	if (dc) _dispatch_source_handler_dispose(dc);
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_source_set_handler_slow(void *context)
-{
-	dispatch_source_t ds = upcast(_dispatch_queue_get_current())._ds;
-	dispatch_assert(dx_type(ds) == DISPATCH_SOURCE_KEVENT_TYPE);
-
-	dispatch_continuation_t dc = context;
-	uintptr_t kind = (uintptr_t)dc->dc_data;
-	dc->dc_data = NULL;
-	_dispatch_source_handler_replace(ds, kind, dc);
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_source_set_handler(dispatch_source_t ds, void *func,
-		uintptr_t kind, bool is_block)
-{
-	dispatch_continuation_t dc;
-
-	dc = _dispatch_source_handler_alloc(ds, func, kind, is_block);
-
-	if (_dispatch_lane_try_inactive_suspend(ds)) {
-		_dispatch_source_handler_replace(ds, kind, dc);
-		return _dispatch_lane_resume(ds, false);
-	}
-
-	dispatch_queue_flags_t dqf = _dispatch_queue_atomic_flags(ds);
-	if (unlikely(dqf & DSF_STRICT)) {
-		DISPATCH_CLIENT_CRASH(kind, "Cannot change a handler of this source "
-				"after it has been activated");
-	}
-	// Ignore handlers mutations past cancelation, it's harmless
-	if ((dqf & DSF_CANCELED) == 0) {
-		_dispatch_ktrace1(DISPATCH_PERF_post_activate_mutation, ds);
-		if (kind == DS_REGISTN_HANDLER) {
-			_dispatch_bug_deprecated("Setting registration handler after "
-					"the source has been activated");
-		} else if (func == NULL) {
-			_dispatch_bug_deprecated("Clearing handler after "
-					"the source has been activated");
-		}
-	}
-	dc->dc_data = (void *)kind;
-	_dispatch_barrier_trysync_or_async_f(ds, dc,
-			_dispatch_source_set_handler_slow, 0);
-}
-
-#ifdef __BLOCKS__
-void
-dispatch_source_set_event_handler(dispatch_source_t ds,
-		dispatch_block_t handler)
-{
-	_dispatch_source_set_handler(ds, handler, DS_EVENT_HANDLER, true);
-}
-#endif /* __BLOCKS__ */
-
-void
-dispatch_source_set_event_handler_f(dispatch_source_t ds,
-		dispatch_function_t handler)
-{
-	_dispatch_source_set_handler(ds, handler, DS_EVENT_HANDLER, false);
-}
-
-#ifdef __BLOCKS__
-void
-dispatch_source_set_cancel_handler(dispatch_source_t ds,
-		dispatch_block_t handler)
-{
-	_dispatch_source_set_handler(ds, handler, DS_CANCEL_HANDLER, true);
-}
-
-void
-dispatch_source_set_mandatory_cancel_handler(dispatch_source_t ds,
-		dispatch_block_t handler)
-{
-	_dispatch_queue_atomic_flags_set_and_clear(ds, DSF_STRICT, DQF_MUTABLE);
-	dispatch_source_set_cancel_handler(ds, handler);
-}
-#endif /* __BLOCKS__ */
-
-void
-dispatch_source_set_cancel_handler_f(dispatch_source_t ds,
-		dispatch_function_t handler)
-{
-	_dispatch_source_set_handler(ds, handler, DS_CANCEL_HANDLER, false);
-}
-
-void
-dispatch_source_set_mandatory_cancel_handler_f(dispatch_source_t ds,
-		dispatch_function_t handler)
-{
-	_dispatch_queue_atomic_flags_set_and_clear(ds, DSF_STRICT, DQF_MUTABLE);
-	dispatch_source_set_cancel_handler_f(ds, handler);
-}
-
-#ifdef __BLOCKS__
-void
-dispatch_source_set_registration_handler(dispatch_source_t ds,
-		dispatch_block_t handler)
-{
-	_dispatch_source_set_handler(ds, handler, DS_REGISTN_HANDLER, true);
-}
-#endif /* __BLOCKS__ */
-
-void
-dispatch_source_set_registration_handler_f(dispatch_source_t ds,
-	dispatch_function_t handler)
-{
-	_dispatch_source_set_handler(ds, handler, DS_REGISTN_HANDLER, false);
-}
-
-#pragma mark -
-#pragma mark dispatch_source_invoke
-
-#if TARGET_OS_MAC
-bool
-_dispatch_source_will_reenable_kevent_4NW(dispatch_source_t ds)
-{
-	uint64_t dq_state = os_atomic_load2o(ds, dq_state, relaxed);
-
-	if (unlikely(!_dq_state_drain_locked_by_self(dq_state))) {
-		DISPATCH_CLIENT_CRASH(0, "_dispatch_source_will_reenable_kevent_4NW "
-				"not called from within the event handler");
-	}
-	return _dispatch_unote_needs_rearm(ds->ds_refs);
-}
-#endif // TARGET_OS_MAC
-
-static void
-_dispatch_source_registration_callout(dispatch_source_t ds, dispatch_queue_t cq,
-		dispatch_invoke_flags_t flags)
-{
-	dispatch_continuation_t dc;
-
-	dc = _dispatch_source_handler_take(ds->ds_refs, DS_REGISTN_HANDLER);
-	if (ds->dq_atomic_flags & (DSF_CANCELED | DQF_RELEASED)) {
-		// no registration callout if source is canceled rdar://problem/8955246
-		return _dispatch_source_handler_dispose(dc);
-	}
-	if (dc->dc_flags & DC_FLAG_FETCH_CONTEXT) {
-		dc->dc_ctxt = ds->do_ctxt;
-	}
-
-	_dispatch_trace_source_callout_entry(ds, DS_REGISTN_HANDLER, cq, dc);
-	_dispatch_continuation_pop(dc, NULL, flags, cq);
-}
-
-static void
-_dispatch_source_cancel_callout(dispatch_source_t ds, dispatch_queue_t cq,
-		dispatch_invoke_flags_t flags)
-{
-	dispatch_source_refs_t dr = ds->ds_refs;
-	dispatch_continuation_t dc;
-
-	dc = _dispatch_source_handler_take(dr, DS_CANCEL_HANDLER);
-	dr->ds_pending_data = 0;
-	dr->ds_data = 0;
-	_dispatch_source_handler_free(dr, DS_EVENT_HANDLER);
-	_dispatch_source_handler_free(dr, DS_REGISTN_HANDLER);
-	if (!dc) {
-		return;
-	}
-	if (!(ds->dq_atomic_flags & DSF_CANCELED)) {
-		return _dispatch_source_handler_dispose(dc);
-	}
-	if (dc->dc_flags & DC_FLAG_FETCH_CONTEXT) {
-		dc->dc_ctxt = ds->do_ctxt;
-	}
-	_dispatch_trace_source_callout_entry(ds, DS_CANCEL_HANDLER, cq, dc);
-	_dispatch_continuation_pop(dc, NULL, flags, cq);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dispatch_source_refs_needs_configuration(dispatch_unote_t du)
-{
-	return du._du->du_is_timer &&
-			os_atomic_load2o(du._dt, dt_pending_config, relaxed);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dispatch_source_refs_needs_rearm(dispatch_unote_t du)
-{
-	if (!du._du->du_is_timer) {
-		return _dispatch_unote_needs_rearm(du);
-	}
-	if (os_atomic_load2o(du._dt, dt_pending_config, relaxed)) {
-		return true;
-	}
-	if (_dispatch_unote_needs_rearm(du)) {
-		return du._dt->dt_timer.target < INT64_MAX;
-	}
-	return false;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline unsigned long
-_dispatch_source_timer_data(dispatch_timer_source_refs_t dr, uint64_t prev)
-{
-	unsigned long data = (unsigned long)prev >> 1;
-
-	// The timer may be in _dispatch_source_invoke2() already for other
-	// reasons such as running the registration handler when ds_pending_data
-	// is changed by _dispatch_timers_run2() without holding the drain lock.
-	//
-	// We hence need dependency ordering to pair with the release barrier
-	// done by _dispatch_timers_run2() when setting the DISARMED_MARKER bit.
-	os_atomic_thread_fence(dependency);
-	dr = os_atomic_force_dependency_on(dr, data);
-
-	if (dr->dt_timer.target < INT64_MAX) {
-		uint64_t now = _dispatch_time_now(DISPATCH_TIMER_CLOCK(dr->du_ident));
-		if (now >= dr->dt_timer.target) {
-			data = _dispatch_timer_unote_compute_missed(dr, now, data);
-		}
-	}
-
-	return data;
-}
-
-static void
-_dispatch_source_latch_and_call(dispatch_source_t ds, dispatch_queue_t cq,
-		dispatch_invoke_flags_t flags)
-{
-	dispatch_source_refs_t dr = ds->ds_refs;
-	dispatch_continuation_t dc = _dispatch_source_get_handler(dr, DS_EVENT_HANDLER);
-	uint64_t prev = os_atomic_xchg2o(dr, ds_pending_data, 0, relaxed);
-
-	if (dr->du_is_timer && (dr->du_timer_flags & DISPATCH_TIMER_AFTER)) {
-		_dispatch_trace_item_pop(cq, dc); // see _dispatch_after
-	}
-	switch (dux_type(dr)->dst_action) {
-	case DISPATCH_UNOTE_ACTION_SOURCE_TIMER:
-		if (prev & DISPATCH_TIMER_DISARMED_MARKER) {
-			dr->ds_data = _dispatch_source_timer_data(ds->ds_timer_refs, prev);
-		} else {
-			dr->ds_data = prev >> 1;
-		}
-		break;
-	case DISPATCH_UNOTE_ACTION_SOURCE_SET_DATA:
-		dr->ds_data = ~prev;
-		break;
-	default:
-		if (prev == 0 && dr->du_filter == DISPATCH_EVFILT_CUSTOM_REPLACE) {
-			return;
-		}
-		dr->ds_data = prev;
-		break;
-	}
-	if (unlikely(!dc)) {
-		return _dispatch_ktrace1(DISPATCH_PERF_handlerless_source_fire, ds);
-	}
-	if (!dispatch_assume(prev != 0)) {
-		return;
-	}
-	_dispatch_trace_source_callout_entry(ds, DS_EVENT_HANDLER, cq, dc);
-#ifdef DBG_BSD_MEMSTAT
-	if (unlikely(dr->du_filter == EVFILT_MEMORYSTATUS)) {
-		_dispatch_ktrace2(KDBG_CODE(DBG_BSD, DBG_BSD_MEMSTAT, 0x100) | DBG_FUNC_START,
-				prev, _dispatch_continuation_get_function_symbol(dc));
-	}
-#endif
-	_dispatch_continuation_pop(dc, NULL, flags, cq);
-#ifdef DBG_BSD_MEMSTAT
-	if (unlikely(dr->du_filter == EVFILT_MEMORYSTATUS)) {
-		_dispatch_ktrace0(KDBG_CODE(DBG_BSD, DBG_BSD_MEMSTAT, 0x100) | DBG_FUNC_END);
-	}
-#endif
-	if (dr->du_is_timer) {
-		if ((prev & DISPATCH_TIMER_DISARMED_MARKER) &&
-				_dispatch_source_refs_needs_configuration(dr)) {
-			_dispatch_timer_unote_configure(ds->ds_timer_refs);
-		}
-		if (dr->du_timer_flags & DISPATCH_TIMER_AFTER) {
-			_dispatch_trace_item_complete(dc); // see _dispatch_after
-			_dispatch_source_handler_free(dr, DS_EVENT_HANDLER);
-			dispatch_release(ds); // dispatch_after sources are one-shot
-		}
-	}
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_source_refs_finalize_unregistration(dispatch_source_t ds)
-{
-	dispatch_queue_flags_t dqf;
-	dqf = _dispatch_queue_atomic_flags_set_and_clear_orig(ds,
-			DSF_DELETED, DSF_NEEDS_EVENT | DSF_CANCEL_WAITER);
-	if (dqf & DSF_DELETED) {
-		DISPATCH_INTERNAL_CRASH(dqf, "Source finalized twice");
-	}
-	if (dqf & DSF_CANCEL_WAITER) {
-		_dispatch_wake_by_address(&ds->dq_atomic_flags);
-	}
-	_dispatch_object_debug(ds, "%s", __func__);
-	return _dispatch_release_tailcall(ds); // see _dispatch_queue_alloc()
-}
-
-static void
-_dispatch_source_refs_unregister(dispatch_source_t ds, uint32_t options)
-{
-	_dispatch_object_debug(ds, "%s", __func__);
-	dispatch_source_refs_t dr = ds->ds_refs;
-
-	if (_dispatch_unote_unregister(dr, options)) {
-		return _dispatch_source_refs_finalize_unregistration(ds);
-	}
-
-	// deferred unregistration
-	dispatch_queue_flags_t oqf, nqf;
-	os_atomic_rmw_loop2o(ds, dq_atomic_flags, oqf, nqf, relaxed, {
-		if (oqf & (DSF_NEEDS_EVENT | DSF_DELETED)) {
-			os_atomic_rmw_loop_give_up(break);
-		}
-		nqf = oqf | DSF_NEEDS_EVENT;
-	});
-}
-
-static void
-_dispatch_source_install(dispatch_source_t ds, dispatch_wlh_t wlh,
-		dispatch_priority_t pri)
-{
-	dispatch_source_refs_t dr = ds->ds_refs;
-
-	dispatch_assert(!ds->ds_is_installed);
-	ds->ds_is_installed = true;
-
-	_dispatch_object_debug(ds, "%s", __func__);
-	if (unlikely(!_dispatch_unote_register(dr, wlh, pri))) {
-		return _dispatch_source_refs_finalize_unregistration(ds);
-	}
-}
-
-void
-_dispatch_source_activate(dispatch_source_t ds, bool *allow_resume)
-{
-	dispatch_continuation_t dc;
-	dispatch_source_refs_t dr = ds->ds_refs;
-	dispatch_priority_t pri;
-	dispatch_wlh_t wlh;
-
-	if (unlikely(_dispatch_queue_atomic_flags(ds) & DSF_CANCELED)) {
-		ds->ds_is_installed = true;
-		return _dispatch_source_refs_finalize_unregistration(ds);
-	}
-
-	dc = _dispatch_source_get_event_handler(dr);
-	if (dc) {
-		if (_dispatch_object_is_barrier(dc)) {
-			_dispatch_queue_atomic_flags_set(ds, DQF_BARRIER_BIT);
-		}
-		if ((dc->dc_priority & _PTHREAD_PRIORITY_ENFORCE_FLAG) ||
-				!_dispatch_queue_priority_manually_selected(ds->dq_priority)) {
-			ds->dq_priority = _dispatch_priority_from_pp_strip_flags(dc->dc_priority);
-		}
-		if (dc->dc_flags & DC_FLAG_FETCH_CONTEXT) {
-			dc->dc_ctxt = ds->do_ctxt;
-		}
-	} else {
-		_dispatch_bug_deprecated("dispatch source activated "
-				"with no event handler set");
-	}
-
-	// call "super"
-	_dispatch_lane_activate(ds, allow_resume);
-
-	if ((dr->du_is_direct || dr->du_is_timer) && !ds->ds_is_installed) {
-		pri = _dispatch_queue_compute_priority_and_wlh(ds, &wlh);
-		if (pri) {
-#if DISPATCH_USE_KEVENT_WORKLOOP
-			dispatch_workloop_t dwl = _dispatch_wlh_to_workloop(wlh);
-			if (dwl && dr->du_filter == DISPATCH_EVFILT_TIMER_WITH_CLOCK &&
-					dr->du_ident < DISPATCH_TIMER_WLH_COUNT) {
-				if (!dwl->dwl_timer_heap) {
-					uint32_t count = DISPATCH_TIMER_WLH_COUNT;
-					dwl->dwl_timer_heap = _dispatch_calloc(count,
-							sizeof(struct dispatch_timer_heap_s));
-				}
-				dr->du_is_direct = true;
-				_dispatch_wlh_retain(wlh);
-				_dispatch_unote_state_set(dr, wlh, 0);
-			}
-#endif
-			_dispatch_source_install(ds, wlh, pri);
-		}
-	}
-}
-
-DISPATCH_NOINLINE
-static void
-_dispatch_source_handle_wlh_change(dispatch_source_t ds)
-{
-	dispatch_queue_flags_t dqf;
-
-	dqf = _dispatch_queue_atomic_flags_set_orig(ds, DSF_WLH_CHANGED);
-	if (!(dqf & DQF_MUTABLE)) {
-		DISPATCH_CLIENT_CRASH(0, "Changing target queue "
-				"hierarchy after source was activated");
-	}
-	if (!(dqf & DSF_WLH_CHANGED)) {
-		_dispatch_bug_deprecated("Changing target queue "
-				"hierarchy after source was activated");
-	}
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_queue_wakeup_target_t
-_dispatch_source_invoke2(dispatch_source_t ds, dispatch_invoke_context_t dic,
-		dispatch_invoke_flags_t flags, uint64_t *owned)
-{
-	dispatch_queue_wakeup_target_t retq = DISPATCH_QUEUE_WAKEUP_NONE;
-	dispatch_queue_t dq = _dispatch_queue_get_current();
-	dispatch_source_refs_t dr = ds->ds_refs;
-	dispatch_queue_flags_t dqf;
-
-	if (unlikely(!(flags & DISPATCH_INVOKE_MANAGER_DRAIN) &&
-			_dispatch_unote_wlh_changed(dr, _dispatch_get_event_wlh()))) {
-		_dispatch_source_handle_wlh_change(ds);
-	}
-
-	if (_dispatch_queue_class_probe(ds)) {
-		// Intentionally always drain even when on the manager queue
-		// and not the source's regular target queue: we need to be able
-		// to drain timer setting and the like there.
-		dispatch_with_disabled_narrowing(dic, {
-			retq = _dispatch_lane_serial_drain(ds, dic, flags, owned);
-		});
-	}
-
-	// This function performs all source actions. Each action is responsible
-	// for verifying that it takes place on the appropriate queue. If the
-	// current queue is not the correct queue for this action, the correct queue
-	// will be returned and the invoke will be re-driven on that queue.
-
-	// The order of tests here in invoke and in wakeup should be consistent.
-
-	dispatch_queue_t dkq = _dispatch_mgr_q._as_dq;
-	bool avoid_starvation = false;
-
-	if (dr->du_is_direct) {
-		dkq = ds->do_targetq;
-	}
-
-	if (!ds->ds_is_installed) {
-		// The source needs to be installed on the kevent queue.
-		if (dq != dkq) {
-			return dkq;
-		}
-		dispatch_priority_t pri = DISPATCH_PRIORITY_FLAG_MANAGER;
-		if (likely(flags & DISPATCH_INVOKE_WORKER_DRAIN)) {
-			pri = _dispatch_get_basepri();
-		}
-		_dispatch_source_install(ds, _dispatch_get_event_wlh(), pri);
-	}
-
-	if (unlikely(DISPATCH_QUEUE_IS_SUSPENDED(ds))) {
-		// Source suspended by an item drained from the source queue.
-		return ds->do_targetq;
-	}
-
-	if (_dispatch_source_refs_needs_configuration(dr)) {
-		dqf = _dispatch_queue_atomic_flags(ds);
-		if (!(dqf & (DSF_CANCELED | DQF_RELEASED))) {
-			if (dq != dkq) {
-				return dkq;
-			}
-			_dispatch_timer_unote_configure(ds->ds_timer_refs);
-		}
-	}
-
-	if (_dispatch_source_get_registration_handler(dr)) {
-		// The source has been registered and the registration handler needs
-		// to be delivered on the target queue.
-		if (dq != ds->do_targetq) {
-			return ds->do_targetq;
-		}
-		// clears ds_registration_handler
-		_dispatch_source_registration_callout(ds, dq, flags);
-	}
-
-	if (_dispatch_unote_needs_delete(dr)) {
-		_dispatch_source_refs_unregister(ds, DUU_DELETE_ACK | DUU_MUST_SUCCEED);
-	}
-
-	dqf = _dispatch_queue_atomic_flags(ds);
-	if (!(dqf & (DSF_CANCELED | DQF_RELEASED)) &&
-			os_atomic_load2o(dr, ds_pending_data, relaxed)) {
-		// The source has pending data to deliver via the event handler callback
-		// on the target queue. Some sources need to be rearmed on the kevent
-		// queue after event delivery.
-		if (dq == ds->do_targetq) {
-			_dispatch_source_latch_and_call(ds, dq, flags);
-			dqf = _dispatch_queue_atomic_flags(ds);
-
-			// starvation avoidance: if the source triggers itself then force a
-			// re-queue to give other things already queued on the target queue
-			// a chance to run.
-			//
-			// however, if the source is directly targeting an overcommit root
-			// queue, this would requeue the source and ask for a new overcommit
-			// thread right away.
-			if (!(dqf & (DSF_CANCELED | DSF_DELETED))) {
-				avoid_starvation = dq->do_targetq ||
-						!(dq->dq_priority & DISPATCH_PRIORITY_FLAG_OVERCOMMIT);
-			}
-			if (avoid_starvation &&
-					os_atomic_load2o(dr, ds_pending_data, relaxed)) {
-				retq = ds->do_targetq;
-			}
-		} else {
-			// there is no point trying to be eager, the next thing to do is
-			// to deliver the event
-			return ds->do_targetq;
-		}
-	}
-
-	if ((dqf & (DSF_CANCELED | DQF_RELEASED)) && !(dqf & DSF_DELETED)) {
-		// The source has been cancelled and needs to be uninstalled from the
-		// kevent queue. After uninstallation, the cancellation handler needs
-		// to be delivered to the target queue.
-		if (dr->du_is_timer && !_dispatch_unote_armed(dr)) {
-			// timers can cheat if not armed because there's nothing left
-			// to do on the manager queue and unregistration can happen
-			// on the regular target queue
-		} else if (dq != dkq) {
-			return dkq;
-		}
-		uint32_t duu_options = DUU_DELETE_ACK;
-		if (!(dqf & DSF_NEEDS_EVENT)) duu_options |= DUU_PROBE;
-		_dispatch_source_refs_unregister(ds, duu_options);
-		dqf = _dispatch_queue_atomic_flags(ds);
-		if (unlikely(!(dqf & DSF_DELETED))) {
-			// we need to wait for the EV_DELETE
-			return retq ? retq : DISPATCH_QUEUE_WAKEUP_WAIT_FOR_EVENT;
-		}
-	}
-
-	if ((dqf & (DSF_CANCELED | DQF_RELEASED)) && (dqf & DSF_DELETED)) {
-		if (dq != ds->do_targetq && (_dispatch_source_get_event_handler(dr) ||
-				_dispatch_source_get_cancel_handler(dr) ||
-				_dispatch_source_get_registration_handler(dr))) {
-			retq = ds->do_targetq;
-		} else {
-			_dispatch_source_cancel_callout(ds, dq, flags);
-			dqf = _dispatch_queue_atomic_flags(ds);
-		}
-		avoid_starvation = false;
-	}
-
-	if (!(dqf & (DSF_CANCELED | DQF_RELEASED)) &&
-			_dispatch_source_refs_needs_rearm(dr)) {
-		// The source needs to be rearmed on the kevent queue.
-		if (dq != dkq) {
-			return dkq;
-		}
-		if (unlikely(DISPATCH_QUEUE_IS_SUSPENDED(ds))) {
-			// do not try to rearm the kevent if the source is suspended
-			// from the source handler
-			return ds->do_targetq;
-		}
-		if (avoid_starvation && _dispatch_unote_wlh(dr) == DISPATCH_WLH_ANON) {
-			// keep the old behavior to force re-enqueue to our target queue
-			// for the rearm.
-			//
-			// if the handler didn't run, or this is a pending delete
-			// or our target queue is a global queue, then starvation is
-			// not a concern and we can rearm right away.
-			return ds->do_targetq;
-		}
-		_dispatch_unote_resume(dr);
-		if (!avoid_starvation && _dispatch_wlh_should_poll_unote(dr)) {
-			// try to redrive the drain from under the lock for sources
-			// targeting an overcommit root queue to avoid parking
-			// when the next event has already fired
-			_dispatch_event_loop_drain(KEVENT_FLAG_IMMEDIATE);
-		}
-	}
-
-	return retq;
-}
-
-DISPATCH_NOINLINE
-void
-_dispatch_source_invoke(dispatch_source_t ds, dispatch_invoke_context_t dic,
-		dispatch_invoke_flags_t flags)
-{
-	_dispatch_queue_class_invoke(ds, dic, flags,
-			DISPATCH_INVOKE_DISALLOW_SYNC_WAITERS, _dispatch_source_invoke2);
-
-#if DISPATCH_EVENT_BACKEND_KEVENT
-	if (flags & DISPATCH_INVOKE_WORKLOOP_DRAIN) {
-		dispatch_workloop_t dwl = (dispatch_workloop_t)_dispatch_get_wlh();
-		dispatch_timer_heap_t dth = dwl->dwl_timer_heap;
-		if (dth && dth[0].dth_dirty_bits) {
-			_dispatch_event_loop_drain_timers(dwl->dwl_timer_heap,
-					DISPATCH_TIMER_WLH_COUNT);
-		}
-	}
-#endif // DISPATCH_EVENT_BACKEND_KEVENT
-}
-
-void
-_dispatch_source_wakeup(dispatch_source_t ds, dispatch_qos_t qos,
-		dispatch_wakeup_flags_t flags)
-{
-	// This function determines whether the source needs to be invoked.
-	// The order of tests here in wakeup and in invoke should be consistent.
-
-	dispatch_source_refs_t dr = ds->ds_refs;
-	dispatch_queue_wakeup_target_t dkq = DISPATCH_QUEUE_WAKEUP_MGR;
-	dispatch_queue_wakeup_target_t tq = DISPATCH_QUEUE_WAKEUP_NONE;
-	dispatch_queue_flags_t dqf = _dispatch_queue_atomic_flags(ds);
-	dispatch_unote_state_t du_state = _dispatch_unote_state(dr);
-
-	if (dr->du_is_direct) {
-		dkq = DISPATCH_QUEUE_WAKEUP_TARGET;
-	}
-
-	if (!ds->ds_is_installed) {
-		// The source needs to be installed on the kevent queue.
-		tq = dkq;
-	} else if (!(dqf & (DSF_CANCELED | DQF_RELEASED)) &&
-			_dispatch_source_refs_needs_configuration(dr)) {
-		// timer has to be configured on the kevent queue
-		tq = dkq;
-	} else if (_dispatch_source_get_registration_handler(dr)) {
-		// The registration handler needs to be delivered to the target queue.
-		tq = DISPATCH_QUEUE_WAKEUP_TARGET;
-	} else if (_du_state_needs_delete(du_state)) {
-		// Deferred deletion can be acknowledged which can always be done
-		// from the target queue
-		tq = DISPATCH_QUEUE_WAKEUP_TARGET;
-	} else if (!(dqf & (DSF_CANCELED | DQF_RELEASED)) &&
-			os_atomic_load2o(dr, ds_pending_data, relaxed)) {
-		// The source has pending data to deliver to the target queue.
-		tq = DISPATCH_QUEUE_WAKEUP_TARGET;
-	} else if ((dqf & (DSF_CANCELED | DQF_RELEASED)) && !(dqf & DSF_DELETED)) {
-		// The source needs to be uninstalled from the kevent queue, or the
-		// cancellation handler needs to be delivered to the target queue.
-		// Note: cancellation assumes installation.
-		if (dr->du_is_timer && !_dispatch_unote_armed(dr)) {
-			// timers can cheat if not armed because there's nothing left
-			// to do on the manager queue and unregistration can happen
-			// on the regular target queue
-			tq = DISPATCH_QUEUE_WAKEUP_TARGET;
-		} else if ((dqf & DSF_NEEDS_EVENT) && !(flags & DISPATCH_WAKEUP_EVENT)){
-			// we're waiting for an event
-		} else {
-			// we need to initialize the deletion sequence
-			tq = dkq;
-		}
-	} else if ((dqf & (DSF_CANCELED | DQF_RELEASED)) && (dqf & DSF_DELETED) &&
-			(_dispatch_source_get_event_handler(dr) ||
-			_dispatch_source_get_cancel_handler(dr) ||
-			_dispatch_source_get_registration_handler(dr))) {
-		tq = DISPATCH_QUEUE_WAKEUP_TARGET;
-	} else if (!(dqf & (DSF_CANCELED | DQF_RELEASED)) &&
-			_dispatch_source_refs_needs_rearm(dr)) {
-		// The source needs to be rearmed on the kevent queue.
-		tq = dkq;
-	}
-	if (!tq && _dispatch_queue_class_probe(ds)) {
-		tq = DISPATCH_QUEUE_WAKEUP_TARGET;
-	}
-
-	if ((tq == DISPATCH_QUEUE_WAKEUP_TARGET) &&
-			ds->do_targetq == _dispatch_mgr_q._as_dq) {
-		tq = DISPATCH_QUEUE_WAKEUP_MGR;
-	}
-
-	return _dispatch_queue_wakeup(ds, qos, flags, tq);
-}
-
-void
-dispatch_source_cancel(dispatch_source_t ds)
-{
-	_dispatch_object_debug(ds, "%s", __func__);
-	// Right after we set the cancel flag, someone else
-	// could potentially invoke the source, do the cancellation,
-	// unregister the source, and deallocate it. We would
-	// need to therefore retain/release before setting the bit
-	_dispatch_retain_2(ds);
-
-	if (_dispatch_queue_atomic_flags_set_orig(ds, DSF_CANCELED) & DSF_CANCELED){
-		_dispatch_release_2_tailcall(ds);
-	} else {
-		dx_wakeup(ds, 0, DISPATCH_WAKEUP_MAKE_DIRTY | DISPATCH_WAKEUP_CONSUME_2);
-	}
-}
-
-void
-dispatch_source_cancel_and_wait(dispatch_source_t ds)
-{
-	dispatch_queue_flags_t old_dqf, new_dqf;
-	dispatch_source_refs_t dr = ds->ds_refs;
-
-	if (unlikely(_dispatch_source_get_cancel_handler(dr))) {
-		DISPATCH_CLIENT_CRASH(ds, "Source has a cancel handler");
-	}
-
-	_dispatch_object_debug(ds, "%s", __func__);
-	os_atomic_rmw_loop2o(ds, dq_atomic_flags, old_dqf, new_dqf, relaxed, {
-		new_dqf = old_dqf | DSF_CANCELED;
-		if (old_dqf & DSF_CANCEL_WAITER) {
-			os_atomic_rmw_loop_give_up(break);
-		}
-		if (old_dqf & DSF_DELETED) {
-			// just add DSF_CANCELED
-		} else if ((old_dqf & DSF_NEEDS_EVENT) || dr->du_is_timer ||
-				!dr->du_is_direct) {
-			new_dqf |= DSF_CANCEL_WAITER;
-		}
-	});
-
-	if (old_dqf & DQF_RELEASED) {
-		DISPATCH_CLIENT_CRASH(ds, "Dispatch source used after last release");
-	}
-	if (old_dqf & DSF_DELETED) {
-		return;
-	}
-	if (new_dqf & DSF_CANCEL_WAITER) {
-		goto wakeup;
-	}
-
-	// simplified version of _dispatch_queue_drain_try_lock
-	// that also sets the DIRTY bit on failure to lock
-	uint64_t set_owner_and_set_full_width = _dispatch_lock_value_for_self() |
-			DISPATCH_QUEUE_WIDTH_FULL_BIT | DISPATCH_QUEUE_IN_BARRIER;
-	uint64_t old_state, new_state;
-
-	os_atomic_rmw_loop2o(ds, dq_state, old_state, new_state, seq_cst, {
-		new_state = old_state;
-		if (likely(_dq_state_is_runnable(old_state) &&
-				!_dq_state_drain_locked(old_state))) {
-			new_state &= DISPATCH_QUEUE_DRAIN_PRESERVED_BITS_MASK;
-			new_state |= set_owner_and_set_full_width;
-		} else if (old_dqf & DSF_CANCELED) {
-			os_atomic_rmw_loop_give_up(break);
-		} else {
-			// this case needs a release barrier, hence the seq_cst above
-			new_state |= DISPATCH_QUEUE_DIRTY;
-		}
-	});
-
-	if (unlikely(_dq_state_is_suspended(old_state))) {
-		if (unlikely(_dq_state_suspend_cnt(old_state))) {
-			DISPATCH_CLIENT_CRASH(ds, "Source is suspended");
-		}
-		// inactive sources have never been registered and there is no need
-		// to wait here because activation will notice and mark the source
-		// as deleted without ever trying to use the fd or mach port.
-		return dispatch_activate(ds);
-	}
-
-	if (likely(_dq_state_is_runnable(old_state) &&
-			!_dq_state_drain_locked(old_state))) {
-		// deletion may have proceeded concurrently while we were
-		// taking the lock, so we need to check we're not doing it twice.
-		if (likely(!(_dispatch_queue_atomic_flags(ds) & DSF_DELETED))) {
-			// same thing _dispatch_source_invoke2() does for cancellation
-			_dispatch_source_refs_unregister(ds, DUU_DELETE_ACK | DUU_PROBE);
-		}
-		if (likely(_dispatch_queue_atomic_flags(ds) & DSF_DELETED)) {
-			_dispatch_source_cancel_callout(ds, NULL, DISPATCH_INVOKE_NONE);
-		}
-		dx_wakeup(ds, 0, DISPATCH_WAKEUP_EVENT |
-				DISPATCH_WAKEUP_BARRIER_COMPLETE);
-	} else if (unlikely(_dq_state_drain_locked_by_self(old_state))) {
-		DISPATCH_CLIENT_CRASH(ds, "dispatch_source_cancel_and_wait "
-				"called from a source handler");
-	} else {
-		dispatch_qos_t qos;
-wakeup:
-		qos = _dispatch_qos_from_pp(_dispatch_get_priority());
-		dx_wakeup(ds, qos, DISPATCH_WAKEUP_MAKE_DIRTY);
-		dispatch_activate(ds);
-	}
-
-	dispatch_queue_flags_t dqf = _dispatch_queue_atomic_flags(ds);
-	while (unlikely(!(dqf & DSF_DELETED))) {
-		if (unlikely(!(dqf & DSF_CANCEL_WAITER))) {
-			if (!os_atomic_cmpxchgv2o(ds, dq_atomic_flags,
-					dqf, dqf | DSF_CANCEL_WAITER, &dqf, relaxed)) {
-				continue;
-			}
-			dqf |= DSF_CANCEL_WAITER;
-		}
-		_dispatch_wait_on_address(&ds->dq_atomic_flags, dqf,
-				DISPATCH_TIME_FOREVER, DLOCK_LOCK_NONE);
-		dqf = _dispatch_queue_atomic_flags(ds);
-	}
-}
-
-void
-_dispatch_source_merge_evt(dispatch_unote_t du, uint32_t flags,
-		OS_UNUSED uintptr_t data, pthread_priority_t pp)
-{
-	dispatch_source_t ds = _dispatch_source_from_refs(du._dr);
-
-	dispatch_unote_state_t du_state = _dispatch_unote_state(du);
-	if (!(flags & EV_UDATA_SPECIFIC) && !_du_state_registered(du_state)) {
-		if (!du._du->du_is_timer) {
-			// Timers must be unregistered from their target queue, else this
-			// unregistration can race with the optimization in
-			// _dispatch_source_invoke() to unregister fired oneshot timers.
-			//
-			// Because oneshot timers dominate the world, we prefer paying an
-			// extra wakeup for repeating timers, and avoid the wakeup for
-			// oneshot timers.
-			_dispatch_source_refs_finalize_unregistration(ds);
-		}
-	}
-
-	dispatch_queue_flags_t dqf = _dispatch_queue_atomic_flags(ds);
-	if (unlikely(flags & EV_VANISHED)) {
-		if (dqf & DSF_STRICT) {
-			DISPATCH_CLIENT_CRASH(du._du->du_ident, "Unexpected EV_VANISHED "
-					"(do not destroy random mach ports or file descriptors)");
-		} else {
-			_dispatch_bug_kevent_vanished(du._du);
-		}
-		// if the resource behind the ident vanished, the event handler can't
-		// do anything useful anymore, so do not try to call it at all
-		os_atomic_store2o(du._dr, ds_pending_data, 0, relaxed);
-	}
-
-	_dispatch_debug("kevent-source[%p]: merged kevent[%p]", ds, du._dr);
-	_dispatch_object_debug(ds, "%s", __func__);
-	dx_wakeup(ds, _dispatch_qos_from_pp(pp), DISPATCH_WAKEUP_EVENT |
-			DISPATCH_WAKEUP_CONSUME_2 | DISPATCH_WAKEUP_MAKE_DIRTY);
-}
-
-#pragma mark -
-#pragma mark dispatch_source_timer
-
-#define _dispatch_source_timer_telemetry_enabled() false
-
-DISPATCH_NOINLINE
-static void
-_dispatch_source_timer_telemetry_slow(dispatch_source_t ds,
-		dispatch_clock_t clock, struct dispatch_timer_source_s *values)
-{
-	if (_dispatch_trace_timer_configure_enabled()) {
-		_dispatch_trace_timer_configure(ds, clock, values);
-	}
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_source_timer_telemetry(dispatch_source_t ds, dispatch_clock_t clock,
-		struct dispatch_timer_source_s *values)
-{
-	if (_dispatch_trace_timer_configure_enabled() ||
-			_dispatch_source_timer_telemetry_enabled()) {
-		_dispatch_source_timer_telemetry_slow(ds, clock, values);
-		__asm__ __volatile__ (""); // prevent tailcall
-	}
-}
-
-static dispatch_timer_config_t
-_dispatch_timer_config_create(dispatch_time_t start,
-		uint64_t interval, uint64_t leeway, dispatch_timer_source_refs_t dt)
-{
-	dispatch_timer_config_t dtc;
-	dtc = _dispatch_calloc(1ul, sizeof(struct dispatch_timer_config_s));
-	if (unlikely(interval == 0)) {
-		if (start != DISPATCH_TIME_FOREVER) {
-			_dispatch_bug_deprecated("Setting timer interval to 0 requests "
-					"a 1ns timer, did you mean FOREVER (a one-shot timer)?");
-		}
-		interval = 1;
-	} else if ((int64_t)interval < 0) {
-		// 6866347 - make sure nanoseconds won't overflow
-		interval = INT64_MAX;
-	}
-	if ((int64_t)leeway < 0) {
-		leeway = INT64_MAX;
-	}
-
-	dispatch_clock_t clock;
-	uint64_t target;
-	if (start == DISPATCH_TIME_FOREVER) {
-		target = INT64_MAX;
-		// Do not change the clock when postponing the time forever in the
-		// future, this will default to UPTIME if no clock was set.
-		clock = _dispatch_timer_flags_to_clock(dt->du_timer_flags);
-	} else {
-		_dispatch_time_to_clock_and_value(start, &clock, &target);
-		if (target == DISPATCH_TIME_NOW) {
-			if (clock == DISPATCH_CLOCK_UPTIME) {
-				target = _dispatch_uptime();
-			} else {
-				dispatch_assert(clock == DISPATCH_CLOCK_MONOTONIC);
-				target = _dispatch_monotonic_time();
-			}
-		}
-	}
-
-	if (clock != DISPATCH_CLOCK_WALL) {
-		// uptime or monotonic clock
-		interval = _dispatch_time_nano2mach(interval);
-		if (interval < 1) {
-			// rdar://problem/7287561 interval must be at least one in
-			// in order to avoid later division by zero when calculating
-			// the missed interval count. (NOTE: the wall clock's
-			// interval is already "fixed" to be 1 or more)
-			interval = 1;
-		}
-		leeway = _dispatch_time_nano2mach(leeway);
-	}
-	if (interval < INT64_MAX && leeway > interval / 2) {
-		leeway = interval / 2;
-	}
-
-	dtc->dtc_clock = clock;
-	dtc->dtc_timer.target = target;
-	dtc->dtc_timer.interval = interval;
-	if (target + leeway < INT64_MAX) {
-		dtc->dtc_timer.deadline = target + leeway;
-	} else {
-		dtc->dtc_timer.deadline = INT64_MAX;
-	}
-	return dtc;
-}
-
-static dispatch_timer_config_t
-_dispatch_interval_config_create(dispatch_time_t start,
-		uint64_t interval, uint64_t leeway, dispatch_timer_source_refs_t dt)
-{
-#define NSEC_PER_FRAME (NSEC_PER_SEC/60)
-// approx 1 year (60s * 60m * 24h * 365d)
-#define FOREVER_NSEC 31536000000000000ull
-
-	const bool animation = dt->du_timer_flags & DISPATCH_INTERVAL_UI_ANIMATION;
-	dispatch_timer_config_t dtc;
-	dtc = _dispatch_calloc(1ul, sizeof(struct dispatch_timer_config_s));
-	dtc->dtc_clock = DISPATCH_CLOCK_UPTIME;
-
-	if (start == DISPATCH_TIME_FOREVER) {
-		dtc->dtc_timer.target = INT64_MAX;
-		dtc->dtc_timer.interval = INT64_MAX;
-		dtc->dtc_timer.deadline = INT64_MAX;
-		return dtc;
-	}
-
-	if (start != DISPATCH_TIME_NOW) {
-		DISPATCH_CLIENT_CRASH(0, "Start value is not DISPATCH_TIME_NOW or "
-				"DISPATCH_TIME_FOREVER");
-	} else if (unlikely(interval == 0)) {
-		DISPATCH_CLIENT_CRASH(0, "Setting interval to 0");
-	}
-
-	if (likely(interval <= (animation ? FOREVER_NSEC/NSEC_PER_FRAME :
-			FOREVER_NSEC/NSEC_PER_MSEC))) {
-		interval *= animation ? NSEC_PER_FRAME : NSEC_PER_MSEC;
-	} else {
-		interval = FOREVER_NSEC;
-	}
-
-	interval = _dispatch_time_nano2mach(interval);
-	start = _dispatch_uptime() + interval;
-	start -= (start % interval);
-	if (leeway <= 1000) {
-		leeway = interval * leeway / 1000;
-	} else if (leeway != UINT64_MAX) {
-		DISPATCH_CLIENT_CRASH(0, "Passing an invalid leeway");
-	} else if (animation) {
-		leeway = _dispatch_time_nano2mach(NSEC_PER_FRAME);
-	} else {
-		leeway = interval / 2;
-	}
-	dtc->dtc_clock = DISPATCH_CLOCK_UPTIME;
-	dtc->dtc_timer.target = start;
-	dtc->dtc_timer.deadline = start + leeway;
-	dtc->dtc_timer.interval = interval;
-	return dtc;
-}
-
-DISPATCH_NOINLINE
-void
-dispatch_source_set_timer(dispatch_source_t ds, dispatch_time_t start,
-		uint64_t interval, uint64_t leeway)
-{
-	dispatch_timer_source_refs_t dt = ds->ds_timer_refs;
-	dispatch_timer_config_t dtc;
-
-	if (unlikely(!dt->du_is_timer)) {
-		DISPATCH_CLIENT_CRASH(ds, "Attempt to set timer on a non-timer source");
-	}
-
-	if (dt->du_timer_flags & DISPATCH_TIMER_INTERVAL) {
-		dtc = _dispatch_interval_config_create(start, interval, leeway, dt);
-	} else {
-		dtc = _dispatch_timer_config_create(start, interval, leeway, dt);
-	}
-	if (_dispatch_timer_flags_to_clock(dt->du_timer_flags) != dtc->dtc_clock &&
-			dt->du_filter == DISPATCH_EVFILT_TIMER_WITH_CLOCK) {
-		DISPATCH_CLIENT_CRASH(0, "Attempting to modify timer clock");
-	}
-
-	_dispatch_source_timer_telemetry(ds, dtc->dtc_clock, &dtc->dtc_timer);
-	dtc = os_atomic_xchg2o(dt, dt_pending_config, dtc, release);
-	if (dtc) free(dtc);
-	dx_wakeup(ds, 0, DISPATCH_WAKEUP_MAKE_DIRTY);
-}
-
-#pragma mark -
-#pragma mark dispatch_after
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_after(dispatch_time_t when, dispatch_queue_t dq,
-		void *ctxt, void *handler, bool block)
-{
-	dispatch_timer_source_refs_t dt;
-	dispatch_source_t ds;
-	uint64_t leeway, delta;
-
-	if (when == DISPATCH_TIME_FOREVER) {
-#if DISPATCH_DEBUG
-		DISPATCH_CLIENT_CRASH(0, "dispatch_after called with 'when' == infinity");
-#endif
-		return;
-	}
-
-	delta = _dispatch_timeout(when);
-	if (delta == 0) {
-		if (block) {
-			return dispatch_async(dq, handler);
-		}
-		return dispatch_async_f(dq, ctxt, handler);
-	}
-	leeway = delta / 10; // <rdar://problem/13447496>
-
-	if (leeway < NSEC_PER_MSEC) leeway = NSEC_PER_MSEC;
-	if (leeway > 60 * NSEC_PER_SEC) leeway = 60 * NSEC_PER_SEC;
-
-	// this function can and should be optimized to not use a dispatch source
-	ds = dispatch_source_create(&_dispatch_source_type_after, 0, 0, dq);
-	dt = ds->ds_timer_refs;
-
-	dispatch_continuation_t dc = _dispatch_continuation_alloc();
-	if (block) {
-		_dispatch_continuation_init(dc, dq, handler, 0, 0);
-	} else {
-		_dispatch_continuation_init_f(dc, dq, ctxt, handler, 0, 0);
-	}
-	// reference `ds` so that it doesn't show up as a leak
-	dc->dc_data = ds;
-	_dispatch_trace_item_push(dq, dc);
-	os_atomic_store2o(dt, ds_handler[DS_EVENT_HANDLER], dc, relaxed);
-
-	dispatch_clock_t clock;
-	uint64_t target;
-	_dispatch_time_to_clock_and_value(when, &clock, &target);
-	if (clock != DISPATCH_CLOCK_WALL) {
-		leeway = _dispatch_time_nano2mach(leeway);
-	}
-	dt->du_timer_flags |= _dispatch_timer_flags_from_clock(clock);
-	dt->dt_timer.target = target;
-	dt->dt_timer.interval = UINT64_MAX;
-	dt->dt_timer.deadline = target + leeway;
-	dispatch_activate(ds);
-}
-
-DISPATCH_NOINLINE
-void
-dispatch_after_f(dispatch_time_t when, dispatch_queue_t queue, void *ctxt,
-		dispatch_function_t func)
-{
-	_dispatch_after(when, queue, ctxt, func, false);
-}
-
-#ifdef __BLOCKS__
-void
-dispatch_after(dispatch_time_t when, dispatch_queue_t queue,
-		dispatch_block_t work)
-{
-	_dispatch_after(when, queue, NULL, work, true);
-}
-#endif
-
-#pragma mark -
-#pragma mark dispatch_source_debug
-
-DISPATCH_COLD
-static size_t
-_dispatch_source_debug_attr(dispatch_source_t ds, char* buf, size_t bufsiz)
-{
-	dispatch_queue_t target = ds->do_targetq;
-	dispatch_source_refs_t dr = ds->ds_refs;
-	dispatch_queue_flags_t dqf = _dispatch_queue_atomic_flags(ds);
-	dispatch_unote_state_t du_state = _dispatch_unote_state(dr);
-	return dsnprintf(buf, bufsiz, "target = %s[%p], ident = 0x%x, "
-			"mask = 0x%x, pending_data = 0x%llx, registered = %d, "
-			"armed = %d, %s%s%s",
-			target && target->dq_label ? target->dq_label : "", target,
-			dr->du_ident, dr->du_fflags, (unsigned long long)dr->ds_pending_data,
-			_du_state_registered(du_state), _du_state_armed(du_state),
-			(dqf & DSF_CANCELED) ? "cancelled, " : "",
-			(dqf & DSF_NEEDS_EVENT) ? "needs-event, " : "",
-			(dqf & DSF_DELETED) ? "deleted, " : "");
-}
-
-DISPATCH_COLD
-static size_t
-_dispatch_timer_debug_attr(dispatch_source_t ds, char* buf, size_t bufsiz)
-{
-	dispatch_timer_source_refs_t dr = ds->ds_timer_refs;
-	return dsnprintf(buf, bufsiz, "timer = { target = 0x%llx, deadline = 0x%llx"
-			", interval = 0x%llx, flags = 0x%x }, ",
-			(unsigned long long)dr->dt_timer.target,
-			(unsigned long long)dr->dt_timer.deadline,
-			(unsigned long long)dr->dt_timer.interval, dr->du_timer_flags);
-}
-
-size_t
-_dispatch_source_debug(dispatch_source_t ds, char *buf, size_t bufsiz)
-{
-	dispatch_source_refs_t dr = ds->ds_refs;
-	size_t offset = 0;
-	offset += dsnprintf(&buf[offset], bufsiz - offset, "%s[%p] = { ",
-			_dispatch_object_class_name(ds), ds);
-	offset += _dispatch_object_debug_attr(ds, &buf[offset], bufsiz - offset);
-	offset += _dispatch_source_debug_attr(ds, &buf[offset], bufsiz - offset);
-	if (dr->du_is_timer) {
-		offset += _dispatch_timer_debug_attr(ds, &buf[offset], bufsiz - offset);
-	}
-	offset += dsnprintf(&buf[offset], bufsiz - offset, "kevent = %p%s, "
-			"filter = %s }", dr,  dr->du_is_direct ? " (direct)" : "",
-			dux_type(dr)->dst_kind);
-	return offset;
-}
--- a/Telegram/ThirdParty/dispatch/src/source_internal.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/source_internal.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,72 +0,0 @@
-/*
- * Copyright (c) 2008-2013 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-/*
- * IMPORTANT: This header file describes INTERNAL interfaces to libdispatch
- * which are subject to change in future releases of Mac OS X. Any applications
- * relying on these interfaces WILL break.
- */
-
-#ifndef __DISPATCH_SOURCE_INTERNAL__
-#define __DISPATCH_SOURCE_INTERNAL__
-
-#ifndef __DISPATCH_INDIRECT__
-#error "Please #include <dispatch/dispatch.h> instead of this file directly."
-#include <dispatch/base.h> // for HeaderDoc
-#endif
-
-_OS_OBJECT_CLASS_IMPLEMENTS_PROTOCOL(dispatch_source, dispatch_object)
-DISPATCH_CLASS_DECL_BARE(source, QUEUE);
-
-#define DISPATCH_SOURCE_CLASS_HEADER(x) \
-	DISPATCH_LANE_CLASS_HEADER(x); \
-	uint16_t \
-		/* set under the drain lock */ \
-		ds_is_installed:1, \
-		dm_connect_handler_called:1, \
-		dm_cancel_handler_called:1, \
-		dm_is_xpc:1, \
-		__ds_flags_pad : 12; \
-	uint16_t __dq_flags_separation[0]; \
-	uint16_t \
-		/* set under the send queue lock */ \
-		dm_needs_mgr:1, \
-		dm_disconnected:1, \
-		__dm_flags_pad : 14
-
-struct dispatch_source_s {
-	DISPATCH_SOURCE_CLASS_HEADER(source);
-} DISPATCH_ATOMIC64_ALIGN;
-dispatch_assert_valid_lane_type(dispatch_source_s);
-dispatch_static_assert(sizeof(struct dispatch_source_s) <= 128);
-
-void _dispatch_source_xref_dispose(dispatch_source_t ds);
-void _dispatch_source_dispose(dispatch_source_t ds, bool *allow_free);
-void _dispatch_source_activate(dispatch_source_t ds, bool *allow_resume);
-void _dispatch_source_invoke(dispatch_source_t ds,
-		dispatch_invoke_context_t dic, dispatch_invoke_flags_t flags);
-void _dispatch_source_wakeup(dispatch_source_t ds, dispatch_qos_t qos,
-		dispatch_wakeup_flags_t flags);
-void _dispatch_source_merge_evt(dispatch_unote_t du, uint32_t flags,
-		uintptr_t data, pthread_priority_t pp);
-DISPATCH_COLD
-size_t _dispatch_source_debug(dispatch_source_t ds, char* buf, size_t bufsiz);
-
-#endif /* __DISPATCH_SOURCE_INTERNAL__ */
--- a/Telegram/ThirdParty/dispatch/src/swift/Block.swift	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/swift/Block.swift	1970-01-01 00:00:00.000000000 -0000
@@ -1,119 +0,0 @@
-//===----------------------------------------------------------------------===//
-//
-// This source file is part of the Swift.org open source project
-//
-// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
-// Licensed under Apache License v2.0 with Runtime Library Exception
-//
-// See https://swift.org/LICENSE.txt for license information
-// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
-//
-//===----------------------------------------------------------------------===//
-
-import CDispatch
-@_implementationOnly import _DispatchOverlayShims
-
-public struct DispatchWorkItemFlags : OptionSet, RawRepresentable {
-	public let rawValue: UInt
-	public init(rawValue: UInt) { self.rawValue = rawValue }
-
-	public static let barrier = DispatchWorkItemFlags(rawValue: 0x1)
-
-	@available(macOS 10.10, iOS 8.0, *)
-	public static let detached = DispatchWorkItemFlags(rawValue: 0x2)
-
-	@available(macOS 10.10, iOS 8.0, *)
-	public static let assignCurrentContext = DispatchWorkItemFlags(rawValue: 0x4)
-
-	@available(macOS 10.10, iOS 8.0, *)
-	public static let noQoS = DispatchWorkItemFlags(rawValue: 0x8)
-
-	@available(macOS 10.10, iOS 8.0, *)
-	public static let inheritQoS = DispatchWorkItemFlags(rawValue: 0x10)
-
-	@available(macOS 10.10, iOS 8.0, *)
-	public static let enforceQoS = DispatchWorkItemFlags(rawValue: 0x20)
-}
-
-@available(macOS 10.10, iOS 8.0, *)
-public class DispatchWorkItem {
-	internal var _block: _DispatchBlock
-
-	public init(qos: DispatchQoS = .unspecified, flags: DispatchWorkItemFlags = [], block: @escaping @convention(block) () -> ()) {
-#if os(Windows)
-#if arch(arm64) || arch(x86_64)
-		let flags = dispatch_block_flags_t(UInt32(flags.rawValue))
-#else
-		let flags = dispatch_block_flags_t(UInt(flags.rawValue))
-#endif
-#else
-		let flags: dispatch_block_flags_t = numericCast(flags.rawValue)
-#endif
-		_block =  dispatch_block_create_with_qos_class(flags,
-			qos.qosClass.rawValue.rawValue, Int32(qos.relativePriority), block)
-	}
-
-	// Used by DispatchQueue.synchronously<T> to provide a path through
-	// dispatch_block_t, as we know the lifetime of the block in question.
-	internal init(flags: DispatchWorkItemFlags = [], noescapeBlock: () -> ()) {
-#if os(Windows)
-#if arch(arm64) || arch(x86_64)
-		let flags = dispatch_block_flags_t(UInt32(flags.rawValue))
-#else
-		let flags = dispatch_block_flags_t(UInt(flags.rawValue))
-#endif
-#else
-		let flags: dispatch_block_flags_t = numericCast(flags.rawValue)
-#endif
-		_block = _swift_dispatch_block_create_noescape(flags, noescapeBlock)
-	}
-
-	public func perform() {
-		_block()
-	}
-
-	public func wait() {
-		_ = dispatch_block_wait(_block, DispatchTime.distantFuture.rawValue)
-	}
-
-	public func wait(timeout: DispatchTime) -> DispatchTimeoutResult {
-		return dispatch_block_wait(_block, timeout.rawValue) == 0 ? .success : .timedOut
-	}
-
-	public func wait(wallTimeout: DispatchWallTime) -> DispatchTimeoutResult {
-		return dispatch_block_wait(_block, wallTimeout.rawValue) == 0 ? .success : .timedOut
-	}
-
-	public func notify(
-		qos: DispatchQoS = .unspecified,
-		flags: DispatchWorkItemFlags = [],
-		queue: DispatchQueue,
-		execute: @escaping @convention(block) () -> ())
-	{
-		if qos != .unspecified || !flags.isEmpty {
-			let item = DispatchWorkItem(qos: qos, flags: flags, block: execute)
-			dispatch_block_notify(_block, queue.__wrapped, item._block)
-		} else {
-			dispatch_block_notify(_block, queue.__wrapped, execute)
-		}
-	}
-
-	public func notify(queue: DispatchQueue, execute: DispatchWorkItem) {
-		dispatch_block_notify(_block, queue.__wrapped, execute._block)
-	}
-
-	public func cancel() {
-		dispatch_block_cancel(_block)
-	}
-
-	public var isCancelled: Bool {
-		return dispatch_block_testcancel(_block) != 0
-	}
-}
-
-/// The dispatch_block_t typealias is different from usual closures in that it
-/// uses @convention(block). This is to avoid unnecessary bridging between
-/// C blocks and Swift closures, which interferes with dispatch APIs that depend
-/// on the referential identity of a block. Particularly, dispatch_block_create.
-internal typealias _DispatchBlock = @convention(block) () -> Void
-internal typealias dispatch_block_t = @convention(block) () -> Void
--- a/Telegram/ThirdParty/dispatch/src/swift/CMakeLists.txt	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/swift/CMakeLists.txt	1970-01-01 00:00:00.000000000 -0000
@@ -1,66 +0,0 @@
-
-# NOTE(compnerd) Today regardless of whether or not ObjC interop is enabled,
-# swift will use an autoreleased return value convention for certain CF
-# functions (including some that are used/related to dispatch). This means that
-# the swift compiler in callers to such functions will call the function, and
-# then pass the result of the function to objc_retainAutoreleasedReturnValue. In
-# a context where we have ObjC interop disabled, we do not have access to the
-# objc runtime so an implementation of objc_retainAutoreleasedReturnValue is not
-# available. To work around this, we provide a shim for
-# objc_retainAutoreleasedReturnValue in DispatchStubs.cc that just calls retain
-# on the object. Once we fix the swift compiler to switch to a different model
-# for handling these arguments with objc-interop disabled these shims can be
-# eliminated.
-add_library(DispatchStubs STATIC
-  DispatchStubs.cc)
-target_include_directories(DispatchStubs PRIVATE
-  ${PROJECT_SOURCE_DIR})
-set_target_properties(DispatchStubs PROPERTIES
-  POSITION_INDEPENDENT_CODE YES)
-
-add_library(swiftDispatch
-  Block.swift
-  Data.swift
-  Dispatch.swift
-  IO.swift
-  Private.swift
-  Queue.swift
-  Source.swift
-  Time.swift
-  Wrapper.swift)
-target_compile_options(swiftDispatch PRIVATE
-  "SHELL:-Xcc -fblocks"
-  "SHELL:-Xcc -fmodule-map-file=${PROJECT_SOURCE_DIR}/dispatch/module.modulemap"
-  "SHELL:-Xcc -I${PROJECT_SOURCE_DIR}"
-  "SHELL:-Xcc -I${PROJECT_SOURCE_DIR}/src/swift/shims")
-set_target_properties(swiftDispatch PROPERTIES
-  Swift_MODULE_NAME Dispatch
-  Swift_MODULE_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/swift
-  INTERFACE_INCLUDE_DIRECTORIES ${CMAKE_CURRENT_BINARY_DIR}/swift)
-target_link_libraries(swiftDispatch PRIVATE
-  DispatchStubs
-  BlocksRuntime::BlocksRuntime)
-target_link_libraries(swiftDispatch PUBLIC
-  dispatch)
-add_dependencies(swiftDispatch module-maps)
-
-get_swift_host_arch(swift_arch)
-install(FILES
-  ${CMAKE_CURRENT_BINARY_DIR}/swift/Dispatch.swiftmodule
-  ${CMAKE_CURRENT_BINARY_DIR}/swift/Dispatch.swiftdoc
-  DESTINATION ${INSTALL_TARGET_DIR}/${swift_arch})
-set_property(GLOBAL APPEND PROPERTY DISPATCH_EXPORTS swiftDispatch)
-install(TARGETS swiftDispatch
-  EXPORT dispatchExports
-  ARCHIVE DESTINATION ${INSTALL_TARGET_DIR}
-  LIBRARY DESTINATION ${INSTALL_TARGET_DIR}
-  RUNTIME DESTINATION bin)
-if(NOT BUILD_SHARED_LIBS)
-  set_property(GLOBAL APPEND PROPERTY DISPATCH_EXPORTS DispatchStubs)
-  install(TARGETS DispatchStubs
-    EXPORT dispatchExports
-    DESTINATION ${INSTALL_TARGET_DIR})
-elseif(NOT CMAKE_SYSTEM_NAME MATCHES "Darwin|Windows")
-  target_link_options(swiftDispatch PRIVATE "SHELL:-no-toolchain-stdlib-rpath")
-  set_target_properties(swiftDispatch PROPERTIES INSTALL_RPATH "$ORIGIN")
-endif()
--- a/Telegram/ThirdParty/dispatch/src/swift/Data.swift	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/swift/Data.swift	1970-01-01 00:00:00.000000000 -0000
@@ -1,360 +0,0 @@
-//===----------------------------------------------------------------------===//
-//
-// This source file is part of the Swift.org open source project
-//
-// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
-// Licensed under Apache License v2.0 with Runtime Library Exception
-//
-// See https://swift.org/LICENSE.txt for license information
-// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
-//
-//===----------------------------------------------------------------------===//
-
-import CDispatch
-@_implementationOnly import _DispatchOverlayShims
-
-public struct DispatchData : RandomAccessCollection {
-	public typealias Iterator = DispatchDataIterator
-	public typealias Index = Int
-	public typealias Indices = DefaultIndices<DispatchData>
-
-	public static let empty: DispatchData = DispatchData(data: _swift_dispatch_data_empty())
-
-	public enum Deallocator {
-		/// Use `free`
-		case free
-
-		/// Use `munmap`
-		case unmap
-
-		/// A custom deallocator
-		// FIXME: Want @convention(block) here to minimize the overhead of
-		//        doing the conversion (once per custom enum instance instead
-		//        of once per call to DispatchData.init using the enum instance).
-		//        However, adding the annotation here results in Data.o containing
-		//        a reference to _TMBO (opaque metadata for Builtin.UnknownObject)
-		//        which is only made available on platforms with Objective-C.
-		case custom(DispatchQueue?, () -> Void)
-
-		fileprivate var _deallocator: (DispatchQueue?, @convention(block) () -> Void) {
-			switch self {
-			case .free: return (nil, _swift_dispatch_data_destructor_free())
-			case .unmap: return (nil, _swift_dispatch_data_destructor_munmap())
-			case .custom(let q, let b): return (q, b)
-			}
-		}
-	}
-
-	internal var __wrapped: __DispatchData
-
-	/// Initialize a `Data` with copied memory content.
-	///
-	/// - parameter bytes: A pointer to the memory. It will be copied.
-	@available(swift, deprecated: 4, message: "Use init(bytes: UnsafeRawBufferPointer) instead")
-	public init(bytes buffer: UnsafeBufferPointer<UInt8>) {
-		let d = buffer.baseAddress == nil ? _swift_dispatch_data_empty()
-					: dispatch_data_create(buffer.baseAddress!, buffer.count, nil,
-							_swift_dispatch_data_destructor_default())
-		self.init(data: d)
-	}
-
-	/// Initialize a `Data` with copied memory content.
-	///
-	/// - parameter bytes: A pointer to the memory. It will be copied.
-	/// - parameter count: The number of bytes to copy.
-	public init(bytes buffer: UnsafeRawBufferPointer) {
-		let d = buffer.baseAddress == nil ? _swift_dispatch_data_empty()
-					: dispatch_data_create(buffer.baseAddress!, buffer.count, nil,
-							_swift_dispatch_data_destructor_default())
-		self.init(data: d)
-	}
-
-	/// Initialize a `Data` without copying the bytes.
-	///
-	/// - parameter bytes: A buffer pointer containing the data.
-	/// - parameter deallocator: Specifies the mechanism to free the indicated buffer.
-	@available(swift, deprecated: 4, message: "Use init(bytesNoCopy: UnsafeRawBufferPointer, deallocater: Deallocator) instead")
-	public init(bytesNoCopy bytes: UnsafeBufferPointer<UInt8>, deallocator: Deallocator = .free) {
-		let (q, b) = deallocator._deallocator
-		let d = bytes.baseAddress == nil ? _swift_dispatch_data_empty()
-					: dispatch_data_create(bytes.baseAddress!, bytes.count, q?.__wrapped, b)
-		self.init(data: d)
-	}
-
-	/// Initialize a `Data` without copying the bytes.
-	///
-	/// - parameter bytes: A pointer to the bytes.
-	/// - parameter count: The size of the bytes.
-	/// - parameter deallocator: Specifies the mechanism to free the indicated buffer.
-	public init(bytesNoCopy bytes: UnsafeRawBufferPointer, deallocator: Deallocator = .free) {
-		let (q, b) = deallocator._deallocator
-		let d = bytes.baseAddress == nil ? _swift_dispatch_data_empty()
-					: dispatch_data_create(bytes.baseAddress!, bytes.count, q?.__wrapped, b)
-		self.init(data: d)
-	}
-
-	internal init(data: dispatch_data_t) {
-		__wrapped = __DispatchData(data: data, owned: true)
-	}
-
-	internal init(borrowedData: dispatch_data_t) {
-		__wrapped = __DispatchData(data: borrowedData, owned: false)
-	}
-
-	public var count: Int {
-		return CDispatch.dispatch_data_get_size(__wrapped.__wrapped)
-	}
-
-	public func withUnsafeBytes<Result, ContentType>(
-		body: (UnsafePointer<ContentType>) throws -> Result) rethrows -> Result
-	{
-		var ptr: UnsafeRawPointer? = nil
-		var size = 0
-		let data = CDispatch.dispatch_data_create_map(__wrapped.__wrapped, &ptr, &size)
-		let contentPtr = ptr!.bindMemory(
-			to: ContentType.self, capacity: size / MemoryLayout<ContentType>.stride)
-		defer { _fixLifetime(data) }
-		return try body(contentPtr)
-	}
-
-	@available(swift 4.2)
-	public func enumerateBytes(
-		_ block: (_ buffer: UnsafeBufferPointer<UInt8>, _ byteIndex: Int, _ stop: inout Bool) -> Void)
-	{
-		enumerateBytesCommon(block)
-	}
-
-	@available(swift, obsoleted: 4.2, renamed: "enumerateBytes(_:)")
-	public func enumerateBytes(
-		block: (_ buffer: UnsafeBufferPointer<UInt8>, _ byteIndex: Int, _ stop: inout Bool) -> Void)
-	{
-		enumerateBytesCommon(block)
-	}
-
-	private func enumerateBytesCommon(
-		_ block: (_ buffer: UnsafeBufferPointer<UInt8>, _ byteIndex: Int, _ stop: inout Bool) -> Void)
-	{
-		// we know that capturing block in the closure being created/passed to dispatch_data_apply
-		// does not cause block to escape because dispatch_data_apply does not allow its
-		// block argument to escape.  Therefore, the usage of withoutActuallyEscaping to
-		// bypass the Swift type system is safe.
-		withoutActuallyEscaping(block) { escapableBlock in
-			_ = CDispatch.dispatch_data_apply(__wrapped.__wrapped) { (_, offset: Int, ptr: UnsafeRawPointer, size: Int) in
-				let bytePtr = ptr.bindMemory(to: UInt8.self, capacity: size)
-				let bp = UnsafeBufferPointer(start: bytePtr, count: size)
-				var stop = false
-				escapableBlock(bp, offset, &stop)
-				return !stop
-			}
-		}
-	}
-
-	/// Append bytes to the data.
-	///
-	/// - parameter bytes: A pointer to the bytes to copy in to the data.
-	/// - parameter count: The number of bytes to copy.
-	@available(swift, deprecated: 4, message: "Use append(_: UnsafeRawBufferPointer) instead")
-	public mutating func append(_ bytes: UnsafePointer<UInt8>, count: Int) {
-		let data = dispatch_data_create(bytes, count, nil, _swift_dispatch_data_destructor_default())
-		self.append(DispatchData(data: data))
-	}
-
-	/// Append bytes to the data.
-	///
-	/// - parameter bytes: A pointer to the bytes to copy in to the data.
-	/// - parameter count: The number of bytes to copy.
-	public mutating func append(_ bytes: UnsafeRawBufferPointer) {
-		// Nil base address does nothing.
-		guard bytes.baseAddress != nil else { return }
-		let data = dispatch_data_create(bytes.baseAddress!, bytes.count, nil, _swift_dispatch_data_destructor_default())
-		self.append(DispatchData(data: data))
-	}
-
-	/// Append data to the data.
-	///
-	/// - parameter data: The data to append to this data.
-	public mutating func append(_ other: DispatchData) {
-		let data = CDispatch.dispatch_data_create_concat(__wrapped.__wrapped, other.__wrapped.__wrapped)
-		__wrapped = __DispatchData(data: data, owned: true)
-	}
-
-	/// Append a buffer of bytes to the data.
-	///
-	/// - parameter buffer: The buffer of bytes to append. The size is calculated from `SourceType` and `buffer.count`.
-	public mutating func append<SourceType>(_ buffer : UnsafeBufferPointer<SourceType>) {
-		self.append(UnsafeRawBufferPointer(buffer))
-	}
-
-	private func _copyBytesHelper(to pointer: UnsafeMutableRawPointer, from range: Range<Index>) {
-		var copiedCount = 0
-		if range.isEmpty { return }
-		let rangeSize = range.count
-		_ = CDispatch.dispatch_data_apply(__wrapped.__wrapped) { (data: dispatch_data_t, offset: Int, ptr: UnsafeRawPointer, size: Int) in
-			if offset >= range.endIndex { return false } // This region is after endIndex
-			let copyOffset = range.startIndex > offset ? range.startIndex - offset : 0 // offset of first byte, in this region
-			if copyOffset >= size { return true } // This region is before startIndex
-			let count = Swift.min(rangeSize - copiedCount, size - copyOffset)
-			memcpy(pointer + copiedCount, ptr + copyOffset, count)
-			copiedCount += count
-			return copiedCount < rangeSize
-		}
-	}
-
-	/// Copy the contents of the data to a pointer.
-	///
-	/// - parameter pointer: A pointer to the buffer you wish to copy the bytes into.
-	/// - parameter count: The number of bytes to copy.
-	/// - warning: This method does not verify that the contents at pointer have enough space to hold `count` bytes.
-	@available(swift, deprecated: 4, message: "Use copyBytes(to: UnsafeMutableRawBufferPointer, count: Int) instead")
-	public func copyBytes(to pointer: UnsafeMutablePointer<UInt8>, count: Int) {
-		_copyBytesHelper(to: pointer, from: 0..<count)
-	}
-
-	/// Copy the contents of the data to a pointer.
-	///
-	/// - parameter pointer: A pointer to the buffer you wish to copy the bytes into. The buffer must be large
-	///	enough to hold `count` bytes.
-	/// - parameter count: The number of bytes to copy.
-	public func copyBytes(to pointer: UnsafeMutableRawBufferPointer, count: Int) {
-		assert(count <= pointer.count, "Buffer too small to copy \(count) bytes")
-		guard pointer.baseAddress != nil else { return }
-		_copyBytesHelper(to: pointer.baseAddress!, from: 0..<count)
-	}
-		
-	/// Copy a subset of the contents of the data to a pointer.
-	///
-	/// - parameter pointer: A pointer to the buffer you wish to copy the bytes into.
-	/// - parameter range: The range in the `Data` to copy.
-	/// - warning: This method does not verify that the contents at pointer have enough space to hold the required number of bytes.
-	@available(swift, deprecated: 4, message: "Use copyBytes(to: UnsafeMutableRawBufferPointer, from: Range<Index>) instead")
-	public func copyBytes(to pointer: UnsafeMutablePointer<UInt8>, from range: Range<Index>) {
-		_copyBytesHelper(to: pointer, from: range)
-	}
-	
-	/// Copy a subset of the contents of the data to a pointer.
-	///
-	/// - parameter pointer: A pointer to the buffer you wish to copy the bytes into. The buffer must be large
-	///	enough to hold `count` bytes.
-	/// - parameter range: The range in the `Data` to copy.
-	public func copyBytes(to pointer: UnsafeMutableRawBufferPointer, from range: Range<Index>) {
-		assert(range.count <= pointer.count, "Buffer too small to copy \(range.count) bytes")
-		guard pointer.baseAddress != nil else { return }
-		_copyBytesHelper(to: pointer.baseAddress!, from: range)
-	}
-
-	/// Copy the contents of the data into a buffer.
-	///
-	/// This function copies the bytes in `range` from the data into the buffer. If the count of the `range` is greater than `MemoryLayout<DestinationType>.stride * buffer.count` then the first N bytes will be copied into the buffer.
-	/// - precondition: The range must be within the bounds of the data. Otherwise `fatalError` is called.
-	/// - parameter buffer: A buffer to copy the data into.
-	/// - parameter range: A range in the data to copy into the buffer. If the range is empty, this function will return 0 without copying anything. If the range is nil, as much data as will fit into `buffer` is copied.
-	/// - returns: Number of bytes copied into the destination buffer.
-	public func copyBytes<DestinationType>(to buffer: UnsafeMutableBufferPointer<DestinationType>, from range: Range<Index>? = nil) -> Int {
-		let cnt = count
-		guard cnt > 0 else { return 0 }
-		
-		let copyRange : Range<Index>
-		if let r = range {
-			guard !r.isEmpty else { return 0 }
-			precondition(r.startIndex >= 0)
-			precondition(r.startIndex < cnt, "The range is outside the bounds of the data")
-			
-			precondition(r.endIndex >= 0)
-			precondition(r.endIndex <= cnt, "The range is outside the bounds of the data")
-			
-			copyRange = r.startIndex..<(r.startIndex + Swift.min(buffer.count * MemoryLayout<DestinationType>.stride, r.count))
-		} else {
-			copyRange = 0..<Swift.min(buffer.count * MemoryLayout<DestinationType>.stride, cnt)
-		}
-		
-		guard !copyRange.isEmpty else { return 0 }
-		
-		_copyBytesHelper(to: buffer.baseAddress!, from: copyRange)
-		return copyRange.count
-	}
-
-	/// Sets or returns the byte at the specified index.
-	public subscript(index: Index) -> UInt8 {
-		var offset = 0
-		let subdata = CDispatch.dispatch_data_copy_region(__wrapped.__wrapped, index, &offset)
-
-		var ptr: UnsafeRawPointer? = nil
-		var size = 0
-		let map = CDispatch.dispatch_data_create_map(subdata, &ptr, &size)
-		defer { _fixLifetime(map) }
-
-		return ptr!.load(fromByteOffset: index - offset, as: UInt8.self)
-	}
-
-	public subscript(bounds: Range<Int>) -> Slice<DispatchData> {
-		return Slice(base: self, bounds: bounds)
-	}
-
-	/// Return a new copy of the data in a specified range.
-	///
-	/// - parameter range: The range to copy.
-	public func subdata(in range: Range<Index>) -> DispatchData {
-		let subrange = CDispatch.dispatch_data_create_subrange(
-			__wrapped.__wrapped, range.startIndex, range.endIndex - range.startIndex)
-		return DispatchData(data: subrange)
-	}
-
-	public func region(location: Int) -> (data: DispatchData, offset: Int) {
-		var offset: Int = 0
-		let data = CDispatch.dispatch_data_copy_region(__wrapped.__wrapped, location, &offset)
-		return (DispatchData(data: data), offset)
-	}
-
-	public var startIndex: Index {
-		return 0
-	}
-
-	public var endIndex: Index {
-		return count
-	}
-
-	public func index(before i: Index) -> Index {
-		return i - 1
-	}
-
-	public func index(after i: Index) -> Index {
-		return i + 1
-	}
-
-	/// An iterator over the contents of the data.
-	///
-	/// The iterator will increment byte-by-byte.
-	public func makeIterator() -> DispatchData.Iterator {
-		return DispatchDataIterator(_data: self)
-	}
-}
-
-public struct DispatchDataIterator : IteratorProtocol, Sequence {
-        public typealias Element = UInt8
-
-	/// Create an iterator over the given DispatchData
-	public init(_data: DispatchData) {
-		var ptr: UnsafeRawPointer?
-		self._count = 0
-		self._data = __DispatchData(data: CDispatch.dispatch_data_create_map(_data.__wrapped.__wrapped, &ptr, &self._count), owned: true)
-		self._ptr = ptr
-		self._position = _data.startIndex
-
-		// The only time we expect a 'nil' pointer is when the data is empty.
-		assert(self._ptr != nil || self._count == self._position)
-	}
-
-	/// Advance to the next element and return it, or `nil` if no next
-	/// element exists.
-	public mutating func next() -> DispatchData.Element? {
-		if _position == _count { return nil }
-		let element = _ptr.load(fromByteOffset: _position, as: UInt8.self)
-		_position = _position + 1
-		return element
-	}
-
-	internal let _data: __DispatchData
-	internal var _ptr: UnsafeRawPointer!
-	internal var _count: Int
-	internal var _position: DispatchData.Index
-}
--- a/Telegram/ThirdParty/dispatch/src/swift/Dispatch.apinotes	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/swift/Dispatch.apinotes	1970-01-01 00:00:00.000000000 -0000
@@ -1,330 +0,0 @@
----
-Name: Dispatch
-Typedefs:
-- Name: dispatch_object_t
-  Availability: nonswift
-- Name: dispatch_block_t
-  Availability: nonswift
-- Name: dispatch_queue_t
-  Availability: nonswift
-- Name: dispatch_semaphore_t
-  Availability: nonswift
-- Name: dispatch_io_t
-  Availability: nonswift
-- Name: dispatch_data_t
-  Availability: nonswift
-- Name: dispatch_group_t
-  Availability: nonswift
-- Name: dispatch_qos_class_t
-  Availability: nonswift
-- Name: dispatch_data_applier_t
-  Availability: nonswift
-- Name: dispatch_fd_t
-  Availability: nonswift
-- Name: dispatch_io_handler_t
-  Availability: nonswift
-- Name: dispatch_source_t
-  Availability: nonswift
-- Name: dispatch_function_t
-  Availability: nonswift
-- Name: dispatch_io_close_flags_t
-  Availability: nonswift
-- Name: dispatch_io_interval_flags_t
-  Availability: nonswift
-- Name: dispatch_io_type_t
-  Availability: nonswift
-- Name: dispatch_source_timer_flags_t
-  Availability: nonswift
-- Name: dispatch_autorelease_frequency_t
-  SwiftPrivate: true
-- Name: dispatch_queue_attr_t
-  Availability: nonswift
-- Name: dispatch_queue_priority_t
-  Availability: nonswift
-- Name: dispatch_block_flags_t
-  SwiftPrivate: true
-- Name: dispatch_source_type_t
-  SwiftPrivate: true
-- Name: dispatch_source_mach_send_flags_t
-  Availability: nonswift
-- Name: dispatch_source_memorypressure_flags_t
-  Availability: nonswift
-- Name: dispatch_source_proc_flags_t
-  Availability: nonswift
-- Name: dispatch_source_vnode_flags_t
-  Availability: nonswift
-Classes:
-- Name: OS_dispatch_object
-  SwiftName: DispatchObject
-- Name: OS_dispatch_queue
-  SwiftName: DispatchQueue
-- Name: OS_dispatch_io
-  SwiftName: DispatchIO
-- Name: OS_dispatch_semaphore
-  SwiftName: DispatchSemaphore
-- Name: OS_dispatch_group
-  SwiftName: DispatchGroup
-- Name: OS_dispatch_source
-  SwiftName: DispatchSource
-- Name: OS_dispatch_queue_attr
-  SwiftPrivate: true
-- Name: OS_dispatch_data
-  SwiftName: __DispatchData
-Protocols:
-- Name: OS_dispatch_source
-  SwiftName: DispatchSourceType
-- Name: OS_dispatch_source_mach_send
-  SwiftName: DispatchSourceMachSend
-- Name: OS_dispatch_source_mach_recv
-  SwiftName: DispatchSourceMachReceive
-- Name: OS_dispatch_source_memorypressure
-  SwiftName: DispatchSourceMemoryPressure
-- Name: OS_dispatch_source_proc
-  SwiftName: DispatchSourceProcess
-- Name: OS_dispatch_source_read
-  SwiftName: DispatchSourceRead
-- Name: OS_dispatch_source_signal
-  SwiftName: DispatchSourceSignal
-- Name: OS_dispatch_source_timer
-  SwiftName: DispatchSourceTimer
-- Name: OS_dispatch_source_data_or
-  SwiftName: DispatchSourceUserDataOr
-- Name: OS_dispatch_source_data_add
-  SwiftName: DispatchSourceUserDataAdd
-- Name: OS_dispatch_source_data_replace
-  SwiftName: DispatchSourceUserDataReplace
-- Name: OS_dispatch_source_vnode
-  SwiftName: DispatchSourceFileSystemObject
-- Name: OS_dispatch_source_write
-  SwiftName: DispatchSourceWrite
-Functions:
-- Name: dispatch_release
-  Availability: nonswift
-- Name: dispatch_retain
-  Availability: nonswift
-# dispatch_queue_t
-- Name: dispatch_queue_create
-  SwiftName: 'DispatchQueue.init(__label:attr:)'
-  SwiftPrivate: true
-- Name: dispatch_get_global_queue
-  SwiftPrivate: true
-- Name: dispatch_queue_create_with_target
-  SwiftName: 'DispatchQueue.init(__label:attr:queue:)'
-  SwiftPrivate: true
-- Name: dispatch_assert_queue
-  SwiftPrivate: true
-- Name: dispatch_assert_queue_barrier
-  SwiftPrivate: true
-- Name: dispatch_assert_queue_not
-  SwiftPrivate: true
-- Name: dispatch_async
-  SwiftPrivate: true
-- Name: dispatch_async_f
-  Availability: nonswift
-- Name: dispatch_barrier_async
-  SwiftPrivate: true
-- Name: dispatch_barrier_async_f
-  Availability: nonswift
-- Name: dispatch_apply
-  SwiftPrivate: true
-- Name: dispatch_apply_f
-  Availability: nonswift
-- Name: dispatch_sync
-  SwiftName: 'DispatchQueue.sync(self:execute:)'
-- Name: dispatch_sync_f
-  Availability: nonswift
-- Name: dispatch_barrier_sync
-  SwiftPrivate: true
-- Name: dispatch_barrier_sync_f
-  Availability: nonswift
-- Name: dispatch_queue_get_label
-  SwiftPrivate: true
-- Name: dispatch_queue_get_qos_class
-  SwiftPrivate: true
-- Name: dispatch_after
-  SwiftPrivate: true
-- Name: dispatch_after_f
-  Availability: nonswift
-- Name: dispatch_queue_get_specific
-  SwiftPrivate: true
-- Name: dispatch_queue_set_specific
-  SwiftPrivate: true
-- Name: dispatch_get_specific
-  SwiftPrivate: true
-- Name: dispatch_get_main_queue
-  Availability: nonswift
-- Name: dispatch_queue_attr_make_initially_inactive
-  SwiftPrivate: true
-- Name: dispatch_queue_attr_make_with_autorelease_frequency
-  SwiftPrivate: true
-- Name: dispatch_queue_attr_make_with_qos_class
-  SwiftPrivate: true
-# dispatch_object_t
-- Name: dispatch_set_target_queue
-  SwiftName: 'DispatchObject.setTarget(self:queue:)'
-- Name: dispatch_activate
-  SwiftName: 'DispatchObject.activate(self:)'
-- Name: dispatch_suspend
-  SwiftName: 'DispatchObject.suspend(self:)'
-- Name: dispatch_resume
-  SwiftName: 'DispatchObject.resume(self:)'
-- Name: dispatch_set_finalizer_f
-  Availability: nonswift
-- Name: dispatch_get_context
-  Availability: nonswift
-- Name: dispatch_set_context
-  Availability: nonswift
-- Name: _dispatch_object_validate
-  Availability: nonswift
-# dispatch_block
-- Name: dispatch_block_create
-  Availability: nonswift
-  AvailabilityMsg: 'Use DispatchWorkItem()'
-- Name: dispatch_block_create_with_qos_class
-  Availability: nonswift
-  AvailabilityMsg: 'Use DispatchWorkItem()'
-- Name: dispatch_block_perform
-  Availability: nonswift
-  AvailabilityMsg: 'Use DispatchWorkItem.perform()'
-- Name: dispatch_block_wait
-  Availability: nonswift
-  AvailabilityMsg: 'Use DispatchWorkItem.wait(timeout:)'
-- Name: dispatch_block_notify
-  Availability: nonswift
-  AvailabilityMsg: 'Use DispatchWorkItem.notify(queue:execute:)'
-- Name: dispatch_block_cancel
-  Availability: nonswift
-  AvailabilityMsg: 'Use DispatchWorkItem.cancel()'
-- Name: dispatch_block_testcancel
-  Availability: nonswift
-  AvailabilityMsg: 'Use DispatchWorkItem.isCancelled'
-# dispatch_data
-- Name: dispatch_data_create
-  SwiftPrivate: true
-- Name: dispatch_data_get_size
-  SwiftPrivate: true
-- Name: dispatch_data_apply
-  SwiftPrivate: true
-- Name: dispatch_data_create_concat
-  SwiftPrivate: true
-- Name: dispatch_data_create_subrange
-  SwiftPrivate: true
-- Name: dispatch_data_copy_region
-  SwiftPrivate: true
-- Name: dispatch_data_create_map
-  SwiftPrivate: true
-# dispatch_group_t
-- Name: dispatch_group_create
-  SwiftName: 'DispatchGroup.init()'
-  Availability: available
-- Name: dispatch_group_async
-  SwiftPrivate: true
-- Name: dispatch_group_async_f
-  Availability: nonswift
-- Name: dispatch_group_wait
-  SwiftPrivate: true
-- Name: dispatch_group_notify
-  SwiftPrivate: true
-- Name: dispatch_group_notify_f
-  Availability: nonswift
-- Name: dispatch_group_enter
-  SwiftName: 'DispatchGroup.enter(self:)'
-- Name: dispatch_group_leave
-  SwiftName: 'DispatchGroup.leave(self:)'
-# dispatch_io
-- Name: dispatch_io_create
-  SwiftPrivate: true
-  SwiftName: 'DispatchIO.init(__type:fd:queue:handler:)'
-- Name: dispatch_io_create_with_path
-  SwiftPrivate: true
-  SwiftName: 'DispatchIO.init(__type:path:oflag:mode:queue:handler:)'
-- Name: dispatch_io_create_with_io
-  SwiftPrivate: true
-  SwiftName: 'DispatchIO.init(__type:io:queue:handler:)'
-- Name: dispatch_io_read
-  SwiftPrivate: true
-- Name: dispatch_io_write
-  SwiftPrivate: true
-- Name: dispatch_io_close
-  SwiftPrivate: true
-- Name: dispatch_io_barrier
-  SwiftName: 'DispatchIO.barrier(self:execute:)'
-- Name: dispatch_io_get_descriptor
-  SwiftName: 'getter:DispatchIO.fileDescriptor(self:)'
-- Name: dispatch_io_set_high_water
-  SwiftName: 'DispatchIO.setLimit(self:highWater:)'
-- Name: dispatch_io_set_low_water
-  SwiftName: 'DispatchIO.setLimit(self:lowWater:)'
-- Name: dispatch_io_set_interval
-  SwiftPrivate: true
-- Name: dispatch_read
-  SwiftPrivate: true
-- Name: dispatch_write
-  SwiftPrivate: true
-# dispatch_semaphore
-- Name: dispatch_semaphore_create
-  SwiftName: 'DispatchSemaphore.init(value:)'
-- Name: dispatch_semaphore_wait
-  SwiftPrivate: true
-- Name: dispatch_semaphore_signal
-  SwiftPrivate: true
-# dispatch_source
-- Name: dispatch_source_create
-  SwiftPrivate: true
-- Name: dispatch_source_get_handle
-  SwiftPrivate: true
-- Name: dispatch_source_get_mask
-  SwiftPrivate: true
-- Name: dispatch_source_get_data
-  SwiftPrivate: true
-- Name: dispatch_source_merge_data
-  SwiftPrivate: true
-- Name: dispatch_source_set_event_handler
-  SwiftPrivate: true
-- Name: dispatch_source_set_event_handler_f
-  Availability: nonswift
-- Name: dispatch_source_set_cancel_handler
-  SwiftPrivate: true
-- Name: dispatch_source_set_cancel_handler_f
-  Availability: nonswift
-- Name: dispatch_source_set_registration_handler
-  SwiftPrivate: true
-- Name: dispatch_source_set_registration_handler_f
-  Availability: nonswift
-- Name: dispatch_source_cancel
-  SwiftPrivate: true
-- Name: dispatch_source_testcancel
-  SwiftPrivate: true
-- Name: dispatch_source_set_timer
-  SwiftPrivate: true
-# dispatch_time
-- Name: dispatch_time
-  SwiftPrivate: true
-- Name: dispatch_walltime
-  SwiftPrivate: true
-- Name: dispatch_main
-  SwiftName: 'dispatchMain()'
-Globals:
-- Name: _dispatch_data_destructor_free
-  Availability: nonswift
-- Name: _dispatch_data_destructor_munmap
-  Availability: nonswift
-Enumerators:
-- Name: DISPATCH_BLOCK_BARRIER
-  Availability: nonswift
-- Name: DISPATCH_BLOCK_DETACHED
-  Availability: nonswift
-- Name: DISPATCH_BLOCK_ASSIGN_CURRENT
-  Availability: nonswift
-- Name: DISPATCH_BLOCK_NO_QOS_CLASS
-  Availability: nonswift
-- Name: DISPATCH_BLOCK_INHERIT_QOS_CLASS
-  Availability: nonswift
-- Name: DISPATCH_BLOCK_ENFORCE_QOS_CLASS
-  Availability: nonswift
-- Name: DISPATCH_AUTORELEASE_FREQUENCY_INHERIT
-  Availability: nonswift
-- Name: DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM
-  Availability: nonswift
-- Name: DISPATCH_AUTORELEASE_FREQUENCY_NEVER
-  Availability: nonswift
--- a/Telegram/ThirdParty/dispatch/src/swift/DispatchStubs.cc	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/swift/DispatchStubs.cc	1970-01-01 00:00:00.000000000 -0000
@@ -1,95 +0,0 @@
-//===----------------------------------------------------------------------===//
-//
-// This source file is part of the Swift.org open source project
-//
-// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
-// Licensed under Apache License v2.0 with Runtime Library Exception
-//
-// See https://swift.org/LICENSE.txt for license information
-// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
-//
-//===----------------------------------------------------------------------===//
-
-#include <dispatch/dispatch.h>
-#include <stdio.h>
-
-#if defined(__ELF__) || defined(__MACH__) || defined(__WASM__)
-#define DISPATCH_RUNTIME_STDLIB_INTERFACE __attribute__((__visibility__("default")))
-#else
-#define DISPATCH_RUNTIME_STDLIB_INTERFACE __declspec(dllexport)
-#endif
-
-#if USE_OBJC
-@protocol OS_dispatch_source;
-@protocol OS_dispatch_source_mach_send;
-@protocol OS_dispatch_source_mach_recv;
-@protocol OS_dispatch_source_memorypressure;
-@protocol OS_dispatch_source_proc;
-@protocol OS_dispatch_source_read;
-@protocol OS_dispatch_source_signal;
-@protocol OS_dispatch_source_timer;
-@protocol OS_dispatch_source_data_add;
-@protocol OS_dispatch_source_data_or;
-@protocol OS_dispatch_source_data_replace;
-@protocol OS_dispatch_source_vnode;
-@protocol OS_dispatch_source_write;
-
-// #include <dispatch/private.h>
-__attribute__((constructor))
-static void _dispatch_overlay_constructor() {
-  Class source = objc_lookUpClass("OS_dispatch_source");
-  if (source) {
-    class_addProtocol(source, @protocol(OS_dispatch_source));
-    class_addProtocol(source, @protocol(OS_dispatch_source_mach_send));
-    class_addProtocol(source, @protocol(OS_dispatch_source_mach_recv));
-    class_addProtocol(source, @protocol(OS_dispatch_source_memorypressure));
-    class_addProtocol(source, @protocol(OS_dispatch_source_proc));
-    class_addProtocol(source, @protocol(OS_dispatch_source_read));
-    class_addProtocol(source, @protocol(OS_dispatch_source_signal));
-    class_addProtocol(source, @protocol(OS_dispatch_source_timer));
-    class_addProtocol(source, @protocol(OS_dispatch_source_data_add));
-    class_addProtocol(source, @protocol(OS_dispatch_source_data_or));
-    class_addProtocol(source, @protocol(OS_dispatch_source_data_replace));
-    class_addProtocol(source, @protocol(OS_dispatch_source_vnode));
-    class_addProtocol(source, @protocol(OS_dispatch_source_write));
-  }
-}
-
-#endif /* USE_OBJC */
-
-#if !USE_OBJC
-DISPATCH_RUNTIME_STDLIB_INTERFACE
-extern "C" void * objc_retainAutoreleasedReturnValue(void *obj);
-#endif
-
-#if !USE_OBJC
-
-// For CF functions with 'Get' semantics, the compiler currently assumes that
-// the result is autoreleased and must be retained. It does so on all platforms
-// by emitting a call to objc_retainAutoreleasedReturnValue. On Darwin, this is
-// implemented by the ObjC runtime. On non-ObjC platforms, there is no runtime,
-// and therefore we have to stub it out here ourselves. The compiler will
-// eventually call swift_release to balance the retain below. This is a
-// workaround until the compiler no longer emits this callout on non-ObjC
-// platforms.
-extern "C"
-#if defined(_WIN32)
-__declspec(dllimport)
-#endif
-void swift_retain(void *);
-
-DISPATCH_RUNTIME_STDLIB_INTERFACE
-extern "C" void * objc_retainAutoreleasedReturnValue(void *obj) {
-    if (obj) {
-        swift_retain(obj);
-        return obj;
-    }
-    else return NULL;
-}
-
-#if defined(_WIN32)
-extern "C" void *(*__imp_objc_retainAutoreleasedReturnValue)(void *) =
-    &objc_retainAutoreleasedReturnValue;
-#endif
-
-#endif // !USE_OBJC
--- a/Telegram/ThirdParty/dispatch/src/swift/Dispatch.swift	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/swift/Dispatch.swift	1970-01-01 00:00:00.000000000 -0000
@@ -1,183 +0,0 @@
-//===----------------------------------------------------------------------===//
-//
-// This source file is part of the Swift.org open source project
-//
-// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
-// Licensed under Apache License v2.0 with Runtime Library Exception
-//
-// See https://swift.org/LICENSE.txt for license information
-// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
-//
-//===----------------------------------------------------------------------===//
-
-@_exported import Dispatch
-
-import CDispatch
-
-/// dispatch_assert
-
-@available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
-public enum DispatchPredicate {
-	case onQueue(DispatchQueue)
-	case onQueueAsBarrier(DispatchQueue)
-	case notOnQueue(DispatchQueue)
-}
-
-@available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
-public func _dispatchPreconditionTest(_ condition: DispatchPredicate) -> Bool {
-	switch condition {
-	case .onQueue(let q):
-		dispatch_assert_queue(q.__wrapped)
-	case .onQueueAsBarrier(let q):
-		dispatch_assert_queue_barrier(q.__wrapped)
-	case .notOnQueue(let q):
-		dispatch_assert_queue_not(q.__wrapped)
-	}
-	return true
-}
-
-@_transparent
-@available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
-public func dispatchPrecondition(condition: @autoclosure () -> DispatchPredicate, file: StaticString = #file, line: UInt = #line) {
-	// precondition is able to determine release-vs-debug asserts where the overlay
-	// cannot, so formulating this into a call that we can call with precondition()
-	precondition(_dispatchPreconditionTest(condition()), "dispatchPrecondition failure", file: file, line: line)
-}
-
-/// qos_class_t
-
-public struct DispatchQoS : Equatable {
-	public let qosClass: QoSClass
-	public let relativePriority: Int
-
-	@available(macOS 10.10, iOS 8.0, *)
-	public static let background = DispatchQoS(qosClass: .background, relativePriority: 0)
-
-	@available(macOS 10.10, iOS 8.0, *)
-	public static let utility = DispatchQoS(qosClass: .utility, relativePriority: 0)
-
-	@available(macOS 10.10, iOS 8.0, *)
-	public static let `default` = DispatchQoS(qosClass: .default, relativePriority: 0)
-
-	@available(macOS 10.10, iOS 8.0, *)
-	public static let userInitiated = DispatchQoS(qosClass: .userInitiated, relativePriority: 0)
-
-	@available(macOS 10.10, iOS 8.0, *)
-	public static let userInteractive = DispatchQoS(qosClass: .userInteractive, relativePriority: 0)
-
-	public static let unspecified = DispatchQoS(qosClass: .unspecified, relativePriority: 0)
-
-	public enum QoSClass {
-		@available(macOS 10.10, iOS 8.0, *)
-		case background
-
-		@available(macOS 10.10, iOS 8.0, *)
-		case utility
-
-		@available(macOS 10.10, iOS 8.0, *)
-		case `default`
-
-		@available(macOS 10.10, iOS 8.0, *)
-		case userInitiated
-
-		@available(macOS 10.10, iOS 8.0, *)
-		case userInteractive
-
-		case unspecified
-
-		// _OSQoSClass is internal on Linux, so this initialiser has to 
-		// remain as an internal init.
-		@available(macOS 10.10, iOS 8.0, *)
-		internal init?(rawValue: _OSQoSClass) {
-			switch rawValue {
-			case .QOS_CLASS_BACKGROUND: self = .background
-			case .QOS_CLASS_UTILITY: self = .utility
-			case .QOS_CLASS_DEFAULT: self = .default
-			case .QOS_CLASS_USER_INITIATED: self = .userInitiated
-			case .QOS_CLASS_USER_INTERACTIVE: self = .userInteractive
-			case .QOS_CLASS_UNSPECIFIED: self = .unspecified
-			default: return nil
-			}
-		}
-
-		@available(macOS 10.10, iOS 8.0, *)
-		internal var rawValue: _OSQoSClass {
-			switch self {
-			case .background: return .QOS_CLASS_BACKGROUND
-			case .utility: return .QOS_CLASS_UTILITY
-			case .default: return .QOS_CLASS_DEFAULT
-			case .userInitiated: return .QOS_CLASS_USER_INITIATED
-			case .userInteractive: return .QOS_CLASS_USER_INTERACTIVE
-			case .unspecified: return .QOS_CLASS_UNSPECIFIED
-			}
-		}
-	}
-
-	public init(qosClass: QoSClass, relativePriority: Int) {
-		self.qosClass = qosClass
-		self.relativePriority = relativePriority
-	}
-}
-
-public func ==(a: DispatchQoS, b: DispatchQoS) -> Bool {
-	return a.qosClass == b.qosClass && a.relativePriority == b.relativePriority
-}
-
-/// 
-
-public enum DispatchTimeoutResult {
-    static let KERN_OPERATION_TIMED_OUT:Int = 49
-	case success
-	case timedOut
-}
-
-/// dispatch_group
-
-extension DispatchGroup {
-	public func notify(qos: DispatchQoS = .unspecified, flags: DispatchWorkItemFlags = [], queue: DispatchQueue, execute work: @escaping @convention(block) () -> ()) {
-		if #available(macOS 10.10, iOS 8.0, *), qos != .unspecified || !flags.isEmpty {
-			let item = DispatchWorkItem(qos: qos, flags: flags, block: work)
-			dispatch_group_notify(self.__wrapped, queue.__wrapped, item._block)
-		} else {
-			dispatch_group_notify(self.__wrapped, queue.__wrapped, work)
-		}
-	}
-
-	@available(macOS 10.10, iOS 8.0, *)
-	public func notify(queue: DispatchQueue, work: DispatchWorkItem) {
-		dispatch_group_notify(self.__wrapped, queue.__wrapped, work._block)
-	}
-
-	public func wait() {
-		_ = dispatch_group_wait(self.__wrapped, DispatchTime.distantFuture.rawValue)
-	}
-
-	public func wait(timeout: DispatchTime) -> DispatchTimeoutResult {
-		return dispatch_group_wait(self.__wrapped, timeout.rawValue) == 0 ? .success : .timedOut
-	}
-
-	public func wait(wallTimeout timeout: DispatchWallTime) -> DispatchTimeoutResult {
-		return dispatch_group_wait(self.__wrapped, timeout.rawValue) == 0 ? .success : .timedOut
-	}
-}
-
-/// dispatch_semaphore
-
-extension DispatchSemaphore {
-	@discardableResult
-	public func signal() -> Int {
-		return Int(dispatch_semaphore_signal(self.__wrapped))
-	}
-
-	public func wait() {
-		_ = dispatch_semaphore_wait(self.__wrapped, DispatchTime.distantFuture.rawValue)
-	}
-
-	public func wait(timeout: DispatchTime) -> DispatchTimeoutResult {
-		return dispatch_semaphore_wait(self.__wrapped, timeout.rawValue) == 0 ? .success : .timedOut
-	}
-
-	public func wait(wallTimeout: DispatchWallTime) -> DispatchTimeoutResult {
-		return dispatch_semaphore_wait(self.__wrapped, wallTimeout.rawValue) == 0 ? .success : .timedOut
-	}
-}
--- a/Telegram/ThirdParty/dispatch/src/swift/IO.swift	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/swift/IO.swift	1970-01-01 00:00:00.000000000 -0000
@@ -1,129 +0,0 @@
-//===----------------------------------------------------------------------===//
-//
-// This source file is part of the Swift.org open source project
-//
-// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
-// Licensed under Apache License v2.0 with Runtime Library Exception
-//
-// See https://swift.org/LICENSE.txt for license information
-// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
-//
-//===----------------------------------------------------------------------===//
-
-import CDispatch
-#if os(Windows)
-import WinSDK
-#endif
-
-extension DispatchIO {
-
-	public enum StreamType : UInt  {
-		case stream = 0
-		case random = 1
-	}
-
-	public struct CloseFlags : OptionSet, RawRepresentable {
-		public let rawValue: UInt
-		public init(rawValue: UInt) { self.rawValue = rawValue }
-
-		public static let stop = CloseFlags(rawValue: 1)
-	}
-
-	public struct IntervalFlags : OptionSet, RawRepresentable {
-		public let rawValue: UInt
-		public init(rawValue: UInt) { self.rawValue = rawValue }
-		public init(nilLiteral: ()) { self.rawValue = 0 }
-
-		public static let strictInterval = IntervalFlags(rawValue: 1)
-	}
-
-#if os(Windows)
-	public class func read(fromHandle: HANDLE, maxLength: Int, runningHandlerOn queue: DispatchQueue, handler: @escaping (_ data: DispatchData, _ error: Int32) -> Void) {
-		dispatch_read(dispatch_fd_t(bitPattern: fromHandle), maxLength, queue.__wrapped) { (data: dispatch_data_t, error: Int32) in
-			handler(DispatchData(borrowedData: data), error)
-		}
-	}
-#endif
-
-	public class func read(fromFileDescriptor: Int32, maxLength: Int, runningHandlerOn queue: DispatchQueue, handler: @escaping (_ data: DispatchData, _ error: Int32) -> Void) {
-		dispatch_read(dispatch_fd_t(fromFileDescriptor), maxLength, queue.__wrapped) { (data: dispatch_data_t, error: Int32) in
-			handler(DispatchData(borrowedData: data), error)
-		}
-	}
-
-#if os(Windows)
-	public class func write(toHandle: HANDLE, data: DispatchData, runningHandlerOn queue: DispatchQueue, handler: @escaping(_ data: DispatchData??, _ error: Int32) -> Void) {
-		dispatch_write(dispatch_fd_t(bitPattern: toHandle), data.__wrapped.__wrapped, queue.__wrapped) { (data: dispatch_data_t?, error: Int32) in
-			handler(data.map { DispatchData(borrowedData: $0) }, error)
-		}
-	}
-#endif
-
-	public class func write(toFileDescriptor: Int32, data: DispatchData, runningHandlerOn queue: DispatchQueue, handler: @escaping (_ data: DispatchData?, _ error: Int32) -> Void) {
-		dispatch_write(dispatch_fd_t(toFileDescriptor), data.__wrapped.__wrapped, queue.__wrapped) { (data: dispatch_data_t?, error: Int32) in
-			handler(data.map { DispatchData(borrowedData: $0) }, error)
-		}
-	}
-
-	public convenience init(
-		type: StreamType,
-		fileDescriptor: dispatch_fd_t,
-		queue: DispatchQueue,
-		cleanupHandler: @escaping (_ error: Int32) -> Void)
-	{
-		self.init(__type: type.rawValue, fd: fileDescriptor, queue: queue, handler: cleanupHandler)
-	}
-
-	@available(swift, obsoleted: 4)
-	public convenience init(
-		type: StreamType,
-		path: UnsafePointer<Int8>,
-		oflag: Int32,
-		mode: mode_t,
-		queue: DispatchQueue,
-		cleanupHandler: @escaping (_ error: Int32) -> Void)
-	{
-		self.init(__type: type.rawValue, path: path, oflag: oflag, mode: mode, queue: queue, handler: cleanupHandler)
-	}
-
-	@available(swift, introduced: 4)
-	public convenience init?(
-		type: StreamType,
-		path: UnsafePointer<Int8>,
-		oflag: Int32,
-		mode: mode_t,
-		queue: DispatchQueue,
-		cleanupHandler: @escaping (_ error: Int32) -> Void)
-	{
-		self.init(__type: type.rawValue, path: path, oflag: oflag, mode: mode, queue: queue, handler: cleanupHandler)
-	}
-
-	public convenience init(
-		type: StreamType,
-		io: DispatchIO,
-		queue: DispatchQueue,
-		cleanupHandler: @escaping (_ error: Int32) -> Void)
-	{
-		self.init(__type: type.rawValue, io: io, queue: queue, handler: cleanupHandler)
-	}
-
-	public func read(offset: off_t, length: Int, queue: DispatchQueue, ioHandler: @escaping (_ done: Bool, _ data: DispatchData?, _ error: Int32) -> Void) {
-		dispatch_io_read(self.__wrapped, offset, length, queue.__wrapped) { (done: Bool, data: dispatch_data_t?, error: Int32) in
-			ioHandler(done, data.map { DispatchData(borrowedData: $0) }, error)
-		}
-	}
-
-	public func write(offset: off_t, data: DispatchData, queue: DispatchQueue, ioHandler: @escaping (_ done: Bool, _ data: DispatchData?, _ error: Int32) -> Void) {
-		dispatch_io_write(self.__wrapped, offset, data.__wrapped.__wrapped, queue.__wrapped) { (done: Bool, data: dispatch_data_t?, error: Int32) in
-			ioHandler(done, data.map { DispatchData(borrowedData: $0) }, error)
-		}
-	}
-
-	public func setInterval(interval: DispatchTimeInterval, flags: IntervalFlags = []) {
-		dispatch_io_set_interval(self.__wrapped, UInt64(interval.rawValue), dispatch_io_interval_flags_t(flags.rawValue))
-	}
-
-	public func close(flags: CloseFlags = []) {
-		dispatch_io_close(self.__wrapped, dispatch_io_close_flags_t(flags.rawValue))
-	}
-}
--- a/Telegram/ThirdParty/dispatch/src/swift/Private.swift	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/swift/Private.swift	1970-01-01 00:00:00.000000000 -0000
@@ -1,474 +0,0 @@
-//===----------------------------------------------------------------------===//
-//
-// This source file is part of the Swift.org open source project
-//
-// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
-// Licensed under Apache License v2.0 with Runtime Library Exception
-//
-// See https://swift.org/LICENSE.txt for license information
-// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
-//
-//===----------------------------------------------------------------------===//
-
-// Redeclarations of all SwiftPrivate functions with appropriate markup.
-
-import CDispatch
-
-@available(*, unavailable, renamed:"DispatchQueue.init(label:qos:attributes:autoreleaseFrequency:target:)")
-public func dispatch_queue_create(_ label: UnsafePointer<Int8>?, _ attr: dispatch_queue_attr_t?) -> DispatchQueue
-{
-	fatalError()
-}
-
-@available(*, unavailable, renamed:"DispatchQueue.init(label:qos:attributes:autoreleaseFrequency:target:)")
-public func dispatch_queue_create_with_target(_ label: UnsafePointer<Int8>?, _ attr: dispatch_queue_attr_t?, _ queue: DispatchQueue?) -> DispatchQueue
-{
-	fatalError()
-}
-
-@available(*, unavailable, renamed:"DispatchIO.init(type:fileDescriptor:queue:cleanupHandler:)")
-public func dispatch_io_create(_ type: UInt, _ fd: dispatch_fd_t, _ queue: DispatchQueue, _ cleanup_handler: @escaping (Int32) -> Void) -> DispatchIO
-{
-	fatalError()
-}
-
-@available(*, unavailable, renamed:"DispatchIO.init(type:path:oflag:mode:queue:cleanupHandler:)")
-public func dispatch_io_create_with_path(_ type: UInt, _ path: UnsafePointer<Int8>, _ oflag: Int32, _ mode: mode_t, _ queue: DispatchQueue, _ cleanup_handler: @escaping (Int32) -> Void) -> DispatchIO
-{
-	fatalError()
-}
-
-@available(*, unavailable, renamed:"DispatchIO.init(type:io:queue:cleanupHandler:)")
-public func dispatch_io_create_with_io(_ type: UInt, _ io: DispatchIO, _ queue: DispatchQueue, _ cleanup_handler: @escaping (Int32) -> Void) -> DispatchIO
-{
-	fatalError()
-}
-
-@available(*, unavailable, renamed:"DispatchIO.read(fileDescriptor:length:queue:handler:)")
-public func dispatch_read(_ fd: Int32, _ length: Int, _ queue: DispatchQueue, _ handler: @escaping (dispatch_data_t, Int32) -> Void)
-{
-	fatalError()
-}
-
-@available(*, unavailable, renamed:"DispatchIO.read(self:offset:length:queue:ioHandler:)")
-func dispatch_io_read(_ channel: DispatchIO, _ offset: off_t, _ length: Int, _ queue: DispatchQueue, _ io_handler: @escaping (Bool, dispatch_data_t?, Int32) -> Void)
-{
-	fatalError()
-}
-
-@available(*, unavailable, renamed:"DispatchIO.write(self:offset:data:queue:ioHandler:)")
-func dispatch_io_write(_ channel: DispatchIO, _ offset: off_t, _ data: dispatch_data_t, _ queue: DispatchQueue, _ io_handler: @escaping (Bool, dispatch_data_t?, Int32) -> Void)
-{
-	fatalError()
-}
-
-@available(*, unavailable, renamed:"DispatchIO.write(fileDescriptor:data:queue:handler:)")
-func dispatch_write(_ fd: Int32, _ data: dispatch_data_t, _ queue: DispatchQueue, _ handler: @escaping (dispatch_data_t?, Int32) -> Void)
-{
-	fatalError()
-}
-
-@available(*, unavailable, renamed:"DispatchData.init(bytes:)")
-public func dispatch_data_create(_ buffer: UnsafeRawPointer, _ size: Int, _ queue: DispatchQueue?, _ destructor: (() -> Void)?) -> dispatch_data_t
-{
-	fatalError()
-}
-
-@available(*, unavailable, renamed:"getter:DispatchData.count(self:)")
-public func dispatch_data_get_size(_ data: dispatch_data_t) -> Int
-{
-	fatalError()
-}
-
-@available(*, unavailable, renamed:"DispatchData.withUnsafeBytes(self:body:)")
-public func dispatch_data_create_map(_ data: dispatch_data_t, _ buffer_ptr: UnsafeMutablePointer<UnsafeRawPointer?>?, _ size_ptr: UnsafeMutablePointer<Int>?) -> dispatch_data_t
-{
-	fatalError()
-}
-
-@available(*, unavailable, renamed:"DispatchData.append(self:_:)")
-public func dispatch_data_create_concat(_ data1: dispatch_data_t, _ data2: dispatch_data_t) -> dispatch_data_t
-{
-	fatalError()
-}
-
-@available(*, unavailable, renamed:"DispatchData.subdata(self:in:)")
-public func dispatch_data_create_subrange(_ data: dispatch_data_t, _ offset: Int, _ length: Int) -> dispatch_data_t
-{
-	fatalError()
-}
-
-@available(*, unavailable, renamed:"DispatchData.enumerateBytes(self:block:)")
-public func dispatch_data_apply(_ data: dispatch_data_t, _ applier: @escaping (dispatch_data_t, Int, UnsafeRawPointer, Int) -> Bool) -> Bool
-{
-	fatalError()
-}
-
-@available(*, unavailable, renamed:"DispatchData.region(self:location:)")
-public func dispatch_data_copy_region(_ data: dispatch_data_t, _ location: Int, _ offset_ptr: UnsafeMutablePointer<Int>) -> dispatch_data_t
-{
-	fatalError()
-}
-
-@available(*, unavailable, renamed:"DispatchQueue.async(self:group:qos:flags:execute:)")
-public func dispatch_group_async(_ group: DispatchGroup, _ queue: DispatchQueue, _ block: @escaping () -> Void)
-{
-	fatalError()
-}
-
-@available(*, unavailable, renamed: "DispatchGroup.notify(self:qos:flags:queue:execute:)")
-public func dispatch_group_notify(_ group: DispatchGroup, _ queue: DispatchQueue, _ block: @escaping () -> Void)
-{
-	fatalError()
-}
-
-@available(*, unavailable, renamed:"DispatchGroup.wait(self:timeout:)")
-public func dispatch_group_wait(_ group: DispatchGroup, _ timeout: dispatch_time_t) -> Int
-{
-	fatalError()
-}
-
-@available(*, unavailable, renamed:"DispatchIO.close(self:flags:)")
-public func dispatch_io_close(_ channel: DispatchIO, _ flags: UInt)
-{
-	fatalError()
-}
-
-@available(*, unavailable, renamed:"DispatchIO.setInterval(self:interval:flags:)")
-public func dispatch_io_set_interval(_ channel: DispatchIO, _ interval: UInt64, _ flags: UInt)
-{
-	fatalError()
-}
-
-@available(*, unavailable, renamed:"DispatchQueue.concurrentPerform(iterations:execute:)")
-public func dispatch_apply(_ iterations: Int, _ queue: DispatchQueue, _ block: (Int) -> Void)
-{
-	fatalError()
-}
-
-@available(*, unavailable, renamed:"DispatchQueue.async(self:execute:)")
-public func dispatch_async(_ queue: DispatchQueue, _ block: @escaping () -> Void)
-{
-	fatalError()
-}
-
-@available(*, unavailable, renamed:"DispatchQueue.global(attributes:)")
-public func dispatch_get_global_queue(_ identifier: Int, _ flags: UInt) -> DispatchQueue
-{
-	fatalError()
-}
-
-@available(*, unavailable, renamed: "getter:DispatchQueue.main()")
-public func dispatch_get_main_queue() -> DispatchQueue
-{
-	fatalError()
-}
-
-@available(*, unavailable, renamed:"DispatchQueue.Attributes.initiallyInactive")
-public func dispatch_queue_attr_make_initially_inactive(_ attr: dispatch_queue_attr_t?) -> dispatch_queue_attr_t
-{
-	fatalError()
-}
-
-@available(*, unavailable, renamed:"DispatchQueue.AutoreleaseFrequency.workItem")
-public func dispatch_queue_attr_make_with_autorelease_frequency(_ attr: dispatch_queue_attr_t?, _ frequency: dispatch_autorelease_frequency_t) -> dispatch_queue_attr_t
-{
-	fatalError()
-}
-
-@available(*, unavailable, renamed:"DispatchQoS")
-public func dispatch_queue_attr_make_with_qos_class(_ attr: dispatch_queue_attr_t?, _ qos_class: dispatch_qos_class_t, _ relative_priority: Int32) -> dispatch_queue_attr_t
-{
-	fatalError()
-}
-
-@available(*, unavailable, renamed:"getter:DispatchQueue.label(self:)")
-public func dispatch_queue_get_label(_ queue: DispatchQueue?) -> UnsafePointer<Int8>
-{
-	fatalError()
-}
-
-@available(*, unavailable, renamed:"getter:DispatchQueue.qos(self:)")
-public func dispatch_queue_get_qos_class(_ queue: DispatchQueue, _ relative_priority_ptr: UnsafeMutablePointer<Int32>?) -> dispatch_qos_class_t
-{
-	fatalError()
-}
-
-@available(*, unavailable, renamed:"DispatchQueue.asyncAfter(self:deadline:qos:flags:execute:)")
-public func dispatch_after(_ when: dispatch_time_t, _ queue: DispatchQueue, _ block: @escaping () -> Void)
-{
-	fatalError()
-}
-
-@available(*, unavailable, renamed:"DispatchQueue.async(self:group:qos:flags:execute:)")
-public func dispatch_barrier_async(_ queue: DispatchQueue, _ block: @escaping () -> Void)
-{
-	fatalError()
-}
-
-@available(*, unavailable, renamed:"DispatchQueue.sync(self:flags:execute:)")
-public func dispatch_barrier_sync(_ queue: DispatchQueue, _ block: () -> Void)
-{
-	fatalError()
-}
-
-@available(*, unavailable, renamed:"DispatchQueue.setSpecific(self:key:value:)")
-public func dispatch_queue_set_specific(_ queue: DispatchQueue, _ key: UnsafeRawPointer, _ context: UnsafeMutableRawPointer?, _ destructor: (@convention(c) (UnsafeMutableRawPointer?) -> Void)?)
-{
-	fatalError()
-}
-
-@available(*, unavailable, renamed:"DispatchQueue.getSpecific(self:key:)")
-public func dispatch_queue_get_specific(_ queue: DispatchQueue, _ key: UnsafeRawPointer) -> UnsafeMutableRawPointer?
-{
-	fatalError()
-}
-
-@available(*, unavailable, renamed:"DispatchQueue.getSpecific(key:)")
-public func dispatch_get_specific(_ key: UnsafeRawPointer) -> UnsafeMutableRawPointer?
-{
-	fatalError()
-}
-
-@available(*, unavailable, renamed:"dispatchPrecondition(_:)")
-public func dispatch_assert_queue(_ queue: DispatchQueue)
-{
-	fatalError()
-}
-
-@available(*, unavailable, renamed:"dispatchPrecondition(_:)")
-public func dispatch_assert_queue_barrier(_ queue: DispatchQueue)
-{
-	fatalError()
-}
-
-@available(*, unavailable, renamed:"dispatchPrecondition(_:)")
-public func dispatch_assert_queue_not(_ queue: DispatchQueue)
-{
-	fatalError()
-}
-
-@available(*, unavailable, renamed:"DispatchSemaphore.wait(self:timeout:)")
-public func dispatch_semaphore_wait(_ dsema: DispatchSemaphore, _ timeout: dispatch_time_t) -> Int
-{
-	fatalError()
-}
-
-@available(*, unavailable, renamed: "DispatchSemaphore.signal(self:)")
-public func dispatch_semaphore_signal(_ dsema: DispatchSemaphore) -> Int
-{
-	fatalError()
-}
-
-@available(*, unavailable, message:"Use DispatchSource class methods")
-public func dispatch_source_create(_ type: dispatch_source_type_t, _ handle: UInt, _ mask: UInt, _ queue: DispatchQueue?) -> DispatchSource
-{
-	fatalError()
-}
-
-@available(*, unavailable, renamed:"DispatchSource.setEventHandler(self:handler:)")
-public func dispatch_source_set_event_handler(_ source: DispatchSource, _ handler: (() -> Void)?)
-{
-	fatalError()
-}
-
-@available(*, unavailable, renamed:"DispatchSource.setCancelHandler(self:handler:)")
-public func dispatch_source_set_cancel_handler(_ source: DispatchSource, _ handler: (() -> Void)?)
-{
-	fatalError()
-}
-
-@available(*, unavailable, renamed:"DispatchSource.cancel(self:)")
-public func dispatch_source_cancel(_ source: DispatchSource)
-{
-	fatalError()
-}
-
-@available(*, unavailable, renamed:"getter:DispatchSource.isCancelled(self:)")
-public func dispatch_source_testcancel(_ source: DispatchSource) -> Int
-{
-	fatalError()
-}
-
-@available(*, unavailable, renamed:"getter:DispatchSource.handle(self:)")
-public func dispatch_source_get_handle(_ source: DispatchSource) -> UInt
-{
-	fatalError()
-}
-
-@available(*, unavailable, renamed:"getter:DispatchSource.mask(self:)")
-public func dispatch_source_get_mask(_ source: DispatchSource) -> UInt
-{
-	fatalError()
-}
-
-@available(*, unavailable, renamed:"getter:DispatchSource.data(self:)")
-public func dispatch_source_get_data(_ source: DispatchSource) -> UInt
-{
-	fatalError()
-}
-
-@available(*, unavailable, renamed:"DispatchUserDataAdd.mergeData(self:value:)")
-public func dispatch_source_merge_data(_ source: DispatchSource, _ value: UInt)
-{
-	fatalError()
-}
-
-@available(*, unavailable, renamed:"DispatchTimerSource.setTimer(self:start:interval:leeway:)")
-public func dispatch_source_set_timer(_ source: DispatchSource, _ start: dispatch_time_t, _ interval: UInt64, _ leeway: UInt64)
-{
-	fatalError()
-}
-
-@available(*, unavailable, renamed:"DispatchSource.setRegistrationHandler(self:handler:)")
-public func dispatch_source_set_registration_handler(_ source: DispatchSource, _ handler: (() -> Void)?)
-{
-	fatalError()
-}
-
-@available(*, unavailable, renamed:"DispatchTime.now()")
-public func dispatch_time(_ when: dispatch_time_t, _ delta: Int64) -> dispatch_time_t
-{
-	fatalError()
-}
-
-@available(*, unavailable, renamed:"DispatchWalltime.init(time:)")
-public func dispatch_walltime(_ when: UnsafePointer<timespec>?, _ delta: Int64) -> dispatch_time_t
-{
-	fatalError()
-}
-
-@available(*, unavailable, renamed: "DispatchQueue.GlobalQueuePriority.high")
-public var DISPATCH_QUEUE_PRIORITY_HIGH: Int {
-  fatalError()
-}
-
-@available(*, unavailable, renamed: "DispatchQueue.GlobalQueuePriority.default")
-public var DISPATCH_QUEUE_PRIORITY_DEFAULT: Int {
-  fatalError()
-}
-
-@available(*, unavailable, renamed: "DispatchQueue.GlobalQueuePriority.low")
-public var DISPATCH_QUEUE_PRIORITY_LOW: Int {
-  fatalError()
-}
-
-@available(*, unavailable, renamed: "DispatchQueue.GlobalQueuePriority.background")
-public var DISPATCH_QUEUE_PRIORITY_BACKGROUND: Int {
-  fatalError()
-}
-
-@available(*, unavailable, renamed: "DispatchIO.StreamType.stream")
-public var DISPATCH_IO_STREAM: Int {
-  fatalError()
-}
-
-@available(*, unavailable, renamed: "DispatchIO.StreamType.random")
-public var DISPATCH_IO_RANDOM: Int {
-  fatalError()
-}
-
-@available(*, unavailable, renamed: "DispatchIO.CloseFlags.stop")
-public var DISPATCH_IO_STOP: Int {
-  fatalError()
-}
-
-@available(*, unavailable, renamed: "DispatchIO.IntervalFlags.strictInterval")
-public var DISPATCH_IO_STRICT_INTERVAL: Int {
-  fatalError()
-}
-
-@available(*, unavailable, renamed: "DispatchSource.MachSendEvent.dead")
-public var DISPATCH_MACH_SEND_DEAD: Int {
-  fatalError()
-}
-
-@available(*, unavailable, renamed: "DispatchSource.MemoryPressureEvent.normal")
-public var DISPATCH_MEMORYPRESSURE_NORMAL: Int {
-  fatalError()
-}
-
-@available(*, unavailable, renamed: "DispatchSource.MemoryPressureEvent.warning")
-public var DISPATCH_MEMORYPRESSURE_WARN: Int {
-  fatalError()
-}
-
-@available(*, unavailable, renamed: "DispatchSource.MemoryPressureEvent.critical")
-public var DISPATCH_MEMORYPRESSURE_CRITICAL: Int {
-  fatalError()
-}
-
-@available(*, unavailable, renamed: "DispatchSource.ProcessEvent.exit")
-public var DISPATCH_PROC_EXIT: Int {
-  fatalError()
-}
-
-@available(*, unavailable, renamed: "DispatchSource.ProcessEvent.fork")
-public var DISPATCH_PROC_FORK: Int {
-  fatalError()
-}
-
-@available(*, unavailable, renamed: "DispatchSource.ProcessEvent.exec")
-public var DISPATCH_PROC_EXEC: Int {
-  fatalError()
-}
-
-@available(*, unavailable, renamed: "DispatchSource.ProcessEvent.signal")
-public var DISPATCH_PROC_SIGNAL: Int {
-  fatalError()
-}
-
-@available(*, unavailable, renamed: "DispatchSource.TimerFlags.strict")
-public var DISPATCH_TIMER_STRICT: Int {
-  fatalError()
-}
-
-@available(*, unavailable, renamed: "DispatchSource.FileSystemEvent.delete")
-public var DISPATCH_VNODE_DELETE: Int {
-  fatalError()
-}
-
-@available(*, unavailable, renamed: "DispatchSource.FileSystemEvent.write")
-public var DISPATCH_VNODE_WRITE: Int {
-  fatalError()
-}
-
-@available(*, unavailable, renamed: "DispatchSource.FileSystemEvent.extend")
-public var DISPATCH_VNODE_EXTEND: Int {
-  fatalError()
-}
-
-@available(*, unavailable, renamed: "DispatchSource.FileSystemEvent.attrib")
-public var DISPATCH_VNODE_ATTRIB: Int {
-  fatalError()
-}
-
-@available(*, unavailable, renamed: "DispatchSource.FileSystemEvent.link")
-public var DISPATCH_VNODE_LINK: Int {
-  fatalError()
-}
-
-@available(*, unavailable, renamed: "DispatchSource.FileSystemEvent.rename")
-public var DISPATCH_VNODE_RENAME: Int {
-  fatalError()
-}
-
-@available(*, unavailable, renamed: "DispatchSource.FileSystemEvent.revoke")
-public var DISPATCH_VNODE_REVOKE: Int {
-  fatalError()
-}
-
-@available(*, unavailable, renamed: "DispatchSource.FileSystemEvent.funlock")
-public var DISPATCH_VNODE_FUNLOCK: Int {
-  fatalError()
-}
-
-@available(*, unavailable, renamed: "DispatchTime.now()")
-public var DISPATCH_TIME_NOW: Int {
-  fatalError()
-}
-
-@available(*, unavailable, renamed: "DispatchTime.distantFuture")
-public var DISPATCH_TIME_FOREVER: Int {
-  fatalError()
-}
--- a/Telegram/ThirdParty/dispatch/src/swift/Queue.swift	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/swift/Queue.swift	1970-01-01 00:00:00.000000000 -0000
@@ -1,498 +0,0 @@
-//===----------------------------------------------------------------------===//
-//
-// This source file is part of the Swift.org open source project
-//
-// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
-// Licensed under Apache License v2.0 with Runtime Library Exception
-//
-// See https://swift.org/LICENSE.txt for license information
-// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
-//
-//===----------------------------------------------------------------------===//
-
-// dispatch/queue.h
-
-import CDispatch
-@_implementationOnly import _DispatchOverlayShims
-
-public final class DispatchSpecificKey<T> {
-	public init() {}
-}
-
-internal class _DispatchSpecificValue<T> {
-	internal let value: T
-	internal init(value: T) { self.value = value }
-}
-
-extension DispatchQueue {
-	public struct Attributes : OptionSet {
-		public let rawValue: UInt64
-		public init(rawValue: UInt64) { self.rawValue = rawValue }
-
-		public static let concurrent = Attributes(rawValue: 1<<1)
-
-		@available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
-		public static let initiallyInactive = Attributes(rawValue: 1<<2)
-
-		fileprivate func _attr() -> dispatch_queue_attr_t? {
-			var attr: dispatch_queue_attr_t? = nil
-
-			if self.contains(.concurrent) {
-				attr = _swift_dispatch_queue_concurrent()
-			}
-			if #available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *) {
-				if self.contains(.initiallyInactive) {
-					attr = CDispatch.dispatch_queue_attr_make_initially_inactive(attr)
-				}
-			}
-			return attr
-		}
-	}
-
-	public enum GlobalQueuePriority {
-		@available(macOS, deprecated: 10.10, message: "Use qos attributes instead")
-		@available(iOS, deprecated: 8.0, message: "Use qos attributes instead")
-		@available(tvOS, deprecated, message: "Use qos attributes instead")
-		@available(watchOS, deprecated, message: "Use qos attributes instead")
-		case high
-
-		@available(macOS, deprecated: 10.10, message: "Use qos attributes instead")
-		@available(iOS, deprecated: 8.0, message: "Use qos attributes instead")
-		@available(tvOS, deprecated, message: "Use qos attributes instead")
-		@available(watchOS, deprecated, message: "Use qos attributes instead")
-		case `default`
-
-		@available(macOS, deprecated: 10.10, message: "Use qos attributes instead")
-		@available(iOS, deprecated: 8.0, message: "Use qos attributes instead")
-		@available(tvOS, deprecated, message: "Use qos attributes instead")
-		@available(watchOS, deprecated, message: "Use qos attributes instead")
-		case low
-
-		@available(macOS, deprecated: 10.10, message: "Use qos attributes instead")
-		@available(iOS, deprecated: 8.0, message: "Use qos attributes instead")
-		@available(tvOS, deprecated, message: "Use qos attributes instead")
-		@available(watchOS, deprecated, message: "Use qos attributes instead")
-		case background
-
-		internal var _translatedValue: Int {
-			switch self {
-			case .high: return 2 // DISPATCH_QUEUE_PRIORITY_HIGH
-			case .default: return 0 // DISPATCH_QUEUE_PRIORITY_DEFAULT
-			case .low: return -2 // DISPATCH_QUEUE_PRIORITY_LOW
-			case .background: return Int(Int16.min) // DISPATCH_QUEUE_PRIORITY_BACKGROUND
-			}
-		}
-	}
-
-	public enum AutoreleaseFrequency {
-		case inherit
-
-		@available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
-		case workItem
-
-		@available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
-		case never
-
-		internal func _attr(attr: dispatch_queue_attr_t?) -> dispatch_queue_attr_t? {
-			if #available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *) {
-				switch self {
-				case .inherit:
-					// DISPATCH_AUTORELEASE_FREQUENCY_INHERIT
-					return CDispatch.dispatch_queue_attr_make_with_autorelease_frequency(attr, dispatch_autorelease_frequency_t(0))
-				case .workItem:
-					// DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM
-					return CDispatch.dispatch_queue_attr_make_with_autorelease_frequency(attr, dispatch_autorelease_frequency_t(1))
-				case .never:
-					// DISPATCH_AUTORELEASE_FREQUENCY_NEVER
-					return CDispatch.dispatch_queue_attr_make_with_autorelease_frequency(attr, dispatch_autorelease_frequency_t(2))
-				}
-			} else {
-				return attr
-			}
-		}
-	}
-
-	public class func concurrentPerform(iterations: Int, execute work: (Int) -> Void) {
-		_swift_dispatch_apply_current(iterations, work)
-	}
-
-	public class var main: DispatchQueue {
-		return DispatchQueue(queue: _swift_dispatch_get_main_queue())
-	}
-
-	@available(macOS, deprecated: 10.10, message: "")
-	@available(iOS, deprecated: 8.0, message: "")
-	@available(tvOS, deprecated, message: "")
-	@available(watchOS, deprecated, message: "")
-	public class func global(priority: GlobalQueuePriority) -> DispatchQueue {
-		return DispatchQueue(queue: CDispatch.dispatch_get_global_queue(Int(priority._translatedValue), 0))
-	}
-
-	@available(macOS 10.10, iOS 8.0, *)
-	public class func global(qos: DispatchQoS.QoSClass = .default) -> DispatchQueue {
-		return DispatchQueue(queue: CDispatch.dispatch_get_global_queue(Int(qos.rawValue.rawValue), 0))
-	}
-
-	public class func getSpecific<T>(key: DispatchSpecificKey<T>) -> T? {
-		let k = Unmanaged.passUnretained(key).toOpaque()
-		if let p = CDispatch.dispatch_get_specific(k) {
-			let v = Unmanaged<_DispatchSpecificValue<T>>
-				.fromOpaque(p)
-				.takeUnretainedValue()
-			return v.value
-		}
-		return nil
-	}
-
-	public convenience init(
-		label: String,
-		qos: DispatchQoS = .unspecified,
-		attributes: Attributes = [],
-		autoreleaseFrequency: AutoreleaseFrequency = .inherit,
-		target: DispatchQueue? = nil)
-	{
-		var attr = attributes._attr()
-		if autoreleaseFrequency != .inherit {
-			attr = autoreleaseFrequency._attr(attr: attr)
-		}
-		if #available(macOS 10.10, iOS 8.0, *), qos != .unspecified {
-			attr = CDispatch.dispatch_queue_attr_make_with_qos_class(attr, qos.qosClass.rawValue.rawValue, Int32(qos.relativePriority))
-		}
-
-		if #available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *) {
-			self.init(__label: label, attr: attr, queue: target)
-		} else {
-			self.init(__label: label, attr: attr)
-			if let tq = target { self.setTarget(queue: tq) }
-		}
-	}
-
-	public var label: String {
-		return String(validatingUTF8: dispatch_queue_get_label(self.__wrapped))!
-	}
-
-	///
-	/// Submits a block for synchronous execution on this queue.
-	///
-	/// Submits a work item to a dispatch queue like `async(execute:)`, however
-	/// `sync(execute:)` will not return until the work item has finished.
-	///
-	/// Work items submitted to a queue with `sync(execute:)` do not observe certain
-	/// queue attributes of that queue when invoked (such as autorelease frequency
-	/// and QoS class).
-	///
-	/// Calls to `sync(execute:)` targeting the current queue will result
-	/// in deadlock. Use of `sync(execute:)` is also subject to the same
-	/// multi-party deadlock problems that may result from the use of a mutex.
-	/// Use of `async(execute:)` is preferred.
-	///
-	/// As an optimization, `sync(execute:)` invokes the work item on the thread which
-	/// submitted it, except when the queue is the main queue or
-	/// a queue targetting it.
-	///
-	/// - parameter execute: The work item to be invoked on the queue.
-	/// - SeeAlso: `async(execute:)`
-	///
-	@available(macOS 10.10, iOS 8.0, *)
-	public func sync(execute workItem: DispatchWorkItem) {
-		CDispatch.dispatch_sync(self.__wrapped, workItem._block)
-	}
-
-	///
-	/// Submits a work item for asynchronous execution on a dispatch queue.
-	///
-	/// `async(execute:)` is the fundamental mechanism for submitting
-	/// work items to a dispatch queue.
-	///
-	/// Calls to `async(execute:)` always return immediately after the work item has
-	/// been submitted, and never wait for the work item to be invoked.
-	///
-	/// The target queue determines whether the work item will be invoked serially or
-	/// concurrently with respect to other work items submitted to that same queue.
-	/// Serial queues are processed concurrently with respect to each other.
-	///
-	/// - parameter execute: The work item to be invoked on the queue.
-	/// - SeeAlso: `sync(execute:)`
-	///
-	@available(macOS 10.10, iOS 8.0, *)
-	public func async(execute workItem: DispatchWorkItem) {
-		CDispatch.dispatch_async(self.__wrapped, workItem._block)
-	}
-
-	///
-	/// Submits a work item to a dispatch queue and associates it with the given
-	/// dispatch group. The dispatch group may be used to wait for the completion
-	/// of the work items it references.
-	///
-	/// - parameter group: the dispatch group to associate with the submitted block.
-	/// - parameter execute: The work item to be invoked on the queue.
-	/// - SeeAlso: `sync(execute:)`
-	///
-	@available(macOS 10.10, iOS 8.0, *)
-	public func async(group: DispatchGroup, execute workItem: DispatchWorkItem) {
-		CDispatch.dispatch_group_async(group.__wrapped, self.__wrapped, workItem._block)
-	}
-
-	///
-	/// Submits a work item to a dispatch queue and optionally associates it with a
-	/// dispatch group. The dispatch group may be used to wait for the completion
-	/// of the work items it references.
-	///
-	/// - parameter group: the dispatch group to associate with the submitted
-	/// work item. If this is `nil`, the work item is not associated with a group.
-	/// - parameter flags: flags that control the execution environment of the
-	/// - parameter qos: the QoS at which the work item should be executed.
-	///     Defaults to `DispatchQoS.unspecified`.
-	/// - parameter flags: flags that control the execution environment of the
-	/// work item.
-	/// - parameter execute: The work item to be invoked on the queue.
-	/// - SeeAlso: `sync(execute:)`
-	/// - SeeAlso: `DispatchQoS`
-	/// - SeeAlso: `DispatchWorkItemFlags`
-	///
-	public func async(
-		group: DispatchGroup? = nil,
-		qos: DispatchQoS = .unspecified,
-		flags: DispatchWorkItemFlags = [],
-		execute work: @escaping @convention(block) () -> Void)
-	{
-		if group == nil && qos == .unspecified {
-			// Fast-path route for the most common API usage
-			if flags.isEmpty {
-				CDispatch.dispatch_async(self.__wrapped, work)
-				return
-			} else if flags == .barrier {
-				CDispatch.dispatch_barrier_async(self.__wrapped, work)
-				return
-			}
-		}
-
-		var block: @convention(block) () -> Void = work
-		if #available(macOS 10.10, iOS 8.0, *), (qos != .unspecified || !flags.isEmpty) {
-			let workItem = DispatchWorkItem(qos: qos, flags: flags, block: work)
-			block = workItem._block
-		}
-
-		if let g = group {
-			CDispatch.dispatch_group_async(g.__wrapped, self.__wrapped, block)
-		} else {
-			CDispatch.dispatch_async(self.__wrapped, block)
-		}
-	}
-
-	private func _syncBarrier(block: () -> ()) {
-		CDispatch.dispatch_barrier_sync(self.__wrapped, block)
-	}
-
-	private func _syncHelper<T>(
-		fn: (() -> ()) -> (),
-		execute work: () throws -> T,
-		rescue: ((Swift.Error) throws -> (T))) rethrows -> T
-	{
-		var result: T?
-		var error: Swift.Error?
-		withoutActuallyEscaping(work) { _work in
-			fn {
-				do {
-					result = try _work()
-				} catch let e {
-					error = e
-				}
-			}
-		}
-		if let e = error {
-			return try rescue(e)
-		} else {
-			return result!
-		}
-	}
-
-	@available(macOS 10.10, iOS 8.0, *)
-	private func _syncHelper<T>(
-		fn: (DispatchWorkItem) -> (),
-		flags: DispatchWorkItemFlags,
-		execute work: () throws -> T,
-		rescue: @escaping ((Swift.Error) throws -> (T))) rethrows -> T
-	{
-		var result: T?
-		var error: Swift.Error?
-		let workItem = DispatchWorkItem(flags: flags, noescapeBlock: {
-			do {
-				result = try work()
-			} catch let e {
-				error = e
-			}
-		})
-		fn(workItem)
-		if let e = error {
-			return try rescue(e)
-		} else {
-			return result!
-		}
-	}
-
-	///
-	/// Submits a block for synchronous execution on this queue.
-	///
-	/// Submits a work item to a dispatch queue like `sync(execute:)`, and returns
-	/// the value, of type `T`, returned by that work item.
-	///
-	/// - parameter execute: The work item to be invoked on the queue.
-	/// - returns the value returned by the work item.
-	/// - SeeAlso: `sync(execute:)`
-	///
-	public func sync<T>(execute work: () throws -> T) rethrows -> T {
-		return try self._syncHelper(fn: sync, execute: work, rescue: { throw $0 })
-	}
-
-	///
-	/// Submits a block for synchronous execution on this queue.
-	///
-	/// Submits a work item to a dispatch queue like `sync(execute:)`, and returns
-	/// the value, of type `T`, returned by that work item.
-	///
-	/// - parameter flags: flags that control the execution environment of the
-	/// - parameter execute: The work item to be invoked on the queue.
-	/// - returns the value returned by the work item.
-	/// - SeeAlso: `sync(execute:)`
-	/// - SeeAlso: `DispatchWorkItemFlags`
-	///
-	public func sync<T>(flags: DispatchWorkItemFlags, execute work: () throws -> T) rethrows -> T {
-		if flags == .barrier {
-			return try self._syncHelper(fn: _syncBarrier, execute: work, rescue: { throw $0 })
-		} else if #available(macOS 10.10, iOS 8.0, *), !flags.isEmpty {
-			return try self._syncHelper(fn: sync, flags: flags, execute: work, rescue: { throw $0 })
-		} else {
-			return try self._syncHelper(fn: sync, execute: work, rescue: { throw $0 })
-		}
-	}
-
-	///
-	/// Submits a work item to a dispatch queue for asynchronous execution after
-	/// a specified time.
-	///
-	/// - parameter deadline: the time after which the work item should be executed,
-	/// given as a `DispatchTime`.
-	/// - parameter qos: the QoS at which the work item should be executed.
-	///	Defaults to `DispatchQoS.unspecified`.
-	/// - parameter flags: flags that control the execution environment of the
-	/// work item.
-	/// - parameter execute: The work item to be invoked on the queue.
-	/// - SeeAlso: `async(execute:)`
-	/// - SeeAlso: `asyncAfter(deadline:execute:)`
-	/// - SeeAlso: `DispatchQoS`
-	/// - SeeAlso: `DispatchWorkItemFlags`
-	/// - SeeAlso: `DispatchTime`
-	///
-	public func asyncAfter(
-		deadline: DispatchTime,
-		qos: DispatchQoS = .unspecified,
-		flags: DispatchWorkItemFlags = [],
-		execute work: @escaping @convention(block) () -> Void)
-	{
-		if #available(macOS 10.10, iOS 8.0, *), qos != .unspecified || !flags.isEmpty {
-			let item = DispatchWorkItem(qos: qos, flags: flags, block: work)
-			CDispatch.dispatch_after(deadline.rawValue, self.__wrapped, item._block)
-		} else {
-			CDispatch.dispatch_after(deadline.rawValue, self.__wrapped, work)
-		}
-	}
-
-	///
-	/// Submits a work item to a dispatch queue for asynchronous execution after
-	/// a specified time.
-	///
-	/// - parameter deadline: the time after which the work item should be executed,
-	/// given as a `DispatchWallTime`.
-	/// - parameter qos: the QoS at which the work item should be executed.
-	///	Defaults to `DispatchQoS.unspecified`.
-	/// - parameter flags: flags that control the execution environment of the
-	/// work item.
-	/// - parameter execute: The work item to be invoked on the queue.
-	/// - SeeAlso: `async(execute:)`
-	/// - SeeAlso: `asyncAfter(wallDeadline:execute:)`
-	/// - SeeAlso: `DispatchQoS`
-	/// - SeeAlso: `DispatchWorkItemFlags`
-	/// - SeeAlso: `DispatchWallTime`
-	///
-	public func asyncAfter(
-		wallDeadline: DispatchWallTime,
-		qos: DispatchQoS = .unspecified,
-		flags: DispatchWorkItemFlags = [],
-		execute work: @escaping @convention(block) () -> Void)
-	{
-		if #available(macOS 10.10, iOS 8.0, *), qos != .unspecified || !flags.isEmpty {
-			let item = DispatchWorkItem(qos: qos, flags: flags, block: work)
-			CDispatch.dispatch_after(wallDeadline.rawValue, self.__wrapped, item._block)
-		} else {
-			CDispatch.dispatch_after(wallDeadline.rawValue, self.__wrapped, work)
-		}
-	}
-
-	///
-	/// Submits a work item to a dispatch queue for asynchronous execution after
-	/// a specified time.
-	///
-	/// - parameter deadline: the time after which the work item should be executed,
-	/// given as a `DispatchTime`.
-	/// - parameter execute: The work item to be invoked on the queue.
-	/// - SeeAlso: `asyncAfter(deadline:qos:flags:execute:)`
-	/// - SeeAlso: `DispatchTime`
-	///
-	@available(macOS 10.10, iOS 8.0, *)
-	public func asyncAfter(deadline: DispatchTime, execute: DispatchWorkItem) {
-		CDispatch.dispatch_after(deadline.rawValue, self.__wrapped, execute._block)
-	}
-
-	///
-	/// Submits a work item to a dispatch queue for asynchronous execution after
-	/// a specified time.
-	///
-	/// - parameter deadline: the time after which the work item should be executed,
-	/// given as a `DispatchWallTime`.
-	/// - parameter execute: The work item to be invoked on the queue.
-	/// - SeeAlso: `asyncAfter(wallDeadline:qos:flags:execute:)`
-	/// - SeeAlso: `DispatchTime`
-	///
-	@available(macOS 10.10, iOS 8.0, *)
-	public func asyncAfter(wallDeadline: DispatchWallTime, execute: DispatchWorkItem) {
-		CDispatch.dispatch_after(wallDeadline.rawValue, self.__wrapped, execute._block)
-	}
-
-	@available(macOS 10.10, iOS 8.0, *)
-	public var qos: DispatchQoS {
-		var relPri: Int32 = 0
-		let cls = DispatchQoS.QoSClass(rawValue: _OSQoSClass(qosClass: dispatch_queue_get_qos_class(self.__wrapped, &relPri))!)!
-		return DispatchQoS(qosClass: cls, relativePriority: Int(relPri))
-	}
-
-	public func getSpecific<T>(key: DispatchSpecificKey<T>) -> T? {
-		let k = Unmanaged.passUnretained(key).toOpaque()
-		if let p = dispatch_queue_get_specific(self.__wrapped, k) {
-			let v = Unmanaged<_DispatchSpecificValue<T>>
-				.fromOpaque(p)
-				.takeUnretainedValue()
-			return v.value
-		}
-		return nil
-	}
-
-	public func setSpecific<T>(key: DispatchSpecificKey<T>, value: T?) {
-		let k = Unmanaged.passUnretained(key).toOpaque()
-		let v = value.map { _DispatchSpecificValue(value: $0) }
-		let p = v.map { Unmanaged.passRetained($0).toOpaque() }
-		dispatch_queue_set_specific(self.__wrapped, k, p, _destructDispatchSpecificValue)
-	}
-
-	#if os(Android)
-	public static func setThreadDetachCallback(_ cb: @escaping @convention(c) () -> Void) {
-		_dispatch_install_thread_detach_callback(cb)
-	}
-	#endif
-}
-
-private func _destructDispatchSpecificValue(ptr: UnsafeMutableRawPointer?) {
-	if let p = ptr {
-		Unmanaged<AnyObject>.fromOpaque(p).release()
-	}
-}
--- a/Telegram/ThirdParty/dispatch/src/swift/shims/DispatchOverlayShims.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/swift/shims/DispatchOverlayShims.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,253 +0,0 @@
-//===--- DispatchOverlayShims.h - Compatibility decls -----------*- C++ -*-===//
-//
-// This source file is part of the Swift.org open source project
-//
-// Copyright (c) 2014 - 2022 Apple Inc. and the Swift project authors
-// Licensed under Apache License v2.0 with Runtime Library Exception
-//
-// See https://swift.org/LICENSE.txt for license information
-// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
-//
-
-#ifndef SWIFT_SHIMS_DISPATCH_OVERLAY_SHIMS_H
-#define SWIFT_SHIMS_DISPATCH_OVERLAY_SHIMS_H
-
-#include <dispatch/dispatch.h>
-
-#ifdef __OBJC__
-#define SWIFT_DISPATCH_RETURNS_RETAINED __attribute__((__ns_returns_retained__))
-#else
-#define SWIFT_DISPATCH_RETURNS_RETAINED
-#endif
-
-#define SWIFT_DISPATCH_NOESCAPE __attribute__((__noescape__))
-
-#pragma clang assume_nonnull begin
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-typedef void (^__swift_shims_dispatch_block_t)(void);
-
-#ifdef __OBJC__
-typedef id __swift_shims_dispatch_data_t;
-#else
-typedef void *__swift_shims_dispatch_data_t;
-#endif
-
-
-static inline dispatch_queue_attr_t
-_swift_dispatch_queue_concurrent(void) {
-  return DISPATCH_QUEUE_CONCURRENT;
-}
-
-static inline dispatch_queue_t
-_swift_dispatch_get_main_queue(void) {
-  return dispatch_get_main_queue();
-}
-
-static inline dispatch_data_t
-_swift_dispatch_data_empty(void) {
-  return dispatch_data_empty;
-}
-
-static inline __swift_shims_dispatch_block_t _Nullable
-_swift_dispatch_data_destructor_default(void) {
-  return DISPATCH_DATA_DESTRUCTOR_DEFAULT;
-}
-
-static inline __swift_shims_dispatch_block_t
-_swift_dispatch_data_destructor_free(void) {
-  return _dispatch_data_destructor_free;
-}
-
-static inline __swift_shims_dispatch_block_t
-_swift_dispatch_data_destructor_munmap(void) {
-  return _dispatch_data_destructor_munmap;
-}
-
-#define SWIFT_DISPATCH_SOURCE_TYPE(t)                                          \
-  static inline dispatch_source_type_t _swift_dispatch_source_type_##t(void) { \
-    return DISPATCH_SOURCE_TYPE_##t;                                           \
-  }
-
-SWIFT_DISPATCH_SOURCE_TYPE(DATA_ADD)
-SWIFT_DISPATCH_SOURCE_TYPE(DATA_OR)
-SWIFT_DISPATCH_SOURCE_TYPE(DATA_REPLACE)
-SWIFT_DISPATCH_SOURCE_TYPE(READ)
-SWIFT_DISPATCH_SOURCE_TYPE(SIGNAL)
-SWIFT_DISPATCH_SOURCE_TYPE(TIMER)
-SWIFT_DISPATCH_SOURCE_TYPE(WRITE)
-
-#if __APPLE__
-SWIFT_DISPATCH_SOURCE_TYPE(MACH_SEND)
-SWIFT_DISPATCH_SOURCE_TYPE(MACH_RECV)
-SWIFT_DISPATCH_SOURCE_TYPE(MEMORYPRESSURE)
-SWIFT_DISPATCH_SOURCE_TYPE(PROC)
-SWIFT_DISPATCH_SOURCE_TYPE(VNODE)
-#endif
-
-extern void
-_swift_dispatch_source_create_abort(void);
-
-SWIFT_DISPATCH_RETURNS_RETAINED
-static inline dispatch_source_t
-_swift_dispatch_source_create(
-    dispatch_source_type_t type,
-	uintptr_t handle,
-	unsigned long mask,
-	dispatch_queue_t _Nullable queue)
-{
-  dispatch_source_t source = dispatch_source_create(type, handle, mask, queue);
-  if (!source) {
-    _swift_dispatch_source_create_abort();
-  }
-  return source;
-}
-
-static inline SWIFT_DISPATCH_RETURNS_RETAINED __swift_shims_dispatch_block_t
-_swift_dispatch_block_create_with_qos_class(
-    dispatch_block_flags_t flags, dispatch_qos_class_t qos,
-    int relative_priority, __swift_shims_dispatch_block_t _Nonnull block) {
-  return dispatch_block_create_with_qos_class(
-      flags, qos, relative_priority, block);
-}
-
-static inline __swift_shims_dispatch_block_t
-_swift_dispatch_block_create_noescape(
-    dispatch_block_flags_t flags,
-    __swift_shims_dispatch_block_t SWIFT_DISPATCH_NOESCAPE block) {
-  return dispatch_block_create(flags, block);
-}
-
-static inline int _swift_dispatch_block_wait(
-    __swift_shims_dispatch_block_t block,
-    unsigned long long timeout) {
-  return dispatch_block_wait(block, timeout);
-}
-
-static inline void _swift_dispatch_block_notify(
-    __swift_shims_dispatch_block_t block,
-    dispatch_queue_t queue,
-    __swift_shims_dispatch_block_t notifier) {
-  dispatch_block_notify(block, queue, notifier);
-}
-
-static inline void _swift_dispatch_block_cancel(
-    __swift_shims_dispatch_block_t block) {
-  dispatch_block_cancel(block);
-}
-
-static inline int _swift_dispatch_block_testcancel(
-    __swift_shims_dispatch_block_t block) {
-  return dispatch_block_testcancel(block);
-}
-
-static inline void _swift_dispatch_async(
-    dispatch_queue_t queue,
-    __swift_shims_dispatch_block_t block) {
-  dispatch_async(queue, block);
-}
-
-static inline void _swift_dispatch_sync(
-    dispatch_queue_t queue,
-    __swift_shims_dispatch_block_t block) {
-  dispatch_sync(queue, block);
-}
-
-static inline void _swift_dispatch_barrier_async(
-    dispatch_queue_t queue,
-    __swift_shims_dispatch_block_t block) {
-  dispatch_barrier_async(queue, block);
-}
-
-static inline void _swift_dispatch_group_async(
-    dispatch_group_t group,
-    dispatch_queue_t queue,
-    __swift_shims_dispatch_block_t block) {
-  dispatch_group_async((dispatch_group_t)group, queue, block);
-}
-
-static inline void _swift_dispatch_group_notify(
-    dispatch_group_t group,
-    dispatch_queue_t queue,
-    __swift_shims_dispatch_block_t block) {
-  dispatch_group_notify(group, queue, block);
-}
-
-static inline void _swift_dispatch_after(
-    dispatch_time_t when,
-    dispatch_queue_t queue,
-    __swift_shims_dispatch_block_t block) {
-  dispatch_after(when, queue, block);
-}
-
-
-static inline void _swift_dispatch_apply_current(
-    size_t iterations,
-    void SWIFT_DISPATCH_NOESCAPE (^block)(intptr_t)) {
-  dispatch_apply(iterations, (dispatch_queue_t _Nonnull)0, ^(size_t i){
-    block((intptr_t)i);
-  });
-}
-
-SWIFT_DISPATCH_RETURNS_RETAINED
-static inline __swift_shims_dispatch_data_t
-_swift_dispatch_data_create(
-    const void *buffer,
-    size_t size,
-    dispatch_queue_t _Nullable queue,
-    __swift_shims_dispatch_block_t _Nullable destructor) {
-  return dispatch_data_create(buffer, size, queue, destructor);
-}
-
-typedef unsigned int (^__swift_shims_dispatch_data_applier)(__swift_shims_dispatch_data_t, size_t, const void *, size_t);
-
-static inline unsigned int
-_swift_dispatch_data_apply(
-    __swift_shims_dispatch_data_t data,
-    __swift_shims_dispatch_data_applier SWIFT_DISPATCH_NOESCAPE applier) {
-  return dispatch_data_apply((dispatch_data_t)data, ^bool(dispatch_data_t data, size_t off, const void *loc, size_t size){
-    return applier((__swift_shims_dispatch_data_t)data, off, loc, size);
-  });
-}
-
-static inline void _swift_dispatch_source_set_event_handler(
-    dispatch_source_t source,
-    __swift_shims_dispatch_block_t _Nullable block) {
-  dispatch_source_set_event_handler(source, block);
-}
-
-static inline void _swift_dispatch_source_set_cancel_handler(
-    dispatch_source_t source,
-    __swift_shims_dispatch_block_t _Nullable block) {
-  dispatch_source_set_cancel_handler(source, block);
-}
-
-static inline void _swift_dispatch_source_set_registration_handler(
-    dispatch_source_t source,
-    __swift_shims_dispatch_block_t _Nullable block) {
-  dispatch_source_set_registration_handler(source, block);
-}
-
-#if defined(__ANDROID__)
-extern void _dispatch_install_thread_detach_callback(void (*cb)(void));
-#endif
-
-static inline void _swift_dispatch_retain(dispatch_object_t object) {
-  dispatch_retain(object);
-}
-
-static inline void _swift_dispatch_release(dispatch_object_t object) {
-  dispatch_release(object);
-}
-
-#ifdef __cplusplus
-} // extern "C"
-#endif
-
-#pragma clang assume_nonnull end
-
-#endif // SWIFT_SHIMS_DISPATCH_OVERLAY_SHIMS_H
-
--- a/Telegram/ThirdParty/dispatch/src/swift/shims/module.modulemap	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/swift/shims/module.modulemap	1970-01-01 00:00:00.000000000 -0000
@@ -1,3 +0,0 @@
-module _DispatchOverlayShims {
-  header "DispatchOverlayShims.h"
-}
--- a/Telegram/ThirdParty/dispatch/src/swift/Source.swift	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/swift/Source.swift	1970-01-01 00:00:00.000000000 -0000
@@ -1,699 +0,0 @@
-//===----------------------------------------------------------------------===//
-//
-// This source file is part of the Swift.org open source project
-//
-// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
-// Licensed under Apache License v2.0 with Runtime Library Exception
-//
-// See https://swift.org/LICENSE.txt for license information
-// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
-//
-//===----------------------------------------------------------------------===//
-
-import CDispatch
-@_implementationOnly import _DispatchOverlayShims
-#if os(Windows)
-import WinSDK
-#endif
-
-extension DispatchSourceProtocol {
-
-	public func setEventHandler(qos: DispatchQoS = .unspecified, flags: DispatchWorkItemFlags = [], handler: DispatchSourceHandler?) {
-		if #available(macOS 10.10, iOS 8.0, *), let h = handler, qos != .unspecified || !flags.isEmpty {
-			let item = DispatchWorkItem(qos: qos, flags: flags, block: h)
-			CDispatch.dispatch_source_set_event_handler((self as! DispatchSource).__wrapped, item._block)
-		} else {
-			CDispatch.dispatch_source_set_event_handler((self as! DispatchSource).__wrapped, handler)
-		}
-	}
-
-	@available(macOS 10.10, iOS 8.0, *)
-	public func setEventHandler(handler: DispatchWorkItem) {
-		CDispatch.dispatch_source_set_event_handler((self as! DispatchSource).__wrapped, handler._block)
-	}
-
-	public func setCancelHandler(qos: DispatchQoS = .unspecified, flags: DispatchWorkItemFlags = [], handler: DispatchSourceHandler?) {
-		if #available(macOS 10.10, iOS 8.0, *), let h = handler, qos != .unspecified || !flags.isEmpty {
-			let item = DispatchWorkItem(qos: qos, flags: flags, block: h)
-			CDispatch.dispatch_source_set_cancel_handler((self as! DispatchSource).__wrapped, item._block)
-		} else {
-			CDispatch.dispatch_source_set_cancel_handler((self as! DispatchSource).__wrapped, handler)
-		}
-	}
-
-	@available(macOS 10.10, iOS 8.0, *)
-	public func setCancelHandler(handler: DispatchWorkItem) {
-		CDispatch.dispatch_source_set_cancel_handler((self as! DispatchSource).__wrapped, handler._block)
-	}
-
-	public func setRegistrationHandler(qos: DispatchQoS = .unspecified, flags: DispatchWorkItemFlags = [], handler: DispatchSourceHandler?) {
-		if #available(macOS 10.10, iOS 8.0, *), let h = handler, qos != .unspecified || !flags.isEmpty {
-			let item = DispatchWorkItem(qos: qos, flags: flags, block: h)
-			CDispatch.dispatch_source_set_registration_handler((self as! DispatchSource).__wrapped, item._block)
-		} else {
-			CDispatch.dispatch_source_set_registration_handler((self as! DispatchSource).__wrapped, handler)
-		}
-	}
-
-	@available(macOS 10.10, iOS 8.0, *)
-	public func setRegistrationHandler(handler: DispatchWorkItem) {
-		CDispatch.dispatch_source_set_registration_handler((self as! DispatchSource).__wrapped, handler._block)
-	}
-
-	@available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
-	public func activate() {
-		(self as! DispatchSource).activate()
-	}
-
-	public func cancel() {
-		CDispatch.dispatch_source_cancel((self as! DispatchSource).__wrapped)
-	}
-
-	public func resume() {
-		(self as! DispatchSource).resume()
-	}
-
-	public func suspend() {
-		(self as! DispatchSource).suspend()
-	}
-
-	public var handle: UInt {
-		return CDispatch.dispatch_source_get_handle((self as! DispatchSource).__wrapped)
-	}
-
-	public var mask: UInt {
-		return CDispatch.dispatch_source_get_mask((self as! DispatchSource).__wrapped)
-	}
-
-	public var data: UInt {
-		return CDispatch.dispatch_source_get_data((self as! DispatchSource).__wrapped)
-	}
-
-	public var isCancelled: Bool {
-		return CDispatch.dispatch_source_testcancel((self as! DispatchSource).__wrapped) != 0
-	}
-}
-
-extension DispatchSource {
-#if HAVE_MACH
-	public struct MachSendEvent : OptionSet, RawRepresentable {
-		public let rawValue: UInt
-		public init(rawValue: UInt) { self.rawValue = rawValue }
-
-		public static let dead = MachSendEvent(rawValue: 0x1)
-	}
-#endif
-
-#if HAVE_MACH
-	public struct MemoryPressureEvent : OptionSet, RawRepresentable {
-		public let rawValue: UInt
-		public init(rawValue: UInt) { self.rawValue = rawValue }
-
-		public static let normal = MemoryPressureEvent(rawValue: 0x1)
-		public static let warning = MemoryPressureEvent(rawValue: 0x2)
-		public static let critical = MemoryPressureEvent(rawValue: 0x4)
-		public static let all: MemoryPressureEvent = [.normal, .warning, .critical]
-	}
-#endif
-
-#if !os(Linux) && !os(Android) && !os(Windows)
-	public struct ProcessEvent : OptionSet, RawRepresentable {
-		public let rawValue: UInt
-		public init(rawValue: UInt) { self.rawValue = rawValue }
-
-		public static let exit = ProcessEvent(rawValue: 0x80000000)
-		public static let fork = ProcessEvent(rawValue: 0x40000000)
-		public static let exec = ProcessEvent(rawValue: 0x20000000)
-		public static let signal = ProcessEvent(rawValue: 0x08000000)
-		public static let all: ProcessEvent = [.exit, .fork, .exec, .signal]
-	}
-#endif
-
-	public struct TimerFlags : OptionSet, RawRepresentable {
-		public let rawValue: UInt
-		public init(rawValue: UInt) { self.rawValue = rawValue }
-
-		public static let strict = TimerFlags(rawValue: 1)
-	}
-
-	public struct FileSystemEvent : OptionSet, RawRepresentable {
-		public let rawValue: UInt
-		public init(rawValue: UInt) { self.rawValue = rawValue }
-
-		public static let delete = FileSystemEvent(rawValue: 0x1)
-		public static let write = FileSystemEvent(rawValue: 0x2)
-		public static let extend = FileSystemEvent(rawValue: 0x4)
-		public static let attrib = FileSystemEvent(rawValue: 0x8)
-		public static let link = FileSystemEvent(rawValue: 0x10)
-		public static let rename = FileSystemEvent(rawValue: 0x20)
-		public static let revoke = FileSystemEvent(rawValue: 0x40)
-		public static let funlock = FileSystemEvent(rawValue: 0x100)
-
-		public static let all: FileSystemEvent = [
-			.delete, .write, .extend, .attrib, .link, .rename, .revoke]
-	}
-
-#if HAVE_MACH
-	public class func makeMachSendSource(port: mach_port_t, eventMask: MachSendEvent, queue: DispatchQueue? = nil) -> DispatchSourceMachSend {
-		let source = dispatch_source_create(_swift_dispatch_source_type_MACH_SEND(), UInt(port), eventMask.rawValue, queue?.__wrapped)
-		return DispatchSource(source: source) as DispatchSourceMachSend
-	}
-#endif
-
-#if HAVE_MACH
-	public class func makeMachReceiveSource(port: mach_port_t, queue: DispatchQueue? = nil) -> DispatchSourceMachReceive {
-		let source = dispatch_source_create(_swift_dispatch_source_type_MACH_RECV(), UInt(port), 0, queue?.__wrapped)
-		return DispatchSource(source) as DispatchSourceMachReceive
-	}
-#endif
-
-#if HAVE_MACH
-	public class func makeMemoryPressureSource(eventMask: MemoryPressureEvent, queue: DispatchQueue? = nil) -> DispatchSourceMemoryPressure {
-		let source = dispatch_source_create(_swift_dispatch_source_type_MEMORYPRESSURE(), 0, eventMask.rawValue, queue.__wrapped)
-		return DispatchSourceMemoryPressure(source)
-	}
-#endif
-
-#if !os(Linux) && !os(Android) && !os(Windows)
-	public class func makeProcessSource(identifier: pid_t, eventMask: ProcessEvent, queue: DispatchQueue? = nil) -> DispatchSourceProcess {
-		let source = dispatch_source_create(_swift_dispatch_source_type_PROC(), UInt(identifier), eventMask.rawValue, queue?.__wrapped)
-		return DispatchSource(source: source) as DispatchSourceProcess
-	}
-#endif
-
-#if os(Windows)
-	public class func makeReadSource(handle: HANDLE, queue: DispatchQueue? = nil) -> DispatchSourceRead {
-		let source = dispatch_source_create(_swift_dispatch_source_type_READ(), UInt(bitPattern: handle), 0, queue?.__wrapped)
-		return DispatchSource(source: source) as DispatchSourceRead
-	}
-#endif
-
-	public class func makeReadSource(fileDescriptor: Int32, queue: DispatchQueue? = nil) -> DispatchSourceRead {
-#if os(Windows)
-		let handle: UInt = UInt(_get_osfhandle(fileDescriptor))
-		if handle == UInt(bitPattern: INVALID_HANDLE_VALUE) { fatalError("unable to get underlying handle from file descriptor") }
-#else
-		let handle: UInt = UInt(fileDescriptor)
-#endif
-		let source = dispatch_source_create(_swift_dispatch_source_type_READ(), handle, 0, queue?.__wrapped)
-		return DispatchSource(source: source) as DispatchSourceRead
-	}
-
-	public class func makeSignalSource(signal: Int32, queue: DispatchQueue? = nil) -> DispatchSourceSignal {
-		let source = dispatch_source_create(_swift_dispatch_source_type_SIGNAL(), UInt(signal), 0, queue?.__wrapped)
-		return DispatchSource(source: source) as DispatchSourceSignal
-	}
-
-	public class func makeTimerSource(flags: TimerFlags = [], queue: DispatchQueue? = nil) -> DispatchSourceTimer {
-		let source = dispatch_source_create(_swift_dispatch_source_type_TIMER(), 0, UInt(flags.rawValue), queue?.__wrapped)
-		return DispatchSource(source: source) as DispatchSourceTimer
-	}
-
-	public class func makeUserDataAddSource(queue: DispatchQueue? = nil) -> DispatchSourceUserDataAdd {
-		let source = dispatch_source_create(_swift_dispatch_source_type_DATA_ADD(), 0, 0, queue?.__wrapped)
-		return DispatchSource(source: source) as DispatchSourceUserDataAdd
-	}
-
-	public class func makeUserDataOrSource(queue: DispatchQueue? = nil) -> DispatchSourceUserDataOr {
-		let source = dispatch_source_create(_swift_dispatch_source_type_DATA_OR(), 0, 0, queue?.__wrapped)
-		return DispatchSource(source: source) as DispatchSourceUserDataOr
-	}
-    
-	public class func makeUserDataReplaceSource(queue: DispatchQueue? = nil) -> DispatchSourceUserDataReplace {
-		let source = dispatch_source_create(_swift_dispatch_source_type_DATA_REPLACE(), 0, 0, queue?.__wrapped)
-		return DispatchSource(source: source) as DispatchSourceUserDataReplace
-	}
-
-#if !os(Linux) && !os(Android) && !os(Windows)
-	public class func makeFileSystemObjectSource(fileDescriptor: Int32, eventMask: FileSystemEvent, queue: DispatchQueue? = nil) -> DispatchSourceFileSystemObject {
-		let source = dispatch_source_create(_swift_dispatch_source_type_VNODE(), UInt(fileDescriptor), eventMask.rawValue, queue?.__wrapped)
-		return DispatchSource(source: source) as DispatchSourceFileSystemObject
-	}
-#endif
-
-#if os(Windows)
-	public class func makeWriteSource(handle: HANDLE, queue: DispatchQueue? = nil) -> DispatchSourceWrite {
-		let source = dispatch_source_create(_swift_dispatch_source_type_WRITE(), UInt(bitPattern: handle), 0, queue?.__wrapped)
-		return DispatchSource(source: source) as DispatchSourceWrite
-	}
-#endif
-
-	public class func makeWriteSource(fileDescriptor: Int32, queue: DispatchQueue? = nil) -> DispatchSourceWrite {
-#if os(Windows)
-		let handle: UInt = UInt(_get_osfhandle(fileDescriptor))
-		if handle == UInt(bitPattern: INVALID_HANDLE_VALUE) { fatalError("unable to get underlying handle from file descriptor") }
-#else
-		let handle: UInt = UInt(fileDescriptor)
-#endif
-		let source = dispatch_source_create(_swift_dispatch_source_type_WRITE(), handle, 0, queue?.__wrapped)
-		return DispatchSource(source: source) as DispatchSourceWrite
-	}
-}
-
-#if HAVE_MACH
-extension DispatchSourceMachSend {
-	public var handle: mach_port_t {
-		return mach_port_t(dispatch_source_get_handle(self as! DispatchSource))
-	}
-
-	public var data: DispatchSource.MachSendEvent {
-		let data = dispatch_source_get_data(self as! DispatchSource)
-		return DispatchSource.MachSendEvent(rawValue: data)
-	}
-
-	public var mask: DispatchSource.MachSendEvent {
-		let mask = dispatch_source_get_mask(self as! DispatchSource)
-		return DispatchSource.MachSendEvent(rawValue: mask)
-	}
-}
-#endif
-
-#if HAVE_MACH
-extension DispatchSourceMachReceive {
-	public var handle: mach_port_t {
-		return mach_port_t(dispatch_source_get_handle(self as! DispatchSource))
-	}
-}
-#endif
-
-#if HAVE_MACH
-extension DispatchSourceMemoryPressure {
-	public var data: DispatchSource.MemoryPressureEvent {
-		let data = dispatch_source_get_data(self as! DispatchSource)
-		return DispatchSource.MemoryPressureEvent(rawValue: data)
-	}
-
-	public var mask: DispatchSource.MemoryPressureEvent {
-		let mask = dispatch_source_get_mask(self as! DispatchSource)
-		return DispatchSource.MemoryPressureEvent(rawValue: mask)
-	}
-}
-#endif
-
-#if !os(Linux) && !os(Android) && !os(Windows)
-extension DispatchSourceProcess {
-	public var handle: pid_t {
-		return pid_t(dispatch_source_get_handle(self as! DispatchSource))
-	}
-
-	public var data: DispatchSource.ProcessEvent {
-		return DispatchSource.ProcessEvent(rawValue: (self as! DispatchSource).data)
-	}
-
-	public var mask: DispatchSource.ProcessEvent {
-		return DispatchSource.ProcessEvent(rawValue: (self as! DispatchSource).mask)
-	}
-}
-#endif
-
-extension DispatchSourceTimer {
-	///
-	/// Sets the deadline and leeway for a timer event that fires once.
-	///
-	/// Once this function returns, any pending source data accumulated for the previous timer values
-	/// has been cleared and the next timer event will occur at `deadline`.
-	///
-	/// Delivery of the timer event may be delayed by the system in order to improve power consumption
-	/// and system performance. The upper limit to the allowable delay may be configured with the `leeway`
-	/// argument; the lower limit is under the control of the system.
-	///
-	/// The lower limit to the allowable delay may vary with process state such as visibility of the
-	/// application UI. If the timer source was created with flags `TimerFlags.strict`, the system
-	/// will make a best effort to strictly observe the provided `leeway` value, even if it is smaller
-	/// than the current lower limit. Note that a minimal amount of delay is to be expected even if
-	/// this flag is specified.
-	///
-	/// Calling this method has no effect if the timer source has already been canceled.
-	/// - note: Delivery of the timer event does not cancel the timer source.
-	///
-	/// - parameter deadline: the time at which the timer event will be delivered, subject to the
-	///     leeway and other considerations described above. The deadline is based on Mach absolute
-	///     time.
-	/// - parameter leeway: the leeway for the timer.
-	///
-	@available(swift, deprecated: 4, renamed: "schedule(deadline:repeating:leeway:)")
-	public func scheduleOneshot(deadline: DispatchTime, leeway: DispatchTimeInterval = .nanoseconds(0)) {
-		dispatch_source_set_timer((self as! DispatchSource).__wrapped, deadline.rawValue, ~0, UInt64(leeway.rawValue))
-	}
-
-	///
-	/// Sets the deadline and leeway for a timer event that fires once.
-	///
-	/// Once this function returns, any pending source data accumulated for the previous timer values
-	/// has been cleared and the next timer event will occur at `wallDeadline`.
-	///
-	/// Delivery of the timer event may be delayed by the system in order to improve power consumption
-	/// and system performance. The upper limit to the allowable delay may be configured with the `leeway`
-	/// argument; the lower limit is under the control of the system.
-	///
-	/// The lower limit to the allowable delay may vary with process state such as visibility of the
-	/// application UI. If the timer source was created with flags `TimerFlags.strict`, the system
-	/// will make a best effort to strictly observe the provided `leeway` value, even if it is smaller
-	/// than the current lower limit. Note that a minimal amount of delay is to be expected even if
-	/// this flag is specified.
-	///
-	/// Calling this method has no effect if the timer source has already been canceled.
-	/// - note: Delivery of the timer event does not cancel the timer source.
-	///
-	/// - parameter wallDeadline: the time at which the timer event will be delivered, subject to the
-	///     leeway and other considerations described above. The deadline is based on
-	///     `gettimeofday(3)`.
-	/// - parameter leeway: the leeway for the timer.
-	///
-	@available(swift, deprecated: 4, renamed: "schedule(wallDeadline:repeating:leeway:)")
-	public func scheduleOneshot(wallDeadline: DispatchWallTime, leeway: DispatchTimeInterval = .nanoseconds(0)) {
-		dispatch_source_set_timer((self as! DispatchSource).__wrapped, wallDeadline.rawValue, ~0, UInt64(leeway.rawValue))
-	}
-
-	///
-	/// Sets the deadline, interval and leeway for a timer event that fires at least once.
-	///
-	/// Once this function returns, any pending source data accumulated for the previous timer values
-	/// has been cleared. The next timer event will occur at `deadline` and every `interval` units of
-	/// time thereafter until the timer source is canceled.
-	///
-	/// Delivery of a timer event may be delayed by the system in order to improve power consumption
-	/// and system performance. The upper limit to the allowable delay may be configured with the `leeway`
-	/// argument; the lower limit is under the control of the system.
-	///
-	/// For the initial timer fire at `deadline`, the upper limit to the allowable delay is set to
-	/// `leeway`. For the subsequent timer fires at `deadline + N * interval`, the upper
-	/// limit is the smaller of `leeway` and `interval/2`.
-	///
-	/// The lower limit to the allowable delay may vary with process state such as visibility of the
-	/// application UI. If the timer source was created with flags `TimerFlags.strict`, the system
-	/// will make a best effort to strictly observe the provided `leeway` value, even if it is smaller
-	/// than the current lower limit. Note that a minimal amount of delay is to be expected even if
-	/// this flag is specified.
-	///
-	/// Calling this method has no effect if the timer source has already been canceled.
-	///
-	/// - parameter deadline: the time at which the timer event will be delivered, subject to the
-	///     leeway and other considerations described above. The deadline is based on Mach absolute
-	///     time.
-	/// - parameter interval: the interval for the timer.
-	/// - parameter leeway: the leeway for the timer.
-	///
-	@available(swift, deprecated: 4, renamed: "schedule(deadline:repeating:leeway:)")
-	public func scheduleRepeating(deadline: DispatchTime, interval: DispatchTimeInterval, leeway: DispatchTimeInterval = .nanoseconds(0)) {
-		dispatch_source_set_timer((self as! DispatchSource).__wrapped, deadline.rawValue, interval == .never ? ~0 : UInt64(interval.rawValue), UInt64(leeway.rawValue))
-	}
-
-	///
-	/// Sets the deadline, interval and leeway for a timer event that fires at least once.
-	///
-	/// Once this function returns, any pending source data accumulated for the previous timer values
-	/// has been cleared. The next timer event will occur at `deadline` and every `interval` seconds
-	/// thereafter until the timer source is canceled.
-	///
-	/// Delivery of a timer event may be delayed by the system in order to improve power consumption and
-	/// system performance. The upper limit to the allowable delay may be configured with the `leeway`
-	/// argument; the lower limit is under the control of the system.
-	///
-	/// For the initial timer fire at `deadline`, the upper limit to the allowable delay is set to
-	/// `leeway`. For the subsequent timer fires at `deadline + N * interval`, the upper
-	/// limit is the smaller of `leeway` and `interval/2`.
-	///
-	/// The lower limit to the allowable delay may vary with process state such as visibility of the
-	/// application UI. If the timer source was created with flags `TimerFlags.strict`, the system
-	/// will make a best effort to strictly observe the provided `leeway` value, even if it is smaller
-	/// than the current lower limit. Note that a minimal amount of delay is to be expected even if
-	/// this flag is specified.
-	///
-	/// Calling this method has no effect if the timer source has already been canceled.
-	///
-	/// - parameter deadline: the time at which the timer event will be delivered, subject to the
-	///     leeway and other considerations described above. The deadline is based on Mach absolute
-	///     time.
-	/// - parameter interval: the interval for the timer in seconds.
-	/// - parameter leeway: the leeway for the timer.
-	///
-	@available(swift, deprecated: 4, renamed: "schedule(deadline:repeating:leeway:)")
-	public func scheduleRepeating(deadline: DispatchTime, interval: Double, leeway: DispatchTimeInterval = .nanoseconds(0)) {
-		dispatch_source_set_timer((self as! DispatchSource).__wrapped, deadline.rawValue, interval.isInfinite ? ~0 : UInt64(interval * Double(NSEC_PER_SEC)), UInt64(leeway.rawValue))
-	}
-
-	///
-	/// Sets the deadline, interval and leeway for a timer event that fires at least once.
-	///
-	/// Once this function returns, any pending source data accumulated for the previous timer values
-	/// has been cleared. The next timer event will occur at `wallDeadline` and every `interval` units of
-	/// time thereafter until the timer source is canceled.
-	///
-	/// Delivery of a timer event may be delayed by the system in order to improve power consumption and
-	/// system performance. The upper limit to the allowable delay may be configured with the `leeway`
-	/// argument; the lower limit is under the control of the system.
-	///
-	/// For the initial timer fire at `wallDeadline`, the upper limit to the allowable delay is set to
-	/// `leeway`. For the subsequent timer fires at `wallDeadline + N * interval`, the upper
-	/// limit is the smaller of `leeway` and `interval/2`.
-	///
-	/// The lower limit to the allowable delay may vary with process state such as visibility of the
-	/// application UI. If the timer source was created with flags `TimerFlags.strict`, the system
-	/// will make a best effort to strictly observe the provided `leeway` value, even if it is smaller
-	/// than the current lower limit. Note that a minimal amount of delay is to be expected even if
-	/// this flag is specified.
-	///
-	/// Calling this method has no effect if the timer source has already been canceled.
-	///
-	/// - parameter wallDeadline: the time at which the timer event will be delivered, subject to the
-	///     leeway and other considerations described above. The deadline is based on
-	///     `gettimeofday(3)`.
-	/// - parameter interval: the interval for the timer.
-	/// - parameter leeway: the leeway for the timer.
-	///
-	@available(swift, deprecated: 4, renamed: "schedule(wallDeadline:repeating:leeway:)")
-	public func scheduleRepeating(wallDeadline: DispatchWallTime, interval: DispatchTimeInterval, leeway: DispatchTimeInterval = .nanoseconds(0)) {
-		dispatch_source_set_timer((self as! DispatchSource).__wrapped, wallDeadline.rawValue, interval == .never ? ~0 : UInt64(interval.rawValue), UInt64(leeway.rawValue))
-	}
-
-	///
-	/// Sets the deadline, interval and leeway for a timer event that fires at least once.
-	///
-	/// Once this function returns, any pending source data accumulated for the previous timer values
-	/// has been cleared. The next timer event will occur at `wallDeadline` and every `interval` seconds
-	/// thereafter until the timer source is canceled.
-	///
-	/// Delivery of a timer event may be delayed by the system in order to improve power consumption and
-	/// system performance. The upper limit to the allowable delay may be configured with the `leeway`
-	/// argument; the lower limit is under the control of the system.
-	///
-	/// For the initial timer fire at `wallDeadline`, the upper limit to the allowable delay is set to
-	/// `leeway`. For the subsequent timer fires at `wallDeadline + N * interval`, the upper
-	/// limit is the smaller of `leeway` and `interval/2`.
-	///
-	/// The lower limit to the allowable delay may vary with process state such as visibility of the
-	/// application UI. If the timer source was created with flags `TimerFlags.strict`, the system
-	/// will make a best effort to strictly observe the provided `leeway` value, even if it is smaller
-	/// than the current lower limit. Note that a minimal amount of delay is to be expected even if
-	/// this flag is specified.
-	///
-	/// Calling this method has no effect if the timer source has already been canceled.
-	///
-	/// - parameter wallDeadline: the time at which the timer event will be delivered, subject to the
-	///     leeway and other considerations described above. The deadline is based on
-	///     `gettimeofday(3)`.
-	/// - parameter interval: the interval for the timer in seconds.
-	/// - parameter leeway: the leeway for the timer.
-	///
-	@available(swift, deprecated: 4, renamed: "schedule(wallDeadline:repeating:leeway:)")
-	public func scheduleRepeating(wallDeadline: DispatchWallTime, interval: Double, leeway: DispatchTimeInterval = .nanoseconds(0)) {
-		dispatch_source_set_timer((self as! DispatchSource).__wrapped, wallDeadline.rawValue, interval.isInfinite ? ~0 : UInt64(interval * Double(NSEC_PER_SEC)), UInt64(leeway.rawValue))
-	}
-
-	///
-	/// Sets the deadline, repeat interval and leeway for a timer event.
-	///
-	/// Once this function returns, any pending source data accumulated for the previous timer values
-	/// has been cleared. The next timer event will occur at `deadline` and every `repeating` units of
-	/// time thereafter until the timer source is canceled. If the value of `repeating` is `.never`,
-	/// or is defaulted, the timer fires only once.
-	///
-	/// Delivery of a timer event may be delayed by the system in order to improve power consumption
-	/// and system performance. The upper limit to the allowable delay may be configured with the `leeway`
-	/// argument; the lower limit is under the control of the system.
-	///
-	/// For the initial timer fire at `deadline`, the upper limit to the allowable delay is set to
-	/// `leeway`. For the subsequent timer fires at `deadline + N * repeating`, the upper
-	/// limit is the smaller of `leeway` and `repeating/2`.
-	///
-	/// The lower limit to the allowable delay may vary with process state such as visibility of the
-	/// application UI. If the timer source was created with flags `TimerFlags.strict`, the system
-	/// will make a best effort to strictly observe the provided `leeway` value, even if it is smaller
-	/// than the current lower limit. Note that a minimal amount of delay is to be expected even if
-	/// this flag is specified.
-	///
-	/// Calling this method has no effect if the timer source has already been canceled.
-	///
-	/// - parameter deadline: the time at which the first timer event will be delivered, subject to the
-	///     leeway and other considerations described above. The deadline is based on Mach absolute
-	///     time.
-	/// - parameter repeating: the repeat interval for the timer, or `.never` if the timer should fire
-	///		only once.
-	/// - parameter leeway: the leeway for the timer.
-	///
-	@available(swift, introduced: 4)
-	public func schedule(deadline: DispatchTime, repeating interval: DispatchTimeInterval = .never, leeway: DispatchTimeInterval = .nanoseconds(0)) {
-		dispatch_source_set_timer((self as! DispatchSource).__wrapped, deadline.rawValue, interval == .never ? ~0 : UInt64(interval.rawValue), UInt64(leeway.rawValue))
-	}
-
-	///
-	/// Sets the deadline, repeat interval and leeway for a timer event.
-	///
-	/// Once this function returns, any pending source data accumulated for the previous timer values
-	/// has been cleared. The next timer event will occur at `deadline` and every `repeating` seconds
-	/// thereafter until the timer source is canceled. If the value of `repeating` is `.infinity`,
-	/// the timer fires only once.
-	///
-	/// Delivery of a timer event may be delayed by the system in order to improve power consumption
-	/// and system performance. The upper limit to the allowable delay may be configured with the `leeway`
-	/// argument; the lower limit is under the control of the system.
-	///
-	/// For the initial timer fire at `deadline`, the upper limit to the allowable delay is set to
-	/// `leeway`. For the subsequent timer fires at `deadline + N * repeating`, the upper
-	/// limit is the smaller of `leeway` and `repeating/2`.
-	///
-	/// The lower limit to the allowable delay may vary with process state such as visibility of the
-	/// application UI. If the timer source was created with flags `TimerFlags.strict`, the system
-	/// will make a best effort to strictly observe the provided `leeway` value, even if it is smaller
-	/// than the current lower limit. Note that a minimal amount of delay is to be expected even if
-	/// this flag is specified.
-	///
-	/// Calling this method has no effect if the timer source has already been canceled.
-	///
-	/// - parameter deadline: the time at which the timer event will be delivered, subject to the
-	///     leeway and other considerations described above. The deadline is based on Mach absolute
-	///     time.
-	/// - parameter repeating: the repeat interval for the timer in seconds, or `.infinity` if the timer
-	///		should fire only once.
-	/// - parameter leeway: the leeway for the timer.
-	///
-	@available(swift, introduced: 4)
-	public func schedule(deadline: DispatchTime, repeating interval: Double, leeway: DispatchTimeInterval = .nanoseconds(0)) {
-		dispatch_source_set_timer((self as! DispatchSource).__wrapped, deadline.rawValue, interval.isInfinite ? ~0 : UInt64(interval * Double(NSEC_PER_SEC)), UInt64(leeway.rawValue))
-	}
-
-	///
-	/// Sets the deadline, repeat interval and leeway for a timer event.
-	///
-	/// Once this function returns, any pending source data accumulated for the previous timer values
-	/// has been cleared. The next timer event will occur at `wallDeadline` and every `repeating` units of
-	/// time thereafter until the timer source is canceled. If the value of `repeating` is `.never`,
-	/// or is defaulted, the timer fires only once.
-	///
-	/// Delivery of a timer event may be delayed by the system in order to improve power consumption and
-	/// system performance. The upper limit to the allowable delay may be configured with the `leeway`
-	/// argument; the lower limit is under the control of the system.
-	///
-	/// For the initial timer fire at `wallDeadline`, the upper limit to the allowable delay is set to
-	/// `leeway`. For the subsequent timer fires at `wallDeadline + N * repeating`, the upper
-	/// limit is the smaller of `leeway` and `repeating/2`.
-	///
-	/// The lower limit to the allowable delay may vary with process state such as visibility of the
-	/// application UI. If the timer source was created with flags `TimerFlags.strict`, the system
-	/// will make a best effort to strictly observe the provided `leeway` value, even if it is smaller
-	/// than the current lower limit. Note that a minimal amount of delay is to be expected even if
-	/// this flag is specified.
-	///
-	/// Calling this method has no effect if the timer source has already been canceled.
-	///
-	/// - parameter wallDeadline: the time at which the timer event will be delivered, subject to the
-	///     leeway and other considerations described above. The deadline is based on
-	///     `gettimeofday(3)`.
-	/// - parameter repeating: the repeat interval for the timer, or `.never` if the timer should fire
-	///		only once.
-	/// - parameter leeway: the leeway for the timer.
-	///
-	@available(swift, introduced: 4)
-	public func schedule(wallDeadline: DispatchWallTime, repeating interval: DispatchTimeInterval = .never, leeway: DispatchTimeInterval = .nanoseconds(0)) {
-		dispatch_source_set_timer((self as! DispatchSource).__wrapped, wallDeadline.rawValue, interval == .never ? ~0 : UInt64(interval.rawValue), UInt64(leeway.rawValue))
-	}
-
-	///
-	/// Sets the deadline, repeat interval and leeway for a timer event that fires at least once.
-	///
-	/// Once this function returns, any pending source data accumulated for the previous timer values
-	/// has been cleared. The next timer event will occur at `wallDeadline` and every `repeating` seconds
-	/// thereafter until the timer source is canceled. If the value of `repeating` is `.infinity`,
-	/// the timer fires only once.
-	///
-	/// Delivery of a timer event may be delayed by the system in order to improve power consumption
-	/// and system performance. The upper limit to the allowable delay may be configured with the `leeway`
-	/// argument; the lower limit is under the control of the system.
-	///
-	/// For the initial timer fire at `wallDeadline`, the upper limit to the allowable delay is set to
-	/// `leeway`. For the subsequent timer fires at `wallDeadline + N * repeating`, the upper
-	/// limit is the smaller of `leeway` and `repeating/2`.
-	///
-	/// The lower limit to the allowable delay may vary with process state such as visibility of the
-	/// application UI. If the timer source was created with flags `TimerFlags.strict`, the system
-	/// will make a best effort to strictly observe the provided `leeway` value, even if it is smaller
-	/// than the current lower limit. Note that a minimal amount of delay is to be expected even if
-	/// this flag is specified.
-	///
-	/// Calling this method has no effect if the timer source has already been canceled.
-	///
-	/// - parameter wallDeadline: the time at which the timer event will be delivered, subject to the
-	///     leeway and other considerations described above. The deadline is based on
-	///     `gettimeofday(3)`.
-	/// - parameter repeating: the repeat interval for the timer in seconds, or `.infinity` if the timer
-	///		should fire only once.
-	/// - parameter leeway: the leeway for the timer.
-	///
-	@available(swift, introduced: 4)
-	public func schedule(wallDeadline: DispatchWallTime, repeating interval: Double, leeway: DispatchTimeInterval = .nanoseconds(0)) {
-		dispatch_source_set_timer((self as! DispatchSource).__wrapped, wallDeadline.rawValue, interval.isInfinite ? ~0 : UInt64(interval * Double(NSEC_PER_SEC)), UInt64(leeway.rawValue))
-	}
-}
-
-#if !os(Linux) && !os(Android) && !os(Windows)
-extension DispatchSourceFileSystemObject {
-	public var handle: Int32 {
-		return Int32(dispatch_source_get_handle((self as! DispatchSource).__wrapped))
-	}
-
-	public var data: DispatchSource.FileSystemEvent {
-		let data = dispatch_source_get_data((self as! DispatchSource).__wrapped)
-		return DispatchSource.FileSystemEvent(rawValue: UInt(data))
-	}
-
-	public var mask: DispatchSource.FileSystemEvent {
-		let data = dispatch_source_get_mask((self as! DispatchSource).__wrapped)
-		return DispatchSource.FileSystemEvent(rawValue: UInt(data))
-	}
-}
-#endif
-
-extension DispatchSourceUserDataAdd {
-	/// Merges data into a dispatch source of type `DISPATCH_SOURCE_TYPE_DATA_ADD`
-	/// and submits its event handler block to its target queue.
-	///
-	/// - parameter data: the value to add to the current pending data. A value of zero
-	///		has no effect and will not result in the submission of the event handler block.
-	public func add(data: UInt) {
-		dispatch_source_merge_data((self as! DispatchSource).__wrapped, UInt(data))
-	}
-}
-
-extension DispatchSourceUserDataOr {
-	/// Merges data into a dispatch source of type `DISPATCH_SOURCE_TYPE_DATA_OR` and
-	/// submits its event handler block to its target queue.
-	///
-	/// - parameter data: The value to OR into the current pending data. A value of zero
-	///		has no effect and will not result in the submission of the event handler block.
-	public func or(data: UInt) {
-		dispatch_source_merge_data((self as! DispatchSource).__wrapped, UInt(data))
-	}
-}
-
-extension DispatchSourceUserDataReplace {
-	/// Merges data into a dispatch source of type `DISPATCH_SOURCE_TYPE_DATA_REPLACE`
-	/// and submits its event handler block to its target queue.
-	///
-	/// - parameter data: The value that will replace the current pending data.
-	///		A value of zero will be stored but will not result in the submission of the event
-	///		handler block.
-	public func replace(data: UInt) {
-		dispatch_source_merge_data((self as! DispatchSource).__wrapped, UInt(data))
-	}
-}
--- a/Telegram/ThirdParty/dispatch/src/swift/Time.swift	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/swift/Time.swift	1970-01-01 00:00:00.000000000 -0000
@@ -1,233 +0,0 @@
-//===----------------------------------------------------------------------===//
-//
-// This source file is part of the Swift.org open source project
-//
-// Copyright (c) 2014 - 2017 Apple Inc. and the Swift project authors
-// Licensed under Apache License v2.0 with Runtime Library Exception
-//
-// See https://swift.org/LICENSE.txt for license information
-// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
-//
-//===----------------------------------------------------------------------===//
-
-// dispatch/time.h
-// DISPATCH_TIME_NOW: ok
-// DISPATCH_TIME_FOREVER: ok
-
-import CDispatch
-
-public struct DispatchTime : Comparable {
-#if HAVE_MACH
-	private static let timebaseInfo: mach_timebase_info_data_t = {
-		var info = mach_timebase_info_data_t(numer: 1, denom: 1)
-		mach_timebase_info(&info)
-		return info
-	}()
-#endif
- 
-	public let rawValue: dispatch_time_t
-
-	public static func now() -> DispatchTime {
-		let t = CDispatch.dispatch_time(0, 0)
-		return DispatchTime(rawValue: t)
-	}
-
-	public static let distantFuture = DispatchTime(rawValue: ~0)
-
-	fileprivate init(rawValue: dispatch_time_t) {
-		self.rawValue = rawValue
-	}
-
-	/// Creates a `DispatchTime` relative to the system clock that
-	/// ticks since boot.
-	///
-	/// - Parameters:
-	///   - uptimeNanoseconds: The number of nanoseconds since boot, excluding
-	///                        time the system spent asleep
-	/// - Returns: A new `DispatchTime`
-	/// - Discussion: This clock is the same as the value returned by
-	///               `mach_absolute_time` when converted into nanoseconds.
-	///               On some platforms, the nanosecond value is rounded up to a
-	///               multiple of the Mach timebase, using the conversion factors
-	///               returned by `mach_timebase_info()`. The nanosecond equivalent
-	///               of the rounded result can be obtained by reading the
-	///               `uptimeNanoseconds` property.
-	///               Note that `DispatchTime(uptimeNanoseconds: 0)` is
-	///               equivalent to `DispatchTime.now()`, that is, its value
-	///               represents the number of nanoseconds since boot (excluding
-	///               system sleep time), not zero nanoseconds since boot.
-	public init(uptimeNanoseconds: UInt64) {
-		var rawValue = uptimeNanoseconds
-#if HAVE_MACH
-		// UInt64.max means distantFuture. Do not try to scale it.
-		if rawValue != UInt64.max && DispatchTime.timebaseInfo.numer != DispatchTime.timebaseInfo.denom {
-			var (result, overflow) = rawValue.multipliedReportingOverflow(by: UInt64(DispatchTime.timebaseInfo.denom))
-			if !overflow {
-				(result, overflow) = result.addingReportingOverflow(UInt64(DispatchTime.timebaseInfo.numer - 1))
-			}
-			rawValue = overflow ? UInt64.max : result / UInt64(DispatchTime.timebaseInfo.numer)
-		}
-#endif
-		self.rawValue = dispatch_time_t(rawValue)
-	}
-
-	public var uptimeNanoseconds: UInt64 {
-		var result = self.rawValue
-#if HAVE_MACH
-		var overflow: Bool
-
-		// UInt64.max means distantFuture. Do not try to scale it.
-		if rawValue != UInt64.max && DispatchTime.timebaseInfo.numer != DispatchTime.timebaseInfo.denom {
-			(result, overflow) = result.multipliedReportingOverflow(by: UInt64(DispatchTime.timebaseInfo.numer))
-			result = overflow ? UInt64.max : result / UInt64(DispatchTime.timebaseInfo.denom)
-		}
-#endif
-		return result
-	}
-}
-
-extension DispatchTime {
-	public static func < (a: DispatchTime, b: DispatchTime) -> Bool {
-		return a.rawValue < b.rawValue
-	}
-
-	public static func ==(a: DispatchTime, b: DispatchTime) -> Bool {
-		return a.rawValue == b.rawValue
-	}
-}
-
-public struct DispatchWallTime : Comparable {
-	public let rawValue: dispatch_time_t
-
-	public static func now() -> DispatchWallTime {
-		return DispatchWallTime(rawValue: CDispatch.dispatch_walltime(nil, 0))
-	}
-
-	public static let distantFuture = DispatchWallTime(rawValue: ~0)
-
-	fileprivate init(rawValue: dispatch_time_t) {
-		self.rawValue = rawValue
-	}
-
-	public init(timespec: timespec) {
-		var t = timespec
-		self.rawValue = CDispatch.dispatch_walltime(&t, 0)
-	}
-}
-
-extension DispatchWallTime {
-	public static func <(a: DispatchWallTime, b: DispatchWallTime) -> Bool {
-		let negativeOne: dispatch_time_t = ~0
-		if b.rawValue == negativeOne {
-			return a.rawValue != negativeOne
-		} else if a.rawValue == negativeOne {
-			return false
-		}
-		return -Int64(bitPattern: a.rawValue) < -Int64(bitPattern: b.rawValue)
-	}
-
-	public static func ==(a: DispatchWallTime, b: DispatchWallTime) -> Bool {
-		return a.rawValue == b.rawValue
-	}
-}
-
-// Returns m1 * m2, clamped to the range [Int64.min, Int64.max].
-// Because of the way this function is used, we can always assume
-// that m2 > 0.
-private func clampedInt64Product(_ m1: Int64, _ m2: Int64) -> Int64 {
-	assert(m2 > 0, "multiplier must be positive")
-	let (result, overflow) = m1.multipliedReportingOverflow(by: m2)
-	if overflow {
-		return m1 > 0 ? Int64.max : Int64.min
-	}
-	return result
-}
-
-// Returns its argument clamped to the range [Int64.min, Int64.max].
-private func toInt64Clamped(_ value: Double) -> Int64 {
-	if value.isNaN { return Int64.max }
-	if value >= Double(Int64.max) { return Int64.max }
-	if value <= Double(Int64.min) { return Int64.min }
-	return Int64(value)
-}
-
-/// Represents a time interval that can be used as an offset from a `DispatchTime`
-/// or `DispatchWallTime`.
-///
-/// For example:
-/// 	let inOneSecond = DispatchTime.now() + DispatchTimeInterval.seconds(1)
-///
-/// If the requested time interval is larger then the internal representation
-/// permits, the result of adding it to a `DispatchTime` or `DispatchWallTime`
-/// is `DispatchTime.distantFuture` and `DispatchWallTime.distantFuture`
-/// respectively. Such time intervals compare as equal:
-///
-/// 	let t1 = DispatchTimeInterval.seconds(Int.max)
-///		let t2 = DispatchTimeInterval.milliseconds(Int.max)
-///		let result = t1 == t2   // true
-public enum DispatchTimeInterval {
-	case seconds(Int)
-	case milliseconds(Int)
-	case microseconds(Int)
-	case nanoseconds(Int)
-	case never
-
-	internal var rawValue: Int64 {
-		switch self {
-		case .seconds(let s): return clampedInt64Product(Int64(s), Int64(NSEC_PER_SEC))
-		case .milliseconds(let ms): return clampedInt64Product(Int64(ms), Int64(NSEC_PER_MSEC))
-		case .microseconds(let us): return clampedInt64Product(Int64(us), Int64(NSEC_PER_USEC))
-		case .nanoseconds(let ns): return Int64(ns)
-		case .never: return Int64.max
-		}
-	}
-
-	public static func ==(lhs: DispatchTimeInterval, rhs: DispatchTimeInterval) -> Bool {
-		switch (lhs, rhs) {
-		case (.never, .never): return true
-		case (.never, _): return false
-		case (_, .never): return false
-		default: return lhs.rawValue == rhs.rawValue
-		}
-	}
-}
-
-public func +(time: DispatchTime, interval: DispatchTimeInterval) -> DispatchTime {
-	let t = CDispatch.dispatch_time(time.rawValue, interval.rawValue)
-	return DispatchTime(rawValue: t)
-}
-
-public func -(time: DispatchTime, interval: DispatchTimeInterval) -> DispatchTime {
-	let t = CDispatch.dispatch_time(time.rawValue, -interval.rawValue)
-	return DispatchTime(rawValue: t)
-}
-
-public func +(time: DispatchTime, seconds: Double) -> DispatchTime {
-	let t = CDispatch.dispatch_time(time.rawValue, toInt64Clamped(seconds * Double(NSEC_PER_SEC)));
-	return DispatchTime(rawValue: t)
-}
-
-public func -(time: DispatchTime, seconds: Double) -> DispatchTime {
-	let t = CDispatch.dispatch_time(time.rawValue, toInt64Clamped(-seconds * Double(NSEC_PER_SEC)));
-	return DispatchTime(rawValue: t)
-}
-
-public func +(time: DispatchWallTime, interval: DispatchTimeInterval) -> DispatchWallTime {
-	let t = CDispatch.dispatch_time(time.rawValue, interval.rawValue)
-	return DispatchWallTime(rawValue: t)
-}
-
-public func -(time: DispatchWallTime, interval: DispatchTimeInterval) -> DispatchWallTime {
-	let t = CDispatch.dispatch_time(time.rawValue, -interval.rawValue)
-	return DispatchWallTime(rawValue: t)
-}
-
-public func +(time: DispatchWallTime, seconds: Double) -> DispatchWallTime {
-	let t = CDispatch.dispatch_time(time.rawValue, toInt64Clamped(seconds * Double(NSEC_PER_SEC)));
-	return DispatchWallTime(rawValue: t)
-}
-
-public func -(time: DispatchWallTime, seconds: Double) -> DispatchWallTime {
-	let t = CDispatch.dispatch_time(time.rawValue, toInt64Clamped(-seconds * Double(NSEC_PER_SEC)));
-	return DispatchWallTime(rawValue: t)
-}
--- a/Telegram/ThirdParty/dispatch/src/swift/Wrapper.swift	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/swift/Wrapper.swift	1970-01-01 00:00:00.000000000 -0000
@@ -1,338 +0,0 @@
-//===----------------------------------------------------------------------===//
-//
-// This source file is part of the Swift.org open source project
-//
-// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
-// Licensed under Apache License v2.0 with Runtime Library Exception
-//
-// See https://swift.org/LICENSE.txt for license information
-// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
-//
-//===----------------------------------------------------------------------===//
-
-import CDispatch
-@_implementationOnly import _DispatchOverlayShims
-
-// This file contains declarations that are provided by the
-// importer via Dispatch.apinote when the platform has Objective-C support
-
-public func dispatchMain() -> Never {
-	CDispatch.dispatch_main()
-}
-
-public class DispatchObject {
-
-	internal func wrapped() -> dispatch_object_t {
-		fatalError("should be overriden in subclass")
-	}
-
-	public func setTarget(queue:DispatchQueue) {
-		dispatch_set_target_queue(wrapped(), queue.__wrapped)
-	}
-
-	public func activate() {
-		dispatch_activate(wrapped())
-	}
-
-	public func suspend() {
-		dispatch_suspend(wrapped())
-	}
-
-	public func resume() {
-		dispatch_resume(wrapped())
-	}
-}
-
-
-public class DispatchGroup : DispatchObject {
-	internal let __wrapped:dispatch_group_t;
-
-	final internal override func wrapped() -> dispatch_object_t {
-		return unsafeBitCast(__wrapped, to: dispatch_object_t.self)
-	}
-
-	public override init() {
-		__wrapped = dispatch_group_create()
-	}
-
-	deinit {
-		_swift_dispatch_release(wrapped())
-	}
-
-	public func enter() {
-		dispatch_group_enter(__wrapped)
-	}
-
-	public func leave() {
-		dispatch_group_leave(__wrapped)
-	}
-}
-
-public class DispatchSemaphore : DispatchObject {
-	internal let __wrapped: dispatch_semaphore_t;
-
-	final internal override func wrapped() -> dispatch_object_t {
-		return unsafeBitCast(__wrapped, to: dispatch_object_t.self)
-	}
-
-	public init(value: Int) {
-		__wrapped = dispatch_semaphore_create(Int(value))
-	}
-
-	deinit {
-		_swift_dispatch_release(wrapped())
-	}
-}
-
-public class DispatchIO : DispatchObject {
-	internal let __wrapped:dispatch_io_t
-
-	final internal override func wrapped() -> dispatch_object_t {
-		return unsafeBitCast(__wrapped, to: dispatch_object_t.self)
-	}
-
-	internal init(__type: UInt, fd: dispatch_fd_t, queue: DispatchQueue,
-				  handler: @escaping (_ error: Int32) -> Void) {
-		__wrapped = dispatch_io_create(dispatch_io_type_t(__type), dispatch_fd_t(fd), queue.__wrapped, handler)
-	}
-
-	internal init(__type: UInt, path: UnsafePointer<Int8>, oflag: Int32,
-				  mode: mode_t, queue: DispatchQueue, handler: @escaping (_ error: Int32) -> Void) {
-		__wrapped = dispatch_io_create_with_path(dispatch_io_type_t(__type), path, oflag, mode, queue.__wrapped, handler)
-	}
-
-	internal init(__type: UInt, io: DispatchIO,
-				  queue: DispatchQueue, handler: @escaping (_ error: Int32) -> Void) {
-		__wrapped = dispatch_io_create_with_io(dispatch_io_type_t(__type), io.__wrapped, queue.__wrapped, handler)
-	}
-
-	deinit {
-		_swift_dispatch_release(wrapped())
-	}
-
-	public func barrier(execute: @escaping () -> ()) {
-		dispatch_io_barrier(self.__wrapped, execute)
-	}
-
-	public var fileDescriptor: Int32 {
-		return Int32(dispatch_io_get_descriptor(__wrapped))
-	}
-
-	public func setLimit(highWater: Int) {
-		dispatch_io_set_high_water(__wrapped, highWater)
-	}
-
-	public func setLimit(lowWater: Int) {
-		dispatch_io_set_low_water(__wrapped, lowWater)
-	}
-}
-
-public class DispatchQueue : DispatchObject {
-	internal let __wrapped:dispatch_queue_t;
-
-	final internal override func wrapped() -> dispatch_object_t {
-		return unsafeBitCast(__wrapped, to: dispatch_object_t.self)
-	}
-
-	internal init(__label: String, attr: dispatch_queue_attr_t?) {
-		__wrapped = dispatch_queue_create(__label, attr)
-	}
-
-	internal init(__label: String, attr:  dispatch_queue_attr_t?, queue: DispatchQueue?) {
-		__wrapped = dispatch_queue_create_with_target(__label, attr, queue?.__wrapped)
-	}
-
-	internal init(queue:dispatch_queue_t) {
-		__wrapped = queue
-	}
-
-	deinit {
-		_swift_dispatch_release(wrapped())
-	}
-
-	public func sync(execute workItem: ()->()) {
-		dispatch_sync(self.__wrapped, workItem)
-	}
-}
-
-public class DispatchSource : DispatchObject,
-	DispatchSourceProtocol,	DispatchSourceRead,
-	DispatchSourceSignal, DispatchSourceTimer,
-	DispatchSourceUserDataAdd, DispatchSourceUserDataOr,
-	DispatchSourceUserDataReplace, DispatchSourceWrite {
-	internal let __wrapped:dispatch_source_t
-
-	final internal override func wrapped() -> dispatch_object_t {
-		return unsafeBitCast(__wrapped, to: dispatch_object_t.self)
-	}
-
-	internal init(source:dispatch_source_t) {
-		__wrapped = source
-	}
-
-	deinit {
-		_swift_dispatch_release(wrapped())
-	}
-}
-
-#if HAVE_MACH
-extension DispatchSource : DispatchSourceMachSend,
-	DispatchSourceMachReceive, DispatchSourceMemoryPressure {
-}
-#endif
-
-#if !os(Linux) && !os(Android) && !os(Windows)
-extension DispatchSource : DispatchSourceProcess,
-	DispatchSourceFileSystemObject {
-}
-#endif
-
-internal class __DispatchData : DispatchObject {
-	internal let __wrapped:dispatch_data_t
-
-	final internal override func wrapped() -> dispatch_object_t {
-		return unsafeBitCast(__wrapped, to: dispatch_object_t.self)
-	}
-
-	internal init(data:dispatch_data_t, owned:Bool) {
-		__wrapped = data
-		if !owned {
-			_swift_dispatch_retain(unsafeBitCast(data, to: dispatch_object_t.self))
-		}
-	}
-
-	deinit {
-		_swift_dispatch_release(wrapped())
-	}
-}
-
-public typealias DispatchSourceHandler = @convention(block) () -> Void
-
-public protocol DispatchSourceProtocol {
-	func setEventHandler(qos: DispatchQoS, flags: DispatchWorkItemFlags, handler: DispatchSourceHandler?)
-
-	func setEventHandler(handler: DispatchWorkItem)
-
-	func setCancelHandler(qos: DispatchQoS, flags: DispatchWorkItemFlags, handler: DispatchSourceHandler?)
-
-	func setCancelHandler(handler: DispatchWorkItem)
-
-	func setRegistrationHandler(qos: DispatchQoS, flags: DispatchWorkItemFlags, handler: DispatchSourceHandler?)
-
-	func setRegistrationHandler(handler: DispatchWorkItem)
-
-	func cancel()
-
-	func resume()
-
-	func suspend()
-
-	var handle: UInt { get }
-
-	var mask: UInt { get }
-
-	var data: UInt { get }
-
-	var isCancelled: Bool { get }
-}
-
-public protocol DispatchSourceUserDataAdd : DispatchSourceProtocol {
-	func add(data: UInt)
-}
-
-public protocol DispatchSourceUserDataOr : DispatchSourceProtocol {
-	func or(data: UInt)
-}
-
-public protocol DispatchSourceUserDataReplace : DispatchSourceProtocol {
-	func replace(data: UInt)
-}
-
-#if HAVE_MACH
-public protocol DispatchSourceMachSend : DispatchSourceProtocol {
-	public var handle: mach_port_t { get }
-
-	public var data: DispatchSource.MachSendEvent { get }
-
-	public var mask: DispatchSource.MachSendEvent { get }
-}
-#endif
-
-#if HAVE_MACH
-public protocol DispatchSourceMachReceive : DispatchSourceProtocol {
-	var handle: mach_port_t { get }
-}
-#endif
-
-#if HAVE_MACH
-public protocol DispatchSourceMemoryPressure : DispatchSourceProtocol {
-	public var data: DispatchSource.MemoryPressureEvent { get }
-
-	public var mask: DispatchSource.MemoryPressureEvent { get }
-}
-#endif
-
-#if !os(Linux) && !os(Android) && !os(Windows)
-public protocol DispatchSourceProcess : DispatchSourceProtocol {
-	var handle: pid_t { get }
-
-	var data: DispatchSource.ProcessEvent { get }
-
-	var mask: DispatchSource.ProcessEvent { get }
-}
-#endif
-
-public protocol DispatchSourceRead : DispatchSourceProtocol {
-}
-
-public protocol DispatchSourceSignal : DispatchSourceProtocol {
-}
-
-public protocol DispatchSourceTimer : DispatchSourceProtocol {
-	func scheduleOneshot(deadline: DispatchTime, leeway: DispatchTimeInterval)
-
-	func scheduleOneshot(wallDeadline: DispatchWallTime, leeway: DispatchTimeInterval)
-
-	func scheduleRepeating(deadline: DispatchTime, interval: DispatchTimeInterval, leeway: DispatchTimeInterval)
-
-	func scheduleRepeating(deadline: DispatchTime, interval: Double, leeway: DispatchTimeInterval)
-
-	func scheduleRepeating(wallDeadline: DispatchWallTime, interval: DispatchTimeInterval, leeway: DispatchTimeInterval)
-
-	func scheduleRepeating(wallDeadline: DispatchWallTime, interval: Double, leeway: DispatchTimeInterval)
-}
-
-#if !os(Linux) && !os(Android) && !os(Windows)
-public protocol DispatchSourceFileSystemObject : DispatchSourceProtocol {
-	var handle: Int32 { get }
-
-	var data: DispatchSource.FileSystemEvent { get }
-
-	var mask: DispatchSource.FileSystemEvent { get }
-}
-#endif
-
-public protocol DispatchSourceWrite : DispatchSourceProtocol {
-}
-
-
-internal enum _OSQoSClass : UInt32  {
-	case QOS_CLASS_USER_INTERACTIVE = 0x21
-	case QOS_CLASS_USER_INITIATED = 0x19
-	case QOS_CLASS_DEFAULT = 0x15
-	case QOS_CLASS_UTILITY = 0x11
-	case QOS_CLASS_BACKGROUND = 0x09
-	case QOS_CLASS_UNSPECIFIED = 0x00
-
-	internal init?(qosClass:dispatch_qos_class_t) {
-		switch qosClass {
-		case 0x21: self = .QOS_CLASS_USER_INTERACTIVE
-		case 0x19: self = .QOS_CLASS_USER_INITIATED
-		case 0x15: self = .QOS_CLASS_DEFAULT
-		case 0x11: self = .QOS_CLASS_UTILITY
-		case 0x09: self = .QOS_CLASS_BACKGROUND
-		case 0x00: self = .QOS_CLASS_UNSPECIFIED
-		default: return nil
-		}
-	}
-}
--- a/Telegram/ThirdParty/dispatch/src/time.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/time.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,206 +0,0 @@
-/*
- * Copyright (c) 2008-2013 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include "internal.h"
-
-#if DISPATCH_USE_HOST_TIME
-typedef struct _dispatch_host_time_data_s {
-	long double frac;
-	bool ratio_1_to_1;
-} _dispatch_host_time_data_s;
-
-static _dispatch_host_time_data_s _dispatch_host_time_data;
-
-uint64_t (*_dispatch_host_time_mach2nano)(uint64_t machtime);
-uint64_t (*_dispatch_host_time_nano2mach)(uint64_t nsec);
-
-static uint64_t
-_dispatch_mach_host_time_mach2nano(uint64_t machtime)
-{
-	_dispatch_host_time_data_s *const data = &_dispatch_host_time_data;
-
-	if (unlikely(!machtime || data->ratio_1_to_1)) {
-		return machtime;
-	}
-	if (machtime >= INT64_MAX) {
-		return INT64_MAX;
-	}
-	long double big_tmp = ((long double)machtime * data->frac) + .5L;
-	if (unlikely(big_tmp >= INT64_MAX)) {
-		return INT64_MAX;
-	}
-	return (uint64_t)big_tmp;
-}
-
-static uint64_t
-_dispatch_mach_host_time_nano2mach(uint64_t nsec)
-{
-	_dispatch_host_time_data_s *const data = &_dispatch_host_time_data;
-
-	if (unlikely(!nsec || data->ratio_1_to_1)) {
-		return nsec;
-	}
-	if (nsec >= INT64_MAX) {
-		return INT64_MAX;
-	}
-	long double big_tmp = ((long double)nsec / data->frac) + .5L;
-	if (unlikely(big_tmp >= INT64_MAX)) {
-		return INT64_MAX;
-	}
-	return (uint64_t)big_tmp;
-}
-
-static void
-_dispatch_host_time_init(mach_timebase_info_data_t *tbi)
-{
-	_dispatch_host_time_data.frac = tbi->numer;
-	_dispatch_host_time_data.frac /= tbi->denom;
-	_dispatch_host_time_data.ratio_1_to_1 = (tbi->numer == tbi->denom);
-	_dispatch_host_time_mach2nano = _dispatch_mach_host_time_mach2nano;
-	_dispatch_host_time_nano2mach = _dispatch_mach_host_time_nano2mach;
-}
-#endif // DISPATCH_USE_HOST_TIME
-
-void
-_dispatch_time_init(void)
-{
-#if DISPATCH_USE_HOST_TIME
-	mach_timebase_info_data_t tbi;
-	(void)dispatch_assume_zero(mach_timebase_info(&tbi));
-	_dispatch_host_time_init(&tbi);
-#endif // DISPATCH_USE_HOST_TIME
-}
-
-dispatch_time_t
-dispatch_time(dispatch_time_t inval, int64_t delta)
-{
-	uint64_t offset;
-	if (inval == DISPATCH_TIME_FOREVER) {
-		return DISPATCH_TIME_FOREVER;
-	}
-
-	dispatch_clock_t clock;
-	uint64_t value;
-	_dispatch_time_to_clock_and_value(inval, &clock, &value);
-	if (value == DISPATCH_TIME_FOREVER) {
-		// Out-of-range for this clock.
-		return value;
-	}
-	if (clock == DISPATCH_CLOCK_WALL) {
-		// wall clock
-		offset = (uint64_t)delta;
-		if (delta >= 0) {
-			if ((int64_t)(value += offset) <= 0) {
-				return DISPATCH_TIME_FOREVER; // overflow
-			}
-		} else {
-			if ((int64_t)(value += offset) < 1) {
-				// -1 is special == DISPATCH_TIME_FOREVER == forever, so
-				// return -2 (after conversion to dispatch_time_t) instead.
-				value = 2; // underflow.
-			}
-		}
-		return _dispatch_clock_and_value_to_time(DISPATCH_CLOCK_WALL, value);
-	}
-
-	// up time or monotonic time. "value" has the clock type removed,
-	// so the test against DISPATCH_TIME_NOW is correct for either clock.
-	if (value == DISPATCH_TIME_NOW) {
-		if (clock == DISPATCH_CLOCK_UPTIME) {
-			value = _dispatch_uptime();
-		} else {
-			dispatch_assert(clock == DISPATCH_CLOCK_MONOTONIC);
-			value = _dispatch_monotonic_time();
-		}
-	}
-	if (delta >= 0) {
-		offset = _dispatch_time_nano2mach((uint64_t)delta);
-		if ((int64_t)(value += offset) <= 0) {
-			return DISPATCH_TIME_FOREVER; // overflow
-		}
-		return _dispatch_clock_and_value_to_time(clock, value);
-	} else {
-		offset = _dispatch_time_nano2mach((uint64_t)-delta);
-		if ((int64_t)(value -= offset) < 1) {
-			return _dispatch_clock_and_value_to_time(clock, 1); // underflow
-		}
-		return _dispatch_clock_and_value_to_time(clock, value);
-	}
-}
-
-dispatch_time_t
-dispatch_walltime(const struct timespec *inval, int64_t delta)
-{
-	int64_t nsec;
-	if (inval) {
-		nsec = (int64_t)_dispatch_timespec_to_nano(*inval);
-	} else {
-		nsec = (int64_t)_dispatch_get_nanoseconds();
-	}
-	nsec += delta;
-	if (nsec <= 1) {
-		// -1 is special == DISPATCH_TIME_FOREVER == forever
-		return delta >= 0 ? DISPATCH_TIME_FOREVER : (dispatch_time_t)-2ll;
-	}
-	return (dispatch_time_t)-nsec;
-}
-
-uint64_t
-_dispatch_timeout(dispatch_time_t when)
-{
-	dispatch_time_t now;
-	if (when == DISPATCH_TIME_FOREVER) {
-		return DISPATCH_TIME_FOREVER;
-	}
-	if (when == DISPATCH_TIME_NOW) {
-		return 0;
-	}
-
-	dispatch_clock_t clock;
-	uint64_t value;
-	_dispatch_time_to_clock_and_value(when, &clock, &value);
-	if (clock == DISPATCH_CLOCK_WALL) {
-		now = _dispatch_get_nanoseconds();
-		return now >= value ? 0 : value - now;
-	} else {
-		if (clock == DISPATCH_CLOCK_UPTIME) {
-			now = _dispatch_uptime();
-		} else {
-			dispatch_assert(clock == DISPATCH_CLOCK_MONOTONIC);
-			now = _dispatch_monotonic_time();
-		}
-		return now >= value ? 0 : _dispatch_time_mach2nano(value - now);
-	}
-}
-
-uint64_t
-_dispatch_time_nanoseconds_since_epoch(dispatch_time_t when)
-{
-	if (when == DISPATCH_TIME_FOREVER) {
-		return DISPATCH_TIME_FOREVER;
-	}
-	if ((int64_t)when < 0) {
-		// time in nanoseconds since the POSIX epoch already
-		return (uint64_t)-(int64_t)when;
-	}
-
-	// Up time or monotonic time.
-	return _dispatch_get_nanoseconds() + _dispatch_timeout(when);
-}
--- a/Telegram/ThirdParty/dispatch/src/trace.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/trace.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,512 +0,0 @@
-/*
- * Copyright (c) 2010-2013 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-/*
- * IMPORTANT: This header file describes INTERNAL interfaces to libdispatch
- * which are subject to change in future releases of Mac OS X. Any applications
- * relying on these interfaces WILL break.
- */
-
-#ifndef __DISPATCH_TRACE__
-#define __DISPATCH_TRACE__
-
-#if DISPATCH_PURE_C
-
-#if DISPATCH_USE_DTRACE_INTROSPECTION
-#define _dispatch_trace_callout(_c, _f, _dcc) do { \
-		if (unlikely(DISPATCH_CALLOUT_ENTRY_ENABLED() || \
-				DISPATCH_CALLOUT_RETURN_ENABLED())) { \
-			dispatch_queue_t _dq = _dispatch_queue_get_current(); \
-			const char *_label = _dq && _dq->dq_label ? _dq->dq_label : ""; \
-			dispatch_function_t _func = (dispatch_function_t)(_f); \
-			void *_ctxt = (_c); \
-			DISPATCH_CALLOUT_ENTRY(_dq, _label, _func, _ctxt); \
-			_dcc; \
-			DISPATCH_CALLOUT_RETURN(_dq, _label, _func, _ctxt); \
-		} else { \
-			_dcc; \
-		} \
-	} while (0)
-#elif DISPATCH_INTROSPECTION
-#define _dispatch_trace_callout(_c, _f, _dcc) \
-		do { (void)(_c); (void)(_f); _dcc; } while (0)
-#endif // DISPATCH_USE_DTRACE_INTROSPECTION || DISPATCH_INTROSPECTION
-
-#if DISPATCH_USE_DTRACE_INTROSPECTION || DISPATCH_INTROSPECTION
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_trace_client_callout(void *ctxt, dispatch_function_t f)
-{
-	dispatch_function_t func = (f == _dispatch_call_block_and_release &&
-			ctxt ? _dispatch_Block_invoke(ctxt) : f);
-	_dispatch_introspection_callout_entry(ctxt, func);
-	_dispatch_trace_callout(ctxt, func, _dispatch_client_callout(ctxt, f));
-	_dispatch_introspection_callout_return(ctxt, func);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_trace_client_callout2(void *ctxt, size_t i, void (*f)(void *, size_t))
-{
-	dispatch_function_t func = (dispatch_function_t)f;
-	_dispatch_introspection_callout_entry(ctxt, func);
-	_dispatch_trace_callout(ctxt, func, _dispatch_client_callout2(ctxt, i, f));
-	_dispatch_introspection_callout_return(ctxt, func);
-}
-
-#define _dispatch_client_callout		_dispatch_trace_client_callout
-#define _dispatch_client_callout2		_dispatch_trace_client_callout2
-#endif // DISPATCH_USE_DTRACE_INTROSPECTION || DISPATCH_INTROSPECTION
-
-#ifdef _COMM_PAGE_KDEBUG_ENABLE
-#define DISPATCH_KTRACE_ENABLED \
-		(*(volatile uint32_t *)_COMM_PAGE_KDEBUG_ENABLE != 0)
-
-#if DISPATCH_INTROSPECTION
-#define _dispatch_only_if_ktrace_enabled(...) \
-		if (unlikely(DISPATCH_KTRACE_ENABLED)) ({ __VA_ARGS__; })
-#else
-#define _dispatch_only_if_ktrace_enabled(...) (void)0
-#endif /* DISPATCH_INTROSPECTION */
-
-#else /* _COMM_PAGE_KDEBUG_ENABLE */
-
-#define DISPATCH_KTRACE_ENABLED 0
-#define _dispatch_only_if_ktrace_enabled(...) (void)0
-#endif /* _COMM_PAGE_KDEBUG_ENABLE */
-
-
-#if DISPATCH_USE_DTRACE_INTROSPECTION
-#define _dispatch_trace_continuation(_q, _o, _t) do { \
-		dispatch_queue_t _dq = (_q); \
-		const char *_label = _dq && _dq->dq_label ? _dq->dq_label : ""; \
-		struct dispatch_object_s *_do = (_o); \
-		dispatch_continuation_t _dc; \
-		char *_kind; \
-		dispatch_function_t _func; \
-		void *_ctxt; \
-		if (_dispatch_object_has_vtable(_do)) { \
-			_kind = (char*)_dispatch_object_class_name(_do); \
-			if ((dx_metatype(_do) == _DISPATCH_SOURCE_TYPE) && \
-					_dq != _dispatch_mgr_q._as_dq) { \
-				dispatch_source_t _ds = (dispatch_source_t)_do; \
-				_dc = os_atomic_load(&_ds->ds_refs->ds_handler[ \
-						DS_EVENT_HANDLER], relaxed); \
-				_func = _dc ? _dc->dc_func : NULL; \
-				_ctxt = _dc ? _dc->dc_ctxt : NULL; \
-			} else { \
-				_func = (dispatch_function_t)_dispatch_lane_invoke; \
-				_ctxt = _do->do_ctxt; \
-			} \
-		} else { \
-			_dc = (void*)_do; \
-			_ctxt = _dc->dc_ctxt; \
-			if (_dc->dc_flags & DC_FLAG_SYNC_WAITER) { \
-				_kind = "semaphore"; \
-				_func = (dispatch_function_t)dispatch_semaphore_signal; \
-			} else if (_dc->dc_flags & DC_FLAG_BLOCK) { \
-				_kind = "block"; \
-				_func = _dispatch_Block_invoke(_dc->dc_ctxt); \
-			} else { \
-				_kind = "function"; \
-				_func = _dc->dc_func; \
-			} \
-		} \
-		_t(_dq, _label, _do, _kind, _func, _ctxt); \
-	} while (0)
-#elif DISPATCH_INTROSPECTION
-#define _dispatch_trace_continuation(_q, _o, _t) \
-		do { (void)(_q); (void)(_o); } while(0)
-#define DISPATCH_QUEUE_PUSH_ENABLED() 0
-#define DISPATCH_QUEUE_POP_ENABLED() 0
-#endif // DISPATCH_USE_DTRACE_INTROSPECTION || DISPATCH_INTROSPECTION
-
-#if DISPATCH_USE_DTRACE_INTROSPECTION || DISPATCH_INTROSPECTION
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_queue_class_t
-_dispatch_trace_queue_create(dispatch_queue_class_t dqu)
-{
-	_dispatch_only_if_ktrace_enabled({
-		uint64_t dq_label[4] = {0}; // So that we get the right null termination
-		dispatch_queue_t dq = dqu._dq;
-		strncpy((char *)dq_label, (char *)dq->dq_label ?: "", sizeof(dq_label));
-
-		_dispatch_ktrace2(DISPATCH_QOS_TRACE_queue_creation_start,
-				dq->dq_serialnum,
-				_dispatch_priority_to_pp_prefer_fallback(dq->dq_priority));
-
-		_dispatch_ktrace4(DISPATCH_QOS_TRACE_queue_creation_end,
-						dq_label[0], dq_label[1], dq_label[2], dq_label[3]);
-	});
-
-	return _dispatch_introspection_queue_create(dqu);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_trace_queue_dispose(dispatch_queue_class_t dqu)
-{
-	_dispatch_ktrace1(DISPATCH_QOS_TRACE_queue_dispose, (dqu._dq)->dq_serialnum);
-	_dispatch_introspection_queue_dispose(dqu);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_trace_source_dispose(dispatch_source_t ds)
-{
-	_dispatch_ktrace1(DISPATCH_QOS_TRACE_src_dispose, (uintptr_t)ds);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_trace_block_create_with_voucher_and_priority(dispatch_block_t db,
-		void *func, dispatch_block_flags_t original_flags,
-		pthread_priority_t original_priority,
-		pthread_priority_t thread_prio, pthread_priority_t final_block_prio)
-{
-	_dispatch_ktrace4(DISPATCH_QOS_TRACE_private_block_creation,
-			(uintptr_t)db,
-			(uintptr_t)func,
-			BITPACK_UINT32_PAIR(original_flags, original_priority),
-			BITPACK_UINT32_PAIR(thread_prio, final_block_prio));
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_trace_firehose_reserver_gave_up(uint8_t stream, uint8_t ref,
-		bool waited, uint64_t old_state, uint64_t new_state)
-{
-	uint64_t first = ((uint64_t)ref << 8) | (uint64_t)stream;
-	uint64_t second = waited;
-	_dispatch_ktrace4(DISPATCH_FIREHOSE_TRACE_reserver_gave_up, first, second,
-			old_state, new_state);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_trace_firehose_reserver_wait(uint8_t stream, uint8_t ref,
-		bool waited, uint64_t old_state, uint64_t new_state, bool reliable)
-{
-	uint64_t first = ((uint64_t)ref << 8) | (uint64_t)stream;
-	uint64_t second = ((uint64_t)reliable << 1) | waited;
-	_dispatch_ktrace4(DISPATCH_FIREHOSE_TRACE_reserver_wait, first, second,
-			old_state, new_state);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_trace_firehose_allocator(uint64_t ask0, uint64_t ask1,
-		uint64_t old_state, uint64_t new_state)
-{
-	_dispatch_ktrace4(DISPATCH_FIREHOSE_TRACE_allocator, ask0, ask1, old_state,
-			new_state);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_trace_firehose_wait_for_logd(uint8_t stream, uint64_t timestamp,
-		uint64_t old_state, uint64_t new_state)
-{
-	_dispatch_ktrace4(DISPATCH_FIREHOSE_TRACE_wait_for_logd, stream, timestamp,
-			old_state, new_state);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_trace_firehose_chunk_install(uint64_t ask0, uint64_t ask1,
-		uint64_t old_state, uint64_t new_state)
-{
-	_dispatch_ktrace4(DISPATCH_FIREHOSE_TRACE_chunk_install, ask0, ask1,
-			old_state, new_state);
-}
-
-/* Implemented in introspection.c */
-void
-_dispatch_trace_item_push_internal(dispatch_queue_t dq, dispatch_object_t dou);
-
-#define _dispatch_trace_item_push_inline(...) \
-		_dispatch_only_if_ktrace_enabled({ \
-			_dispatch_trace_item_push_internal(__VA_ARGS__); \
-		})
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_trace_item_push_list(dispatch_queue_global_t dq,
-		dispatch_object_t _head, dispatch_object_t _tail)
-{
-	if (unlikely(DISPATCH_QUEUE_PUSH_ENABLED() || DISPATCH_KTRACE_ENABLED)) {
-		struct dispatch_object_s *dou = _head._do;
-		do {
-			if (unlikely(DISPATCH_QUEUE_PUSH_ENABLED())) {
-				_dispatch_trace_continuation(dq->_as_dq, dou, DISPATCH_QUEUE_PUSH);
-			}
-
-			_dispatch_trace_item_push_inline(dq->_as_dq, dou);
-		} while (dou != _tail._do && (dou = dou->do_next));
-	}
-	_dispatch_introspection_queue_push_list(dq, _head, _tail);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_trace_item_push(dispatch_queue_class_t dqu, dispatch_object_t _tail)
-{
-	if (unlikely(DISPATCH_QUEUE_PUSH_ENABLED())) {
-		_dispatch_trace_continuation(dqu._dq, _tail._do, DISPATCH_QUEUE_PUSH);
-	}
-
-	_dispatch_trace_item_push_inline(dqu._dq, _tail._do);
-	_dispatch_introspection_queue_push(dqu, _tail);
-}
-
-/* Implemented in introspection.c */
-void
-_dispatch_trace_item_pop_internal(dispatch_queue_t dq, dispatch_object_t dou);
-
-#define _dispatch_trace_item_pop_inline(...) \
-		_dispatch_only_if_ktrace_enabled({ \
-			_dispatch_trace_item_pop_internal(__VA_ARGS__); \
-		})
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_trace_item_pop(dispatch_queue_class_t dqu, dispatch_object_t dou)
-{
-	if (unlikely(DISPATCH_QUEUE_POP_ENABLED())) {
-		_dispatch_trace_continuation(dqu._dq, dou._do, DISPATCH_QUEUE_POP);
-	}
-
-	_dispatch_trace_item_pop_inline(dqu._dq, dou);
-	_dispatch_introspection_queue_pop(dqu, dou);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_trace_item_complete_inline(dispatch_object_t dou)
-{
-	_dispatch_ktrace1(DISPATCH_QOS_TRACE_queue_item_complete, dou._do_value);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_trace_item_complete(dispatch_object_t dou)
-{
-	_dispatch_trace_item_complete_inline(dou);
-	_dispatch_introspection_queue_item_complete(dou);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline struct dispatch_object_s *
-_dispatch_trace_item_sync_push_pop(dispatch_queue_class_t dqu,
-		void *ctx, dispatch_function_t f, uintptr_t dc_flags)
-{
-	// No need to add tracing here since the introspection calls out to
-	// _trace_item_push and _trace_item_pop
-	return _dispatch_introspection_queue_fake_sync_push_pop(dqu._dq, ctx,
-			f, dc_flags);
-}
-
-/* Implemented in introspection.c */
-void
-_dispatch_trace_source_callout_entry_internal(dispatch_source_t ds, long kind,
-		dispatch_queue_t dq, dispatch_continuation_t dc);
-
-#define _dispatch_trace_source_callout_entry(...) \
-		_dispatch_only_if_ktrace_enabled({ \
-			_dispatch_trace_source_callout_entry_internal(__VA_ARGS__); \
-		})
-
-#define _dispatch_trace_runtime_event(evt, ptr, value) \
-		_dispatch_introspection_runtime_event(\
-				dispatch_introspection_runtime_event_##evt, ptr, value)
-
-#define DISPATCH_TRACE_ARG(arg) , arg
-#else
-#define _dispatch_trace_queue_create _dispatch_introspection_queue_create
-#define _dispatch_trace_queue_dispose _dispatch_introspection_queue_dispose
-#define _dispatch_trace_source_dispose(ds) ((void)0)
-#define _dispatch_trace_block_create_with_voucher_and_priority(_db, _func, \
-		_flags, _pri, _tpri, _bpri) \
-		do { (void)_db; (void)_func; (void) _flags; (void) _pri; (void) _tpri; \
-			(void) _bpri; } while (0)
-#define _dispatch_trace_firehose_reserver_gave_up(stream, ref, waited, \
-		old_state, new_state) \
-		do { (void)(stream); (void)(ref); (void)(waited); (void)(old_state); \
-			(void)(new_state); } while (0)
-#define _dispatch_trace_firehose_reserver_wait(stream, ref, waited, \
-		old_state, new_state, reliable) \
-		do { (void)(stream); (void)(ref); (void)(waited); (void)(old_state); \
-			(void)(new_state); (void)(reliable); } while (0)
-#define _dispatch_trace_firehose_allocator(ask0, ask1, old_state, new_state) \
-		do { (void)(ask0); (void)(ask1); (void)(old_state); \
-			(void)(new_state); } while (0)
-#define _dispatch_trace_firehose_wait_for_logd(stream, timestamp, old_state, \
-		new_state) \
-		do { (void)(stream); (void)(timestamp); (void)(old_state); \
-			(void)(new_state); } while (0)
-#define _dispatch_trace_firehose_chunk_install(ask0, ask1, old_state, \
-		new_state) \
-		do { (void)(ask0); (void)(ask1); (void)(old_state); \
-			(void)(new_state); } while (0)
-#define _dispatch_trace_item_push(dq, dou) \
-		do { (void)(dq); (void)(dou); } while(0)
-#define _dispatch_trace_item_push_list(dq, head, tail) \
-		do { (void)(dq); (void)(head); (void)tail; } while(0)
-#define _dispatch_trace_item_pop(dq, dou) \
-		do { (void)(dq); (void)(dou); } while(0)
-#define _dispatch_trace_item_complete(dou) ((void)0)
-#define _dispatch_trace_item_sync_push_pop(dq, ctxt, func, flags) \
-		do { (void)(dq); (void)(ctxt); (void)(func); (void)(flags); } while(0)
-#define _dispatch_trace_source_callout_entry(ds, k, dq, dc) ((void)0)
-#define _dispatch_trace_runtime_event(evt, ptr, value) \
-		do { (void)(ptr); (void)(value); } while(0)
-#define DISPATCH_TRACE_ARG(arg)
-#endif // DISPATCH_USE_DTRACE_INTROSPECTION || DISPATCH_INTROSPECTION
-
-#if DISPATCH_USE_DTRACE
-static inline dispatch_function_t
-_dispatch_trace_timer_function(dispatch_timer_source_refs_t dr)
-{
-	dispatch_continuation_t dc;
-	dc = os_atomic_load(&dr->ds_handler[DS_EVENT_HANDLER], relaxed);
-	return dc ? dc->dc_func : NULL;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline uint64_t
-_dispatch_time_clock_to_nsecs(dispatch_clock_t clock, uint64_t t)
-{
-#if !DISPATCH_TIME_UNIT_USES_NANOSECONDS
-	switch (clock) {
-	case DISPATCH_CLOCK_MONOTONIC:
-	case DISPATCH_CLOCK_UPTIME:
-		return _dispatch_time_mach2nano(t);
-	case DISPATCH_CLOCK_WALL:
-		return t;
-	}
-#else
-	(void)clock;
-	return t;
-#endif
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline dispatch_trace_timer_params_t
-_dispatch_trace_timer_params(dispatch_clock_t clock,
-		struct dispatch_timer_source_s *values, uint64_t deadline,
-		dispatch_trace_timer_params_t params)
-{
-	#define _dispatch_trace_time2nano3(t) \
-			(_dispatch_time_clock_to_nsecs(clock, t))
-	#define _dispatch_trace_time2nano2(v, t) ({ uint64_t _t = (t); \
-			(v) >= INT64_MAX ? -1ll : (int64_t)_dispatch_trace_time2nano3(_t);})
-	#define _dispatch_trace_time2nano(v) ({ uint64_t _t; \
-			_t = _dispatch_trace_time2nano3(v); _t >= INT64_MAX ? -1ll : \
-			(int64_t)_t; })
-	if (deadline) {
-		params->deadline = (int64_t)deadline;
-	} else {
-		uint64_t now = _dispatch_time_now(clock);
-		params->deadline = _dispatch_trace_time2nano2(values->target,
-				values->target < now ? 0 : values->target - now);
-	}
-	uint64_t leeway = values->deadline - values->target;
-	params->interval = _dispatch_trace_time2nano(values->interval);
-	params->leeway = _dispatch_trace_time2nano(leeway);
-	return params;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_dispatch_trace_timer_configure_enabled(void)
-{
-	return DISPATCH_TIMER_CONFIGURE_ENABLED();
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_trace_timer_configure(dispatch_source_t ds, dispatch_clock_t clock,
-		struct dispatch_timer_source_s *values)
-{
-	dispatch_timer_source_refs_t dr = ds->ds_timer_refs;
-	struct dispatch_trace_timer_params_s params;
-	DISPATCH_TIMER_CONFIGURE(ds, _dispatch_trace_timer_function(dr),
-			_dispatch_trace_timer_params(clock, values, 0, &params));
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_trace_timer_program(dispatch_timer_source_refs_t dr, uint64_t deadline)
-{
-	if (unlikely(DISPATCH_TIMER_PROGRAM_ENABLED())) {
-		if (deadline && dr) {
-			dispatch_source_t ds = _dispatch_source_from_refs(dr);
-			dispatch_clock_t clock = DISPATCH_TIMER_CLOCK(dr->du_ident);
-			struct dispatch_trace_timer_params_s params;
-			DISPATCH_TIMER_PROGRAM(ds, _dispatch_trace_timer_function(dr),
-					_dispatch_trace_timer_params(clock, &dr->dt_timer,
-					deadline, &params));
-		}
-	}
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_trace_timer_wake(dispatch_timer_source_refs_t dr)
-{
-	if (unlikely(DISPATCH_TIMER_WAKE_ENABLED())) {
-		if (dr) {
-			dispatch_source_t ds = _dispatch_source_from_refs(dr);
-			DISPATCH_TIMER_WAKE(ds, _dispatch_trace_timer_function(dr));
-		}
-	}
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_trace_timer_fire(dispatch_timer_source_refs_t dr, uint64_t data,
-		uint64_t missed)
-{
-	if (unlikely(DISPATCH_TIMER_FIRE_ENABLED())) {
-		if (!(data - missed) && dr) {
-			dispatch_source_t ds = _dispatch_source_from_refs(dr);
-			DISPATCH_TIMER_FIRE(ds, _dispatch_trace_timer_function(dr));
-		}
-	}
-}
-
-#else
-
-#define _dispatch_trace_timer_configure_enabled() false
-#define _dispatch_trace_timer_configure(ds, clock, values) \
-		do { (void)(ds); (void)(clock); (void)(values); } while(0)
-#define _dispatch_trace_timer_program(dr, deadline) \
-		do { (void)(dr); (void)(deadline); } while(0)
-#define _dispatch_trace_timer_wake(dr) \
-		do { (void)(dr); } while(0)
-#define _dispatch_trace_timer_fire(dr, data, missed) \
-		do { (void)(dr); (void)(data); (void)(missed); } while(0)
-
-#endif // DISPATCH_USE_DTRACE
-
-#endif // DISPATCH_PURE_C
-
-#endif // __DISPATCH_TRACE__
--- a/Telegram/ThirdParty/dispatch/src/transform.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/transform.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,1133 +0,0 @@
-/*
- * Copyright (c) 2011-2013 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include "internal.h"
-
-#ifdef __APPLE__
-#include <libkern/OSByteOrder.h>
-#elif __linux__
-#include <endian.h>
-#define OSLittleEndian __LITTLE_ENDIAN
-#define OSBigEndian __BIG_ENDIAN
-#elif defined(__FreeBSD__) || defined(__OpenBSD__)
-#include <sys/endian.h>
-#define OSLittleEndian _LITTLE_ENDIAN
-#define OSBigEndian _BIG_ENDIAN
-#elif defined(_WIN32)
-#define OSLittleEndian 1234
-#define OSBigEndian 4321
-#endif
-
-#if defined(__linux__) || defined(__FreeBSD__) || defined(__OpenBSD__)
-#define OSSwapLittleToHostInt16 le16toh
-#define OSSwapBigToHostInt16 be16toh
-#define OSSwapHostToLittleInt16 htole16
-#define OSSwapHostToBigInt16 htobe16
-#elif defined(_WIN32)
-#define OSSwapLittleToHostInt16
-#define OSSwapBigToHostInt16 ntohs
-#define OSSwapHostToLittleInt16
-#define OSSwapHostToBigInt16 htons
-#endif
-
-#if defined(__LITTLE_ENDIAN__)
-#define DISPATCH_DATA_FORMAT_TYPE_UTF16_HOST DISPATCH_DATA_FORMAT_TYPE_UTF16LE
-#define DISPATCH_DATA_FORMAT_TYPE_UTF16_REV DISPATCH_DATA_FORMAT_TYPE_UTF16BE
-#elif defined(__BIG_ENDIAN__)
-#define DISPATCH_DATA_FORMAT_TYPE_UTF16_HOST DISPATCH_DATA_FORMAT_TYPE_UTF16BE
-#define DISPATCH_DATA_FORMAT_TYPE_UTF16_REV DISPATCH_DATA_FORMAT_TYPE_UTF16LE
-#else
-#error Unsupported Endianness
-#endif
-
-enum {
-	_DISPATCH_DATA_FORMAT_NONE = 0x1,
-	_DISPATCH_DATA_FORMAT_UTF8 = 0x2,
-	_DISPATCH_DATA_FORMAT_UTF16LE = 0x4,
-	_DISPATCH_DATA_FORMAT_UTF16BE = 0x8,
-	_DISPATCH_DATA_FORMAT_UTF_ANY = 0x10,
-	_DISPATCH_DATA_FORMAT_BASE32 = 0x20,
-	_DISPATCH_DATA_FORMAT_BASE32HEX = 0x40,
-	_DISPATCH_DATA_FORMAT_BASE64 = 0x80,
-};
-
-#pragma mark -
-#pragma mark baseXX tables
-
-static const unsigned char base32_encode_table[] =
-		"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
-
-static const signed char base32_decode_table[] = {
-	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 26,
-	27, 28, 29, 30, 31, -1, -1, -1, -1, -1, -2, -1, -1, -1,  0,  1,  2,
-	 3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
-	20, 21, 22, 23, 24, 25
-};
-static const ssize_t base32_decode_table_size =
-		sizeof(base32_decode_table) / sizeof(*base32_decode_table);
-
-static const unsigned char base32hex_encode_table[] =
-		"0123456789ABCDEFGHIJKLMNOPQRSTUV";
-
-static const signed char base32hex_decode_table[] = {
-	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  0,  1,  2,
-	 3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -2, -1, -1, -1, 10, 11, 12,
-	13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
-	30, 31
-};
-static const ssize_t base32hex_decode_table_size =
-		sizeof(base32hex_encode_table) / sizeof(*base32hex_encode_table);
-
-static const unsigned char base64_encode_table[] =
-		"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
-
-static const signed char base64_decode_table[] = {
-	-1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
-	-1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
-	-1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
-	-1,  62,  -1,  -1,  -1,  63,  52,  53,  54,  55,  56,  57,  58,  59,
-	60,  61,  -1,  -1,  -1,  -2,  -1,  -1,  -1,   0,   1,   2,   3,   4,
-	 5,   6,   7,   8,   9,  10,  11,  12,  13,  14,  15,  16,  17,  18,
-	19,  20,  21,  22,  23,  24,  25,  -1,  -1,  -1,  -1,  -1,  -1,  26,
-	27,  28,  29,  30,  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,
-	41,  42,  43,  44,  45,  46,  47,  48,  49,  50,  51
-};
-
-static const ssize_t base64_decode_table_size =
-		sizeof(base64_decode_table) / sizeof(*base64_decode_table);
-
-#pragma mark -
-#pragma mark dispatch_transform_buffer
-
-typedef struct dispatch_transform_buffer_s {
-	dispatch_data_t data;
-	uint8_t *start;
-	union {
-		uint8_t *u8;
-		uint16_t *u16;
-	} ptr;
-	size_t size;
-} dispatch_transform_buffer_s;
-
-#define BUFFER_MALLOC_MAX (100*1024*1024)
-
-static bool
-_dispatch_transform_buffer_new(dispatch_transform_buffer_s *buffer,
-		size_t required, size_t size)
-{
-	size_t remaining = buffer->size - (size_t)(buffer->ptr.u8 - buffer->start);
-	if (required == 0 || remaining < required) {
-		if (buffer->start) {
-			if (buffer->ptr.u8 > buffer->start) {
-				dispatch_data_t _new = dispatch_data_create(buffer->start,
-						(size_t)(buffer->ptr.u8 - buffer->start), NULL,
-						DISPATCH_DATA_DESTRUCTOR_FREE);
-				dispatch_data_t _concat = dispatch_data_create_concat(
-						buffer->data, _new);
-				dispatch_release(_new);
-				dispatch_release(buffer->data);
-				buffer->data = _concat;
-			} else {
-				free(buffer->start);
-			}
-		}
-		buffer->size = required + size;
-		buffer->start = NULL;
-		if (buffer->size > 0) {
-			if (buffer->size > BUFFER_MALLOC_MAX) {
-				return false;
-			}
-			buffer->start = (uint8_t*)malloc(buffer->size);
-			if (buffer->start == NULL) {
-				return false;
-			}
-		}
-		buffer->ptr.u8 = buffer->start;
-	}
-	return true;
-}
-
-#pragma mark -
-#pragma mark dispatch_transform_helpers
-
-static dispatch_data_t
-_dispatch_data_subrange_map(dispatch_data_t data, const void **ptr,
-		size_t offset, size_t size)
-{
-	dispatch_data_t subrange, map = NULL;
-
-	subrange = dispatch_data_create_subrange(data, offset, size);
-	if (dispatch_data_get_size(subrange) == size) {
-		map = dispatch_data_create_map(subrange, ptr, NULL);
-	}
-	dispatch_release(subrange);
-	return map;
-}
-
-static dispatch_data_format_type_t
-_dispatch_transform_detect_utf(dispatch_data_t data)
-{
-	const void *p;
-	dispatch_data_t subrange = _dispatch_data_subrange_map(data, &p, 0, 2);
-
-	if (subrange == NULL) {
-		return NULL;
-	}
-
-	const uint16_t ch = *(const uint16_t *)p;
-	dispatch_data_format_type_t type = DISPATCH_DATA_FORMAT_TYPE_UTF8;
-
-	if (ch == 0xfeff) {
-		type = DISPATCH_DATA_FORMAT_TYPE_UTF16_HOST;
-	} else if (ch == 0xfffe) {
-		type = DISPATCH_DATA_FORMAT_TYPE_UTF16_REV;
-	}
-
-	dispatch_release(subrange);
-
-	return type;
-}
-
-static uint16_t
-_dispatch_transform_swap_to_host(uint16_t x, int32_t byteOrder)
-{
-	if (byteOrder == OSLittleEndian) {
-		return OSSwapLittleToHostInt16(x);
-	}
-	return OSSwapBigToHostInt16(x);
-}
-
-static uint16_t
-_dispatch_transform_swap_from_host(uint16_t x, int32_t byteOrder)
-{
-	if (byteOrder == OSLittleEndian) {
-		return OSSwapHostToLittleInt16(x);
-	}
-	return OSSwapHostToBigInt16(x);
-}
-
-#pragma mark -
-#pragma mark UTF-8
-
-static uint8_t
-_dispatch_transform_utf8_length(uint8_t byte)
-{
-	if ((byte & 0x80) == 0) {
-		return 1;
-	} else if ((byte & 0xe0) == 0xc0) {
-		return 2;
-	} else if ((byte & 0xf0) == 0xe0) {
-		return 3;
-	} else if ((byte & 0xf8) == 0xf0) {
-		return 4;
-	}
-	return 0;
-}
-
-static uint32_t
-_dispatch_transform_read_utf8_sequence(const uint8_t *bytes)
-{
-	uint32_t wch = 0;
-	uint8_t seq_length = _dispatch_transform_utf8_length(*bytes);
-
-	switch (seq_length) {
-	case 4:
-		wch |= (*bytes & 0x7);
-		wch <<= 6;
-		break;
-	case 3:
-		wch |= (*bytes & 0xf);
-		wch <<= 6;
-		break;
-	case 2:
-		wch |= (*bytes & 0x1f);
-		wch <<= 6;
-		break;
-	case 1:
-		wch = (*bytes & 0x7f);
-		break;
-	default:
-		// Not a utf-8 sequence
-		break;
-	}
-
-	bytes++;
-	seq_length--;
-
-	while (seq_length > 0) {
-		wch |= (*bytes & 0x3f);
-		bytes++;
-		seq_length--;
-
-		if (seq_length > 0) {
-			wch <<= 6;
-		}
-	}
-	return wch;
-}
-
-#pragma mark -
-#pragma mark UTF-16
-
-static dispatch_data_t
-_dispatch_transform_to_utf16(dispatch_data_t data, int32_t byteOrder)
-{
-	__block size_t skip = 0;
-
-	__block dispatch_transform_buffer_s buffer = {
-		.data = dispatch_data_empty,
-	};
-
-	bool success = dispatch_data_apply(data, ^(
-			DISPATCH_UNUSED dispatch_data_t region,
-			size_t offset, const void *_buffer, size_t size) {
-		const uint8_t *src = _buffer;
-		size_t i, dest_size;
-
-		if (offset == 0) {
-			if (os_mul_and_add_overflow(size, sizeof(uint16_t),
-					sizeof(uint16_t), &dest_size)) {
-				return (bool)false;
-			}
-			if (!_dispatch_transform_buffer_new(&buffer, dest_size, 0)) {
-				return (bool)false;
-			}
-			// Insert BOM
-			*(buffer.ptr.u16)++ = _dispatch_transform_swap_from_host(0xfeff,
-					byteOrder);
-		}
-
-		// Skip is incremented if the previous block read-ahead into our block
-		if (skip >= size) {
-			skip -= size;
-			return (bool)true;
-		} else if (skip > 0) {
-			src += skip;
-			size -= skip;
-			skip = 0;
-		}
-
-		for (i = 0; i < size;) {
-			uint32_t wch = 0;
-			uint8_t byte_size = _dispatch_transform_utf8_length(*src);
-			size_t next;
-
-			if (byte_size == 0) {
-				return (bool)false;
-			} else if (byte_size + i > size) {
-				// UTF-8 byte sequence spans over into the next block(s)
-				const void *p;
-				dispatch_data_t subrange = _dispatch_data_subrange_map(data, &p,
-						offset + i, byte_size);
-				if (subrange == NULL) {
-					return (bool)false;
-				}
-
-				wch = _dispatch_transform_read_utf8_sequence(p);
-				skip += byte_size - (size - i);
-				src += byte_size;
-				i = size;
-
-				dispatch_release(subrange);
-			} else {
-				wch = _dispatch_transform_read_utf8_sequence(src);
-				src += byte_size;
-				i += byte_size;
-			}
-
-			if (os_mul_overflow(size - i, sizeof(uint16_t), &next)) {
-				return (bool)false;
-			}
-			if (wch == 0xfeff && offset + i == 3) {
-				// skip the BOM if any, as we already inserted one ourselves
-			} else if (wch >= 0xd800 && wch < 0xdfff) {
-				// Illegal range (surrogate pair)
-				return (bool)false;
-			} else if (wch >= 0x10000) {
-				// Surrogate pair
-				if (!_dispatch_transform_buffer_new(&buffer, 2 *
-						sizeof(uint16_t), next)) {
-					return (bool)false;
-				}
-				wch -= 0x10000;
-				*(buffer.ptr.u16)++ = _dispatch_transform_swap_from_host(
-						((wch >> 10) & 0x3ff) + 0xd800, byteOrder);
-				*(buffer.ptr.u16)++ = _dispatch_transform_swap_from_host(
-						(wch & 0x3ff) + 0xdc00, byteOrder);
-			} else {
-				if (!_dispatch_transform_buffer_new(&buffer, 1 *
-						sizeof(uint16_t), next)) {
-					return (bool)false;
-				}
-				*(buffer.ptr.u16)++ = _dispatch_transform_swap_from_host(
-						(wch & 0xffff), byteOrder);
-			}
-		}
-
-		(void)_dispatch_transform_buffer_new(&buffer, 0, 0);
-
-		return (bool)true;
-	});
-
-	if (!success) {
-		(void)_dispatch_transform_buffer_new(&buffer, 0, 0);
-		dispatch_release(buffer.data);
-		return NULL;
-	}
-
-	return buffer.data;
-}
-
-static dispatch_data_t
-_dispatch_transform_from_utf16(dispatch_data_t data, int32_t byteOrder)
-{
-	__block size_t skip = 0;
-
-	__block dispatch_transform_buffer_s buffer = {
-		.data = dispatch_data_empty,
-	};
-
-	bool success = dispatch_data_apply(data, ^(
-			DISPATCH_UNUSED dispatch_data_t region, size_t offset,
-			const void *_buffer, size_t size) {
-		const uint16_t *src = _buffer;
-
-		if (offset == 0) {
-			size_t dest_size = howmany(size, 3) * 2;
-			// Assume first buffer will be mostly single-byte UTF-8 sequences
-			if (!_dispatch_transform_buffer_new(&buffer, dest_size, 0)) {
-				return (bool)false;
-			}
-		}
-
-		size_t i = 0, max = size / 2;
-
-		// Skip is incremented if the previous block read-ahead into our block
-		if (skip >= size) {
-			skip -= size;
-			return (bool)true;
-		} else if (skip > 0) {
-			src = (uint16_t *)(((uint8_t *)src) + skip);
-			size -= skip;
-			max = (size / 2);
-			skip = 0;
-		}
-
-		// If the buffer is an odd size, allow read ahead into the next region
-		if ((size % 2) != 0) {
-			max += 1;
-		}
-
-		for (i = 0; i < max; i++) {
-			uint32_t wch = 0;
-			uint16_t ch;
-			size_t next;
-
-			if ((i == (max - 1)) && (max > (size / 2))) {
-				// Last byte of an odd sized range
-				const void *p;
-				dispatch_data_t range = _dispatch_data_subrange_map(data, &p,
-						offset + (i * 2), 2);
-				if (range == NULL) {
-					return (bool)false;
-				}
-				ch = _dispatch_transform_swap_to_host((uint16_t)*(uint64_t*)p,
-						byteOrder);
-				dispatch_release(range);
-				skip += 1;
-			} else {
-				ch =  _dispatch_transform_swap_to_host(src[i], byteOrder);
-			}
-
-			if (ch == 0xfffe && offset == 0 && i == 0) {
-				// Wrong-endian BOM at beginning of data
-				return (bool)false;
-			} else if (ch == 0xfeff && offset == 0 && i == 0) {
-				// Correct-endian BOM, skip it
-				continue;
-			}
-
-			if ((ch >= 0xd800) && (ch <= 0xdbff)) {
-				// Surrogate pair
-				wch = ((ch - 0xd800u) << 10);
-				if (++i >= max) {
-					// Surrogate byte isn't in this block
-					const void *p;
-					dispatch_data_t range = _dispatch_data_subrange_map(data,
-							&p, offset + (i * 2), 2);
-					if (range == NULL) {
-						return (bool)false;
-					}
-					ch = _dispatch_transform_swap_to_host(*(uint16_t *)p,
-							byteOrder);
-					dispatch_release(range);
-					skip += 2;
-				} else {
-					ch = _dispatch_transform_swap_to_host(src[i], byteOrder);
-				}
-				if (!((ch >= 0xdc00) && (ch <= 0xdfff))) {
-					return (bool)false;
-				}
-				wch = (wch | (ch & 0x3ff));
-				wch += 0x10000;
-			} else if ((ch >= 0xdc00) && (ch <= 0xdfff)) {
-				return (bool)false;
-			} else {
-				wch = ch;
-			}
-
-			if (os_mul_overflow(max - i, 2, &next)) {
-				return (bool)false;
-			}
-			if (wch < 0x80) {
-				if (!_dispatch_transform_buffer_new(&buffer, 1, next)) {
-					return (bool)false;
-				}
-				*(buffer.ptr.u8)++ = (uint8_t)(wch & 0xff);
-			} else if (wch < 0x800) {
-				if (!_dispatch_transform_buffer_new(&buffer, 2, next)) {
-					return (bool)false;
-				}
-				*(buffer.ptr.u8)++ = (uint8_t)(0xc0 | (wch >> 6));
-				*(buffer.ptr.u8)++ = (uint8_t)(0x80 | (wch & 0x3f));
-			} else if (wch < 0x10000) {
-				if (!_dispatch_transform_buffer_new(&buffer, 3, next)) {
-					return (bool)false;
-				}
-				*(buffer.ptr.u8)++ = (uint8_t)(0xe0 | (wch >> 12));
-				*(buffer.ptr.u8)++ = (uint8_t)(0x80 | ((wch >> 6) & 0x3f));
-				*(buffer.ptr.u8)++ = (uint8_t)(0x80 | (wch & 0x3f));
-			} else if (wch < 0x200000) {
-				if (!_dispatch_transform_buffer_new(&buffer, 4, next)) {
-					return (bool)false;
-				}
-				*(buffer.ptr.u8)++ = (uint8_t)(0xf0 | (wch >> 18));
-				*(buffer.ptr.u8)++ = (uint8_t)(0x80 | ((wch >> 12) & 0x3f));
-				*(buffer.ptr.u8)++ = (uint8_t)(0x80 | ((wch >> 6) & 0x3f));
-				*(buffer.ptr.u8)++ = (uint8_t)(0x80 | (wch & 0x3f));
-			}
-		}
-
-		(void)_dispatch_transform_buffer_new(&buffer, 0, 0);
-
-		return (bool)true;
-	});
-
-	if (!success) {
-		(void)_dispatch_transform_buffer_new(&buffer, 0, 0);
-		dispatch_release(buffer.data);
-		return NULL;
-	}
-
-	return buffer.data;
-}
-
-static dispatch_data_t
-_dispatch_transform_from_utf16le(dispatch_data_t data)
-{
-	return _dispatch_transform_from_utf16(data, OSLittleEndian);
-}
-
-static dispatch_data_t
-_dispatch_transform_from_utf16be(dispatch_data_t data)
-{
-	return _dispatch_transform_from_utf16(data, OSBigEndian);
-}
-
-static dispatch_data_t
-_dispatch_transform_to_utf16le(dispatch_data_t data)
-{
-	return _dispatch_transform_to_utf16(data, OSLittleEndian);
-}
-
-static dispatch_data_t
-_dispatch_transform_to_utf16be(dispatch_data_t data)
-{
-	return _dispatch_transform_to_utf16(data, OSBigEndian);
-}
-
-static dispatch_data_t
-_dispatch_transform_to_utf8_without_bom(dispatch_data_t data)
-{
-	static uint8_t const utf8_bom[] = { 0xef, 0xbb, 0xbf };
-	const void *p;
-	dispatch_data_t subrange = _dispatch_data_subrange_map(data, &p, 0, 3);
-	bool has_bom = false;
-
-	if (subrange) {
-		has_bom = (memcmp(p, utf8_bom, sizeof(utf8_bom)) == 0);
-		dispatch_release(subrange);
-	}
-	if (has_bom) {
-		return dispatch_data_create_subrange(data, 3,
-				dispatch_data_get_size(data) - 3);
-	}
-	dispatch_retain(data);
-	return data;
-}
-
-#pragma mark -
-#pragma mark base32
-
-static dispatch_data_t
-_dispatch_transform_from_base32_with_table(dispatch_data_t data,
-		const signed char* table, ssize_t table_size)
-{
-	__block uint64_t x = 0, count = 0, pad = 0;
-
-	__block dispatch_data_t rv = dispatch_data_empty;
-
-	bool success = dispatch_data_apply(data, ^(
-			DISPATCH_UNUSED dispatch_data_t region,
-			DISPATCH_UNUSED size_t offset, const void *buffer, size_t size) {
-		size_t i, dest_size = howmany(size, 8) * 5;
-		uint8_t *dest = (uint8_t*)malloc(dest_size * sizeof(uint8_t));
-		uint8_t *ptr = dest;
-		if (dest == NULL) {
-			return (bool)false;
-		}
-
-		const uint8_t *bytes = buffer;
-
-		for (i = 0; i < size; i++) {
-			if (bytes[i] == '\n' || bytes[i] == '\t' || bytes[i] == ' ') {
-				continue;
-			}
-
-			ssize_t index = bytes[i];
-			if (index >= table_size || table[index] == -1) {
-				free(dest);
-				return (bool)false;
-			}
-			count++;
-
-			signed char value = table[index];
-			if (value == -2) {
-				value = 0;
-				pad++;
-			}
-
-			x <<= 5;
-			x += (uint64_t)value;
-
-			if ((count & 0x7) == 0) {
-				*ptr++ = (x >> 32) & 0xff;
-				*ptr++ = (x >> 24) & 0xff;
-				*ptr++ = (x >> 16) & 0xff;
-				*ptr++ = (x >> 8) & 0xff;
-				*ptr++ = x & 0xff;
-			}
-		}
-
-		size_t final = (size_t)(ptr - dest);
-		switch (pad) {
-		case 1:
-			final -= 1;
-			break;
-		case 3:
-			final -= 2;
-			break;
-		case 4:
-			final -= 3;
-			break;
-		case 6:
-			final -= 4;
-			break;
-		}
-
-		dispatch_data_t val = dispatch_data_create(dest, final, NULL,
-				DISPATCH_DATA_DESTRUCTOR_FREE);
-		dispatch_data_t concat = dispatch_data_create_concat(rv, val);
-
-		dispatch_release(val);
-		dispatch_release(rv);
-		rv = concat;
-
-		return (bool)true;
-	});
-
-	if (!success) {
-		dispatch_release(rv);
-		return NULL;
-	}
-
-	return rv;
-}
-
-static dispatch_data_t
-_dispatch_transform_to_base32_with_table(dispatch_data_t data, const unsigned char* table)
-{
-	size_t total = dispatch_data_get_size(data), dest_size;
-	__block size_t count = 0;
-
-	dest_size = howmany(total, 5);
-	// <rdar://problem/25676583>
-	// os_mul_overflow(dest_size, 8, &dest_size)
-	if (dest_size > SIZE_MAX / 8) {
-		return NULL;
-	}
-	dest_size *= 8;
-
-	uint8_t *dest = (uint8_t*)malloc(dest_size);
-	if (dest == NULL) {
-		return NULL;
-	}
-
-	__block uint8_t *ptr = dest;
-
-	/*
-					    0        1        2        3        4
-	 8-bit bytes:   xxxxxxxx yyyyyyyy zzzzzzzz xxxxxxxx yyyyyyyy
-	 5-bit chunks:  aaaaabbb bbcccccd ddddeeee efffffgg ggghhhhh
-	 */
-
-	bool success = dispatch_data_apply(data, ^(
-			DISPATCH_UNUSED dispatch_data_t region,
-			size_t offset, const void *buffer, size_t size) {
-		const uint8_t *bytes = buffer;
-		size_t i;
-
-		for (i = 0; i < size; i++, count++) {
-			uint8_t curr = bytes[i], last = 0;
-
-			if ((count % 5) != 0) {
-				if (i == 0) {
-					const void *p;
-					dispatch_data_t subrange = _dispatch_data_subrange_map(data,
-							&p, offset - 1, 1);
-					if (subrange == NULL) {
-						return (bool)false;
-					}
-					last = *(uint8_t*)p;
-					dispatch_release(subrange);
-				} else {
-					last = bytes[i - 1];
-				}
-			}
-
-			switch (count % 5) {
-			case 0:
-				// a
-				*ptr++ = table[(curr >> 3) & 0x1fu];
-				break;
-			case 1:
-				// b + c
-				*ptr++ = table[((last << 2)|(curr >> 6)) & 0x1f];
-				*ptr++ = table[(curr >> 1) & 0x1f];
-				break;
-			case 2:
-				// d
-				*ptr++ = table[((last << 4)|(curr >> 4)) & 0x1f];
-				break;
-			case 3:
-				// e + f
-				*ptr++ = table[((last << 1)|(curr >> 7)) & 0x1f];
-				*ptr++ = table[(curr >> 2) & 0x1f];
-				break;
-			case 4:
-				// g + h
-				*ptr++ = table[((last << 3)|(curr >> 5)) & 0x1f];
-				*ptr++ = table[curr & 0x1f];
-				break;
-			}
-		}
-
-		// Last region, insert padding bytes, if needed
-		if (offset + size == total) {
-			switch (count % 5) {
-			case 0:
-				break;
-			case 1:
-				// b[4:2]
-				*ptr++ = table[(bytes[size-1] << 2) & 0x1c];
-				break;
-			case 2:
-				// d[4]
-				*ptr++ = table[(bytes[size-1] << 4) & 0x10];
-				break;
-			case 3:
-				// e[4:1]
-				*ptr++ = table[(bytes[size-1] << 1) & 0x1e];
-				break;
-			case 4:
-				// g[2:3]
-				*ptr++ = table[(bytes[size-1] << 3) & 0x18];
-				break;
-			}
-			switch (count % 5) {
-			case 0:
-				break;
-			case 1:
-				*ptr++ = '='; // c
-				*ptr++ = '='; // d
-				DISPATCH_FALLTHROUGH;
-			case 2:
-				*ptr++ = '='; // e
-				DISPATCH_FALLTHROUGH;
-			case 3:
-				*ptr++ = '='; // f
-				*ptr++ = '='; // g
-				DISPATCH_FALLTHROUGH;
-			case 4:
-				*ptr++ = '='; // h
-				break;
-			}
-		}
-
-		return (bool)true;
-	});
-
-	if (!success) {
-		free(dest);
-		return NULL;
-	}
-	return dispatch_data_create(dest, dest_size, NULL,
-			DISPATCH_DATA_DESTRUCTOR_FREE);
-}
-
-static dispatch_data_t
-_dispatch_transform_from_base32(dispatch_data_t data)
-{
-	return _dispatch_transform_from_base32_with_table(data, base32_decode_table,
-			base32_decode_table_size);
-}
-
-static dispatch_data_t
-_dispatch_transform_to_base32(dispatch_data_t data)
-{
-	return _dispatch_transform_to_base32_with_table(data, base32_encode_table);
-}
-
-static dispatch_data_t
-_dispatch_transform_from_base32hex(dispatch_data_t data)
-{
-	return _dispatch_transform_from_base32_with_table(data,
-			base32hex_decode_table, base32hex_decode_table_size);
-}
-
-static dispatch_data_t
-_dispatch_transform_to_base32hex(dispatch_data_t data)
-{
-	return _dispatch_transform_to_base32_with_table(data,
-			base32hex_encode_table);
-}
-
-#pragma mark -
-#pragma mark base64
-
-static dispatch_data_t
-_dispatch_transform_from_base64(dispatch_data_t data)
-{
-	__block uint64_t x = 0, count = 0;
-	__block size_t pad = 0;
-
-	__block dispatch_data_t rv = dispatch_data_empty;
-
-	bool success = dispatch_data_apply(data, ^(
-			DISPATCH_UNUSED dispatch_data_t region,
-			DISPATCH_UNUSED size_t offset, const void *buffer, size_t size) {
-		size_t i, dest_size = howmany(size, 4) * 3;
-
-		uint8_t *dest = (uint8_t*)malloc(dest_size * sizeof(uint8_t));
-		uint8_t *ptr = dest;
-		if (dest == NULL) {
-			return (bool)false;
-		}
-
-		const uint8_t *bytes = buffer;
-
-		for (i = 0; i < size; i++) {
-			if (bytes[i] == '\n' || bytes[i] == '\t' || bytes[i] == ' ') {
-				continue;
-			}
-
-			ssize_t index = bytes[i];
-			if (index >= base64_decode_table_size ||
-					base64_decode_table[index] == -1) {
-				free(dest);
-				return (bool)false;
-			}
-			count++;
-
-			signed char value = base64_decode_table[index];
-			if (value == -2) {
-				value = 0;
-				pad++;
-			}
-
-			x <<= 6;
-			x += (uint64_t)value;
-
-			if ((count & 0x3) == 0) {
-				*ptr++ = (x >> 16) & 0xff;
-				*ptr++ = (x >> 8) & 0xff;
-				*ptr++ = x & 0xff;
-			}
-		}
-
-		size_t final = (size_t)(ptr - dest);
-		if (pad > 0) {
-			// 2 bytes of pad means only had one char in final group
-			final -= pad;
-		}
-
-		dispatch_data_t val = dispatch_data_create(dest, final, NULL,
-				DISPATCH_DATA_DESTRUCTOR_FREE);
-		dispatch_data_t concat = dispatch_data_create_concat(rv, val);
-
-		dispatch_release(val);
-		dispatch_release(rv);
-		rv = concat;
-
-		return (bool)true;
-	});
-
-	if (!success) {
-		dispatch_release(rv);
-		return NULL;
-	}
-
-	return rv;
-}
-
-static dispatch_data_t
-_dispatch_transform_to_base64(dispatch_data_t data)
-{
-	// RFC 4648 states that we should not linebreak
-	// http://tools.ietf.org/html/rfc4648
-	size_t total = dispatch_data_get_size(data), dest_size;
-	__block size_t count = 0;
-
-	dest_size = howmany(total, 3);
-	// <rdar://problem/25676583>
-	// os_mul_overflow(dest_size, 4, &dest_size)
-	if (dest_size > SIZE_MAX / 4) {
-		return NULL;
-	}
-	dest_size *= 4;
-
-	uint8_t *dest = (uint8_t*)malloc(dest_size);
-	if (dest == NULL) {
-		return NULL;
-	}
-
-	__block uint8_t *ptr = dest;
-
-	/*
-	 * 3 8-bit bytes:	xxxxxxxx yyyyyyyy zzzzzzzz
-	 * 4 6-bit chunks:	aaaaaabb bbbbcccc ccdddddd
-	 */
-
-	bool success = dispatch_data_apply(data, ^(
-			DISPATCH_UNUSED dispatch_data_t region,
-			size_t offset, const void *buffer, size_t size) {
-		const uint8_t *bytes = buffer;
-		size_t i;
-
-		for (i = 0; i < size; i++, count++) {
-			uint8_t curr = bytes[i], last = 0;
-
-			if ((count % 3) != 0) {
-				if (i == 0) {
-					const void *p;
-					dispatch_data_t subrange = _dispatch_data_subrange_map(data,
-						&p, offset - 1, 1);
-					if (subrange == NULL) {
-						return (bool)false;
-					}
-					last = *(uint8_t*)p;
-					dispatch_release(subrange);
-				} else {
-					last = bytes[i - 1];
-				}
-			}
-
-			switch (count % 3) {
-			case 0:
-				*ptr++ = base64_encode_table[(curr >> 2) & 0x3f];
-				break;
-			case 1:
-				*ptr++ = base64_encode_table[((last << 4)|(curr >> 4)) & 0x3f];
-				break;
-			case 2:
-				*ptr++ = base64_encode_table[((last << 2)|(curr >> 6)) & 0x3f];
-				*ptr++ = base64_encode_table[(curr & 0x3f)];
-				break;
-			}
-		}
-
-		// Last region, insert padding bytes, if needed
-		if (offset + size == total) {
-			switch (count % 3) {
-			case 0:
-				break;
-			case 1:
-				*ptr++ = base64_encode_table[(bytes[size-1] << 4) & 0x30];
-				*ptr++ = '=';
-				*ptr++ = '=';
-				break;
-			case 2:
-				*ptr++ = base64_encode_table[(bytes[size-1] << 2) & 0x3c];
-				*ptr++ = '=';
-				break;
-			}
-		}
-
-		return (bool)true;
-	});
-
-	if (!success) {
-		free(dest);
-		return NULL;
-	}
-	return dispatch_data_create(dest, dest_size, NULL,
-			DISPATCH_DATA_DESTRUCTOR_FREE);
-}
-
-#pragma mark -
-#pragma mark dispatch_data_transform
-
-dispatch_data_t
-dispatch_data_create_with_transform(dispatch_data_t data,
-		dispatch_data_format_type_t input, dispatch_data_format_type_t output)
-{
-	if (input->type == _DISPATCH_DATA_FORMAT_UTF_ANY) {
-		input = _dispatch_transform_detect_utf(data);
-		if (input == NULL) {
-			return DISPATCH_BAD_INPUT;
-		}
-	}
-
-	if ((input->type & ~output->input_mask) != 0) {
-		return DISPATCH_BAD_INPUT;
-	}
-
-	if ((output->type & ~input->output_mask) != 0) {
-		return DISPATCH_BAD_INPUT;
-	}
-
-	if (dispatch_data_get_size(data) == 0) {
-		return data;
-	}
-
-	dispatch_data_t temp1;
-	if (input->decode) {
-		temp1 = input->decode(data);
-	} else {
-		dispatch_retain(data);
-		temp1 = data;
-	}
-
-	if (!temp1) {
-		return DISPATCH_BAD_INPUT;
-	}
-
-	dispatch_data_t temp2;
-	if (output->encode) {
-		temp2 = output->encode(temp1);
-	} else {
-		dispatch_retain(temp1);
-		temp2 = temp1;
-	}
-
-	dispatch_release(temp1);
-	return temp2;
-}
-
-const struct dispatch_data_format_type_s _dispatch_data_format_type_none = {
-	.type = _DISPATCH_DATA_FORMAT_NONE,
-	.input_mask = ~0u,
-	.output_mask = ~0u,
-	.decode = NULL,
-	.encode = NULL,
-};
-
-const struct dispatch_data_format_type_s _dispatch_data_format_type_base32 = {
-	.type = _DISPATCH_DATA_FORMAT_BASE32,
-	.input_mask = (_DISPATCH_DATA_FORMAT_NONE | _DISPATCH_DATA_FORMAT_BASE32 |
-			_DISPATCH_DATA_FORMAT_BASE32HEX | _DISPATCH_DATA_FORMAT_BASE64),
-	.output_mask = (_DISPATCH_DATA_FORMAT_NONE | _DISPATCH_DATA_FORMAT_BASE32 |
-			_DISPATCH_DATA_FORMAT_BASE32HEX | _DISPATCH_DATA_FORMAT_BASE64),
-	.decode = _dispatch_transform_from_base32,
-	.encode = _dispatch_transform_to_base32,
-};
-
-const struct dispatch_data_format_type_s _dispatch_data_format_type_base32hex =
-{
-	.type = _DISPATCH_DATA_FORMAT_BASE32HEX,
-	.input_mask = (_DISPATCH_DATA_FORMAT_NONE | _DISPATCH_DATA_FORMAT_BASE32 |
-			_DISPATCH_DATA_FORMAT_BASE32HEX | _DISPATCH_DATA_FORMAT_BASE64),
-	.output_mask = (_DISPATCH_DATA_FORMAT_NONE | _DISPATCH_DATA_FORMAT_BASE32 |
-			_DISPATCH_DATA_FORMAT_BASE32HEX | _DISPATCH_DATA_FORMAT_BASE64),
-	.decode = _dispatch_transform_from_base32hex,
-	.encode = _dispatch_transform_to_base32hex,
-};
-
-const struct dispatch_data_format_type_s _dispatch_data_format_type_base64 = {
-	.type = _DISPATCH_DATA_FORMAT_BASE64,
-	.input_mask = (_DISPATCH_DATA_FORMAT_NONE | _DISPATCH_DATA_FORMAT_BASE32 |
-			_DISPATCH_DATA_FORMAT_BASE32HEX | _DISPATCH_DATA_FORMAT_BASE64),
-	.output_mask = (_DISPATCH_DATA_FORMAT_NONE | _DISPATCH_DATA_FORMAT_BASE32 |
-			_DISPATCH_DATA_FORMAT_BASE32HEX | _DISPATCH_DATA_FORMAT_BASE64),
-	.decode = _dispatch_transform_from_base64,
-	.encode = _dispatch_transform_to_base64,
-};
-
-const struct dispatch_data_format_type_s _dispatch_data_format_type_utf16le = {
-	.type = _DISPATCH_DATA_FORMAT_UTF16LE,
-	.input_mask = (_DISPATCH_DATA_FORMAT_UTF8 | _DISPATCH_DATA_FORMAT_UTF16BE |
-			_DISPATCH_DATA_FORMAT_UTF16LE),
-	.output_mask = (_DISPATCH_DATA_FORMAT_UTF8 | _DISPATCH_DATA_FORMAT_UTF16BE |
-			_DISPATCH_DATA_FORMAT_UTF16LE),
-	.decode = _dispatch_transform_from_utf16le,
-	.encode = _dispatch_transform_to_utf16le,
-};
-
-const struct dispatch_data_format_type_s _dispatch_data_format_type_utf16be = {
-	.type = _DISPATCH_DATA_FORMAT_UTF16BE,
-	.input_mask = (_DISPATCH_DATA_FORMAT_UTF8 | _DISPATCH_DATA_FORMAT_UTF16BE |
-			_DISPATCH_DATA_FORMAT_UTF16LE),
-	.output_mask = (_DISPATCH_DATA_FORMAT_UTF8 | _DISPATCH_DATA_FORMAT_UTF16BE |
-			_DISPATCH_DATA_FORMAT_UTF16LE),
-	.decode = _dispatch_transform_from_utf16be,
-	.encode = _dispatch_transform_to_utf16be,
-};
-
-const struct dispatch_data_format_type_s _dispatch_data_format_type_utf8 = {
-	.type = _DISPATCH_DATA_FORMAT_UTF8,
-	.input_mask = (_DISPATCH_DATA_FORMAT_UTF8 | _DISPATCH_DATA_FORMAT_UTF16BE |
-			_DISPATCH_DATA_FORMAT_UTF16LE),
-	.output_mask = (_DISPATCH_DATA_FORMAT_UTF8 | _DISPATCH_DATA_FORMAT_UTF16BE |
-			_DISPATCH_DATA_FORMAT_UTF16LE),
-	.decode = NULL,
-	.encode = _dispatch_transform_to_utf8_without_bom,
-};
-
-const struct dispatch_data_format_type_s _dispatch_data_format_type_utf_any = {
-	.type = _DISPATCH_DATA_FORMAT_UTF_ANY,
-	.input_mask = 0,
-	.output_mask = 0,
-	.decode = NULL,
-	.encode = NULL,
-};
--- a/Telegram/ThirdParty/dispatch/src/voucher.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/voucher.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,2042 +0,0 @@
-/*
- * Copyright (c) 2013-2016 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include "internal.h"
-
-#ifndef PERSONA_ID_NONE
-#define PERSONA_ID_NONE ((uid_t)-1)
-#endif
-
-#if !DISPATCH_VARIANT_DYLD_STUB
-
-#if VOUCHER_USE_MACH_VOUCHER
-#if !HAVE_PTHREAD_WORKQUEUE_QOS
-#error Unsupported configuration, workqueue QoS support is required
-#endif
-#include <mach/mach_voucher.h>
-#include <sys/proc_info.h>
-
-#define MACH_ACTIVITY_ID_RANGE_SIZE 16
-#define MACH_ACTIVITY_ID_MASK ((1ULL << FIREHOSE_ACTIVITY_ID_FLAGS_SHIFT) - 1)
-#define FIREHOSE_ACTIVITY_ID_MAKE(aid, flags) \
-		FIREHOSE_ACTIVITY_ID_MERGE_FLAGS((aid) & MACH_ACTIVITY_ID_MASK, flags)
-
-DISPATCH_STATIC_GLOBAL(volatile uint64_t _voucher_aid_next);
-
-#pragma mark -
-#pragma mark voucher_t
-
-OS_OBJECT_CLASS_DECL(voucher);
-#if !USE_OBJC
-OS_OBJECT_VTABLE_INSTANCE(voucher,
-		(void (*)(_os_object_t))_voucher_xref_dispose,
-		(void (*)(_os_object_t))_voucher_dispose);
-#endif // USE_OBJC
-#define VOUCHER_CLASS OS_OBJECT_VTABLE(voucher)
-
-static inline voucher_t
-_voucher_alloc(mach_voucher_attr_recipe_size_t extra)
-{
-	voucher_t voucher;
-	size_t voucher_size = sizeof(voucher_s) + extra;
-	voucher = (voucher_t)_os_object_alloc_realized(VOUCHER_CLASS, voucher_size);
-#if VOUCHER_ENABLE_RECIPE_OBJECTS
-	voucher->v_recipe_extra_size = extra;
-	voucher->v_recipe_extra_offset = voucher_size - extra;
-#else
-	dispatch_assert(!extra);
-#endif
-	_dispatch_voucher_debug("alloc", voucher);
-	return voucher;
-}
-
-#if VOUCHER_ENABLE_RECIPE_OBJECTS
-voucher_t
-voucher_create(voucher_recipe_t recipe)
-{
-	// TODO: capture current activities or current kvoucher ?
-	mach_voucher_attr_recipe_size_t extra = recipe ? recipe->vr_size : 0;
-	voucher_t voucher = _voucher_alloc(extra);
-	if (extra) {
-		memcpy(_voucher_extra_recipes(voucher), recipe->vr_data, extra);
-	}
-	_voucher_trace(CREATE, voucher, MACH_PORT_NULL, 0);
-	return voucher;
-}
-#endif
-
-DISPATCH_ALWAYS_INLINE
-static inline voucher_t
-_voucher_clone(const voucher_t ov, voucher_fields_t ignore_fields)
-{
-	mach_voucher_attr_recipe_size_t extra = 0;
-	voucher_t v;
-
-	if (ov && !(ignore_fields & VOUCHER_FIELD_EXTRA)) {
-		extra = _voucher_extra_size(ov);
-	}
-	v = _voucher_alloc(extra);
-	if (ov) {
-		voucher_fields_t fields = ~ignore_fields;
-		if ((fields & VOUCHER_FIELD_KVOUCHER) && ov->v_kvoucher) {
-			voucher_t kvb = ov->v_kvbase ? ov->v_kvbase : ov;
-			v->v_kvbase = _voucher_retain(kvb);
-			v->v_kvoucher = kvb->v_kvoucher;
-			v->v_kv_has_importance = kvb->v_kv_has_importance;
-		}
-		if (fields & VOUCHER_FIELD_PRIORITY) {
-			v->v_priority = ov->v_priority;
-		}
-		if (fields & VOUCHER_FIELD_ACTIVITY) {
-			v->v_activity = ov->v_activity;
-			v->v_activity_creator = ov->v_activity_creator;
-			v->v_parent_activity = ov->v_parent_activity;
-		}
-		if ((fields & VOUCHER_FIELD_EXTRA) && extra) {
-			memcpy(_voucher_extra_recipes(v), _voucher_extra_recipes(ov),extra);
-		}
-	}
-	return v;
-}
-
-voucher_t
-voucher_adopt(voucher_t voucher)
-{
-	if (voucher == VOUCHER_CURRENT) {
-		return _voucher_copy();
-	}
-	return _voucher_adopt(voucher);
-}
-
-voucher_t
-voucher_copy(void)
-{
-	return _voucher_copy();
-}
-
-voucher_t
-voucher_copy_without_importance(void)
-{
-	return _voucher_copy_without_importance();
-}
-
-voucher_t
-voucher_retain(voucher_t voucher)
-{
-	return _voucher_retain(voucher);
-}
-
-void
-voucher_release(voucher_t voucher)
-{
-	return _voucher_release(voucher);
-}
-
-void DISPATCH_TSD_DTOR_CC
-_voucher_thread_cleanup(void *voucher)
-{
-	// when a thread exits and has a voucher left, the kernel
-	// will get rid of the voucher kernel object that is set on the thread,
-	// we only need to release the voucher_t object.
-	_voucher_release(voucher);
-}
-
-#pragma mark -
-#pragma mark voucher_hash
-
-extern voucher_hash_head_s _voucher_hash[VL_HASH_SIZE];
-DISPATCH_GLOBAL_INIT(voucher_hash_head_s _voucher_hash[VL_HASH_SIZE], {
-	[0 ... VL_HASH_SIZE - 1] = { ~(uintptr_t)VOUCHER_NULL },
-});
-DISPATCH_STATIC_GLOBAL(dispatch_unfair_lock_s _voucher_hash_lock);
-
-#define _voucher_hash_head(kv)   (&_voucher_hash[VL_HASH((kv))])
-#define _voucher_hash_lock_lock() \
-		_dispatch_unfair_lock_lock(&_voucher_hash_lock)
-#define _voucher_hash_lock_unlock() \
-		_dispatch_unfair_lock_unlock(&_voucher_hash_lock)
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_voucher_hash_enqueue(mach_voucher_t kv, voucher_t v)
-{
-	// same as LIST_INSERT_HEAD
-	voucher_hash_head_s *head = _voucher_hash_head(kv);
-	voucher_t next = _voucher_hash_get_next(head->vhh_first);
-	v->v_list.vhe_next = head->vhh_first;
-	if (next) {
-		_voucher_hash_set_prev_ptr(&next->v_list.vhe_prev_ptr,
-				&v->v_list.vhe_next);
-	}
-	_voucher_hash_set_next(&head->vhh_first, v);
-	_voucher_hash_set_prev_ptr(&v->v_list.vhe_prev_ptr, &head->vhh_first);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_voucher_hash_remove(voucher_t v)
-{
-	// same as LIST_REMOVE
-	voucher_t next = _voucher_hash_get_next(v->v_list.vhe_next);
-	uintptr_t prev_ptr = v->v_list.vhe_prev_ptr;
-	if (next) {
-		next->v_list.vhe_prev_ptr = prev_ptr;
-	}
-	_voucher_hash_store_to_prev_ptr(prev_ptr, next);
-	_voucher_hash_mark_not_enqueued(v);
-}
-
-static voucher_t
-_voucher_find_and_retain(mach_voucher_t kv)
-{
-	if (!kv) return NULL;
-	_voucher_hash_lock_lock();
-	voucher_hash_head_s *head = _voucher_hash_head(kv);
-	voucher_t v = _voucher_hash_get_next(head->vhh_first);
-	while (v) {
-		if (v->v_ipc_kvoucher == kv) {
-			int xref_cnt = os_atomic_inc2o(v, os_obj_xref_cnt, relaxed);
-			_dispatch_voucher_debug("retain  -> %d", v, xref_cnt + 1);
-			if (unlikely(xref_cnt < 0)) {
-				_dispatch_voucher_debug("over-release", v);
-				_OS_OBJECT_CLIENT_CRASH("Voucher over-release");
-			}
-			if (xref_cnt == 0) {
-				// resurrection: raced with _voucher_remove
-				(void)os_atomic_inc2o(v, os_obj_ref_cnt, relaxed);
-			}
-			break;
-		}
-		v = _voucher_hash_get_next(v->v_list.vhe_next);
-	}
-	_voucher_hash_lock_unlock();
-	return v;
-}
-
-static void
-_voucher_insert(voucher_t v)
-{
-	mach_voucher_t kv = v->v_ipc_kvoucher;
-	if (!kv) return;
-	_voucher_hash_lock_lock();
-	if (unlikely(_voucher_hash_is_enqueued(v))) {
-		_dispatch_voucher_debug("corruption", v);
-		DISPATCH_CLIENT_CRASH(0, "Voucher corruption");
-	}
-	_voucher_hash_enqueue(kv, v);
-	_voucher_hash_lock_unlock();
-}
-
-static void
-_voucher_remove(voucher_t v)
-{
-	mach_voucher_t kv = v->v_ipc_kvoucher;
-	if (!_voucher_hash_is_enqueued(v)) return;
-	_voucher_hash_lock_lock();
-	if (unlikely(!kv)) {
-		_dispatch_voucher_debug("corruption", v);
-		DISPATCH_CLIENT_CRASH(0, "Voucher corruption");
-	}
-	// check for resurrection race with _voucher_find_and_retain
-	if (os_atomic_load2o(v, os_obj_xref_cnt, ordered) < 0) {
-		if (_voucher_hash_is_enqueued(v)) _voucher_hash_remove(v);
-	}
-	_voucher_hash_lock_unlock();
-}
-
-#pragma mark -
-#pragma mark mach_voucher_t
-
-void
-_voucher_dealloc_mach_voucher(mach_voucher_t kv)
-{
-	_dispatch_kvoucher_debug("dealloc", kv);
-	_dispatch_voucher_debug_machport(kv);
-	kern_return_t kr = mach_voucher_deallocate(kv);
-	DISPATCH_VERIFY_MIG(kr);
-	(void)dispatch_assume_zero(kr);
-}
-
-static inline kern_return_t
-_voucher_create_mach_voucher(const mach_voucher_attr_recipe_data_t *recipes,
-		size_t recipes_size, mach_voucher_t *kvp)
-{
-	kern_return_t kr;
-	mach_port_t mhp = _dispatch_get_mach_host_port();
-	mach_voucher_t kv = MACH_VOUCHER_NULL;
-	mach_voucher_attr_raw_recipe_array_t kvr;
-	mach_voucher_attr_recipe_size_t kvr_size;
-	kvr = (mach_voucher_attr_raw_recipe_array_t)recipes;
-	kvr_size = (mach_voucher_attr_recipe_size_t)recipes_size;
-	kr = host_create_mach_voucher(mhp, kvr, kvr_size, &kv);
-	DISPATCH_VERIFY_MIG(kr);
-	if (!kr) {
-		_dispatch_kvoucher_debug("create", kv);
-		_dispatch_voucher_debug_machport(kv);
-	}
-	*kvp = kv;
-	return kr;
-}
-
-void
-_voucher_task_mach_voucher_init(void* ctxt DISPATCH_UNUSED)
-{
-	kern_return_t kr;
-	mach_voucher_t kv = MACH_VOUCHER_NULL;
-#if !VOUCHER_USE_EMPTY_MACH_BASE_VOUCHER
-	static const mach_voucher_attr_recipe_data_t task_create_recipe = {
-		.key = MACH_VOUCHER_ATTR_KEY_BANK,
-		.command = MACH_VOUCHER_ATTR_BANK_CREATE,
-	};
-	kr = _voucher_create_mach_voucher(&task_create_recipe,
-			sizeof(task_create_recipe), &kv);
-	if (unlikely(kr)) {
-		DISPATCH_CLIENT_CRASH(kr, "Could not create task mach voucher");
-	}
-	_voucher_default_task_mach_voucher = kv;
-#endif
-	_voucher_task_mach_voucher = kv;
-}
-
-void
-voucher_replace_default_voucher(void)
-{
-	(void)_voucher_get_task_mach_voucher(); // initalize task mach voucher
-	mach_voucher_t kv, tkv = MACH_VOUCHER_NULL;
-	voucher_t v = _voucher_get();
-	if (v && v->v_kvoucher) {
-		kern_return_t kr;
-		kv = v->v_ipc_kvoucher ? v->v_ipc_kvoucher : v->v_kvoucher;
-		const mach_voucher_attr_recipe_data_t task_copy_recipe = {
-			.key = MACH_VOUCHER_ATTR_KEY_BANK,
-			.command = MACH_VOUCHER_ATTR_COPY,
-			.previous_voucher = kv,
-		};
-		kr = _voucher_create_mach_voucher(&task_copy_recipe,
-				sizeof(task_copy_recipe), &tkv);
-		if (dispatch_assume_zero(kr)) {
-			tkv = MACH_VOUCHER_NULL;
-		}
-	}
-	if (!tkv) tkv = _voucher_default_task_mach_voucher;
-	kv = os_atomic_xchg(&_voucher_task_mach_voucher, tkv, relaxed);
-	if (kv && kv != _voucher_default_task_mach_voucher) {
-		_voucher_dealloc_mach_voucher(kv);
-	}
-	_dispatch_voucher_debug("kvoucher[0x%08x] replace default voucher", v, tkv);
-}
-
-#define _voucher_mach_recipe_size(payload_size) \
-	(sizeof(mach_voucher_attr_recipe_data_t) + (payload_size))
-
-#define _voucher_mach_recipe_alloca(v) ((mach_voucher_attr_recipe_t)alloca(\
-		_voucher_mach_recipe_size(0) + \
-		_voucher_mach_recipe_size(sizeof(ipc_pthread_priority_value_t)) + \
-		_voucher_mach_recipe_size(sizeof(_voucher_mach_udata_s)) + \
-		_voucher_extra_size(v)))
-
-DISPATCH_ALWAYS_INLINE
-static inline mach_voucher_attr_recipe_size_t
-_voucher_mach_recipe_init(mach_voucher_attr_recipe_t mvar_buf, voucher_s *v,
-		mach_voucher_t kvb, pthread_priority_t pp)
-{
-	mach_voucher_attr_recipe_size_t extra = _voucher_extra_size(v);
-	mach_voucher_attr_recipe_size_t size = 0;
-
-	// normalize to just the QoS class and 0 relative priority
-	pp &= _PTHREAD_PRIORITY_QOS_CLASS_MASK;
-	if (pp) pp |= _PTHREAD_PRIORITY_PRIORITY_MASK;
-
-	*mvar_buf++ = (mach_voucher_attr_recipe_data_t){
-		.key = MACH_VOUCHER_ATTR_KEY_ALL,
-		.command = MACH_VOUCHER_ATTR_COPY,
-		.previous_voucher = kvb,
-	};
-	size += _voucher_mach_recipe_size(0);
-
-	if (pp) {
-		ipc_pthread_priority_value_t value = (ipc_pthread_priority_value_t)pp;
-		*mvar_buf++ = (mach_voucher_attr_recipe_data_t){
-			.key = MACH_VOUCHER_ATTR_KEY_PTHPRIORITY,
-			.command = MACH_VOUCHER_ATTR_PTHPRIORITY_CREATE,
-			.content_size = sizeof(value),
-		};
-		mvar_buf = _dispatch_memappend(mvar_buf, &value);
-		size += _voucher_mach_recipe_size(sizeof(value));
-	}
-
-	if ((v && v->v_activity) || pp) {
-		_voucher_mach_udata_s *udata_buf;
-		unsigned udata_size = 0;
-
-		if (v && v->v_activity) {
-			udata_size = offsetof(_voucher_mach_udata_s, _vmu_after_activity);
-		} else {
-			udata_size = offsetof(_voucher_mach_udata_s, _vmu_after_priority);
-		}
-		*mvar_buf = (mach_voucher_attr_recipe_data_t){
-			.key = MACH_VOUCHER_ATTR_KEY_USER_DATA,
-			.command = MACH_VOUCHER_ATTR_USER_DATA_STORE,
-			.content_size = udata_size,
-		};
-		udata_buf = (_voucher_mach_udata_s *)(mvar_buf->content);
-
-		if (v && v->v_activity) {
-			*udata_buf = (_voucher_mach_udata_s){
-				.vmu_magic = VOUCHER_MAGIC_V3,
-				.vmu_priority = (_voucher_priority_t)pp,
-				.vmu_activity = v->v_activity,
-				.vmu_activity_pid = v->v_activity_creator,
-				.vmu_parent_activity = v->v_parent_activity,
-			};
-		} else {
-			*udata_buf = (_voucher_mach_udata_s){
-				.vmu_magic = VOUCHER_MAGIC_V3,
-				.vmu_priority = (_voucher_priority_t)pp,
-			};
-		}
-
-		mvar_buf = (mach_voucher_attr_recipe_t)(mvar_buf->content + udata_size);
-		size += _voucher_mach_recipe_size(udata_size);
-	}
-
-	if (extra) {
-		memcpy(mvar_buf, _voucher_extra_recipes(v), extra);
-		size += extra;
-	}
-	return size;
-}
-
-mach_voucher_t
-_voucher_get_mach_voucher(voucher_t voucher)
-{
-	if (!voucher) return MACH_VOUCHER_NULL;
-	if (voucher->v_ipc_kvoucher) return voucher->v_ipc_kvoucher;
-	mach_voucher_t kvb = voucher->v_kvoucher;
-	if (!kvb) kvb = _voucher_get_task_mach_voucher();
-	if (!voucher->v_activity && !voucher->v_priority &&
-			!_voucher_extra_size(voucher)) {
-		return kvb;
-	}
-
-	mach_voucher_attr_recipe_t mvar = _voucher_mach_recipe_alloca(voucher);
-	mach_voucher_attr_recipe_size_t size;
-	mach_voucher_t kv, kvo;
-	kern_return_t kr;
-
-	size = _voucher_mach_recipe_init(mvar, voucher, kvb, voucher->v_priority);
-	kr = _voucher_create_mach_voucher(mvar, size, &kv);
-	if (dispatch_assume_zero(kr) || !kv) {
-		return MACH_VOUCHER_NULL;
-	}
-	if (!os_atomic_cmpxchgv2o(voucher, v_ipc_kvoucher, MACH_VOUCHER_NULL,
-			kv, &kvo, relaxed)) {
-		_voucher_dealloc_mach_voucher(kv);
-		kv = kvo;
-	} else {
-		if (kv == voucher->v_kvoucher) {
-			// if v_kvoucher == v_ipc_kvoucher we keep only one reference
-			_voucher_dealloc_mach_voucher(kv);
-		}
-		_voucher_insert(voucher);
-		_dispatch_voucher_debug("kvoucher[0x%08x] create", voucher, kv);
-	}
-	return kv;
-}
-
-mach_voucher_t
-_voucher_create_mach_voucher_with_priority(voucher_t voucher,
-		pthread_priority_t priority)
-{
-	if (priority == _voucher_get_priority(voucher)) {
-		return MACH_VOUCHER_NULL; // caller will use _voucher_get_mach_voucher
-	}
-	kern_return_t kr;
-	mach_voucher_t kv, kvb = voucher ? voucher->v_kvoucher : MACH_VOUCHER_NULL;
-	if (!kvb) kvb = _voucher_get_task_mach_voucher();
-
-	mach_voucher_attr_recipe_t mvar = _voucher_mach_recipe_alloca(voucher);
-	mach_voucher_attr_recipe_size_t size;
-
-	size = _voucher_mach_recipe_init(mvar, voucher, kvb, priority);
-	kr = _voucher_create_mach_voucher(mvar, size, &kv);
-	if (dispatch_assume_zero(kr) || !kv) {
-		return MACH_VOUCHER_NULL;
-	}
-	_dispatch_kvoucher_debug("create with priority from voucher[%p]", kv,
-			voucher);
-	return kv;
-}
-
-static voucher_t
-_voucher_create_with_mach_voucher(mach_voucher_t kv, mach_msg_bits_t msgh_bits)
-{
-	if (!kv) return NULL;
-	kern_return_t kr;
-	mach_voucher_attr_recipe_t vr;
-	size_t vr_size;
-	mach_voucher_attr_recipe_size_t kvr_size = 0;
-	mach_voucher_attr_content_size_t udata_sz = 0;
-	_voucher_mach_udata_s *udata = NULL;
-	voucher_t v = _voucher_find_and_retain(kv);
-	if (v) {
-		_dispatch_voucher_debug("kvoucher[0x%08x] found", v, kv);
-		_voucher_dealloc_mach_voucher(kv);
-		return v;
-	}
-	vr_size = sizeof(*vr) + sizeof(_voucher_mach_udata_s);
-	vr = alloca(vr_size);
-	if (kv) {
-		kvr_size = (mach_voucher_attr_recipe_size_t)vr_size;
-		kr = mach_voucher_extract_attr_recipe(kv,
-				MACH_VOUCHER_ATTR_KEY_USER_DATA, (void*)vr, &kvr_size);
-		DISPATCH_VERIFY_MIG(kr);
-		if (!dispatch_assume_zero(kr) && kvr_size >= sizeof(*vr)) {
-			udata_sz = vr->content_size;
-			udata = (_voucher_mach_udata_s*)vr->content;
-			dispatch_assume(udata_sz >= sizeof(_voucher_magic_t));
-		}
-	}
-	vr = NULL;
-
-	v = _voucher_alloc(0);
-	v->v_ipc_kvoucher = v->v_kvoucher = kv;
-	v->v_kv_has_importance = !!(msgh_bits & MACH_MSGH_BITS_RAISEIMP);
-
-	if (udata_sz >= offsetof(_voucher_mach_udata_s,_vmu_after_priority)){
-		if (udata->vmu_magic == VOUCHER_MAGIC_V3) {
-			v->v_priority = udata->vmu_priority;
-		}
-	}
-	bool remove_kv_userdata = false;
-	if (udata_sz >= offsetof(_voucher_mach_udata_s, _vmu_after_activity)) {
-#if !RDAR_25050791
-		remove_kv_userdata = true;
-#endif
-		if (udata->vmu_magic == VOUCHER_MAGIC_V3 && udata->vmu_activity) {
-			v->v_activity = udata->vmu_activity;
-			v->v_activity_creator = udata->vmu_activity_pid;
-			v->v_parent_activity = udata->vmu_parent_activity;
-		}
-	}
-
-	if (remove_kv_userdata) {
-		mach_voucher_t nkv = MACH_VOUCHER_NULL;
-		const mach_voucher_attr_recipe_data_t remove_userdata_recipe[] = {
-			[0] = {
-				.key = MACH_VOUCHER_ATTR_KEY_ALL,
-				.command = MACH_VOUCHER_ATTR_COPY,
-				.previous_voucher = kv,
-			},
-			[1] = {
-				.key = MACH_VOUCHER_ATTR_KEY_USER_DATA,
-				.command = MACH_VOUCHER_ATTR_REMOVE,
-			},
-			[2] = {
-				.key = MACH_VOUCHER_ATTR_KEY_PTHPRIORITY,
-				.command = MACH_VOUCHER_ATTR_REMOVE,
-			},
-		};
-		mach_voucher_attr_recipe_size_t size = sizeof(remove_userdata_recipe);
-		kr = _voucher_create_mach_voucher(remove_userdata_recipe, size, &nkv);
-		if (!dispatch_assume_zero(kr)) {
-			_dispatch_voucher_debug("kvoucher[0x%08x] udata removal "
-					"(created 0x%08x)", v, kv, nkv);
-			v->v_ipc_kvoucher = MACH_VOUCHER_NULL;
-			v->v_kvoucher = nkv;
-			v->v_kvbase = _voucher_find_and_retain(nkv);
-			if (v->v_kvbase) {
-				_voucher_dealloc_mach_voucher(nkv); // borrow base reference
-			}
-			_voucher_dealloc_mach_voucher(kv);
-			kv = nkv;
-		} else {
-			_dispatch_voucher_debug_machport(kv);
-		}
-	}
-
-	_voucher_trace(CREATE, v, v->v_kvoucher, v->v_activity);
-	_voucher_insert(v);
-	_dispatch_voucher_debug("kvoucher[0x%08x] create", v, kv);
-	return v;
-}
-
-voucher_t
-_voucher_create_with_priority_and_mach_voucher(voucher_t ov,
-		pthread_priority_t priority, mach_voucher_t kv)
-{
-	if (priority == _voucher_get_priority(ov)) {
-		if (kv) _voucher_dealloc_mach_voucher(kv);
-		return ov ? _voucher_retain(ov) : NULL;
-	}
-	voucher_t v = _voucher_find_and_retain(kv);
-	voucher_fields_t ignore_fields = VOUCHER_FIELD_PRIORITY;
-
-	if (v) {
-		_dispatch_voucher_debug("kvoucher[0x%08x] find", v, kv);
-		_voucher_dealloc_mach_voucher(kv);
-		return v;
-	}
-
-	if (kv) ignore_fields |= VOUCHER_FIELD_KVOUCHER;
-	v = _voucher_clone(ov, ignore_fields);
-	if (priority) {
-		v->v_priority = (_voucher_priority_t)priority;
-	}
-	if (kv) {
-		v->v_ipc_kvoucher = v->v_kvoucher = kv;
-		_voucher_insert(v);
-		_dispatch_voucher_debug("kvoucher[0x%08x] create with priority from "
-				"voucher[%p]", v, kv, ov);
-		_dispatch_voucher_debug_machport(kv);
-	}
-	_voucher_trace(CREATE, v, v->v_kvoucher, v->v_activity);
-	return v;
-}
-
-voucher_t
-_voucher_create_without_importance(voucher_t ov)
-{
-	// Nothing to do unless the old voucher has a kernel voucher. If it
-	// doesn't, it can't have any importance, now or in the future.
-	if (!ov) return NULL;
-	if (!ov->v_kvoucher || !ov->v_kv_has_importance) return _voucher_retain(ov);
-	kern_return_t kr;
-	mach_voucher_t kv, okv;
-	// Copy kernel voucher, removing importance.
-	okv = ov->v_ipc_kvoucher ? ov->v_ipc_kvoucher : ov->v_kvoucher;
-	const mach_voucher_attr_recipe_data_t importance_remove_recipe[] = {
-		[0] = {
-			.key = MACH_VOUCHER_ATTR_KEY_ALL,
-			.command = MACH_VOUCHER_ATTR_COPY,
-			.previous_voucher = okv,
-		},
-		[1] = {
-			.key = MACH_VOUCHER_ATTR_KEY_IMPORTANCE,
-			.command = MACH_VOUCHER_ATTR_REMOVE,
-		},
-	};
-	kr = _voucher_create_mach_voucher(importance_remove_recipe,
-			sizeof(importance_remove_recipe), &kv);
-	if (dispatch_assume_zero(kr) || !kv) {
-		if (ov->v_ipc_kvoucher) return NULL;
-		kv = MACH_VOUCHER_NULL;
-	}
-	if (kv == okv) {
-		_voucher_dealloc_mach_voucher(kv);
-		return _voucher_retain(ov);
-	}
-	voucher_t v = _voucher_find_and_retain(kv);
-	if (v && ov->v_ipc_kvoucher) {
-		_dispatch_voucher_debug("kvoucher[0x%08x] find without importance "
-				"from voucher[%p]", v, kv, ov);
-		_voucher_dealloc_mach_voucher(kv);
-		return v;
-	}
-	voucher_t kvbase = v;
-	voucher_fields_t ignore_fields = VOUCHER_FIELD_KVOUCHER;
-	v = _voucher_clone(ov, ignore_fields);
-	v->v_kvoucher = kv;
-	if (ov->v_ipc_kvoucher) {
-		v->v_ipc_kvoucher = kv;
-		_voucher_insert(v);
-	} else if (kvbase) {
-		v->v_kvbase = kvbase;
-		_voucher_dealloc_mach_voucher(kv); // borrow base reference
-	}
-	if (!kvbase) {
-		_dispatch_voucher_debug("kvoucher[0x%08x] create without importance "
-				"from voucher[%p]", v, kv, ov);
-	}
-	_voucher_trace(CREATE, v, v->v_kvoucher, v->v_activity);
-	return v;
-}
-
-voucher_t
-_voucher_create_accounting_voucher(voucher_t ov)
-{
-	// Nothing to do unless the old voucher has a kernel voucher. If it does
-	// doesn't, it can't have any accounting attributes.
-	if (!ov || !ov->v_kvoucher) return NULL;
-	kern_return_t kr = KERN_SUCCESS;
-	mach_voucher_t okv, kv = MACH_VOUCHER_NULL;
-	okv = ov->v_ipc_kvoucher ? ov->v_ipc_kvoucher : ov->v_kvoucher;
-	const mach_voucher_attr_recipe_data_t accounting_copy_recipe = {
-		.key = MACH_VOUCHER_ATTR_KEY_BANK,
-		.command = MACH_VOUCHER_ATTR_COPY,
-		.previous_voucher = okv,
-	};
-	kr = _voucher_create_mach_voucher(&accounting_copy_recipe,
-			sizeof(accounting_copy_recipe), &kv);
-	if (dispatch_assume_zero(kr) || !kv) {
-		return NULL;
-	}
-	voucher_t v = _voucher_find_and_retain(kv);
-	if (v) {
-		_dispatch_voucher_debug("kvoucher[0x%08x] find accounting voucher "
-				"from voucher[%p]", v, kv, ov);
-		_voucher_dealloc_mach_voucher(kv);
-		return v;
-	}
-	v = _voucher_alloc(0);
-	v->v_ipc_kvoucher = v->v_kvoucher = kv;
-	if (kv == okv) {
-		v->v_kvbase = _voucher_retain(ov);
-		_voucher_dealloc_mach_voucher(kv); // borrow base reference
-	}
-	_voucher_trace(CREATE, v, kv, v->v_activity);
-	_voucher_insert(v);
-	_dispatch_voucher_debug("kvoucher[0x%08x] create accounting voucher "
-			"from voucher[%p]", v, kv, ov);
-	return v;
-}
-
-voucher_t
-voucher_create_with_mach_msg(mach_msg_header_t *msg)
-{
-	mach_msg_bits_t msgh_bits;
-	mach_voucher_t kv = _voucher_mach_msg_get(msg, &msgh_bits);
-	return _voucher_create_with_mach_voucher(kv, msgh_bits);
-}
-
-void
-voucher_decrement_importance_count4CF(voucher_t v)
-{
-	if (!v || !v->v_kvoucher || !v->v_kv_has_importance) return;
-	kern_return_t kr;
-	mach_voucher_t kv = v->v_ipc_kvoucher ? v->v_ipc_kvoucher : v->v_kvoucher;
-	uint32_t dec = 1;
-	mach_voucher_attr_content_t kvc_in = (mach_voucher_attr_content_t)&dec;
-	mach_voucher_attr_content_size_t kvc_in_size = sizeof(dec);
-	mach_voucher_attr_content_t kvc_out = NULL;
-	mach_voucher_attr_content_size_t kvc_out_size = 0;
-#if DISPATCH_DEBUG
-	uint32_t count = UINT32_MAX;
-	kvc_out = (mach_voucher_attr_content_t)&count;
-	kvc_out_size = sizeof(count);
-#endif
-	kr = mach_voucher_attr_command(kv, MACH_VOUCHER_ATTR_KEY_IMPORTANCE,
-			MACH_VOUCHER_IMPORTANCE_ATTR_DROP_EXTERNAL, kvc_in, kvc_in_size,
-			kvc_out, &kvc_out_size);
-	DISPATCH_VERIFY_MIG(kr);
-	if (kr == KERN_INVALID_TASK) return; // non-denap receiver rdar://25643185
-#if DISPATCH_DEBUG
-	_dispatch_voucher_debug("kvoucher[0x%08x] decrement importance count to %u:"
-			" %s - 0x%x", v, kv, count, mach_error_string(kr), kr);
-#endif
-	if (unlikely(dispatch_assume_zero(kr) == KERN_FAILURE)) {
-		DISPATCH_CLIENT_CRASH(kr, "Voucher importance count underflow");
-	}
-}
-
-#if VOUCHER_ENABLE_GET_MACH_VOUCHER
-mach_voucher_t
-voucher_get_mach_voucher(voucher_t voucher)
-{
-	return _voucher_get_mach_voucher(voucher);
-}
-#endif
-
-void
-_voucher_xref_dispose(voucher_t voucher)
-{
-	_dispatch_voucher_debug("xref_dispose", voucher);
-	_voucher_remove(voucher);
-	return _os_object_release_internal_n_inline((_os_object_t)voucher, 1);
-}
-
-void
-_voucher_dispose(voucher_t voucher)
-{
-	_voucher_trace(DISPOSE, voucher);
-	_dispatch_voucher_debug("dispose", voucher);
-	if (unlikely(_voucher_hash_is_enqueued(voucher))) {
-		_dispatch_voucher_debug("corruption", voucher);
-		DISPATCH_CLIENT_CRASH(0, "Voucher corruption");
-	}
-	_voucher_hash_mark_not_enqueued(voucher);
-	if (voucher->v_ipc_kvoucher) {
-		if (voucher->v_ipc_kvoucher != voucher->v_kvoucher) {
-			_voucher_dealloc_mach_voucher(voucher->v_ipc_kvoucher);
-		}
-		voucher->v_ipc_kvoucher = MACH_VOUCHER_NULL;
-	}
-	if (voucher->v_kvoucher) {
-		if (!voucher->v_kvbase) {
-			_voucher_dealloc_mach_voucher(voucher->v_kvoucher);
-		}
-		voucher->v_kvoucher = MACH_VOUCHER_NULL;
-	}
-	if (voucher->v_kvbase) {
-		_voucher_release(voucher->v_kvbase);
-		voucher->v_kvbase = NULL;
-	}
-	voucher->v_activity = 0;
-	voucher->v_activity_creator = 0;
-	voucher->v_parent_activity = 0;
-	voucher->v_priority = 0;
-#if VOUCHER_ENABLE_RECIPE_OBJECTS
-	voucher->v_recipe_extra_size = 0;
-	voucher->v_recipe_extra_offset = 0;
-#endif
-	return _os_object_dealloc((_os_object_t)voucher);
-}
-
-void
-_voucher_activity_debug_channel_init(void)
-{
-	dispatch_mach_handler_function_t handler = NULL;
-
-	if (_voucher_libtrace_hooks) {
-		handler = _voucher_libtrace_hooks->vah_debug_channel_handler;
-	}
-	if (!handler) return;
-
-	dispatch_mach_t dm;
-	mach_port_t dbgp;
-	kern_return_t kr;
-
-	kr = task_get_debug_control_port(mach_task_self(), &dbgp);
-	DISPATCH_VERIFY_MIG(kr);
-	if (kr) {
-		DISPATCH_CLIENT_CRASH(kr, "Couldn't get debug control port");
-	}
-	if (dbgp) {
-		dm = dispatch_mach_create_f("com.apple.debug-channel",
-				DISPATCH_TARGET_QUEUE_DEFAULT, NULL, handler);
-		dm->dm_recv_refs->du_can_be_wlh = false; // 29906118
-		dispatch_mach_connect(dm, dbgp, MACH_PORT_NULL, NULL);
-		_voucher_activity_debug_channel = dm;
-	}
-}
-
-void
-_voucher_atfork_child(void)
-{
-	_dispatch_thread_setspecific(dispatch_voucher_key, NULL);
-	_voucher_task_mach_voucher_pred = 0;
-	_voucher_task_mach_voucher = MACH_VOUCHER_NULL;
-#if !VOUCHER_USE_EMPTY_MACH_BASE_VOUCHER
-	_voucher_default_task_mach_voucher = MACH_PORT_NULL;
-#endif
-	_voucher_aid_next = 0;
-	_firehose_task_buffer_pred = 0;
-	_firehose_task_buffer = NULL; // firehose buffer is VM_INHERIT_NONE
-}
-
-voucher_t
-voucher_copy_with_persona_mach_voucher(mach_voucher_t persona_mach_voucher)
-{
-#if !VOUCHER_USE_PERSONA
-	(void)persona_mach_voucher;
-	return voucher_copy();
-#else // !VOUCHER_USE_PERSONA
-	if (!persona_mach_voucher) return voucher_copy();
-	kern_return_t kr;
-	mach_voucher_t okv = MACH_VOUCHER_NULL, kv;
-	voucher_t ov = _voucher_get();
-	if (ov) {
-		okv = ov->v_ipc_kvoucher ? ov->v_ipc_kvoucher : ov->v_kvoucher;
-	}
-	const mach_voucher_attr_recipe_data_t bank_redeem_recipe[] = {
-		[0] = {
-			.key = MACH_VOUCHER_ATTR_KEY_ALL,
-			.command = MACH_VOUCHER_ATTR_COPY,
-			.previous_voucher = okv,
-		},
-		[1] = {
-			.key = MACH_VOUCHER_ATTR_KEY_BANK,
-			.command = MACH_VOUCHER_ATTR_REDEEM,
-			.previous_voucher = persona_mach_voucher,
-		},
-	};
-	kr = _voucher_create_mach_voucher(bank_redeem_recipe,
-			sizeof(bank_redeem_recipe), &kv);
-	if (dispatch_assume_zero(kr)) {
-		if (kr == KERN_INVALID_CAPABILITY) {
-			// bank attribute redeem failed
-			return VOUCHER_INVALID;
-		}
-		kv = MACH_VOUCHER_NULL;
-	}
-	if (kv == okv) {
-		if (kv) _voucher_dealloc_mach_voucher(kv);
-		return _voucher_retain(ov);
-	}
-	voucher_t v = _voucher_find_and_retain(kv);
-	if (v && (!ov || ov->v_ipc_kvoucher)) {
-		_dispatch_voucher_debug("kvoucher[0x%08x] find with persona "
-				"from voucher[%p]", v, kv, ov);
-		_voucher_dealloc_mach_voucher(kv);
-		return v;
-	}
-	voucher_t kvbase = v;
-	voucher_fields_t ignore_fields = VOUCHER_FIELD_KVOUCHER;
-	v = _voucher_clone(ov, ignore_fields);
-	v->v_kvoucher = kv;
-	if (!ov || ov->v_ipc_kvoucher) {
-		v->v_ipc_kvoucher = kv;
-		_voucher_insert(v);
-	} else if (kvbase) {
-		v->v_kvbase = kvbase;
-		_voucher_dealloc_mach_voucher(kv); // borrow base reference
-	}
-	if (!kvbase) {
-		_dispatch_voucher_debug("kvoucher[0x%08x] create with persona "
-				"from voucher[%p]", v, kv, ov);
-	}
-	_voucher_trace(CREATE, v, v->v_kvoucher, v->v_activity);
-	return v;
-#endif // VOUCHER_USE_PERSONA
-}
-
-kern_return_t
-mach_voucher_persona_self(mach_voucher_t *persona_mach_voucher)
-{
-	mach_voucher_t bkv = MACH_VOUCHER_NULL;
-	kern_return_t kr = KERN_NOT_SUPPORTED;
-#if VOUCHER_USE_PERSONA
-	mach_voucher_t kv = _voucher_get_task_mach_voucher();
-
-	const mach_voucher_attr_recipe_data_t bank_send_recipe[] = {
-		[0] = {
-			.key = MACH_VOUCHER_ATTR_KEY_BANK,
-			.command = MACH_VOUCHER_ATTR_COPY,
-			.previous_voucher = kv,
-		},
-		[1] = {
-			.key = MACH_VOUCHER_ATTR_KEY_BANK,
-			.command = MACH_VOUCHER_ATTR_SEND_PREPROCESS,
-		},
-	};
-	kr = _voucher_create_mach_voucher(bank_send_recipe,
-			sizeof(bank_send_recipe), &bkv);
-	if (dispatch_assume_zero(kr)) {
-		bkv = MACH_VOUCHER_NULL;
-	}
-#endif // VOUCHER_USE_PERSONA
-	*persona_mach_voucher = bkv;
-	return kr;
-}
-
-kern_return_t
-mach_voucher_persona_for_originator(uid_t persona_id,
-	mach_voucher_t originator_persona_mach_voucher,
-	uint64_t originator_unique_pid, mach_voucher_t *persona_mach_voucher)
-{
-	mach_voucher_t bkv = MACH_VOUCHER_NULL;
-	kern_return_t kr = KERN_NOT_SUPPORTED;
-#if VOUCHER_USE_PERSONA
-	struct persona_modify_info modify_info = {
-		.persona_id = persona_id,
-		.unique_pid = originator_unique_pid,
-	};
-	size_t bank_modify_recipe_size = _voucher_mach_recipe_size(0) +
-			_voucher_mach_recipe_size(sizeof(modify_info));
-	mach_voucher_attr_recipe_t bank_modify_recipe =
-			(mach_voucher_attr_recipe_t)alloca(bank_modify_recipe_size);
-
-	bzero((void *)bank_modify_recipe, bank_modify_recipe_size);
-
-	bank_modify_recipe[0] = (mach_voucher_attr_recipe_data_t){
-		.key = MACH_VOUCHER_ATTR_KEY_BANK,
-		.command = MACH_VOUCHER_ATTR_COPY,
-		.previous_voucher = originator_persona_mach_voucher,
-	};
-	bank_modify_recipe[1] = (mach_voucher_attr_recipe_data_t){
-		.key = MACH_VOUCHER_ATTR_KEY_BANK,
-		.command = MACH_VOUCHER_ATTR_BANK_MODIFY_PERSONA,
-		.content_size = sizeof(modify_info),
-	};
-	_dispatch_memappend(bank_modify_recipe[1].content, &modify_info);
-	kr = _voucher_create_mach_voucher(bank_modify_recipe,
-			bank_modify_recipe_size, &bkv);
-	if (dispatch_assume_zero(kr)) {
-		bkv = MACH_VOUCHER_NULL;
-	}
-#else // VOUCHER_USE_PERSONA
-	(void)persona_id;
-	(void)originator_persona_mach_voucher;
-	(void)originator_unique_pid;
-#endif // VOUCHER_USE_PERSONA
-	*persona_mach_voucher = bkv;
-	return kr;
-}
-
-#if VOUCHER_USE_PERSONA
-static kern_return_t
-_voucher_get_current_persona_token(struct persona_token *token)
-{
-	kern_return_t kr = KERN_FAILURE;
-	voucher_t v = _voucher_get();
-
-	if (v && v->v_kvoucher) {
-		mach_voucher_t kv = v->v_ipc_kvoucher ?: v->v_kvoucher;
-		mach_voucher_attr_content_t kvc_in = NULL;
-		mach_voucher_attr_content_size_t kvc_in_size = 0;
-		mach_voucher_attr_content_t kvc_out =
-			(mach_voucher_attr_content_t)token;
-		mach_voucher_attr_content_size_t kvc_out_size = sizeof(*token);
-
-		kr = mach_voucher_attr_command(kv, MACH_VOUCHER_ATTR_KEY_BANK,
-				BANK_PERSONA_TOKEN, kvc_in, kvc_in_size,
-				kvc_out, &kvc_out_size);
-		if (kr != KERN_NOT_SUPPORTED
-				// Voucher doesn't have a PERSONA_TOKEN
-				&& kr != KERN_INVALID_VALUE
-				// Kernel doesn't understand BANK_PERSONA_TOKEN
-				&& kr != KERN_INVALID_ARGUMENT) {
-			(void)dispatch_assume_zero(kr);
-		}
-	}
-	return kr;
-}
-
-static kern_return_t
-_voucher_get_current_persona_id(uid_t *persona_id)
-{
-	kern_return_t kr = KERN_FAILURE;
-	voucher_t v = _voucher_get();
-
-	if (v && v->v_kvoucher) {
-		mach_voucher_t kv = v->v_ipc_kvoucher ?: v->v_kvoucher;
-		mach_voucher_attr_content_t kvc_in = NULL;
-		mach_voucher_attr_content_size_t kvc_in_size = 0;
-		mach_voucher_attr_content_t kvc_out =
-			(mach_voucher_attr_content_t)persona_id;
-		mach_voucher_attr_content_size_t kvc_out_size = sizeof(*persona_id);
-
-		kr = mach_voucher_attr_command(kv, MACH_VOUCHER_ATTR_KEY_BANK,
-				BANK_PERSONA_ID, kvc_in, kvc_in_size,
-				kvc_out, &kvc_out_size);
-		if (kr != KERN_NOT_SUPPORTED
-				// Voucher doesn't have a persona id
-				&& kr != KERN_INVALID_VALUE
-				// Kernel doesn't understand BANK_PERSONA_ID
-				&& kr != KERN_INVALID_ARGUMENT) {
-			(void)dispatch_assume_zero(kr);
-		}
-	}
-	return kr;
-}
-#endif // VOUCHER_USE_PERSONA
-
-uid_t
-voucher_get_current_persona(void)
-{
-	uid_t persona_id = PERSONA_ID_NONE;
-
-#if VOUCHER_USE_PERSONA
-	int err;
-
-	if (_voucher_get_current_persona_id(&persona_id) == KERN_SUCCESS) {
-		return persona_id;
-	}
-
-	// falling back to the process persona if there is no adopted voucher
-	if (kpersona_get(&persona_id) < 0) {
-		err = errno;
-		if (err != ESRCH) {
-			(void)dispatch_assume_zero(err);
-		}
-	}
-#endif // VOUCHER_USE_PERSONA
-	return persona_id;
-}
-
-int
-voucher_get_current_persona_originator_info(struct proc_persona_info *persona_info)
-{
-#if VOUCHER_USE_PERSONA
-	struct persona_token token;
-	if (_voucher_get_current_persona_token(&token) == KERN_SUCCESS) {
-		*persona_info = token.originator;
-		return 0;
-	}
-#else // VOUCHER_USE_PERSONA
-	(void)persona_info;
-#endif // VOUCHER_USE_PERSONA
-	return -1;
-}
-
-int
-voucher_get_current_persona_proximate_info(struct proc_persona_info *persona_info)
-{
-#if VOUCHER_USE_PERSONA
-	struct persona_token token;
-	if (_voucher_get_current_persona_token(&token) == KERN_SUCCESS) {
-		*persona_info = token.proximate;
-		return 0;
-	}
-#else // VOUCHER_USE_PERSONA
-	(void)persona_info;
-#endif // VOUCHER_USE_PERSONA
-	return -1;
-}
-
-#pragma mark -
-#pragma mark _voucher_init
-
-boolean_t
-voucher_mach_msg_set(mach_msg_header_t *msg)
-{
-	return _voucher_mach_msg_set(msg, _voucher_get());
-}
-
-void
-voucher_mach_msg_clear(mach_msg_header_t *msg)
-{
-	(void)_voucher_mach_msg_clear(msg, false);
-}
-
-voucher_mach_msg_state_t
-voucher_mach_msg_adopt(mach_msg_header_t *msg)
-{
-	mach_msg_bits_t msgh_bits;
-	mach_voucher_t kv = _voucher_mach_msg_get(msg, &msgh_bits);
-	if (!kv) return VOUCHER_MACH_MSG_STATE_UNCHANGED;
-	voucher_t v = _voucher_create_with_mach_voucher(kv, msgh_bits);
-	return (voucher_mach_msg_state_t)_voucher_adopt(v);
-}
-
-void
-voucher_mach_msg_revert(voucher_mach_msg_state_t state)
-{
-	if (state == VOUCHER_MACH_MSG_STATE_UNCHANGED) return;
-	_voucher_replace((voucher_t)state);
-}
-
-#if DISPATCH_USE_LIBKERNEL_VOUCHER_INIT
-#include <_libkernel_init.h>
-
-static const struct _libkernel_voucher_functions _voucher_libkernel_functions =
-{
-	.version = 1,
-	.voucher_mach_msg_set = voucher_mach_msg_set,
-	.voucher_mach_msg_clear = voucher_mach_msg_clear,
-	.voucher_mach_msg_adopt = voucher_mach_msg_adopt,
-	.voucher_mach_msg_revert = voucher_mach_msg_revert,
-};
-
-static void
-_voucher_libkernel_init(void)
-{
-	kern_return_t kr = __libkernel_voucher_init(&_voucher_libkernel_functions);
-	dispatch_assert(!kr);
-}
-#else
-#define _voucher_libkernel_init()
-#endif
-
-void
-voucher_activity_initialize_4libtrace(voucher_activity_hooks_t hooks)
-{
-	if (hooks->vah_version < 3) {
-		DISPATCH_CLIENT_CRASH(hooks->vah_version, "unsupported vah_version");
-	}
-	if (!os_atomic_cmpxchg(&_voucher_libtrace_hooks, NULL,
-			hooks, relaxed)) {
-		DISPATCH_CLIENT_CRASH(_voucher_libtrace_hooks,
-				"voucher_activity_initialize_4libtrace called twice");
-	}
-}
-
-void
-_voucher_init(void)
-{
-	_voucher_libkernel_init();
-}
-
-#pragma mark -
-#pragma mark voucher_activity_t
-
-DISPATCH_NOINLINE
-static uint64_t
-_voucher_activity_id_allocate_slow(uint64_t aid)
-{
-	kern_return_t kr;
-	uint64_t next;
-
-	kr = mach_generate_activity_id(mach_task_self(), 1, &next);
-	if (unlikely(kr)) {
-		DISPATCH_CLIENT_CRASH(kr, "Could not generate an activity ID");
-	}
-	next *= MACH_ACTIVITY_ID_RANGE_SIZE;
-	next &= MACH_ACTIVITY_ID_MASK;
-	if (unlikely(next == 0)) {
-		next++;
-	}
-
-	if (unlikely(aid == 0)) {
-		if (os_atomic_cmpxchg(&_voucher_aid_next, 0, next + 1, relaxed)) {
-			return next;
-		}
-	}
-	return os_atomic_xchg(&_voucher_aid_next, next, relaxed);
-}
-
-DISPATCH_ALWAYS_INLINE
-static firehose_activity_id_t
-_voucher_activity_id_allocate(firehose_activity_flags_t flags)
-{
-	uint64_t aid, next;
-	os_atomic_rmw_loop(&_voucher_aid_next, aid, next, relaxed, {
-		next = aid + 1;
-		if (aid == 0 || next % MACH_ACTIVITY_ID_RANGE_SIZE == 0) {
-			os_atomic_rmw_loop_give_up({
-				aid = _voucher_activity_id_allocate_slow(aid);
-				break;
-			});
-		}
-	});
-	return FIREHOSE_ACTIVITY_ID_MAKE(aid, flags);
-}
-
-firehose_activity_id_t
-voucher_activity_id_allocate(firehose_activity_flags_t flags)
-{
-	return _voucher_activity_id_allocate(flags);
-}
-
-#define _voucher_activity_tracepoint_reserve(stamp, stream, pub, priv, \
-		privbuf, reliable) \
-		firehose_buffer_tracepoint_reserve(_firehose_task_buffer, stamp, \
-				stream, pub, priv, privbuf, reliable)
-
-#define _voucher_activity_tracepoint_flush(ft, ftid) \
-		firehose_buffer_tracepoint_flush(_firehose_task_buffer, ft, ftid)
-
-DISPATCH_NOINLINE
-static void
-_firehose_task_buffer_init(void *ctx OS_UNUSED)
-{
-	mach_port_t logd_port;
-
-	/* Query the uniquepid of the current process */
-	struct proc_uniqidentifierinfo p_uniqinfo = { };
-	int info_size = 0;
-
-	info_size = proc_pidinfo(getpid(), PROC_PIDUNIQIDENTIFIERINFO, 1,
-			&p_uniqinfo, PROC_PIDUNIQIDENTIFIERINFO_SIZE);
-	if (unlikely(info_size != PROC_PIDUNIQIDENTIFIERINFO_SIZE)) {
-		if (info_size == 0) {
-			DISPATCH_INTERNAL_CRASH(errno,
-				"Unable to get the unique pid (error)");
-		} else {
-			DISPATCH_INTERNAL_CRASH(info_size,
-				"Unable to get the unique pid (size)");
-		}
-	}
-	_voucher_unique_pid = p_uniqinfo.p_uniqueid;
-
-
-	if (unlikely(!_voucher_libtrace_hooks)) {
-		return;
-	}
-	logd_port = _voucher_libtrace_hooks->vah_get_logd_port();
-	if (logd_port) {
-		unsigned long flags = 0;
-#if DISPATCH_USE_MEMORYPRESSURE_SOURCE
-		if (_dispatch_memory_warn) {
-			flags |= FIREHOSE_BUFFER_BANK_FLAG_LOW_MEMORY;
-		}
-#endif
-		// firehose_buffer_create always consumes the send-right
-		_firehose_task_buffer = firehose_buffer_create(logd_port,
-				_voucher_unique_pid, flags);
-		if (_voucher_libtrace_hooks->vah_version >= 4 &&
-				_voucher_libtrace_hooks->vah_metadata_init) {
-			firehose_buffer_t fb = _firehose_task_buffer;
-			size_t meta_sz = FIREHOSE_BUFFER_LIBTRACE_HEADER_SIZE;
-			void *meta = (void *)((uintptr_t)(&fb->fb_header + 1) - meta_sz);
-			_voucher_libtrace_hooks->vah_metadata_init(meta, meta_sz);
-		}
-	}
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_voucher_activity_disabled(void)
-{
-	dispatch_once_f(&_firehose_task_buffer_pred,
-			NULL, _firehose_task_buffer_init);
-
-	firehose_buffer_t fb = _firehose_task_buffer;
-	return !fb || fb->fb_header.fbh_sendp[false] == MACH_PORT_DEAD;
-}
-
-void *
-voucher_activity_get_logging_preferences(size_t *length)
-{
-	if (unlikely(_voucher_activity_disabled())) {
-		*length = 0;
-		return NULL;
-	}
-
-	return firehose_buffer_get_logging_prefs(_firehose_task_buffer, length);
-}
-
-bool
-voucher_activity_should_send_strings(void)
-{
-	if (unlikely(_voucher_activity_disabled())) {
-		return false;
-	}
-
-	return firehose_buffer_should_send_strings(_firehose_task_buffer);
-}
-
-void *
-voucher_activity_get_metadata_buffer(size_t *length)
-{
-	if (_voucher_activity_disabled()) {
-		*length = 0;
-		return NULL;
-	}
-
-	firehose_buffer_header_t fbh = &_firehose_task_buffer->fb_header;
-
-	*length = FIREHOSE_BUFFER_LIBTRACE_HEADER_SIZE;
-	return (void *)((uintptr_t)(fbh + 1) - *length);
-}
-
-voucher_t
-voucher_activity_create_with_data(firehose_tracepoint_id_t *trace_id,
-		voucher_t base, firehose_activity_flags_t flags,
-		const void *pubdata, size_t publen)
-{
-	firehose_activity_id_t va_id = 0, current_id = 0, parent_id = 0;
-	firehose_tracepoint_id_u ftid = { .ftid_value = *trace_id };
-	uint64_t creator_id = 0;
-	uint16_t pubsize;
-	voucher_t ov = _voucher_get();
-	voucher_t v;
-
-	if (os_add_overflow(sizeof(va_id), publen, &pubsize) || pubsize > 128) {
-		DISPATCH_CLIENT_CRASH(pubsize, "Absurd publen");
-	}
-	if (base == VOUCHER_CURRENT) {
-		base = ov;
-	}
-
-	FIREHOSE_TRACE_ID_CLEAR_FLAG(ftid, base, has_unique_pid);
-	if (ov && (current_id = ov->v_activity)) {
-		FIREHOSE_TRACE_ID_SET_FLAG(ftid, base, has_current_aid);
-		pubsize += sizeof(firehose_activity_id_t);
-		if ((creator_id = ov->v_activity_creator)) {
-			FIREHOSE_TRACE_ID_SET_FLAG(ftid, base, has_unique_pid);
-			pubsize += sizeof(uint64_t);
-		}
-	}
-	if (base != VOUCHER_NULL) {
-		parent_id = base->v_activity;
-	}
-
-	if (parent_id) {
-		FIREHOSE_TRACE_ID_SET_FLAG(ftid, activity, has_other_aid);
-		pubsize += sizeof(firehose_activity_id_t);
-		flags |= FIREHOSE_ACTIVITY_ID_FLAGS(parent_id);
-	}
-
-	if (firehose_precise_timestamps_enabled()) {
-		flags |= firehose_activity_flags_precise_timestamp;
-	}
-	voucher_fields_t ignore_fields = VOUCHER_FIELD_ACTIVITY;
-	v = _voucher_clone(base, ignore_fields);
-	v->v_activity = va_id = _voucher_activity_id_allocate(flags);
-	v->v_activity_creator = _voucher_unique_pid;
-	v->v_parent_activity = parent_id;
-
-	if (_voucher_activity_disabled()) {
-		goto done;
-	}
-
-	static const firehose_stream_t streams[2] = {
-		firehose_stream_metadata,
-		firehose_stream_persist,
-	};
-	firehose_tracepoint_t ft;
-	uint64_t stamp = firehose_tracepoint_time(flags);
-
-	for (size_t i = 0; i < countof(streams); i++) {
-		ft = _voucher_activity_tracepoint_reserve(stamp, streams[i], pubsize,
-				0, NULL, true);
-		if (unlikely(!ft)) continue;
-
-		uint8_t *pubptr = ft->ft_data;
-		if (current_id) {
-			pubptr = _dispatch_memappend(pubptr, &current_id);
-		}
-		if (creator_id) {
-			pubptr = _dispatch_memappend(pubptr, &creator_id);
-		}
-		if (parent_id) {
-			pubptr = _dispatch_memappend(pubptr, &parent_id);
-		}
-		pubptr = _dispatch_memappend(pubptr, &va_id);
-		pubptr = _dispatch_mempcpy(pubptr, pubdata, publen);
-		_voucher_activity_tracepoint_flush(ft, ftid);
-	}
-done:
-	*trace_id = ftid.ftid_value;
-	_voucher_trace(CREATE, v, v->v_kvoucher, va_id);
-	return v;
-}
-
-voucher_t
-voucher_activity_create_with_location(firehose_tracepoint_id_t *trace_id,
-		voucher_t base, firehose_activity_flags_t flags, uint64_t loc)
-{
-	return voucher_activity_create_with_data(trace_id, base, flags,
-			&loc, sizeof(loc));
-}
-
-#if OS_VOUCHER_ACTIVITY_GENERATE_SWAPS
-void
-_voucher_activity_swap(firehose_activity_id_t old_id,
-		firehose_activity_id_t new_id)
-{
-	if (_voucher_activity_disabled()) return;
-
-	firehose_tracepoint_id_u ftid = { .ftid = {
-		._namespace = firehose_tracepoint_namespace_activity,
-		._type = _firehose_tracepoint_type_activity_swap,
-	} };
-	uint16_t pubsize = 0;
-
-	if (old_id) {
-		FIREHOSE_TRACE_ID_SET_FLAG(ftid, base, has_current_aid);
-		pubsize += sizeof(firehose_activity_id_t);
-	}
-	if (new_id) {
-		FIREHOSE_TRACE_ID_SET_FLAG(ftid, activity, has_other_aid);
-		pubsize += sizeof(firehose_activity_id_t);
-	}
-
-	firehose_stream_t stream = firehose_stream_metadata;
-	firehose_tracepoint_t ft;
-	firehose_activity_flags_t flags = FIREHOSE_ACTIVITY_ID_FLAGS(old_id) |
-			FIREHOSE_ACTIVITY_ID_FLAGS(new_id);
-	uint64_t stamp = firehose_tracepoint_time(flags);
-
-	_dispatch_voucher_ktrace_activity_adopt(new_id);
-
-	ft = _voucher_activity_tracepoint_reserve(stamp, stream, pubsize, 0, NULL,
-			true);
-	if (unlikely(!ft)) return;
-	uint8_t *pubptr = ft->ft_data;
-	if (old_id) pubptr = _dispatch_memappend(pubptr, &old_id);
-	if (new_id) pubptr = _dispatch_memappend(pubptr, &new_id);
-	_voucher_activity_tracepoint_flush(ft, ftid);
-}
-#endif
-
-firehose_activity_id_t
-voucher_get_activity_id_and_creator(voucher_t v, uint64_t *creator_pid,
-		firehose_activity_id_t *parent_id)
-{
-	if (v == VOUCHER_CURRENT) {
-		v = _voucher_get();
-	}
-	if (v == VOUCHER_NULL) {
-		if (creator_pid) *creator_pid = 0;
-		if (parent_id) *parent_id = FIREHOSE_ACTIVITY_ID_NULL;
-		return FIREHOSE_ACTIVITY_ID_NULL;
-	}
-	if (creator_pid) *creator_pid = v->v_activity_creator;
-	if (parent_id) *parent_id = v->v_parent_activity;
-	return v->v_activity;
-}
-
-firehose_activity_id_t
-voucher_get_activity_id(voucher_t v, firehose_activity_id_t *parent_id)
-{
-	return voucher_get_activity_id_and_creator(v, NULL, parent_id);
-}
-
-void
-voucher_activity_flush(firehose_stream_t stream)
-{
-	if (_voucher_activity_disabled()) return;
-	firehose_buffer_stream_flush(_firehose_task_buffer, stream);
-}
-
-DISPATCH_NOINLINE
-firehose_tracepoint_id_t
-voucher_activity_trace_v_2(firehose_stream_t stream,
-		firehose_tracepoint_id_t trace_id, uint64_t stamp,
-		const struct iovec *iov, size_t publen, size_t privlen, uint32_t flags)
-{
-	firehose_tracepoint_id_u ftid = { .ftid_value = trace_id };
-	const uint16_t ft_size = offsetof(struct firehose_tracepoint_s, ft_data);
-	const size_t _firehose_chunk_payload_size =
-			sizeof(((struct firehose_chunk_s *)0)->fc_data);
-	bool reliable = !(flags & VOUCHER_ACTIVITY_TRACE_FLAG_UNRELIABLE);
-
-	if (_voucher_activity_disabled()) return 0;
-
-	firehose_tracepoint_t ft;
-	firehose_activity_id_t va_id = 0;
-	firehose_chunk_t fc;
-	uint8_t *privptr, *pubptr;
-	size_t pubsize = publen;
-	voucher_t ov = _voucher_get();
-	uint64_t creator_pid;
-
-	if ((va_id = _voucher_get_activity_id(ov, &creator_pid))) {
-		FIREHOSE_TRACE_ID_SET_FLAG(ftid, base, has_current_aid);
-		pubsize += sizeof(va_id);
-	}
-	if (FIREHOSE_TRACE_ID_HAS_FLAG(ftid, base, has_unique_pid)) {
-		if (creator_pid) {
-			pubsize += sizeof(creator_pid);
-		} else {
-			FIREHOSE_TRACE_ID_CLEAR_FLAG(ftid, base, has_unique_pid);
-		}
-	} else {
-		creator_pid = 0;
-	}
-
-	if (privlen) {
-		FIREHOSE_TRACE_ID_SET_FLAG(ftid, log, has_private_data);
-		pubsize += sizeof(struct firehose_buffer_range_s);
-	}
-
-	if (unlikely(ft_size + pubsize + privlen > _firehose_chunk_payload_size)) {
-		DISPATCH_CLIENT_CRASH(ft_size + pubsize + privlen, "Log is too large");
-	}
-
-	ft = _voucher_activity_tracepoint_reserve(stamp, stream, (uint16_t)pubsize,
-				(uint16_t)privlen, &privptr, reliable);
-	if (unlikely(!ft)) return 0;
-	pubptr = ft->ft_data;
-	if (va_id) {
-		pubptr = _dispatch_memappend(pubptr, &va_id);
-	}
-	if (creator_pid) {
-		pubptr = _dispatch_memappend(pubptr, &creator_pid);
-	}
-	if (privlen) {
-		fc = firehose_buffer_chunk_for_address(ft);
-		struct firehose_buffer_range_s range = {
-			.fbr_offset = (uint16_t)(privptr - fc->fc_start),
-			.fbr_length = (uint16_t)privlen,
-		};
-		pubptr = _dispatch_memappend(pubptr, &range);
-	}
-	while (publen > 0) {
-		pubptr = _dispatch_mempcpy(pubptr, iov->iov_base, iov->iov_len);
-		if (unlikely(os_sub_overflow(publen, iov->iov_len, &publen))) {
-			DISPATCH_CLIENT_CRASH(0, "Invalid arguments");
-		}
-		iov++;
-	}
-	while (privlen > 0) {
-		privptr = _dispatch_mempcpy(privptr, iov->iov_base, iov->iov_len);
-		if (unlikely(os_sub_overflow(privlen, iov->iov_len, &privlen))) {
-			DISPATCH_CLIENT_CRASH(0, "Invalid arguments");
-		}
-		iov++;
-	}
-	_voucher_activity_tracepoint_flush(ft, ftid);
-	return ftid.ftid_value;
-}
-
-DISPATCH_NOINLINE
-firehose_tracepoint_id_t
-voucher_activity_trace_v(firehose_stream_t stream,
-		firehose_tracepoint_id_t trace_id, uint64_t stamp,
-		const struct iovec *iov, size_t publen, size_t privlen)
-{
-	return voucher_activity_trace_v_2(stream, trace_id, stamp, iov, publen,
-			privlen, 0);
-}
-
-firehose_tracepoint_id_t
-voucher_activity_trace(firehose_stream_t stream,
-		firehose_tracepoint_id_t trace_id, uint64_t stamp,
-		const void *pubdata, size_t publen)
-{
-	struct iovec iov = { (void *)pubdata, publen };
-	return voucher_activity_trace_v(stream, trace_id, stamp, &iov, publen, 0);
-}
-
-#pragma mark -
-#pragma mark _voucher_debug
-
-#define bufprintf(...) \
-		offset += dsnprintf(&buf[offset], bufsiz > offset ? bufsiz - offset : 0, ##__VA_ARGS__)
-#define bufprintprefix() \
-		if (prefix) bufprintf("%s", prefix)
-#define VOUCHER_DETAIL_PREFIX "        "
-#define IKOT_VOUCHER	37U
-#define VOUCHER_CONTENTS_SIZE 8192
-#define MAX_HEX_DATA_SIZE 1024
-
-size_t
-_voucher_debug(voucher_t v, char *buf, size_t bufsiz)
-{
-	size_t offset = 0;
-	bufprintf("voucher[%p] = { xref = %d, ref = %d", v,
-			v->os_obj_xref_cnt + 1, v->os_obj_ref_cnt + 1);
-
-	if (v->v_kvbase) {
-		bufprintf(", base voucher %p", v->v_kvbase);
-	}
-	if (v->v_kvoucher) {
-		bufprintf(", kvoucher%s 0x%x [\n", v->v_kvoucher == v->v_ipc_kvoucher ?
-				" & ipc kvoucher" : "", v->v_kvoucher);
-		offset = voucher_kvoucher_debug(mach_task_self(), v->v_kvoucher, buf,
-				bufsiz, offset, VOUCHER_DETAIL_PREFIX, MAX_HEX_DATA_SIZE);
-		bufprintf("]");
-	}
-	if (v->v_ipc_kvoucher && v->v_ipc_kvoucher != v->v_kvoucher) {
-		bufprintf(", ipc kvoucher 0x%x [\n", v->v_ipc_kvoucher);
-		offset = voucher_kvoucher_debug(mach_task_self(), v->v_ipc_kvoucher,
-				buf, bufsiz, offset, VOUCHER_DETAIL_PREFIX, MAX_HEX_DATA_SIZE);
-		bufprintf("]");
-	}
-	if (v->v_priority) {
-		bufprintf(", QOS 0x%x", v->v_priority);
-	}
-	if (v->v_activity) {
-		bufprintf(", activity 0x%llx (pid: 0x%16llx, parent 0x%llx)",
-				v->v_activity, v->v_activity_creator, v->v_parent_activity);
-	}
-	bufprintf(" }");
-	
-	return offset;
-}
-
-static size_t
-format_hex_data(char *prefix, char *desc, uint8_t *data, size_t data_len,
-	   char *buf, size_t bufsiz, size_t offset)
-{
-	size_t i;
-	uint8_t chars[17];
-	uint8_t *pc = data;
-
-	if (desc) {
- 		bufprintf("%s%s:\n", prefix, desc);
-	}
-
-	ssize_t offset_in_row = -1;
-	for (i = 0; i < data_len; i++) {
-		offset_in_row = i % 16;
-		if (offset_in_row == 0) {
-			if (i != 0) {
-				bufprintf("  %s\n", chars);
-			}
-			bufprintf("%s  %04lx ", prefix, i);
-		}
-		bufprintf(" %02x", pc[i]);
-		chars[offset_in_row] = (pc[i] < 0x20) || (pc[i] > 0x7e) ? '.' : pc[i];
-	}
-	chars[offset_in_row + 1] = '\0';
-
-	if ((i % 16) != 0) {
-		while ((i % 16) != 0) {
-			bufprintf("   ");
-			i++;
-		}
-		bufprintf("  %s\n", chars);
-	}
-	return offset;
-}
-
-static size_t
-format_recipe_detail(mach_voucher_attr_recipe_t recipe, char *buf,
-		size_t bufsiz, size_t offset, char *prefix, size_t max_hex_data)
-{
-	bufprintprefix();
-	bufprintf("Key: %u, ", recipe->key);
-	bufprintf("Command: %u, ", recipe->command);
-	bufprintf("Previous voucher: 0x%x, ", recipe->previous_voucher);
-	bufprintf("Content size: %u\n", recipe->content_size);
-
-	switch (recipe->key) {
-	case MACH_VOUCHER_ATTR_KEY_ATM:
-		bufprintprefix();
-		bufprintf("ATM ID: %llu", *(uint64_t *)(uintptr_t)recipe->content);
-		break;
-	case MACH_VOUCHER_ATTR_KEY_IMPORTANCE:
-		bufprintprefix();
-		bufprintf("IMPORTANCE INFO: %s", (char *)recipe->content);
-		break;
-	case MACH_VOUCHER_ATTR_KEY_BANK:
-		bufprintprefix();
-		bufprintf("RESOURCE ACCOUNTING INFO: %s", (char *)recipe->content);
-		break;
-	default:
-		offset = format_hex_data(prefix, "Recipe Contents", recipe->content,
-				MIN(recipe->content_size, max_hex_data), buf, bufsiz, offset);
-		break;
-	}
-	if (buf[offset - 1] != '\n') {
-		bufprintf("\n");
-	}
-	return offset;
-}
-
-size_t
-voucher_kvoucher_debug(mach_port_t task, mach_port_name_t voucher, char *buf,
-		size_t bufsiz, size_t offset, char *prefix, size_t max_hex_data)
-{
-	uint8_t voucher_contents[VOUCHER_CONTENTS_SIZE];
-	bzero(voucher_contents, VOUCHER_CONTENTS_SIZE);
-	size_t recipe_size = VOUCHER_CONTENTS_SIZE;
-	unsigned v_kobject = 0;
-	unsigned v_kotype = 0;
-
-	kern_return_t kr = mach_port_kernel_object(task, voucher, &v_kotype,
-			&v_kobject);
-	if (kr == KERN_SUCCESS && v_kotype == IKOT_VOUCHER) {
-		kr = mach_voucher_debug_info(task, voucher,
-				(mach_voucher_attr_raw_recipe_array_t)voucher_contents,
-				(mach_msg_type_number_t *)&recipe_size);
-		if (kr != KERN_SUCCESS && kr != KERN_NOT_SUPPORTED) {
-			bufprintprefix();
-			bufprintf("Voucher: 0x%x Failed to get contents %s\n", v_kobject,
-					mach_error_string(kr));
-			goto done;
-		}
-
-		if (recipe_size == 0) {
-			bufprintprefix();
-			bufprintf("Voucher: 0x%x has no contents\n", v_kobject);
-			goto done;
-		}
-
-		bufprintprefix();
-		bufprintf("Voucher: 0x%x\n", v_kobject);
-		unsigned int used_size = 0;
-		mach_voucher_attr_recipe_t recipe = NULL;
-		while (recipe_size > used_size) {
-			recipe = (mach_voucher_attr_recipe_t)&voucher_contents[used_size];
-			if (recipe->key) {
-				offset = format_recipe_detail(recipe, buf, bufsiz, offset,
-						prefix, max_hex_data);
-			}
-			used_size += sizeof(mach_voucher_attr_recipe_data_t)
-					+ recipe->content_size;
-		}
-	} else {
-		bufprintprefix();
-		bufprintf("Invalid voucher: 0x%x\n", voucher);
-   	}
-
-done:
-	return offset;
-}
-
-#else // VOUCHER_USE_MACH_VOUCHER
-
-#pragma mark -
-#pragma mark Simulator / vouchers disabled
-
-#if VOUCHER_ENABLE_RECIPE_OBJECTS
-voucher_t
-voucher_create(voucher_recipe_t recipe)
-{
-	(void)recipe;
-	return NULL;
-}
-#endif // VOUCHER_ENABLE_RECIPE_OBJECTS
-
-voucher_t
-voucher_adopt(voucher_t voucher)
-{
-	return voucher;
-}
-
-voucher_t
-voucher_copy(void)
-{
-	return NULL;
-}
-
-voucher_t
-voucher_copy_without_importance(void)
-{
-	return NULL;
-}
-
-voucher_t
-voucher_retain(voucher_t voucher)
-{
-	return voucher;
-}
-
-void
-voucher_release(voucher_t voucher)
-{
-	(void)voucher;
-}
-
-void
-voucher_replace_default_voucher(void)
-{
-}
-
-void
-voucher_decrement_importance_count4CF(voucher_t v)
-{
-	(void)v;
-}
-
-void DISPATCH_TSD_DTOR_CC
-_voucher_thread_cleanup(void *voucher)
-{
-	(void)voucher;
-}
-
-void
-_voucher_dealloc_mach_voucher(mach_voucher_t kv)
-{
-	(void)kv;
-}
-
-mach_voucher_t
-_voucher_get_mach_voucher(voucher_t voucher)
-{
-	(void)voucher;
-	return MACH_VOUCHER_NULL;
-}
-
-mach_voucher_t
-_voucher_create_mach_voucher_with_priority(voucher_t voucher,
-		pthread_priority_t priority)
-{
-	(void)voucher; (void)priority;
-	return MACH_VOUCHER_NULL;
-}
-
-voucher_t
-_voucher_create_with_priority_and_mach_voucher(voucher_t voucher,
-		pthread_priority_t priority, mach_voucher_t kv)
-{
-	(void)voucher; (void)priority; (void)kv;
-	return NULL;
-}
-
-voucher_t
-_voucher_create_accounting_voucher(voucher_t voucher)
-{
-	(void)voucher;
-	return NULL;
-}
-
-#if HAVE_MACH
-voucher_t
-voucher_create_with_mach_msg(mach_msg_header_t *msg)
-{
-	(void)msg;
-	return NULL;
-}
-#endif
-
-#if VOUCHER_ENABLE_GET_MACH_VOUCHER
-mach_voucher_t
-voucher_get_mach_voucher(voucher_t voucher)
-{
-	(void)voucher;
-	return 0;
-}
-#endif // VOUCHER_ENABLE_GET_MACH_VOUCHER
-
-void
-_voucher_xref_dispose(voucher_t voucher)
-{
-	(void)voucher;
-}
-
-void
-_voucher_dispose(voucher_t voucher)
-{
-	(void)voucher;
-}
-
-#if __has_include(<mach/mach.h>)
-voucher_t
-voucher_copy_with_persona_mach_voucher(mach_voucher_t persona_mach_voucher)
-{
-	(void)persona_mach_voucher;
-	return NULL;
-}
-
-kern_return_t
-mach_voucher_persona_self(mach_voucher_t *persona_mach_voucher)
-{
-	(void)persona_mach_voucher;
-	return KERN_NOT_SUPPORTED;
-}
-
-kern_return_t
-mach_voucher_persona_for_originator(uid_t persona_id,
-	mach_voucher_t originator_persona_mach_voucher,
-	uint64_t originator_unique_pid, mach_voucher_t *persona_mach_voucher)
-{
-	(void)persona_id; (void)originator_persona_mach_voucher;
-	(void)originator_unique_pid; (void)persona_mach_voucher;
-	return KERN_NOT_SUPPORTED;
-}
-
-uid_t
-voucher_get_current_persona(void)
-{
-	return PERSONA_ID_NONE;
-}
-
-int
-voucher_get_current_persona_originator_info(struct proc_persona_info *persona_info)
-{
-	(void)persona_info;
-	return -1;
-}
-
-int
-voucher_get_current_persona_proximate_info(struct proc_persona_info *persona_info)
-{
-	(void)persona_info;
-	return -1;
-}
-#endif // __has_include(<mach/mach.h>)
-
-void
-_voucher_activity_debug_channel_init(void)
-{
-}
-
-void
-_voucher_atfork_child(void)
-{
-}
-
-void
-_voucher_init(void)
-{
-}
-
-#if OS_VOUCHER_ACTIVITY_SPI
-void*
-voucher_activity_get_metadata_buffer(size_t *length)
-{
-    *length = 0;
-    return NULL;
-}
-
-voucher_t
-voucher_activity_create(firehose_tracepoint_id_t trace_id,
-		voucher_t base, firehose_activity_flags_t flags, uint64_t location)
-{
-	(void)trace_id; (void)base; (void)flags; (void)location;
-	return NULL;
-}
-
-voucher_t
-voucher_activity_create_with_location(firehose_tracepoint_id_t *trace_id,
-		voucher_t base, firehose_activity_flags_t flags, uint64_t location)
-{
-	(void)trace_id; (void)base; (void)flags; (void)location;
-	return NULL;
-}
-
-firehose_activity_id_t
-voucher_get_activity_id(voucher_t voucher, firehose_activity_id_t *parent_id)
-{
-	(void)voucher; (void)parent_id;
-	return 0;
-}
-
-firehose_activity_id_t
-voucher_get_activity_id_and_creator(voucher_t voucher, uint64_t *creator_pid,
-		firehose_activity_id_t *parent_id)
-{
-	if (creator_pid) *creator_pid = 0;
-	(void)voucher; (void)parent_id;
-	return 0;
-}
-
-firehose_tracepoint_id_t
-voucher_activity_trace(firehose_stream_t stream,
-		firehose_tracepoint_id_t trace_id, uint64_t timestamp,
-		const void *pubdata, size_t publen)
-{
-	(void)stream; (void)trace_id; (void)timestamp;
-	(void)pubdata; (void)publen;
-	return 0;
-}
-
-firehose_tracepoint_id_t
-voucher_activity_trace_with_private_strings(firehose_stream_t stream,
-		firehose_tracepoint_id_t trace_id, uint64_t timestamp,
-		const void *pubdata, size_t publen,
-		const void *privdata, size_t privlen)
-{
-	(void)stream; (void)trace_id; (void)timestamp;
-	(void)pubdata; (void)publen; (void)privdata; (void)privlen;
-	return 0;
-}
-
-firehose_tracepoint_id_t
-voucher_activity_trace_v(firehose_stream_t stream,
-		firehose_tracepoint_id_t trace_id, uint64_t timestamp,
-		const struct iovec *iov, size_t publen, size_t privlen)
-{
-	(void)stream; (void)trace_id; (void)timestamp;
-	(void)iov; (void)publen; (void)privlen;
-	return 0;
-}
-
-void
-voucher_activity_flush(firehose_stream_t stream)
-{
-	(void)stream;
-}
-
-void
-voucher_activity_initialize_4libtrace(voucher_activity_hooks_t hooks)
-{
-	(void)hooks;
-}
-#endif // OS_VOUCHER_ACTIVITY_SPI
-
-size_t
-_voucher_debug(voucher_t v, char* buf, size_t bufsiz)
-{
-	(void)v; (void)buf; (void)bufsiz;
-	return 0;
-}
-
-#endif // VOUCHER_USE_MACH_VOUCHER
-
-#else // DISPATCH_VARIANT_DYLD_STUB
-
-firehose_activity_id_t
-voucher_get_activity_id_4dyld(void)
-{
-#if VOUCHER_USE_MACH_VOUCHER
-	return _voucher_get_activity_id(_voucher_get(), NULL);
-#else
-	return 0;
-#endif
-}
-
-#endif // DISPATCH_VARIANT_DYLD_STUB
--- a/Telegram/ThirdParty/dispatch/src/voucher_internal.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/src/voucher_internal.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,762 +0,0 @@
-/*
- * Copyright (c) 2013 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-/*
- * IMPORTANT: This header file describes INTERNAL interfaces to libdispatch
- * which are subject to change in future releases of Mac OS X. Any applications
- * relying on these interfaces WILL break.
- */
-
-#ifndef __DISPATCH_VOUCHER_INTERNAL__
-#define __DISPATCH_VOUCHER_INTERNAL__
-
-#ifndef __DISPATCH_INDIRECT__
-#error "Please #include <dispatch/dispatch.h> instead of this file directly."
-#include <dispatch/base.h> // for HeaderDoc
-#endif
-
-#pragma mark -
-#pragma mark voucher_recipe_t (disabled)
-
-#if VOUCHER_ENABLE_RECIPE_OBJECTS
-/*!
- * @group Voucher Creation SPI
- * SPI intended for clients that need to create vouchers.
- */
-OS_OBJECT_DECL_CLASS(voucher_recipe);
-
-/*!
- * @function voucher_create
- *
- * @abstract
- * Creates a new voucher object from a recipe.
- *
- * @discussion
- * Error handling TBD
- *
- * @result
- * The newly created voucher object.
- */
-API_AVAILABLE(macos(10.10), ios(8.0))
-OS_EXPORT OS_OBJECT_RETURNS_RETAINED OS_WARN_RESULT OS_NOTHROW
-voucher_t
-voucher_create(voucher_recipe_t recipe);
-#endif // VOUCHER_ENABLE_RECIPE_OBJECTS
-
-#if VOUCHER_ENABLE_GET_MACH_VOUCHER
-/*!
- * @function voucher_get_mach_voucher
- *
- * @abstract
- * Returns the mach voucher port underlying the specified voucher object.
- *
- * @discussion
- * The caller must either maintain a reference on the voucher object while the
- * returned mach voucher port is in use to ensure it stays valid for the
- * duration, or it must retain the mach voucher port with mach_port_mod_refs().
- *
- * @param voucher
- * The voucher object to query.
- *
- * @result
- * A mach voucher port.
- */
-API_AVAILABLE(macos(10.10), ios(8.0))
-OS_VOUCHER_EXPORT OS_WARN_RESULT OS_NOTHROW
-mach_voucher_t
-voucher_get_mach_voucher(voucher_t voucher);
-#endif // VOUCHER_ENABLE_GET_MACH_VOUCHER
-
-#pragma mark -
-#pragma mark voucher_t
-
-void _voucher_init(void);
-void _voucher_atfork_child(void);
-void _voucher_activity_debug_channel_init(void);
-#if OS_VOUCHER_ACTIVITY_SPI && OS_VOUCHER_ACTIVITY_GENERATE_SWAPS
-void _voucher_activity_swap(firehose_activity_id_t old_id,
-		firehose_activity_id_t new_id);
-#endif
-void _voucher_xref_dispose(voucher_t voucher);
-void _voucher_dispose(voucher_t voucher);
-size_t _voucher_debug(voucher_t v, char* buf, size_t bufsiz);
-void DISPATCH_TSD_DTOR_CC _voucher_thread_cleanup(void *voucher);
-mach_voucher_t _voucher_get_mach_voucher(voucher_t voucher);
-voucher_t _voucher_create_without_importance(voucher_t voucher);
-voucher_t _voucher_create_accounting_voucher(voucher_t voucher);
-mach_voucher_t _voucher_create_mach_voucher_with_priority(voucher_t voucher,
-		pthread_priority_t priority);
-voucher_t _voucher_create_with_priority_and_mach_voucher(voucher_t voucher,
-		pthread_priority_t priority, mach_voucher_t kv);
-void _voucher_dealloc_mach_voucher(mach_voucher_t kv);
-
-#if VOUCHER_ENABLE_RECIPE_OBJECTS
-_OS_OBJECT_DECL_SUBCLASS_INTERFACE(voucher_recipe, object)
-#endif
-
-voucher_t voucher_retain(voucher_t voucher);
-void voucher_release(voucher_t voucher);
-
-#define VOUCHER_NO_MACH_VOUCHER MACH_PORT_DEAD
-
-#if VOUCHER_USE_MACH_VOUCHER
-
-#if DISPATCH_DEBUG
-#define DISPATCH_VOUCHER_DEBUG 1
-#define DISPATCH_VOUCHER_ACTIVITY_DEBUG 1
-#endif
-
-#include <voucher/ipc_pthread_priority_types.h>
-
-typedef uint32_t _voucher_magic_t;
-typedef uint32_t _voucher_priority_t;
-
-#define VOUCHER_MAGIC_V3  ((_voucher_magic_t)0x0390cefa) // FACE9003
-
-typedef struct _voucher_mach_udata_s {
-	_voucher_magic_t vmu_magic;
-	_voucher_priority_t vmu_priority;
-	uint8_t _vmu_after_priority[0];
-	firehose_activity_id_t vmu_activity;
-	uint64_t vmu_activity_pid;
-	firehose_activity_id_t vmu_parent_activity;
-	uint8_t _vmu_after_activity[0];
-} _voucher_mach_udata_s;
-
-OS_ENUM(voucher_fields, uint16_t,
-	VOUCHER_FIELD_NONE		= 0,
-	VOUCHER_FIELD_KVOUCHER	= 1u << 0,
-	VOUCHER_FIELD_PRIORITY	= 1u << 1,
-	VOUCHER_FIELD_ACTIVITY	= 1u << 2,
-
-#if VOUCHER_ENABLE_RECIPE_OBJECTS
-	VOUCHER_FIELD_EXTRA		= 1u << 15,
-#else
-	VOUCHER_FIELD_EXTRA		= 0,
-#endif
-);
-
-typedef struct voucher_s {
-	_OS_OBJECT_HEADER(
-	struct voucher_vtable_s *os_obj_isa,
-	os_obj_ref_cnt,
-	os_obj_xref_cnt);
-	struct voucher_hash_entry_s {
-		uintptr_t vhe_next;
-		uintptr_t vhe_prev_ptr;
-	} v_list;
-	mach_voucher_t v_kvoucher, v_ipc_kvoucher; // if equal, only one reference
-	voucher_t v_kvbase; // if non-NULL, v_kvoucher is a borrowed reference
-	firehose_activity_id_t v_activity;
-	uint64_t v_activity_creator;
-	firehose_activity_id_t v_parent_activity;
-	_voucher_priority_t v_priority;
-	unsigned int v_kv_has_importance:1;
-#if VOUCHER_ENABLE_RECIPE_OBJECTS
-	size_t v_recipe_extra_offset;
-	mach_voucher_attr_recipe_size_t v_recipe_extra_size;
-#endif
-} voucher_s;
-
-typedef struct voucher_hash_head_s {
-	uintptr_t vhh_first;
-} voucher_hash_head_s;
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_voucher_hash_is_enqueued(const struct voucher_s *v)
-{
-	return v->v_list.vhe_prev_ptr != 0;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_voucher_hash_mark_not_enqueued(struct voucher_s *v)
-{
-	v->v_list.vhe_prev_ptr = 0;
-	v->v_list.vhe_next = (uintptr_t)DISPATCH_OBJECT_LISTLESS;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_voucher_hash_set_next(uintptr_t *next, struct voucher_s *v)
-{
-	*next = ~(uintptr_t)v;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline voucher_t
-_voucher_hash_get_next(uintptr_t next)
-{
-	return (voucher_t)~next;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_voucher_hash_set_prev_ptr(uintptr_t *prev_ptr, uintptr_t *addr)
-{
-	*prev_ptr = ~(uintptr_t)addr;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_voucher_hash_store_to_prev_ptr(uintptr_t prev_ptr, struct voucher_s *v)
-{
-	*(uintptr_t *)~prev_ptr = ~(uintptr_t)v;
-}
-
-#if VOUCHER_ENABLE_RECIPE_OBJECTS
-#define _voucher_extra_size(v) ((v)->v_recipe_extra_size)
-#define _voucher_extra_recipes(v) ((char*)(v) + (v)->v_recipe_extra_offset)
-#else
-#define _voucher_extra_size(v) 0
-#define _voucher_extra_recipes(v) NULL
-#endif
-
-#if VOUCHER_ENABLE_RECIPE_OBJECTS
-typedef struct voucher_recipe_s {
-	_OS_OBJECT_HEADER(
-	const _os_object_vtable_s *os_obj_isa,
-	os_obj_ref_cnt,
-	os_obj_xref_cnt);
-	size_t vr_allocation_size;
-	mach_voucher_attr_recipe_size_t volatile vr_size;
-	mach_voucher_attr_recipe_t vr_data;
-} voucher_recipe_s;
-#endif
-
-#if TARGET_OS_IPHONE && !TARGET_OS_SIMULATOR
-#define VL_HASH_SIZE  64u // must be a power of two
-#else
-#define VL_HASH_SIZE 256u // must be a power of two
-#endif
-#define VL_HASH(kv) (MACH_PORT_INDEX(kv) & (VL_HASH_SIZE - 1))
-
-#if DISPATCH_DEBUG && DISPATCH_VOUCHER_DEBUG
-#define _dispatch_voucher_debug(msg, v, ...) \
-		_dispatch_debug("voucher[%p]: " msg, v, ##__VA_ARGS__)
-#define _dispatch_kvoucher_debug(msg, kv, ...) \
-		_dispatch_debug("kvoucher[0x%08x]: " msg, kv, ##__VA_ARGS__)
-#define _dispatch_voucher_debug_machport(name) _dispatch_debug_machport(name)
-#else
-#define _dispatch_voucher_debug(msg, v, ...)
-#define _dispatch_kvoucher_debug(msg, kv, ...)
-#define _dispatch_voucher_debug_machport(name) ((void)(name))
-#endif
-
-#if DISPATCH_USE_DTRACE_INTROSPECTION && defined(__APPLE__) // rdar://33642820
-#define _voucher_trace(how, ...)  ({ \
-		if (unlikely(VOUCHER_##how##_ENABLED())) { \
-			VOUCHER_##how(__VA_ARGS__); \
-		} \
-	})
-#else
-#define _voucher_trace(how, ...) ((void)0)
-#endif
-
-#ifndef DISPATCH_VOUCHER_OBJC_DEBUG
-#if DISPATCH_INTROSPECTION || DISPATCH_DEBUG
-#define DISPATCH_VOUCHER_OBJC_DEBUG 1
-#else
-#define DISPATCH_VOUCHER_OBJC_DEBUG 0
-#endif
-#endif // DISPATCH_VOUCHER_OBJC_DEBUG
-
-DISPATCH_ALWAYS_INLINE
-static inline struct voucher_s *
-_voucher_retain_inline(struct voucher_s *voucher)
-{
-	// not using _os_object_refcnt* because we don't need barriers:
-	// vouchers are immutable and are in a hash table with a lock
-	int xref_cnt = os_atomic_inc2o(voucher, os_obj_xref_cnt, relaxed);
-	_voucher_trace(RETAIN, (voucher_t)voucher, xref_cnt + 1);
-	_dispatch_voucher_debug("retain  -> %d", voucher, xref_cnt + 1);
-	if (unlikely(xref_cnt <= 0)) {
-		_OS_OBJECT_CLIENT_CRASH("Voucher resurrection");
-	}
-	return voucher;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_voucher_release_inline(struct voucher_s *voucher)
-{
-	// not using _os_object_refcnt* because we don't need barriers:
-	// vouchers are immutable and are in a hash table with a lock
-	int xref_cnt = os_atomic_dec2o(voucher, os_obj_xref_cnt, relaxed);
-	_voucher_trace(RELEASE, (voucher_t)voucher, xref_cnt + 1);
-	_dispatch_voucher_debug("release -> %d", voucher, xref_cnt + 1);
-	if (likely(xref_cnt >= 0)) {
-		return;
-	}
-	if (unlikely(xref_cnt < -1)) {
-		_OS_OBJECT_CLIENT_CRASH("Voucher over-release");
-	}
-	return _os_object_xref_dispose((_os_object_t)voucher);
-}
-
-#if DISPATCH_PURE_C
-
-DISPATCH_ALWAYS_INLINE
-static inline voucher_t
-_voucher_retain(voucher_t voucher)
-{
-#if DISPATCH_VOUCHER_OBJC_DEBUG
-	os_retain(voucher);
-#else
-	_voucher_retain_inline(voucher);
-#endif // DISPATCH_VOUCHER_OBJC_DEBUG
-	return voucher;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_voucher_release(voucher_t voucher)
-{
-#if DISPATCH_VOUCHER_OBJC_DEBUG
-	os_release(voucher);
-#else
-	_voucher_release_inline(voucher);
-#endif // DISPATCH_VOUCHER_OBJC_DEBUG
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_voucher_release_no_dispose(voucher_t voucher)
-{
-#if !DISPATCH_VOUCHER_OBJC_DEBUG
-	// not using _os_object_refcnt* because we don't need barriers:
-	// vouchers are immutable and are in a hash table with a lock
-	int xref_cnt = os_atomic_dec2o(voucher, os_obj_xref_cnt, relaxed);
-	_voucher_trace(RELEASE, voucher, xref_cnt + 1);
-	_dispatch_voucher_debug("release -> %d", voucher, xref_cnt + 1);
-	if (likely(xref_cnt >= 0)) {
-		return;
-	}
-	_OS_OBJECT_CLIENT_CRASH("Voucher over-release");
-#else
-	return os_release(voucher);
-#endif // DISPATCH_DEBUG
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline voucher_t
-_voucher_get(void)
-{
-	return _dispatch_thread_getspecific(dispatch_voucher_key);
-}
-
-DISPATCH_ALWAYS_INLINE DISPATCH_WARN_RESULT
-static inline voucher_t
-_voucher_copy(void)
-{
-	voucher_t voucher = _voucher_get();
-	if (voucher) _voucher_retain(voucher);
-	return voucher;
-}
-
-DISPATCH_ALWAYS_INLINE DISPATCH_WARN_RESULT
-static inline voucher_t
-_voucher_copy_without_importance(void)
-{
-	voucher_t voucher = _voucher_get();
-	if (voucher) voucher = _voucher_create_without_importance(voucher);
-	return voucher;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_voucher_mach_voucher_set(mach_voucher_t kv)
-{
-	if (kv == VOUCHER_NO_MACH_VOUCHER) return;
-	_dispatch_set_priority_and_mach_voucher_slow(0, kv);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline mach_voucher_t
-_voucher_swap_and_get_mach_voucher(voucher_t ov, voucher_t voucher)
-{
-	if (ov == voucher) return VOUCHER_NO_MACH_VOUCHER;
-	if (ov) _voucher_trace(ORPHAN, ov);
-	_dispatch_thread_setspecific(dispatch_voucher_key, voucher);
-	if (voucher) _voucher_trace(ADOPT, voucher);
-	_dispatch_voucher_debug("swap from voucher[%p]", voucher, ov);
-	mach_voucher_t kv = voucher ? voucher->v_kvoucher : MACH_VOUCHER_NULL;
-	mach_voucher_t okv = ov ? ov->v_kvoucher : MACH_VOUCHER_NULL;
-#if OS_VOUCHER_ACTIVITY_GENERATE_SWAPS
-	firehose_activity_id_t aid = voucher ? voucher->v_activity : 0;
-	firehose_activity_id_t oaid = ov ? ov->v_activity : 0;
-	if (aid != oaid) _voucher_activity_swap(aid, oaid);
-#endif
-	return (kv != okv) ? kv : VOUCHER_NO_MACH_VOUCHER;
-}
-
-DISPATCH_ALWAYS_INLINE DISPATCH_WARN_RESULT
-static inline voucher_t
-_voucher_adopt(voucher_t voucher)
-{
-	voucher_t ov = _voucher_get();
-	_voucher_mach_voucher_set(_voucher_swap_and_get_mach_voucher(ov, voucher));
-	return ov;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_voucher_replace(voucher_t voucher)
-{
-	voucher_t ov = _voucher_adopt(voucher);
-	if (ov) _voucher_release(ov);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_voucher_clear(void)
-{
-	_voucher_replace(NULL);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline pthread_priority_t
-_voucher_get_priority(voucher_t v)
-{
-	return v ? (pthread_priority_t)v->v_priority : 0;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline firehose_activity_id_t
-_voucher_get_activity_id(voucher_t v, uint64_t *creator_pid)
-{
-	if (creator_pid) *creator_pid = v ? v->v_activity_creator : 0;
-	return v ? v->v_activity : 0;
-}
-
-void _voucher_task_mach_voucher_init(void* ctxt);
-extern dispatch_once_t _voucher_task_mach_voucher_pred;
-extern mach_voucher_t _voucher_task_mach_voucher;
-#if VOUCHER_USE_EMPTY_MACH_BASE_VOUCHER
-#define _voucher_default_task_mach_voucher MACH_VOUCHER_NULL
-#else
-extern mach_voucher_t _voucher_default_task_mach_voucher;
-#endif
-DISPATCH_ALWAYS_INLINE
-static inline mach_voucher_t
-_voucher_get_task_mach_voucher(void)
-{
-	dispatch_once_f(&_voucher_task_mach_voucher_pred, NULL,
-			_voucher_task_mach_voucher_init);
-	return _voucher_task_mach_voucher;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_voucher_mach_msg_set_mach_voucher(mach_msg_header_t *msg, mach_voucher_t kv,
-		bool move_send)
-{
-	if (MACH_MSGH_BITS_HAS_VOUCHER(msg->msgh_bits)) return false;
-	if (!kv) return false;
-	msg->msgh_voucher_port = kv;
-	msg->msgh_bits |= MACH_MSGH_BITS_SET_PORTS(0, 0, move_send ?
-			MACH_MSG_TYPE_MOVE_SEND : MACH_MSG_TYPE_COPY_SEND);
-	_dispatch_kvoucher_debug("msg[%p] set %s", kv, msg, move_send ?
-			"move-send" : "copy-send");
-	_dispatch_voucher_debug_machport(kv);
-	return true;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_voucher_mach_msg_set(mach_msg_header_t *msg, voucher_t voucher)
-{
-	if (MACH_MSGH_BITS_HAS_VOUCHER(msg->msgh_bits)) return false;
-	mach_voucher_t kv;
-	if (voucher) {
-		kv = _voucher_get_mach_voucher(voucher);
-	} else {
-		kv = _voucher_get_task_mach_voucher();
-	}
-	return _voucher_mach_msg_set_mach_voucher(msg, kv, false);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline mach_voucher_t
-_voucher_mach_msg_get(mach_msg_header_t *msg, mach_msg_bits_t *msgh_bits)
-{
-	if (!MACH_MSGH_BITS_HAS_VOUCHER(msg->msgh_bits)) {
-		*msgh_bits = 0;
-		return MACH_VOUCHER_NULL;
-	}
-	mach_voucher_t kv = msg->msgh_voucher_port;
-	msg->msgh_voucher_port = MACH_VOUCHER_NULL;
-	mach_msg_bits_t mask = MACH_MSGH_BITS_VOUCHER_MASK|MACH_MSGH_BITS_RAISEIMP;
-	*msgh_bits = msg->msgh_bits & mask;
-	msg->msgh_bits &= ~mask;
-	return kv;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline mach_voucher_t
-_voucher_mach_msg_clear(mach_msg_header_t *msg, bool move_send)
-{
-	mach_msg_bits_t kvbits = MACH_MSGH_BITS_VOUCHER(msg->msgh_bits);
-	mach_voucher_t kv = msg->msgh_voucher_port, kvm = MACH_VOUCHER_NULL;
-	if ((kvbits == MACH_MSG_TYPE_COPY_SEND ||
-			kvbits == MACH_MSG_TYPE_MOVE_SEND) && kv) {
-		_dispatch_kvoucher_debug("msg[%p] clear %s", kv, msg, move_send ?
-				"move-send" : "copy-send");
-		_dispatch_voucher_debug_machport(kv);
-		if (kvbits == MACH_MSG_TYPE_MOVE_SEND) {
-			// <rdar://problem/15694142> return/drop received or pseudo-received
-			// voucher reference (e.g. due to send failure).
-			if (move_send) {
-				kvm = kv;
-			} else {
-				_voucher_dealloc_mach_voucher(kv);
-			}
-		}
-		msg->msgh_voucher_port = MACH_VOUCHER_NULL;
-		msg->msgh_bits &= (mach_msg_bits_t)~MACH_MSGH_BITS_VOUCHER_MASK;
-	}
-	return kvm;
-}
-
-#pragma mark -
-#pragma mark dispatch_continuation_t + voucher_t
-
-#if DISPATCH_USE_VOUCHER_KDEBUG_TRACE
-#define DISPATCH_VOUCHER_CODE(code) DISPATCH_CODE(VOUCHER, code)
-#else
-#define DISPATCH_VOUCHER_CODE(code) 0
-#endif // DISPATCH_USE_VOUCHER_KDEBUG_TRACE
-
-#define DISPATCH_TRACE_VOUCHER_DC_PUSH          DISPATCH_VOUCHER_CODE(0x1)
-#define DISPATCH_TRACE_VOUCHER_DC_POP           DISPATCH_VOUCHER_CODE(0x2)
-#define DISPATCH_TRACE_VOUCHER_DMSG_PUSH        DISPATCH_VOUCHER_CODE(0x3)
-#define DISPATCH_TRACE_VOUCHER_DMSG_POP         DISPATCH_VOUCHER_CODE(0x4)
-#define DISPATCH_TRACE_VOUCHER_ACTIVITY_ADOPT   DISPATCH_VOUCHER_CODE(0x5)
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_voucher_ktrace(uint32_t code, voucher_t v, const void *container)
-{
-	if (v == DISPATCH_NO_VOUCHER) return;
-	natural_t voucher = v ? v->v_kvoucher : MACH_VOUCHER_NULL;
-	_dispatch_ktrace2(code, voucher, (uintptr_t)container);
-}
-#define _dispatch_voucher_ktrace(code, v, container) \
-		_dispatch_voucher_ktrace(DISPATCH_TRACE_VOUCHER_##code, v, container)
-#define _dispatch_voucher_ktrace_dc_push(dc) \
-		_dispatch_voucher_ktrace(DC_PUSH, (dc)->dc_voucher, (dc))
-#define _dispatch_voucher_ktrace_dc_pop(dc, v) \
-		_dispatch_voucher_ktrace(DC_POP, v, (dc))
-#define _dispatch_voucher_ktrace_dmsg_push(dmsg) \
-		_dispatch_voucher_ktrace(DMSG_PUSH, (dmsg)->dmsg_voucher, (dmsg))
-#define _dispatch_voucher_ktrace_dmsg_pop(dmsg) \
-		_dispatch_voucher_ktrace(DMSG_POP, (dmsg)->dmsg_voucher, (dmsg))
-#define _dispatch_voucher_ktrace_activity_adopt(aid) \
-		_dispatch_ktrace1(DISPATCH_TRACE_VOUCHER_ACTIVITY_ADOPT, aid);
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_continuation_voucher_set(dispatch_continuation_t dc,
-		dispatch_block_flags_t flags)
-{
-	voucher_t v = NULL;
-
-	// _dispatch_continuation_voucher_set is never called for blocks with
-	// private data or with the DISPATCH_BLOCK_HAS_VOUCHER flag set.
-	// only _dispatch_continuation_init_slow handles this bit.
-	dispatch_assert(!(flags & DISPATCH_BLOCK_HAS_VOUCHER));
-
-	if (!(flags & DISPATCH_BLOCK_NO_VOUCHER)) {
-		v = _voucher_copy();
-	}
-	dc->dc_voucher = v;
-	_dispatch_voucher_debug("continuation[%p] set", dc->dc_voucher, dc);
-	_dispatch_voucher_ktrace_dc_push(dc);
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_continuation_voucher_adopt(dispatch_continuation_t dc,
-		uintptr_t dc_flags)
-{
-	voucher_t v = dc->dc_voucher;
-	dispatch_thread_set_self_t consume = (dc_flags & DC_FLAG_CONSUME);
-	dispatch_assert(DC_FLAG_CONSUME == DISPATCH_VOUCHER_CONSUME);
-
-	if (consume) {
-		dc->dc_voucher = VOUCHER_INVALID;
-	}
-	if (likely(v != DISPATCH_NO_VOUCHER)) {
-		_dispatch_voucher_ktrace_dc_pop(dc, v);
-		_dispatch_voucher_debug("continuation[%p] adopt", v, dc);
-	}
-	(void)_dispatch_adopt_priority_and_set_voucher(dc->dc_priority, v,
-			consume | DISPATCH_VOUCHER_REPLACE);
-}
-
-#pragma mark -
-#pragma mark _voucher activity subsystem
-
-extern dispatch_once_t _firehose_task_buffer_pred;
-extern union firehose_buffer_u *_firehose_task_buffer;
-extern uint64_t _voucher_unique_pid;
-extern dispatch_mach_t _voucher_activity_debug_channel;
-extern voucher_activity_hooks_t _voucher_libtrace_hooks;
-
-#endif // DISPATCH_PURE_C
-
-#else // VOUCHER_USE_MACH_VOUCHER
-
-#pragma mark -
-#pragma mark Simulator / vouchers disabled
-
-#define _dispatch_voucher_debug(msg, v, ...)
-#define _dispatch_kvoucher_debug(msg, kv, ...)
-
-DISPATCH_ALWAYS_INLINE
-static inline voucher_t
-_voucher_retain(voucher_t voucher)
-{
-	return voucher;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_voucher_release(voucher_t voucher)
-{
-	(void)voucher;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline voucher_t
-_voucher_get(void)
-{
-	return NULL;
-}
-
-DISPATCH_ALWAYS_INLINE DISPATCH_WARN_RESULT
-static inline voucher_t
-_voucher_copy(void)
-{
-	return NULL;
-}
-
-DISPATCH_ALWAYS_INLINE DISPATCH_WARN_RESULT
-static inline voucher_t
-_voucher_copy_without_importance(void)
-{
-	return NULL;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline mach_voucher_t
-_voucher_swap_and_get_mach_voucher(voucher_t ov, voucher_t voucher)
-{
-	(void)ov; (void)voucher;
-	return MACH_VOUCHER_NULL;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline voucher_t
-_voucher_adopt(voucher_t voucher)
-{
-	return voucher;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_voucher_replace(voucher_t voucher)
-{
-	(void)voucher;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_voucher_clear(void)
-{
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline pthread_priority_t
-_voucher_get_priority(voucher_t voucher)
-{
-	(void)voucher;
-	return 0;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_voucher_mach_msg_set_mach_voucher(mach_msg_header_t *msg, mach_voucher_t kv,
-		bool move_send)
-{
-	(void)msg; (void)kv; (void)move_send;
-	return false;
-
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline bool
-_voucher_mach_msg_set(mach_msg_header_t *msg, voucher_t voucher)
-{
-	(void)msg; (void)voucher;
-	return false;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline mach_voucher_t
-_voucher_mach_msg_get(mach_msg_header_t *msg, mach_msg_bits_t *msgh_bits)
-{
-	(void)msg;(void)msgh_bits;
-	return 0;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline mach_voucher_t
-_voucher_mach_msg_clear(mach_msg_header_t *msg, bool move_send)
-{
-	(void)msg; (void)move_send;
-	return MACH_VOUCHER_NULL;
-}
-
-#define _dispatch_voucher_ktrace_dc_push(dc)
-#define _dispatch_voucher_ktrace_dc_pop(dc, v)
-#define _dispatch_voucher_ktrace_dmsg_push(dmsg)
-#define _dispatch_voucher_ktrace_dmsg_pop(dmsg)
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_continuation_voucher_set(dispatch_continuation_t dc,
-		dispatch_block_flags_t flags)
-{
-	(void)dc; (void)flags;
-}
-
-DISPATCH_ALWAYS_INLINE
-static inline void
-_dispatch_continuation_voucher_adopt(dispatch_continuation_t dc,
-		uintptr_t dc_flags)
-{
-	(void)dc; (void)dc_flags;
-}
-
-#endif // VOUCHER_USE_MACH_VOUCHER
-
-#endif /* __DISPATCH_VOUCHER_INTERNAL__ */
--- a/Telegram/ThirdParty/dispatch/TESTING.md	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/TESTING.md	1970-01-01 00:00:00.000000000 -0000
@@ -1,27 +0,0 @@
-## Testing libdispatch
-
-### Running tests
-
-A C-based test suite can be found in the tests subdirectory.
-It uses the automake testing harness to execute the tests.
-
-A default set of tests that are always expected to pass can
-be executed by doing
-
-   ```
-   make check
-   ```
-
-An extended test suite that includes some tests that may fail
-occasionally can be enabled at configure time:
-
-   ```
-   ./configure --enable-extended-test-suite
-   make check
-   ```
-
-### Additional prerequisites
-
-A few test cases require additional packages to be installed.
-In particular, several IO tests assume /usr/bin/vi is available
-as an input file and will fail if it is not present.
--- a/Telegram/ThirdParty/dispatch/tests/bsdtestharness.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/bsdtestharness.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,279 +0,0 @@
-/*
- * Copyright (c) 2008-2011 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include <dispatch/dispatch.h>
-#include <assert.h>
-#include <stdio.h>
-#include <stdlib.h>
-#if defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))
-#include <spawn.h>
-#include <sys/resource.h>
-#include <sys/time.h>
-#include <sys/wait.h>
-#include <unistd.h>
-#elif defined(_WIN32)
-#include <generic_win_port.h>
-#include <Psapi.h>
-#include <Windows.h>
-#endif
-#include <signal.h>
-#ifdef __APPLE__
-#include <mach/clock_types.h>
-#include <mach-o/arch.h>
-#endif
-
-#include <bsdtests.h>
-
-#if !defined(_WIN32)
-extern char **environ;
-#endif
-
-int
-main(int argc, char *argv[])
-{
-	int res;
-	pid_t pid = 0;
-
-	if (argc < 2) {
-		fprintf(stderr, "usage: %s [...]\n", argv[0]);
-		exit(1);
-	}
-
-#ifdef HAVE_POSIX_SPAWNP
-	short spawnflags = 0;
-#ifdef __APPLE__
-	spawnflags |= POSIX_SPAWN_START_SUSPENDED;
-#if TARGET_OS_EMBEDDED
-	spawnflags |= POSIX_SPAWN_SETEXEC;
-#endif
-#endif
-
-	posix_spawnattr_t attr;
-	res = posix_spawnattr_init(&attr);
-	assert(res == 0);
-	res = posix_spawnattr_setflags(&attr, spawnflags);
-	assert(res == 0);
-#endif
-
-#ifdef __APPLE__
-	char *arch = getenv("BSDTEST_ARCH");
-	if (arch) {
-		const NXArchInfo *ai = NXGetArchInfoFromName(arch);
-		if (ai) {
-			res = posix_spawnattr_setbinpref_np(&attr, 1, (cpu_type_t*)&ai->cputype, NULL);
-			assert(res == 0);
-		}
-	}
-
-#endif
-	int i;
-	char** newargv = calloc((size_t)argc, sizeof(void*));
-	for (i = 1; i < argc; ++i) {
-		newargv[i-1] = argv[i];
-	}
-	newargv[i-1] = NULL;
-
-	struct timeval tv_start;
-	gettimeofday(&tv_start, NULL);
-
-#ifdef HAVE_POSIX_SPAWNP
-#ifdef __APPLE__
-	if (spawnflags & POSIX_SPAWN_SETEXEC) {
-		pid = fork();
-	}
-#endif
-	if (!pid) {
-		res = posix_spawnp(&pid, newargv[0], NULL, &attr, newargv, environ);
-		if (res) {
-			errno = res;
-			perror(newargv[0]);
-			exit(EXIT_FAILURE);
-		}
-	}
-#elif defined(__unix__)
-	(void)res;
-	pid = fork();
-	if (pid == -1) {
-		perror("fork");
-		exit(EXIT_FAILURE);
-	} else if (pid == 0) {
-		// Child process
-		if (execve(newargv[0], newargv, environ) == -1) {
-			perror(newargv[0]);
-			_Exit(EXIT_FAILURE);
-		}
-	}
-#elif defined(_WIN32)
-	(void)res;
-	WCHAR *cmdline = argv_to_command_line(newargv);
-	if (!cmdline) {
-		fprintf(stderr, "argv_to_command_line() failed\n");
-		exit(EXIT_FAILURE);
-	}
-	STARTUPINFOW si = {.cb = sizeof(si)};
-	PROCESS_INFORMATION pi;
-	BOOL created = CreateProcessW(NULL, cmdline, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi);
-	DWORD error = GetLastError();
-	free(cmdline);
-	if (!created) {
-		print_winapi_error("CreateProcessW", error);
-		exit(EXIT_FAILURE);
-	}
-	pid = (pid_t)pi.dwProcessId;
-#else
-#error "bsdtestharness not implemented on this platform"
-#endif
-
-	//fprintf(stderr, "pid = %d\n", pid);
-	assert(pid > 0);
-
-#if defined(__linux__)
-	int status;
-	struct rusage usage;
-	struct timeval tv_stop, tv_wall;
-
-	int res2 = wait4(pid, &status, 0, &usage);
-	(void)res2;
-
-	gettimeofday(&tv_stop, NULL);
-	tv_wall.tv_sec = tv_stop.tv_sec - tv_start.tv_sec;
-	tv_wall.tv_sec -= (tv_stop.tv_usec < tv_start.tv_usec);
-	tv_wall.tv_usec = labs(tv_stop.tv_usec - tv_start.tv_usec);
-
-	assert(res2 != -1);
-	test_long("Process exited", (WIFEXITED(status) && WEXITSTATUS(status) && WEXITSTATUS(status) != 0xff) || WIFSIGNALED(status), 0);
-	printf("[PERF]\twall time: %ld.%06ld\n", tv_wall.tv_sec, tv_wall.tv_usec);
-	printf("[PERF]\tuser time: %ld.%06ld\n", usage.ru_utime.tv_sec, usage.ru_utime.tv_usec);
-	printf("[PERF]\tsystem time: %ld.%06ld\n", usage.ru_stime.tv_sec, usage.ru_stime.tv_usec);
-	printf("[PERF]\tmax resident set size: %ld\n", usage.ru_maxrss);
-	printf("[PERF]\tpage faults: %ld\n", usage.ru_majflt);
-	printf("[PERF]\tswaps: %ld\n", usage.ru_nswap);
-	printf("[PERF]\tvoluntary context switches: %ld\n", usage.ru_nvcsw);
-	printf("[PERF]\tinvoluntary context switches: %ld\n", usage.ru_nivcsw);
-	exit((WIFEXITED(status) && WEXITSTATUS(status)) || WIFSIGNALED(status));
-#elif defined(_WIN32)
-	if (WaitForSingleObject(pi.hProcess, INFINITE) != WAIT_OBJECT_0) {
-		print_winapi_error("WaitForSingleObject", GetLastError());
-		exit(EXIT_FAILURE);
-	}
-
-	struct timeval tv_stop, tv_wall;
-	gettimeofday(&tv_stop, NULL);
-	tv_wall.tv_sec = tv_stop.tv_sec - tv_start.tv_sec;
-	tv_wall.tv_sec -= (tv_stop.tv_usec < tv_start.tv_usec);
-	tv_wall.tv_usec = labs(tv_stop.tv_usec - tv_start.tv_usec);
-
-	DWORD status;
-	if (!GetExitCodeProcess(pi.hProcess, &status)) {
-		print_winapi_error("GetExitCodeProcess", GetLastError());
-		exit(EXIT_FAILURE);
-	}
-
-	FILETIME create_time, exit_time, kernel_time, user_time;
-	if (!GetProcessTimes(pi.hProcess, &create_time, &exit_time, &kernel_time, &user_time)) {
-		print_winapi_error("GetProcessTimes", GetLastError());
-		exit(EXIT_FAILURE);
-	}
-	struct timeval utime, stime;
-	filetime_to_timeval(&utime, &user_time);
-	filetime_to_timeval(&stime, &kernel_time);
-
-	PROCESS_MEMORY_COUNTERS counters;
-	if (!GetProcessMemoryInfo(pi.hProcess, &counters, sizeof(counters))) {
-		print_winapi_error("GetProcessMemoryInfo", GetLastError());
-		exit(EXIT_FAILURE);
-	}
-
-	test_long("Process exited", status == 0 || status == 0xff, 1);
-	printf("[PERF]\twall time: %ld.%06ld\n", tv_wall.tv_sec, tv_wall.tv_usec);
-	printf("[PERF]\tuser time: %ld.%06ld\n", utime.tv_sec, utime.tv_usec);
-	printf("[PERF]\tsystem time: %ld.%06ld\n", stime.tv_sec, stime.tv_usec);
-	printf("[PERF]\tmax working set size: %zu\n", counters.PeakWorkingSetSize);
-	printf("[PERF]\tpage faults: %lu\n", counters.PageFaultCount);
-	exit(status ? EXIT_FAILURE : EXIT_SUCCESS);
-#else
-	dispatch_queue_t main_q = dispatch_get_main_queue();
-
-	dispatch_source_t tmp_ds = dispatch_source_create(DISPATCH_SOURCE_TYPE_PROC, pid, DISPATCH_PROC_EXIT, main_q);
-	assert(tmp_ds);
-	dispatch_source_set_event_handler(tmp_ds, ^{
-		int status;
-		struct rusage usage;
-		struct timeval tv_stop, tv_wall;
-
-		gettimeofday(&tv_stop, NULL);
-		tv_wall.tv_sec = tv_stop.tv_sec - tv_start.tv_sec;
-		tv_wall.tv_sec -= (tv_stop.tv_usec < tv_start.tv_usec);
-		tv_wall.tv_usec = abs(tv_stop.tv_usec - tv_start.tv_usec);
-
-		int res2 = wait4(pid, &status, 0, &usage);
-		assert(res2 != -1);
-		test_long("Process exited", (WIFEXITED(status) && WEXITSTATUS(status) && WEXITSTATUS(status) != 0xff) || WIFSIGNALED(status), 0);
-		printf("[PERF]\twall time: %ld.%06d\n", tv_wall.tv_sec, tv_wall.tv_usec);
-		printf("[PERF]\tuser time: %ld.%06d\n", usage.ru_utime.tv_sec, usage.ru_utime.tv_usec);
-		printf("[PERF]\tsystem time: %ld.%06d\n", usage.ru_stime.tv_sec, usage.ru_stime.tv_usec);
-		printf("[PERF]\tmax resident set size: %ld\n", usage.ru_maxrss);
-		printf("[PERF]\tpage faults: %ld\n", usage.ru_majflt);
-		printf("[PERF]\tswaps: %ld\n", usage.ru_nswap);
-		printf("[PERF]\tvoluntary context switches: %ld\n", usage.ru_nvcsw);
-		printf("[PERF]\tinvoluntary context switches: %ld\n", usage.ru_nivcsw);
-		exit((WIFEXITED(status) && WEXITSTATUS(status)) || WIFSIGNALED(status));
-	});
-	dispatch_resume(tmp_ds);
-
-	uint64_t to = 0;
-	char *tos = getenv("BSDTEST_TIMEOUT");
-	if (tos) {
-		to = strtoul(tos, NULL, 0);
-		to *= NSEC_PER_SEC;
-	}
-
-	if (!to) {
-#if TARGET_OS_EMBEDDED
-		to = 180LL * NSEC_PER_SEC;
-#else
-		to = 90LL * NSEC_PER_SEC;
-#endif
-	}
-
-	dispatch_after(dispatch_time(DISPATCH_TIME_NOW, to), main_q, ^{
-		kill(pid, SIGKILL);
-		fprintf(stderr, "Terminating unresponsive process (%0.1lfs)\n", (double)to / NSEC_PER_SEC);
-	});
-
-	signal(SIGINT, SIG_IGN);
-	tmp_ds = dispatch_source_create(DISPATCH_SOURCE_TYPE_SIGNAL, SIGINT, 0, main_q);
-	assert(tmp_ds);
-	dispatch_source_set_event_handler(tmp_ds, ^{
-		fprintf(stderr, "Terminating process due to signal\n");
-		kill(pid, SIGKILL);
-	});
-	dispatch_resume(tmp_ds);
-
-	if (spawnflags & POSIX_SPAWN_SETEXEC) {
-		usleep(USEC_PER_SEC/10);
-	}
-	kill(pid, SIGCONT);
-
-	dispatch_main();
-#endif
-
-	return 0;
-}
--- a/Telegram/ThirdParty/dispatch/tests/bsdtests.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/bsdtests.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,536 +0,0 @@
-/*
- * Copyright (c) 2008-2011 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#if defined(__linux__) || defined(__FreeBSD__)
-// for asprintf
-#define _GNU_SOURCE 1
-#endif
-#include <stdarg.h>
-#include <stdio.h>
-#include <stdlib.h>
-#if defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))
-#include <unistd.h>
-#endif
-#include <errno.h>
-#include <string.h>
-#ifdef __APPLE__
-#include <crt_externs.h>
-#include <mach/mach_error.h>
-#include <spawn.h>
-#include <sys/wait.h>
-#endif
-#if defined(_WIN32)
-#include <generic_win_port.h>
-#endif
-#include <inttypes.h>
-#include "bsdtests.h"
-
-static int _test_exit_code;
-
-#define _test_print(_file, _line, _desc, \
-	_expr, _fmt1, _val1, _fmt2, _val2) do { \
-	const char* _exprstr; \
-	char _linestr[BUFSIZ]; \
-	_linestr[0] = 0; \
-	if (!(_expr)) { \
-		_exprstr = "FAIL"; \
-		_test_exit_code = 0xff; \
-		if (_file && _file[0] != '\0') { \
-			snprintf(_linestr, sizeof(_linestr), \
-					 " (%s:%ld)", _file, _line); \
-		} \
-	} else { \
-		_exprstr = "PASS"; \
-	} \
-	if (_fmt2 == 0) { \
-		fprintf(stdout, "\n"			\
-			"[BEGIN] %s\n"			\
-			"\tValue: " _fmt1 "\n"		\
-			"[%s] %s%s\n",			\
-			_desc,				\
-			_val1,				\
-			_exprstr,			\
-			_desc,				\
-			_linestr);			\
-	} else { \
-		fprintf(stdout, "\n"		   \
-			"[BEGIN] %s\n"		   \
-			"\tActual: " _fmt1 "\n"	   \
-			"\tExpected: " _fmt2 "\n"  \
-			"[%s] %s%s\n",		   \
-			_desc,			   \
-			_val1,			   \
-			_val2,			   \
-			_exprstr,		   \
-			_desc,			   \
-			_linestr);		   \
-	} \
-	if (!_expr && _file && _file[0] != '\0') { \
-		fprintf(stdout, "\t%s:%ld\n", _file, _line); \
-	} \
-	fflush(stdout); \
-} while (0);
-
-#define GENERATE_DESC	\
-	char desc[BUFSIZ];	\
-	va_list args;	\
-	\
-	va_start(args, format);	\
-	vsnprintf(desc, sizeof(desc), format, args);	\
-	va_end(args);
-
-void
-_test_ptr_null(const char* file, long line, const char* desc, const void* ptr)
-{
-	_test_print(file, line, desc,
-		(ptr == NULL), "%p", ptr, "%p", (void*)0);
-}
-
-void
-test_ptr_null_format(void *ptr, const char *format, ...)
-{
-	GENERATE_DESC
-	_test_ptr_null(NULL, 0, desc, ptr);
-}
-
-void
-_test_ptr_notnull(const char* file, long line, const char* desc, const void* ptr)
-{
-	_test_print(file, line, desc,
-		(ptr != NULL), "%p", ptr, "%p", ptr ?: (void*)~0);
-}
-
-void
-test_ptr_notnull_format(const void *ptr, const char *format, ...)
-{
-	GENERATE_DESC
-	_test_ptr_notnull(NULL, 0, desc, ptr);
-}
-
-void
-_test_ptr(const char* file, long line, const char* desc, const void* actual, const void* expected)
-{
-	_test_print(file, line, desc,
-		(actual == expected), "%p", actual, "%p", expected);
-}
-
-void
-test_ptr_format(const void* actual, const void* expected, const char* format, ...)
-{
-	GENERATE_DESC
-	_test_ptr(NULL, 0, desc, actual, expected);
-}
-
-void _test_ptr_not(const char* file, long line, const char* desc, const void* actual, const void* expected)
-{
-	_test_print(file, line, desc,
-				(actual != expected), "%p", actual, "!%p", expected);
-}
-
-void test_ptr_not_format(const void *actual, const void* expected, const char *format, ...)
-{
-	GENERATE_DESC
-	_test_ptr_not(NULL, 0, desc, actual, expected);
-}
-
-void
-_test_uint32(const char* file, long line, const char* desc, uint32_t actual, uint32_t expected)
-{
-	_test_print(file, line, desc,
-		(actual == expected), "%u", actual, "%u", expected);
-}
-
-void
-test_uint32_format(uint32_t actual, uint32_t expected, const char *format, ...)
-{
-	GENERATE_DESC
-	_test_uint32(NULL, 0, desc, actual, expected);
-}
-
-void
-_test_int32(const char* file, long line, const char* desc, int32_t actual, int32_t expected)
-{
-	_test_print(file, line, desc,
-		(actual == expected), "%d", actual, "%d", expected);
-}
-
-void
-test_int32_format(int32_t actual, int32_t expected, const char* format, ...)
-{
-	GENERATE_DESC
-	_test_int32(NULL, 0, desc, actual, expected);
-}
-
-void
-_test_long(const char* file, long line, const char* desc, long actual, long expected)
-{
-	_test_print(file, line, desc,
-		(actual == expected), "%ld", actual, "%ld", expected);
-}
-
-void
-test_long_format(long actual, long expected, const char* format, ...)
-{
-	GENERATE_DESC
-	_test_long(NULL, 0, desc, actual, expected);
-}
-
-void
-_test_sizet(const char* file, long line, const char* desc, size_t actual, size_t expected)
-{
-	_test_print(file, line, desc,
-		(actual == expected), "%zd", actual, "%zd", expected);
-}
-
-void
-test_sizet_format(size_t actual, size_t expected, const char* format, ...)
-{
-	GENERATE_DESC
-	_test_sizet(NULL, 0, desc, actual, expected);
-}
-
-void
-_test_uint64(const char* file, long line, const char* desc, uint64_t actual, uint64_t expected)
-{
-	_test_print(file, line, desc,
-							(actual == expected), "%" PRIu64, actual, "%" PRIu64, expected);
-}
-
-void
-test_uint64_format(uint64_t actual, uint64_t expected, const char* format, ...)
-{
-	GENERATE_DESC
-	_test_uint64(NULL, 0, desc, actual, expected);
-}
-
-void
-_test_int64(const char* file, long line, const char* desc, int64_t actual, int64_t expected)
-{
-	_test_print(file, line, desc,
-							(actual == expected), "%" PRId64, actual, "%" PRId64, expected);
-}
-
-void
-test_int64_format(int64_t actual, int64_t expected, const char* format, ...)
-{
-	GENERATE_DESC
-	_test_int64(NULL, 0, desc, actual, expected);
-}
-
-void
-_test_long_less_than(const char* file, long line, const char* desc, long actual, long expected_max)
-{
-	_test_print(file, line, desc, (actual < expected_max), "%ld", actual, "<%ld", expected_max);
-}
-
-void
-test_long_less_than_format(long actual, long expected_max, const char* format, ...)
-{
-	GENERATE_DESC
-	_test_long_less_than(NULL, 0, desc, actual, expected_max);
-}
-
-void
-_test_long_less_than_or_equal(const char* file, long line, const char* desc, long actual, long expected_max)
-{
-	_test_print(file, line, desc, (actual <= expected_max), "%ld", actual, "<=%ld", expected_max);
-}
-
-void
-test_long_less_than_or_equal_format(long actual, long expected_max, const char* format, ...)
-{
-	GENERATE_DESC
-	_test_long_less_than_or_equal(NULL, 0, desc, actual, expected_max);
-}
-
-void
-_test_long_greater_than_or_equal(const char* file, long line, const char* desc, long actual, long expected_min)
-{
-	_test_print(file, line, desc, (actual >= expected_min), "%ld", actual, ">=%ld", expected_min);
-}
-
-void
-test_long_greater_than_or_equal_format(long actual, long expected_max, const char* format, ...)
-{
-	GENERATE_DESC
-	_test_long_greater_than_or_equal(NULL, 0, desc, actual, expected_max);
-}
-
-void
-_test_sizet_less_than(const char* file, long line, const char* desc, size_t actual, size_t expected_max)
-{
-	_test_print(file, line, desc, (actual < expected_max), "%zd", actual, "<%zd", expected_max);
-}
-
-void
-test_sizet_less_than_format(size_t actual, size_t expected_max, const char* format, ...)
-{
-	GENERATE_DESC
-	_test_sizet_less_than(NULL, 0, desc, actual, expected_max);
-}
-
-void
-_test_sizet_less_than_or_equal(const char* file, long line, const char* desc, size_t actual, size_t expected_max)
-{
-	_test_print(file, line, desc, (actual <= expected_max), "%zd", actual, "<=%zd", expected_max);
-}
-
-void
-test_sizet_less_than_or_equal_format(size_t actual, size_t expected_max, const char* format, ...)
-{
-	GENERATE_DESC
-	_test_sizet_less_than_or_equal(NULL, 0, desc, actual, expected_max);
-}
-
-void
-_test_double_less_than(const char* file, long line, const char* desc, double val, double max_expected)
-{
-	_test_print(file, line, desc, (val < max_expected), "%f", val, "<%f", max_expected);
-}
-
-void
-test_double_less_than_format(double val, double max_expected, const char* format, ...)
-{
-	GENERATE_DESC
-	_test_double_less_than(NULL, 0, desc, val, max_expected);
-}
-
-void
-_test_double_less_than_or_equal(const char* file, long line, const char* desc, double val, double max_expected)
-{
-	_test_print(file, line, desc, (val <= max_expected), "%f", val, "<=%f", max_expected);
-}
-
-void
-test_double_less_than_or_equal_format(double val, double max_expected, const char *format, ...)
-{
-	GENERATE_DESC
-	_test_double_less_than_or_equal(NULL, 0, desc, val, max_expected);
-}
-
-void
-_test_double_equal(const char* file, long line, const char* desc, double val, double expected)
-{
-	#pragma clang diagnostic push
-	#pragma clang diagnostic ignored "-Wfloat-equal"
-	_test_print(file, line, desc, (val == expected), "%f", val, "%f", expected);
-	#pragma clang diagnostic pop
-}
-
-
-void
-test_double_equal_format(double val, double expected, const char *format, ...)
-{
-	GENERATE_DESC
-	_test_double_equal(NULL, 0, desc, val, expected);
-}
-
-void
-_test_errno(const char* file, long line, const char* desc, int actual, int expected)
-{
-	char* actual_str;
-	char* expected_str;
-	(void)asprintf(&actual_str, "%d\t%s", actual, actual ? strerror(actual) : "");
-	(void)asprintf(&expected_str, "%d\t%s", expected, expected ? strerror(expected) : "");
-	_test_print(file, line, desc,
-		(actual == expected), "%s", actual_str, "%s", expected_str);
-	free(actual_str);
-	free(expected_str);
-}
-
-void
-test_errno_format(int actual, int expected, const char *format, ...)
-{
-	GENERATE_DESC
-	_test_errno(NULL, 0, desc, actual, expected);
-}
-
-#ifdef __APPLE__
-void
-_test_mach_error(const char* file, long line, const char* desc,
-		mach_error_t actual, mach_error_t expected)
-{
-	char* actual_str;
-	char* expected_str;
-	(void)asprintf(&actual_str, "%d %s", actual, actual ? mach_error_string(actual) : "");
-	(void)asprintf(&expected_str, "%d %s", expected, expected ? mach_error_string(expected) : "");
-	_test_print(file, line, desc,
-		(actual == expected), "%s", actual_str, "%s", expected_str);
-	free(actual_str);
-	free(expected_str);
-}
-
-void
-test_mach_error_format(mach_error_t actual, mach_error_t expected, const char *format, ...)
-{
-	GENERATE_DESC
-	_test_mach_error(NULL, 0, desc, actual, expected);
-}
-#endif
-
-void
-_test_skip(const char* file, long line, const char* desc)
-{
-	if (file != NULL && file[0] != '\0') {
-		fprintf(stdout, "[SKIP] %s (%s:%ld)\n", desc, file, line);
-	} else {
-		fprintf(stdout, "[SKIP] %s\n", desc);
-	}
-	fflush(stdout);
-}
-
-void
-test_skip_format(const char *format, ...)
-{
-	GENERATE_DESC
-	fprintf(stdout, "[SKIP] %s\n", desc);
-}
-
-#if USE_COREFOUNDATION
-void
-test_cferror(const char *desc, CFErrorRef actual, CFIndex expectedCode)
-{
-	if (actual != NULL) {
-		CFStringRef errDesc = CFErrorCopyDescription(actual);
-		CFIndex code = CFErrorGetCode(actual);
-		char* actual_str;
-		char* expected_str;
-
-		if (code != expectedCode) {
-			char buffer[BUFSIZ];
-			CFStringGetCString(errDesc, buffer, sizeof(buffer), kCFStringEncodingUTF8);
-			(void)asprintf(&actual_str, "%ld\t%s", code, buffer);
-		} else {
-			(void)asprintf(&actual_str, "%ld", code);
-		}
-
-		(void)asprintf(&expected_str, "%ld", expectedCode);
-		_test_print("", (long) 0, desc,
-					(code == expectedCode), "%s", actual_str, "%s", expected_str);
-
-		free(actual_str);
-		free(expected_str);
-
-		CFRelease(errDesc);
-	} else {
-		_test_print("", (long) 0, desc, (0 == expectedCode), "%ld", (long) 0, "%ld", (long) expectedCode);
-	}
-}
-
-void
-test_cferror_format(CFErrorRef actual, CFIndex expectedCode, const char *format, ...)
-{
-	GENERATE_DESC
-	test_cferror(desc, actual, expectedCode);
-}
-#endif
-
-void
-test_start(const char* desc)
-{
-	if (desc) {
-		fprintf(stdout, "\n==================================================\n");
-		fprintf(stdout, "[TEST] %s\n", desc);
-		fprintf(stdout, "[PID] %d\n", getpid());
-		fprintf(stdout, "==================================================\n\n");
-		fflush(stdout);
-	}
-	_test_exit_code = EXIT_SUCCESS;
-	usleep(100000);	// give 'gdb --waitfor=' a chance to find this proc
-}
-
-#if defined(__APPLE__) && defined(__MACH__)
-static char** get_environment(void)
-{
-	return (* _NSGetEnviron());
-}
-
-void
-test_leaks_pid(const char *name, pid_t pid)
-{
-	int res;
-	char pidstr[10];
-
-	if (getenv("NOLEAKS")) {
-		return;
-	}
-
-	if (!name) {
-		name = "Leaks";
-	}
-
-	/* leaks doesn't work against debug variant malloc */
-	const char *dyld_image_suffix = getenv("DYLD_IMAGE_SUFFIX");
-	if (dyld_image_suffix && strstr(dyld_image_suffix, "_debug")) {
-		return;
-	}
-
-	char *inserted_libs = getenv("DYLD_INSERT_LIBRARIES");
-	if (inserted_libs && strstr(inserted_libs, "/usr/lib/libgmalloc.dylib")) {
-		return;
-	}
-
-	unsetenv("DYLD_IMAGE_SUFFIX");
-	unsetenv("DYLD_INSERT_LIBRARIES");
-	unsetenv("DYLD_LIBRARY_PATH");
-
-	unsetenv("MallocStackLogging");
-	unsetenv("MallocStackLoggingNoCompact");
-
-	snprintf(pidstr, sizeof(pidstr), "%d", pid);
-
-	char* args[] = { "./leaks-wrapper", pidstr, NULL };
-	res = posix_spawnp(&pid, args[0], NULL, NULL, args, get_environment());
-	if (res == 0 && pid > 0) {
-		int status;
-		waitpid(pid, &status, 0);
-		test_long(name, status, 0);
-	} else {
-		perror(args[0]);
-	}
-}
-
-void
-test_leaks(const char *name)
-{
-	test_leaks_pid(name, getpid());
-}
-#endif
-
-void
-test_stop_after_delay(void *delay)
-{
-	if (delay != NULL) {
-		sleep((unsigned int)(intptr_t)delay);
-	}
-
-#if defined(__APPLE__) && defined(__MACH__)
-	test_leaks(NULL);
-#endif
-
-	fflush(stdout);
-	_exit(_test_exit_code);
-}
-
-void
-test_stop(void)
-{
-	test_stop_after_delay((void *)(intptr_t)0);
-}
--- a/Telegram/ThirdParty/dispatch/tests/bsdtests.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/bsdtests.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,190 +0,0 @@
-/*
- * Copyright (c) 2008-2011 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#ifndef __BSD_TEST_H__
-#define __BSD_TEST_H__
-
-#if defined(HAVE_CONFIG_H)
-#if __has_include(<config/config_ac.h>)
-#include <config/config_ac.h>
-#else
-#include <config/config.h>
-#endif
-#endif
-
-
-#if !HAVE_PRINTFLIKE
-#ifndef __printflike
-#if __has_attribute(format)
-#define __printflike(a,b) __attribute__((format(printf, a, b)))
-#else
-#define __printflike(a,b)
-#endif // __has_attribute(format)
-#endif // !defined(__printflike)
-#endif // !HAVE_PRINTFLIKE
-
-
-#include <errno.h>
-#ifdef __APPLE__
-#include <mach/error.h>
-#endif
-#if defined(__APPLE__) || defined(HAVE_COREFOUNDATION)
-#include <CoreFoundation/CoreFoundation.h>
-#endif
-
-#if defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))
-#include <unistd.h>
-#endif
-#include <string.h>
-#include <stdint.h>
-
-static inline const char*
-__BASENAME__(const char *_str_)
-{
-	const char *_s_ = strrchr(_str_, '/');
-	return (_s_ ? _s_ : _str_ - 1) + 1;
-}
-#define __SOURCE_FILE__	__BASENAME__(__FILE__)
-
-#if defined(__cplusplus)
-extern "C" {
-#endif
-
-/**
- * test_start() provides the TEST token. Use this once per test "tool"
- */
-void test_start(const char* desc);
-
-#if defined(__APPLE__) && defined(__MACH__)
-/**
- * Explicitly runs the 'leaks' test without stopping the process.
- */
-void test_leaks_pid(const char *name, pid_t pid);
-void test_leaks(const char *name);
-#endif
-
-/**
- * test_stop() checks for leaks during the tests using leaks-wrapper. Use this at the end of each "tool"
- */
-void test_stop(void) __attribute__((__noreturn__));
-void test_stop_after_delay(void *delay) __attribute__((__noreturn__));
-
-/**
- * Each test "tool" can used one or more of these functions to perform actual
- * testing and provide a PASS/FAIL token. All APIs take a descriptive string
- * that is printed after the token.
- */
-void _test_ptr_null(const char* file, long line, const char* desc, const void* ptr);
-#define test_ptr_null(a,b) _test_ptr_null(__SOURCE_FILE__, __LINE__, a, b)
-void test_ptr_null_format(void *ptr, const char *format, ...);
-
-void _test_ptr_notnull(const char* file, long line, const char* desc, const void* ptr);
-#define test_ptr_notnull(a,b) _test_ptr_notnull(__SOURCE_FILE__, __LINE__, a, b)
-void test_ptr_notnull_format(const void *ptr, const char *format, ...) __printflike(2, 3);
-
-void _test_ptr_not(const char* file, long line, const char* desc, const void* actual, const void* expected);
-#define test_ptr_not(a, b, c) _test_ptr_not(__SOURCE_FILE__, __LINE__, a, b, c)
-void test_ptr_not_format(const void* actual, const void* expected, const char *format, ...);
-
-void _test_ptr(const char* file, long line, const char* desc, const void* actual, const void* expected);
-#define test_ptr(a,b,c) _test_ptr(__SOURCE_FILE__, __LINE__, a, b, c)
-void test_ptr_format(const void* actual, const void* expected, const char *format, ...) __printflike(3,4);
-
-void _test_uint32(const char* file, long line, const char* desc, uint32_t actual, uint32_t expected);
-#define test_uint32(a,b,c) _test_uint32(__SOURCE_FILE__, __LINE__, a, b, c)
-void test_uint32_format(uint32_t actual, uint32_t expected, const char *format, ...) __printflike(3,4);
-
-void _test_int32(const char* file, long line, const char* desc, int32_t actual, int32_t expected);
-#define test_int32(a,b,c) _test_int32(__SOURCE_FILE__, __LINE__, a, b, c)
-void test_int32_format(int32_t actual, int32_t expected, const char* format, ...) __printflike(3,4);
-
-void _test_long(const char* file, long line, const char* desc, long actual, long expected);
-#define test_long(a,b,c) _test_long(__SOURCE_FILE__, __LINE__, a, b, c)
-void test_long_format(long actual, long expected, const char *format, ...) __printflike(3,4);
-
-void _test_sizet(const char* file, long line, const char* desc, size_t actual, size_t expected);
-#define test_sizet(a,b,c) _test_sizet(__SOURCE_FILE__, __LINE__, a, b, c)
-void test_sizet_format(size_t actual, size_t expected, const char *format, ...) __printflike(3,4);
-
-void _test_uint64(const char* file, long line, const char* desc, uint64_t actual, uint64_t expected);
-#define test_uint64(a,b,c) _test_uint64(__SOURCE_FILE__, __LINE__, a, b, c)
-void test_uint64_format(uint64_t actual, uint64_t expected, const char* desc, ...);
-
-void _test_int64(const char* file, long line, const char* desc, int64_t actual, int64_t expected);
-#define test_int64(a,b,c) _test_uint64(__SOURCE_FILE__, __LINE__, a, b, c)
-void test_int64_format(int64_t actual, int64_t expected, const char* desc, ...);
-
-void _test_long_less_than(const char* file, long line, const char* desc, long actual, long max_expected);
-#define test_long_less_than(a,b,c) _test_long_less_than(__SOURCE_FILE__, __LINE__, a, b, c)
-void test_long_less_than_format(long actual, long max_expected, const char *format, ...) __printflike(3,4);
-
-void _test_long_less_than_or_equal(const char* file, long line, const char* desc, long actual, long max_expected);
-#define test_long_less_than_or_equal(a,b,c) _test_long_less_than_or_equal(__SOURCE_FILE__, __LINE__, a, b, c)
-void test_long_less_than_or_equal_format(long actual, long max_expected, const char *format, ...) __printflike(3,4);
-
-void _test_long_greater_than_or_equal(const char* file, long line, const char* desc, long actual, long expected_min);
-#define test_long_greater_than_or_equal(a,b,c) _test_long_greater_than_or_equal(__SOURCE_FILE__, __LINE__, a, b, c)
-void test_long_greater_than_or_equal_format(long actual, long expected_min, const char *format, ...) __printflike(3,4);
-
-void _test_sizet_less_than(const char* file, long line, const char* desc, size_t actual, size_t max_expected);
-#define test_sizet_less_than(a,b,c) _test_sizet_less_than(__SOURCE_FILE__, __LINE__, a, b, c)
-void test_sizet_less_than_format(size_t actual, size_t max_expected, const char *format, ...) __printflike(3,4);
-
-void _test_sizet_less_than_or_equal(const char* file, long line, const char* desc, size_t actual, size_t max_expected);
-#define test_sizet_less_than_or_equal(a,b,c) _test_sizet_less_than_or_equal(__SOURCE_FILE__, __LINE__, a, b, c)
-void test_sizet_less_than_or_equal_format(size_t actual, size_t max_expected, const char *format, ...) __printflike(3,4);
-
-void _test_double_less_than_or_equal(const char* file, long line, const char* desc, double val, double max_expected);
-#define test_double_less_than_or_equal(d, v, m) _test_double_less_than_or_equal(__SOURCE_FILE__, __LINE__, d, v, m)
-void test_double_less_than_or_equal_format(double val, double max_expected, const char *format, ...) __printflike(3,4);
-
-void _test_double_less_than(const char* file, long line, const char* desc, double val, double max_expected);
-#define test_double_less_than(d, v, m) _test_double_less_than(__SOURCE_FILE__, __LINE__, d, v, m)
-void test_double_less_than_format(double val, double max_expected, const char *format, ...) __printflike(3,4);
-
-void _test_double_equal(const char* file, long line, const char* desc, double val, double expected);
-#define test_double_equal(d, v, m) _test_double_equal(__SOURCE_FILE__, __LINE__, d, v, m)
-void test_double_equal_format(double val, double expected, const char *format, ...) __printflike(3,4);
-
-void _test_errno(const char* file, long line, const char* desc, int actual, int expected);
-#define test_errno(a,b,c) _test_errno(__SOURCE_FILE__, __LINE__, a, b, c)
-void test_errno_format(int actual, int expected, const char *format, ...) __printflike(3,4);
-
-#if defined(__APPLE__)
-void _test_mach_error(const char* file, long line, const char* desc, mach_error_t actual, mach_error_t expected);
-#define test_mach_error(a,b,c) _test_mach_error(__SOURCE_FILE__, __LINE__, a, b, c)
-void test_mach_error_format(mach_error_t actual, mach_error_t expected, const char *format, ...) __printflike(3,4);
-#endif
-
-#if defined(__APPLE__) || defined(HAVE_COREFOUNDATION)
-void test_cferror(const char* desc, CFErrorRef actual, CFIndex expectedCode);
-void test_cferror_format(CFErrorRef actual, CFIndex expectedCode, const char *format, ...) __printflike(3,4);
-#endif
-
-void _test_skip(const char* file, long line, const char* desc);
-#define test_skip(m) _test_skip(__SOURCE_FILE__, __LINE__, m)
-#define test_skip2(m) _test_skip("", 0, m)
-void test_skip_format(const char *format, ...) __printflike(1,2);
-
-#if defined(__cplusplus)
-} /* extern "C" */
-#endif
-
-#endif /* __BSD_TEST_H__ */
--- a/Telegram/ThirdParty/dispatch/tests/bsdtestsummarize.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/bsdtestsummarize.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,122 +0,0 @@
-/*
- * Copyright (c) 2008-2011 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include <math.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <sys/param.h>
-
-int
-has_prefix(const char* str, const char* prefix)
-{
-	return (strncmp(str, prefix, strlen(prefix)) == 0);
-}
-
-int
-print_summary(FILE* f, long total, long pass, long fail, long skip)
-{
-	double dpass = 100.0 ,dfail = 0.0, dskip = 0.0;
-	fprintf(f, "Total:  %ld\n", total);
-	if (total) {
-		dpass = ((double)pass / (double)(total - skip)) * 10000.0;
-		dpass = floor(dpass) / 100.0;
-
-		dfail = ((double)fail / (double)(total - skip)) * 10000.0;
-		dfail = ceil(dfail) / 100.0;
-
-		dskip = ((double)skip / (double)total) * 10000.0;
-		dskip = ceil(dskip) / 100.0;
-	}
-	fprintf(f, "Passed: %ld (%0.2lf%%)\nFailed: %ld (%0.2lf%%)\nSkipped: %ld (%0.2lf%%)\n\n", pass, dpass, fail, dfail, skip, dskip);
-	return 0;
-}
-
-int
-main(int argc, char* argv[])
-{
-	if (argc > 1) {
-		fprintf(stderr, "%s: usage: summarize\n", argv[0]);
-		exit(1);
-	}
-
-	/*
-	FILE* f = fopen(argv[1], "w");
-	if (f == NULL) {
-		perror(argv[1]);
-		exit(1);
-	}
-	*/
-	FILE* f = stdout;
-
-	fprintf(f, "\n==================================================\n");
-	fprintf(f, "[SUMMARY] Test Summary\n");
-	fprintf(f, "==================================================\n\n");
-
-	size_t len;
-	char* ln, lastln[1024];
-	int  first_test = 1;
-	long total = 0;
-	long pass = 0;
-	long fail = 0;
-	long skip = 0;
-	long total_total = 0;
-	long total_pass = 0;
-	long total_fail = 0;
-	long total_skip = 0;
-	for(;;) {
-		ln = fgetln(stdin, &len);
-		//if (ln) fprintf(stdout, "%.*s", (int)len, ln);
-		if (ln == NULL || (has_prefix(ln, "[TEST]") &&
-				strncmp(ln, lastln, MIN(len,1024)))) {
-			if (total || !first_test) {
-				print_summary(f, total, pass, fail, skip);
-				first_test = 0;
-			}
-			total_total += total;
-			total_pass += pass;
-			total_fail += fail;
-			total_skip += skip;
-			total = 0;
-			pass = 0;
-			fail = 0;
-			skip = 0;
-			if (ln) {
-				fprintf(f, "%.*s", (int)len, ln);
-				strncpy(lastln, ln, MIN(len,1024));
-			} else {
-				fprintf(f, "[TOTAL]\n");
-				print_summary(f, total_total, total_pass, total_fail, total_skip);
-				break;
-			}
-		} else if (has_prefix(ln, "[PASS]")) {
-			++total;
-			++pass;
-		} else if (has_prefix(ln, "[FAIL]")) {
-			++total;
-			++fail;
-		} else if (has_prefix(ln, "[SKIP]")) {
-			++total;
-			++skip;
-		}
-	}
-
-	return (total_fail ? EXIT_FAILURE : EXIT_SUCCESS);
-}
--- a/Telegram/ThirdParty/dispatch/tests/cffd.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/cffd.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,175 +0,0 @@
-/*
- * Copyright (c) 2008-2011 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include <dispatch/dispatch.h>
-
-#include <stdio.h>
-#include <stdlib.h>
-#if defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))
-#include <unistd.h>
-#endif
-#include <string.h>
-#include <sys/param.h>
-#include <sys/ucred.h>
-#include <sys/mount.h>
-#include <sys/queue.h>
-#include <sys/errno.h>
-#include <sys/types.h>
-#include <sys/event.h>
-#include <sys/time.h>
-
-#include <CoreFoundation/CoreFoundation.h>
-
-#include <bsdtests.h>
-#include "dispatch_test.h"
-
-static int long kevent_data = 0;
-
-#if 0
-int debug = 0;
-
-#define DEBUG(...) do { \
-		if (debug) fprintf(stderr, __VA_ARGS__); \
-	} while(0);
-#endif
-
-#define assert_errno(str, expr) do { \
-	if (!(expr)) { \
-		fprintf(stderr, "%s: %s\n", (str), strerror(errno)); \
-		exit(1); \
-	} } while(0);
-
-int
-init_kqueue(void)
-{
-	int kq;
-	int res;
-	struct kevent ke;
-	static struct timespec t0;
-
-	kq = kqueue();
-	assert_errno("kqueue", kq >= 0);
-
-	EV_SET(&ke, 1, EVFILT_TIMER, EV_ADD, NOTE_USECONDS, USEC_PER_SEC/10, 0);
-
-	res = kevent(kq, &ke, 1, NULL, 0, &t0);
-	assert_errno("kevent", res == 0);
-
-	return kq;
-}
-
-int
-read_kevent(int kq)
-{
-	int res;
-	struct kevent ke;
-	//static struct timespec t0;
-
-	res = kevent(kq, NULL, 0, &ke, 1, NULL);
-	assert_errno("kevent", res >= 0);
-
-	kevent_data += ke.data;
-	fprintf(stdout, "kevent.data = %ld\n", ke.data);
-
-	return (res < 0);
-}
-
-
-static void
-cffd_callback(CFFileDescriptorRef cffd,
-	CFOptionFlags callBackTypes __attribute__((unused)),
-	void *info __attribute__((unused)))
-{
-	int kq;
-
-	kq = CFFileDescriptorGetNativeDescriptor(cffd);
-	if (read_kevent(kq) == 0) {
-		// ...
-	}
-
-	CFFileDescriptorEnableCallBacks(cffd, kCFFileDescriptorReadCallBack);
-}
-
-#if 0
-void
-timer()
-{
-	dispatch_source_t ds;
-	ds = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());
-	assert(ds);
-	dispatch_source_set_timer(ds, dispatch_time(0, 1*NSEC_PER_SEC), NSEC_PER_SEC, 0);
-	dispatch_source_set_event_handler(ds, ^{
-		printf("ping\n");
-	});
-	dispatch_resume(ds);
-}
-
-void
-hangup()
-{
-	dispatch_source_t ds;
-	ds = dispatch_source_create(DISPATCH_SOURCE_TYPE_SIGNAL, SIGHUP, 0, dispatch_get_main_queue());
-	assert(ds);
-	dispatch_source_set_event_handler(ds, ^{
-		printf("hangup\n");
-	});
-	dispatch_resume(ds);
-}
-#endif
-
-int
-main(int argc __attribute__((unused)), char *argv[] __attribute__((unused)))
-{
-	int kq;
-	CFFileDescriptorRef cffd;
-	CFRunLoopSourceRef  rls;
-	CFFileDescriptorContext ctx;
-
-	dispatch_test_start("CFFileDescriptor");
-
-#if 0
-	signal(SIGHUP, SIG_IGN);
-#endif
-
-	kq = init_kqueue();
-
-	memset(&ctx, 0, sizeof(CFFileDescriptorContext));
-	cffd = CFFileDescriptorCreate(NULL, kq, 1, cffd_callback, &ctx);
-	assert(cffd);
-
-	rls = CFFileDescriptorCreateRunLoopSource(NULL, cffd, 0);
-	assert(rls);
-	CFRunLoopAddSource(CFRunLoopGetCurrent(), rls, kCFRunLoopDefaultMode);
-	CFFileDescriptorEnableCallBacks(cffd, kCFFileDescriptorReadCallBack);
-
-#if 0
-	timer();
-	hangup();
-#endif
-
-	CFRunLoopRunInMode(kCFRunLoopDefaultMode, 1.05, false);
-	// Should fire at least 10 times ...
-	test_long_greater_than_or_equal("kevent data", kevent_data, 10);
-
-	test_stop();
-
-	return 0;
-}
-
--- a/Telegram/ThirdParty/dispatch/tests/CMakeLists.txt	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/CMakeLists.txt	1970-01-01 00:00:00.000000000 -0000
@@ -1,199 +0,0 @@
-
-if(CMAKE_SYSTEM_NAME STREQUAL Windows)
-    execute_process(COMMAND
-                      "${CMAKE_COMMAND}" -E copy_directory "${PROJECT_SOURCE_DIR}/private"
-                      "${CMAKE_CURRENT_BINARY_DIR}/dispatch")
-    execute_process(COMMAND
-                      "${CMAKE_COMMAND}" -E copy "${CMAKE_CURRENT_SOURCE_DIR}/leaks-wrapper.sh"
-                      "${CMAKE_CURRENT_BINARY_DIR}/leaks-wrapper")
-else()
-    execute_process(COMMAND
-                      "${CMAKE_COMMAND}" -E create_symlink "${PROJECT_SOURCE_DIR}/private"
-                      "${CMAKE_CURRENT_BINARY_DIR}/dispatch")
-    execute_process(COMMAND
-                      "${CMAKE_COMMAND}" -E create_symlink "${CMAKE_CURRENT_SOURCE_DIR}/leaks-wrapper.sh"
-                      "${CMAKE_CURRENT_BINARY_DIR}/leaks-wrapper")
-endif()
-
-if(CMAKE_SYSTEM_NAME STREQUAL Linux)
-    set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -lrt")
-endif()
-
-add_library(bsdtests
-            STATIC
-              bsdtests.c
-              dispatch_test.c)
-target_include_directories(bsdtests
-                           PRIVATE
-                             ${CMAKE_CURRENT_BINARY_DIR}
-                             ${CMAKE_CURRENT_SOURCE_DIR}
-                             ${PROJECT_SOURCE_DIR}
-                           PUBLIC
-                             # bsdtests.h needs config_ac.h
-                             ${PROJECT_BINARY_DIR})
-if (WIN32)
-  target_sources(bsdtests
-                 PRIVATE
-                   generic_win_port.c)
-  target_compile_definitions(bsdtests
-                             PUBLIC
-                               _CRT_NONSTDC_NO_WARNINGS
-                               _CRT_SECURE_NO_WARNINGS
-                               _USE_MATH_DEFINES)
-  target_link_libraries(bsdtests
-                        PUBLIC
-                          bcrypt)
-endif ()
-
-add_executable(bsdtestharness
-               bsdtestharness.c)
-target_include_directories(bsdtestharness
-                           PRIVATE
-                             ${CMAKE_CURRENT_BINARY_DIR}
-                             ${CMAKE_CURRENT_SOURCE_DIR}
-                             ${PROJECT_SOURCE_DIR})
-target_link_libraries(bsdtestharness
-                      PRIVATE
-                        bsdtests
-                        dispatch)
-
-function(add_unit_test name)
-  set(options DISABLED_TEST)
-  set(single_value_args)
-  set(multiple_value_args SOURCES)
-  cmake_parse_arguments(AUT "${options}" "${single_value_args}" "${multiple_value_args}" ${ARGN})
-
-  if(AUT_DISABLED_TEST)
-    return()
-  endif()
-
-  add_executable(${name} ${AUT_SOURCES})
-  target_include_directories(${name}
-                             PRIVATE
-                               ${CMAKE_CURRENT_BINARY_DIR}
-                               ${CMAKE_CURRENT_SOURCE_DIR}
-                               ${PROJECT_SOURCE_DIR})
-  if(ENABLE_SWIFT)
-    # For testing in swift.org CI system; make deadlines lenient by default
-    # to reduce probability of test failures due to machine load.
-    target_compile_options(${name} PRIVATE -DLENIENT_DEADLINES=1)
-  endif()
-  target_include_directories(${name}
-                             SYSTEM BEFORE PRIVATE
-                               "${BlocksRuntime_INCLUDE_DIR}")
-  if("${CMAKE_C_SIMULATE_ID}" STREQUAL "MSVC")
-    target_compile_options(${name} PRIVATE -Xclang -fblocks)
-    target_compile_options(${name} PRIVATE /W3 -Wno-deprecated-declarations)
-  else()
-    target_compile_options(${name} PRIVATE -fblocks)
-    target_compile_options(${name} PRIVATE -Wall -Wno-deprecated-declarations)
-  endif()
-  # Without this flag, cross-compiling static test executables for Android armv7
-  # fails with the multiple definition errors seen in android/ndk#176, so I
-  # pulled in this workaround noted there. The tests build and run with this
-  # flag applied.
-  if(NOT BUILD_SHARED_LIBS AND CMAKE_SYSTEM_NAME STREQUAL Android AND
-     CMAKE_SYSTEM_PROCESSOR STREQUAL armv7-a)
-    target_link_options(${name} PRIVATE "LINKER:--allow-multiple-definition")
-  endif()
-  target_link_libraries(${name}
-                        PRIVATE
-                          dispatch
-                          Threads::Threads
-                          BlocksRuntime::BlocksRuntime)
-  target_link_libraries(${name} PRIVATE bsdtests)
-  add_test(NAME ${name}
-           COMMAND bsdtestharness $<TARGET_FILE:${name}>)
-  set_tests_properties(${name}
-                       PROPERTIES
-                         TIMEOUT 120
-                         DEPENDS bsdtestharness
-                         WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR})
-  if(NOT leaks_EXECUTABLE)
-    set_tests_properties(${name}
-                         PROPERTIES
-                           ENVIRONMENT NOLEAKS=1)
-  endif()
-endfunction()
-
-# Tests that reliably pass on all platforms
-set(DISPATCH_C_TESTS
-    apply
-    api
-    debug
-    queue_finalizer
-    overcommit
-    context_for_key
-    after
-    timer
-    timer_short
-    timer_timeout
-    sema
-    timer_bit31
-    timer_bit63
-    timer_set_time
-    data
-    io_muxed
-    io_net
-    io_pipe
-    io_pipe_close
-    select)
-
-# Tests that usually pass, but occasionally fail.
-# Excluded by default for purposes of Swift CI
-if(EXTENDED_TEST_SUITE)
-  # When dispatch_group is reenabled here, also remove the if(EXTENDED_TEST_SUITE) condition below
-  list(APPEND DISPATCH_C_TESTS
-       priority
-       concur
-       group
-       read
-       read2
-       starfish
-       suspend_timer
-       pingpong
-       drift
-       readsync
-       cascade
-       io)
-  # an oddball; dispatch_priority.c compiled with -DUSE_SET_TARGET_QUEUE=1
-  add_unit_test(dispatch_priority2 SOURCES dispatch_priority.c)
-  target_compile_options(dispatch_priority2 PRIVATE -DUSE_SET_TARGET_QUEUE=1)
-endif()
-
-# add C tests for platform-specific functionality when applicable
-if(CMAKE_SYSTEM_NAME STREQUAL Darwin)
-  list(APPEND DISPATCH_C_TESTS
-       deadname
-       proc
-       vm
-       vnode)
-endif()
-
-foreach(test ${DISPATCH_C_TESTS})
-  add_unit_test(dispatch_${test}
-                SOURCES
-                  dispatch_${test}.c)
-endforeach()
-
-set_tests_properties(dispatch_io_pipe PROPERTIES TIMEOUT 15)
-set_tests_properties(dispatch_io_pipe_close PROPERTIES TIMEOUT 5)
-
-# test dispatch API for various C/CXX language variants
-add_unit_test(dispatch_c99 SOURCES dispatch_c99.c)
-add_unit_test(dispatch_plusplus SOURCES dispatch_plusplus.cpp)
-
-# test-specific link options
-if(WIN32)
-  target_link_libraries(dispatch_io_muxed PRIVATE WS2_32)
-  target_link_libraries(dispatch_io_net PRIVATE WS2_32)
-else()
-  # When dispatch_group is reenabled above, remove this
-  if(EXTENDED_TEST_SUITE)
-    target_link_libraries(dispatch_group PRIVATE m)
-  endif()
-  target_link_libraries(dispatch_timer_short PRIVATE m)
-endif()
-
-# test-specific compile options
-set_target_properties(dispatch_c99 PROPERTIES C_STANDARD 99)
--- a/Telegram/ThirdParty/dispatch/tests/dispatch_after.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/dispatch_after.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,92 +0,0 @@
-/*
- * Copyright (c) 2008-2011 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include <dispatch/dispatch.h>
-#include <stdio.h>
-#if defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))
-#include <unistd.h>
-#endif
-#include <stdlib.h>
-#include <assert.h>
-#ifdef __APPLE__
-#include <libkern/OSAtomic.h>
-#endif
-
-#include <bsdtests.h>
-#include <Block.h>
-
-#include "dispatch_test.h"
-
-static void
-done(void *arg /*__unused */)
-{
-	(void)arg;
-	sleep(1);
-	test_stop();
-}
-
-static void
-test_after(void)
-{
-	__block dispatch_time_t time_a_min, time_a, time_a_max;
-	__block dispatch_time_t time_b_min, time_b, time_b_max;
-	__block dispatch_time_t time_c_min, time_c, time_c_max;
-
-	dispatch_test_start("Dispatch After");
-
-	dispatch_async(dispatch_get_main_queue(), ^{
-		time_a_min = dispatch_time(0,  (int64_t)(5.5*NSEC_PER_SEC));
-		time_a     = dispatch_time(0,   (int64_t)(6*NSEC_PER_SEC));
-		time_a_max = dispatch_time(0,  (int64_t)(6.5*NSEC_PER_SEC));
-		dispatch_after(time_a, dispatch_get_main_queue(), ^{
-			dispatch_time_t now_a = dispatch_time(0, 0);
-			test_long_less_than("can't finish faster than 5.5s", 0, (long)(now_a - time_a_min));
-			test_long_less_than("must finish faster than  6.5s", 0, (long)(time_a_max - now_a));
-
-			time_b_min = dispatch_time(0,  (int64_t)(1.5*NSEC_PER_SEC));
-			time_b     = dispatch_time(0,  (int64_t)(2*NSEC_PER_SEC));
-			time_b_max = dispatch_time(0,  (int64_t)(2.5*NSEC_PER_SEC));
-			dispatch_after(time_b, dispatch_get_main_queue(), ^{
-				dispatch_time_t now_b = dispatch_time(0, 0);
-				test_long_less_than("can't finish faster than 1.5s", 0, (long)(now_b - time_b_min));
-				test_long_less_than("must finish faster than  2.5s", 0, (long)(time_b_max - now_b));
-
-				time_c_min = dispatch_time(0,  0*NSEC_PER_SEC);
-				time_c     = dispatch_time(0,  0*NSEC_PER_SEC);
-				time_c_max = dispatch_time(0,  (int64_t)(.5*NSEC_PER_SEC));
-				dispatch_after(time_c, dispatch_get_main_queue(), ^{
-					dispatch_time_t now_c = dispatch_time(0, 0);
-					test_long_less_than("can't finish faster than 0s", 0, (long)(now_c - time_c_min));
-					test_long_less_than("must finish faster than .5s", 0, (long)(time_c_max - now_c));
-
-					dispatch_async_f(dispatch_get_main_queue(), NULL, done);
-				});
-			});
-		});
-	});
-}
-
-int
-main(void)
-{
-	test_after();
-	dispatch_main();
-	return 1;
-}
--- a/Telegram/ThirdParty/dispatch/tests/dispatch_api.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/dispatch_api.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,44 +0,0 @@
-/*
- * Copyright (c) 2008-2011 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include <stdlib.h>
-
-#include <bsdtests.h>
-#include "dispatch_test.h"
-
-static void
-work(void *context __attribute__((unused)))
-{
-	test_stop();
-	exit(0);
-}
-
-int
-main(void)
-{
-	dispatch_queue_t q;
-	dispatch_test_start("Dispatch (Public) API");
-	q = dispatch_get_main_queue();
-	test_ptr_notnull("dispatch_get_main_queue", q);
-
-	dispatch_async_f(dispatch_get_main_queue(), NULL, work);
-	dispatch_main();
-	return 0;
-}
--- a/Telegram/ThirdParty/dispatch/tests/dispatch_apply.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/dispatch_apply.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,158 +0,0 @@
-/*
- * Copyright (c) 2008-2011 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include <dispatch/dispatch.h>
-#include <stdio.h>
-#if defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))
-#include <unistd.h>
-#ifdef __ANDROID__
-#include <linux/sysctl.h>
-#else
-#if !defined(__linux__)
-#include <sys/sysctl.h>
-#endif
-#endif /* __ANDROID__ */
-#endif
-#include <stdlib.h>
-#include <assert.h>
-#ifdef __APPLE__
-#include <libkern/OSAtomic.h>
-#endif
-#include <sys/types.h>
-
-#include <bsdtests.h>
-#include "dispatch_test.h"
-
-static volatile int32_t busy_threads_started, busy_threads_finished;
-
-/*
- * Keep a thread busy, spinning on the CPU.
- */
-static volatile int all_done = 0;
-
-/* Fiddling with j in the middle and hitting this global will hopefully keep
- * the optimizer from cutting the whole thing out as dead code.
- */
-static volatile unsigned int busythread_useless;
-static void busythread(void *ignored)
-{
-	(void)ignored;
-	/* prevent i and j been optimized out */
-	volatile uint64_t i = 0, j = 0;
-
-	OSAtomicIncrement32(&busy_threads_started);
-
-	while(!all_done)
-	{
-		if(i == 500000) { j -= busythread_useless; }
-		j += i;
-		i += 1;
-	}
-	(void)j;
-
-	OSAtomicIncrement32(&busy_threads_finished);
-}
-
-/*
- * Test that dispatch_apply can make progress and finish, even if there are
- * so many other running and unblocked workqueue threads that the apply's
- * helper threads never get a chance to come up.
- *
- * <rdar://problem/10718199> dispatch_apply should not block waiting on other
- * threads while calling thread is available
- */
-static void test_apply_contended(dispatch_queue_t dq)
-{
-	uint32_t activecpu;
-#if defined(__linux__) || defined(__OpenBSD__)
-	activecpu = (uint32_t)sysconf(_SC_NPROCESSORS_ONLN);
-#elif defined(_WIN32)
-	SYSTEM_INFO si;
-	GetSystemInfo(&si);
-	activecpu = si.dwNumberOfProcessors;
-#else
-	size_t s = sizeof(activecpu);
-	sysctlbyname("hw.activecpu", &activecpu, &s, NULL, 0);
-#endif
-	int tIndex, n_threads = (int)activecpu;
-	dispatch_group_t grp = dispatch_group_create();
-
-	for(tIndex = 0; tIndex < n_threads; tIndex++) {
-		dispatch_group_async_f(grp, dq, NULL, busythread);
-	}
-
-	// Spin until all the threads have actually started
-	while(busy_threads_started < n_threads) {
-		usleep(1);
-	}
-
-	volatile __block int32_t count = 0;
-	const int32_t final = 32;
-
-	int32_t before = busy_threads_started;
-	dispatch_apply(final, dq, ^(size_t i __attribute__((unused))) {
-		OSAtomicIncrement32(&count);
-	});
-	int32_t after = busy_threads_finished;
-
-	test_long("contended: threads started before apply", before, n_threads);
-	test_long("contended: count", count, final);
-	test_long("contended: threads finished before apply", after, 0);
-
-	/* Release busy threads by setting all_done to 1 */
-        all_done = 1;
-
-	dispatch_group_wait(grp, DISPATCH_TIME_FOREVER);
-	dispatch_release(grp);
-
-}
-
-int
-main(void)
-{
-	dispatch_test_start("Dispatch Apply");
-
-	volatile __block int32_t count = 0;
-	const int32_t final = 32;
-
-	dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
-	test_ptr_notnull("dispatch_get_global_queue", queue);
-
-	dispatch_apply(final, queue, ^(size_t i __attribute__((unused))) {
-		OSAtomicIncrement32(&count);
-	});
-	test_long("count", count, final);
-
-	count = 0; // rdar://problem/9294578
-	dispatch_apply(final, queue, ^(size_t i __attribute__((unused))) {
-		dispatch_apply(final, queue, ^(size_t ii __attribute__((unused))) {
-			dispatch_apply(final, queue, ^(size_t iii __attribute__((unused))) {
-				OSAtomicIncrement32(&count);
-			});
-		});
-	});
-	test_long("nested count", count, final * final * final);
-
-	test_apply_contended(queue);
-
-	test_stop();
-
-	return 0;
-}
--- a/Telegram/ThirdParty/dispatch/tests/dispatch_c99.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/dispatch_c99.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,44 +0,0 @@
-/*
- * Copyright (c) 2008-2011 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include <dispatch/dispatch.h>
-#include <stdlib.h>
-
-#include <bsdtests.h>
-#include "dispatch_test.h"
-
-static void
-work(void *context __attribute__((unused)))
-{
-	test_stop();
-	exit(0);
-}
-
-int
-main(void)
-{
-	dispatch_test_start("Dispatch C99");
-	dispatch_queue_t q = dispatch_get_main_queue();
-	test_ptr_notnull("dispatch_get_main_queue", q);
-
-	dispatch_async_f(dispatch_get_main_queue(), NULL, work);
-	dispatch_main();
-	return 0;
-}
--- a/Telegram/ThirdParty/dispatch/tests/dispatch_cascade.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/dispatch_cascade.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,136 +0,0 @@
-/*
- * Copyright (c) 2008-2011 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include <stdio.h>
-#include <dispatch/dispatch.h>
-#if defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))
-#include <unistd.h>
-#endif
-#include <stdlib.h>
-
-#include <bsdtests.h>
-#include "dispatch_test.h"
-
-int done = 0;
-
-#define QUEUES 80
-dispatch_queue_t queues[QUEUES];
-
-#define BLOCKS 10000
-union {
-	size_t index;
-	char padding[64];
-} indices[BLOCKS];
-
-size_t iterations = (QUEUES * BLOCKS) / 4;
-
-static void
-noop(void *ctxt __attribute__((unused)))
-{
-	return;
-}
-
-static void
-cleanup(void *ctxt __attribute__((unused)))
-{
-	size_t q;
-	for (q = 0; q < QUEUES; ++q) {
-		dispatch_sync_f(queues[q], NULL, noop);
-		dispatch_release(queues[q]);
-	}
-	test_stop();
-	exit(0);
-}
-
-static void
-histogram(void)
-{
-	size_t counts[QUEUES] = {};
-	size_t maxcount = 0;
-
-	size_t q;
-	for (q = 0; q < QUEUES; ++q) {
-		size_t i;
-		for (i = 0; i < BLOCKS; ++i) {
-			if (indices[i].index == q) {
-				++counts[q];
-			}
-		}
-	}
-
-	for (q = 0; q < QUEUES; ++q) {
-		if (counts[q] > maxcount) {
-			maxcount = counts[q];
-		}
-	}
-
-	printf("maxcount = %zd\n", maxcount);
-
-	size_t x,y;
-	for (y = 20; y > 0; --y) {
-		for (x = 0; x < QUEUES; ++x) {
-			double fraction = (double)counts[x] / (double)maxcount;
-			double value = fraction * (double)20;
-			printf("%s", (value > y) ? "*" : " ");
-		}
-		printf("\n");
-	}
-}
-
-static void
-cascade(void* context)
-{
-	size_t idx, *idxptr = context;
-
-	if (done) return;
-
-	idx = *idxptr + 1;
-
-	if (idx < QUEUES) {
-		*idxptr = idx;
-		dispatch_async_f(queues[idx], context, cascade);
-	}
-
-	if (__sync_sub_and_fetch(&iterations, 1) == 0) {
-		done = 1;
-		histogram();
-		dispatch_async_f(dispatch_get_main_queue(), NULL, cleanup);
-	}
-}
-
-int
-main(int argc __attribute__((unused)), char* argv[] __attribute__((unused)))
-{
-	int i;
-
-	dispatch_test_start("Dispatch Cascade");
-
-	for (i = 0; i < QUEUES; ++i) {
-		queues[i] = dispatch_queue_create(NULL, NULL);
-	}
-
-	for (i = 0; i < BLOCKS; ++i) {
-		cascade(&indices[i].index);
-	}
-
-	dispatch_main();
-
-	return 0;
-}
--- a/Telegram/ThirdParty/dispatch/tests/dispatch_cf_main.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/dispatch_cf_main.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,61 +0,0 @@
-/*
- * Copyright (c) 2010-2011 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include <dispatch/dispatch.h>
-#include <stdio.h>
-#include <CoreFoundation/CoreFoundation.h>
-#ifdef __APPLE__
-#include <libkern/OSAtomic.h>
-#endif
-
-#include <bsdtests.h>
-#include "dispatch_test.h"
-
-const int32_t final = 10;
-static volatile int32_t count;
-
-static void
-work(void* ctxt __attribute__((unused)))
-{
-	int32_t c = OSAtomicIncrement32(&count);
-	if (c < final-1) {
-		dispatch_async_f(dispatch_get_main_queue(), NULL, work);
-		CFRunLoopPerformBlock(CFRunLoopGetMain(), kCFRunLoopDefaultMode, ^{
-			fprintf(stderr, "CFRunLoopPerformBlock %d\n", c);
-			test_long_less_than("CFRunLoopPerformBlock", count, final);
-		});
-	}
-}
-
-int
-main(void)
-{
-	dispatch_test_start("Dispatch CF main queue"); // <rdar://problem/7760523>
-	dispatch_async_f(dispatch_get_main_queue(), NULL, work);
-	dispatch_async_f(dispatch_get_main_queue(), NULL, work);
-	dispatch_after(dispatch_time(DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC),
-			dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
-		test_long("done", count, final);
-		test_stop();
-	});
-	CFRunLoopRun();
-
-	return 0;
-}
--- a/Telegram/ThirdParty/dispatch/tests/dispatch_concur.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/dispatch_concur.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,295 +0,0 @@
-/*
- * Copyright (c) 2010-2011 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include <dispatch/dispatch.h>
-#include <dispatch/private.h>
-#include <stdlib.h>
-#include <stdio.h>
-#if defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))
-#include <sys/types.h>
-#include <unistd.h>
-#ifdef __ANDROID__
-#include <linux/sysctl.h>
-#else
-#if !defined(__linux__)
-#include <sys/sysctl.h>
-#endif
-#endif /* __ANDROID__ */
-#endif
-
-#include <bsdtests.h>
-#include "dispatch_test.h"
-
-static volatile size_t done, concur;
-static int use_group_async;
-static uint32_t activecpu;
-static uint32_t min_acceptable_concurrency;
-
-static dispatch_queue_t q;
-static dispatch_group_t g, gw;
-
-const size_t workers = 4;
-
-static void
-nop(void* ctxt __attribute__((unused)))
-{
-	return;
-}
-
-static void
-work(void* ctxt __attribute__((unused)))
-{
-	usleep(1000);
-	__sync_add_and_fetch(&done, 1);
-
-	if (!use_group_async) dispatch_group_leave(gw);
-}
-
-static void
-submit_work(void* ctxt)
-{
-	size_t c = __sync_add_and_fetch(&concur, 1), *m = (size_t *)ctxt, i;
-	if (c > *m) *m = c;
-
-	for (i = 0; i < workers; ++i) {
-		if (use_group_async) {
-			dispatch_group_async_f(gw, q, NULL, work);
-		} else {
-			dispatch_group_enter(gw);
-			dispatch_async_f(q, NULL, work);
-		}
-	}
-
-	usleep(10000);
-	__sync_sub_and_fetch(&concur, 1);
-
-	if (!use_group_async) dispatch_group_leave(g);
-}
-
-static void
-test_concur_async(size_t n, size_t qw)
-{
-	size_t i, max_concur = 0, *mcs = calloc(n, sizeof(size_t)), *mc;
-	done = concur = 0;
-
-	dispatch_suspend(q);
-	for (i = 0, mc = mcs; i < n; i++, mc++) {
-		if (use_group_async) {
-			dispatch_group_async_f(g, q, mc, submit_work);
-		} else {
-			dispatch_group_enter(g);
-			dispatch_async_f(q, mc, submit_work);
-		}
-	}
-	dispatch_resume(q);
-
-	dispatch_group_wait(g, DISPATCH_TIME_FOREVER);
-
-	if (qw > 1) {
-		size_t concurrency = MIN(n * workers, qw);
-		if (done > min_acceptable_concurrency) {
-			test_sizet_less_than_or_equal("concurrently completed workers", done, concurrency);
-		} else {
-			test_sizet("concurrently completed workers", done, concurrency);
-		}
-	} else {
-		test_sizet_less_than_or_equal("concurrently completed workers", done, 1);
-	}
-
-	for (i = 0, mc = mcs; i < n; i++, mc++) {
-		if (*mc > max_concur) max_concur = *mc;
-	}
-	free(mcs);
-
-	size_t expect = MIN(n, qw);
-	if (max_concur > min_acceptable_concurrency) {
-		test_sizet_less_than_or_equal("max submission concurrency", max_concur, expect);
-	} else {
-		test_sizet("max submission concurrency", max_concur, expect);
-	}
-
-	dispatch_group_wait(gw, DISPATCH_TIME_FOREVER);
-	usleep(1000);
-}
-
-static void
-sync_work(void* ctxt)
-{
-	size_t c = __sync_add_and_fetch(&concur, 1), *m = (size_t *)ctxt;
-	if (c > *m) *m = c;
-
-	usleep(10000);
-	__sync_sub_and_fetch(&concur, 1);
-}
-
-static void
-test_concur_sync(size_t n, size_t qw)
-{
-	size_t i, max_concur = 0, *mcs = calloc(n, sizeof(size_t)), *mc;
-	concur = 0;
-
-	for (i = 0, mc = mcs; i < n; i++, mc++) {
-		dispatch_group_async(g,
-				dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH,
-				DISPATCH_QUEUE_OVERCOMMIT), ^{
-			usleep(100000);
-			dispatch_sync_f(q, mc, sync_work);
-		});
-	}
-
-	dispatch_group_wait(g, DISPATCH_TIME_FOREVER);
-
-	for (i = 0, mc = mcs; i < n; i++, mc++) {
-		if (*mc > max_concur) max_concur = *mc;
-	}
-	free(mcs);
-
-	size_t expect = qw == 1 ? 1 : n;
-	if (max_concur > min_acceptable_concurrency) {
-		test_sizet_less_than_or_equal("max sync concurrency", max_concur, expect);
-	} else {
-		test_sizet("max sync concurrency", max_concur, expect);
-	}
-}
-
-static void
-apply_work(void* ctxt, size_t i)
-{
-	size_t c = __sync_add_and_fetch(&concur, 1), *m = ((size_t *)ctxt) + i;
-	if (c > *m) *m = c;
-
-	usleep(100000);
-	__sync_sub_and_fetch(&concur, 1);
-}
-
-static void
-test_concur_apply(size_t n, size_t qw)
-{
-	size_t i, max_concur = 0, *mcs = calloc(n, sizeof(size_t)), *mc;
-	concur = 0;
-
-	dispatch_apply_f(n, q, mcs, apply_work);
-
-	for (i = 0, mc = mcs; i < n; i++, mc++) {
-		if (*mc > max_concur) max_concur = *mc;
-	}
-	free(mcs);
-
-	size_t expect = MIN(n, qw);
-	if (max_concur > min_acceptable_concurrency) {
-		test_sizet_less_than_or_equal("max apply concurrency", max_concur, expect);
-	} else {
-		test_sizet("max apply concurrency", max_concur, expect);
-	}
-}
-
-static dispatch_queue_t
-create_queue(long width, dispatch_queue_t tq, long *qw, const char **ql)
-{
-	if (!width) {
-		*qw = LONG_MAX;
-		*ql = "global";
-		return dispatch_get_global_queue(0, 0);
-	};
-	dispatch_queue_t queue;
-	dispatch_queue_attr_t qattr = NULL;
-
-	*qw = width;
-	*ql = width < LONG_MAX ? ( width == 1 ? "serial": "wide" ) : "concurrent";
-#if DISPATCH_API_VERSION >= 20100518 // <rdar://problem/7790099>
-	qattr = width < LONG_MAX ? NULL : DISPATCH_QUEUE_CONCURRENT;
-#endif
-	queue = dispatch_queue_create(*ql, qattr);
-	if (!qattr) {
-		dispatch_queue_set_width(queue, width);
-	}
-	if (tq) {
-		dispatch_set_target_queue(queue, tq);
-	}
-	if (!qattr || tq) {
-		dispatch_barrier_sync_f(queue, NULL, nop); // wait for changes to take effect
-	}
-	return queue;
-}
-
-int
-main(int argc __attribute__((unused)), char* argv[] __attribute__((unused)))
-{
-	dispatch_test_start("Dispatch Private Concurrent/Wide Queue"); // <rdar://problem/8049506&8169448&8186485>
-
-#ifdef __linux__
-	activecpu = (uint32_t)sysconf(_SC_NPROCESSORS_ONLN);
-#elif defined(_WIN32)
-	SYSTEM_INFO si;
-	GetSystemInfo(&si);
-	activecpu = si.dwNumberOfProcessors;
-#else
-	size_t s = sizeof(activecpu);
-	sysctlbyname("hw.activecpu", &activecpu, &s, NULL, 0);
-#endif
-	size_t n = activecpu / 2 > 1 ? activecpu / 2 : 1, w = activecpu * 2;
-	min_acceptable_concurrency = (uint32_t)n;
-	dispatch_queue_t tq, ttq;
-	long qw, tqw, ttqw;
-	const char *ql, *tql, *ttql;
-	size_t qi, tqi, ttqi;
-	long qws[] = {
-		0, LONG_MAX, (long)w, 1, // 0 <=> global queue
-	};
-
-	g = dispatch_group_create();
-	gw = dispatch_group_create();
-
-	for (ttqi = 0; ttqi < sizeof(qws)/sizeof(*qws); ttqi++) {
-		ttq = create_queue(qws[ttqi], NULL, &ttqw, &ttql);
-		for (tqi = 0; tqi < sizeof(qws)/sizeof(*qws); tqi++) {
-			if (!qws[tqi] && qws[ttqi]) continue;
-			tq = create_queue(qws[tqi], ttq, &tqw, &tql);
-			for (qi = 0; qi < sizeof(qws)/sizeof(*qws); qi++) {
-				if (!qws[qi] && qws[tqi]) continue;
-				q = create_queue(qws[qi], tq, &qw, &ql);
-				for (use_group_async = 0; use_group_async < 2; use_group_async++) {
-					fprintf(stdout, "Testing dispatch%s_async on "
-							"queue hierarchy: %s -> %s -> %s\n",
-							use_group_async ? "_group" : "", ql, tql, ttql);
-					fflush(stdout);
-					test_concur_async(n, (size_t)MIN(qw, MIN(tqw, ttqw)));
-				}
-				fprintf(stdout, "Testing dispatch_sync on "
-						"queue hierarchy: %s -> %s -> %s\n", ql, tql, ttql);
-				fflush(stdout);
-				test_concur_sync(w, (size_t)MIN(qw, MIN(tqw, ttqw)));
-				fprintf(stdout, "Testing dispatch_apply on "
-						"queue hierarchy: %s -> %s -> %s\n", ql, tql, ttql);
-				fflush(stdout);
-				test_concur_apply(activecpu, (size_t)MIN(qw, MIN(tqw, ttqw)));
-				dispatch_release(q);
-			}
-			dispatch_release(tq);
-		}
-		dispatch_release(ttq);
-	}
-
-	dispatch_release(g);
-	dispatch_release(gw);
-
-	test_stop();
-	return 0;
-}
--- a/Telegram/ThirdParty/dispatch/tests/dispatch_context_for_key.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/dispatch_context_for_key.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,158 +0,0 @@
-/*
- * Copyright (c) 2010-2011 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include <dispatch/dispatch.h>
-#include <stdlib.h>
-#include <stdio.h>
-#if defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))
-#include <unistd.h>
-#endif
-#include <assert.h>
-
-#include <bsdtests.h>
-#include "dispatch_test.h"
-
-#if DISPATCH_API_VERSION >= 20100825 && DISPATCH_API_VERSION != 20101110
-
-static const char *ctxts[] = {"ctxt for app", "ctxt for key 1",
-		"ctxt for key 2", "ctxt for key 1 bis", "ctxt for key 4"};
-volatile long ctxts_destroyed;
-static dispatch_group_t g;
-
-static void
-destructor(void *ctxt)
-{
-	fprintf(stderr, "destructor of %s\n", (char*)ctxt);
-	(void)__sync_add_and_fetch(&ctxts_destroyed, 1);
-	dispatch_group_leave(g);
-}
-
-static void
-test_context_for_key(void)
-{
-	g = dispatch_group_create();
-	dispatch_queue_t q = dispatch_queue_create("q", NULL);
-#if DISPATCH_API_VERSION >= 20100518
-	dispatch_queue_t tq = dispatch_queue_create("tq", DISPATCH_QUEUE_CONCURRENT);
-#else
-	dispatch_queue_t tq = dispatch_queue_create("tq", NULL);
-	dispatch_queue_set_width(tq, LONG_MAX);
-#endif
-	dispatch_queue_t ttq = dispatch_get_global_queue(0, 0);
-	dispatch_group_enter(g);
-#if DISPATCH_API_VERSION >= 20101011
-	dispatch_queue_set_specific(tq, &ctxts[4], (char *)ctxts[4], destructor);
-#else
-	dispatch_set_context_for_key(tq, &ctxts[4], ctxts[4], ttq, destructor);
-#endif
-	dispatch_set_target_queue(tq, ttq);
-	dispatch_group_enter(g);
-	dispatch_set_context(q, (char *)ctxts[0]);
-	dispatch_set_target_queue(q, tq);
-	dispatch_set_finalizer_f(q, destructor);
-
-	dispatch_async(q, ^{
-		dispatch_group_enter(g);
-#if DISPATCH_API_VERSION >= 20101011
-		dispatch_queue_set_specific(q, &ctxts[1], (char *)ctxts[1], destructor);
-#else
-		dispatch_set_context_for_key(q, &ctxts[1], ctxts[1], ttq, destructor);
-#endif
-	});
-	dispatch_retain(q);
-	dispatch_async(dispatch_get_global_queue(0, 0), ^{
-		dispatch_group_enter(g);
-#if DISPATCH_API_VERSION >= 20101011
-		dispatch_queue_set_specific(q, &ctxts[2], (char *)ctxts[2], destructor);
-#else
-		dispatch_set_context_for_key(q, &ctxts[2], ctxts[2], ttq, destructor);
-#endif
-		dispatch_async(dispatch_get_global_queue(0, 0), ^{
-			void *ctxt;
-#if DISPATCH_API_VERSION >= 20101011
-			ctxt = dispatch_queue_get_specific(q, &ctxts[2]);
-#else
-			ctxt = dispatch_get_context_for_key(q, &ctxts[2]);
-#endif
-			test_ptr("get context for key 2", ctxt, ctxts[2]);
-			dispatch_release(q);
-		});
-	});
-	dispatch_async(q, ^{
-		void *ctxt;
-#if DISPATCH_API_VERSION >= 20101011
-		ctxt = dispatch_get_specific(&ctxts[1]);
-		test_ptr("get current context for key 1", ctxt, ctxts[1]);
-		ctxt = dispatch_get_specific(&ctxts[4]);
-		test_ptr("get current context for key 4 (on target queue)", ctxt, ctxts[4]);
-		ctxt = dispatch_queue_get_specific(q, &ctxts[1]);
-#else
-		ctxt = dispatch_get_context_for_key(tq, &ctxts[4]);
-		test_ptr("get context for key 4 (on target queue)", ctxt, ctxts[4]);
-		ctxt = dispatch_get_context_for_key(q, &ctxts[1]);
-#endif
-		test_ptr("get context for key 1", ctxt, ctxts[1]);
-	});
-	dispatch_async(q, ^{
-		dispatch_group_enter(g);
-		void *ctxt;
-#if DISPATCH_API_VERSION >= 20101011
-		dispatch_queue_set_specific(q, &ctxts[1], (char *)ctxts[3], destructor);
-		ctxt = dispatch_queue_get_specific(q, &ctxts[1]);
-#else
-		dispatch_set_context_for_key(q, &ctxts[1], ctxts[3], ttq, destructor);
-		ctxt = dispatch_get_context_for_key(q, &ctxts[1]);
-#endif
-		test_ptr("get context for key 1", ctxt, ctxts[3]);
-	});
-	dispatch_async(q, ^{
-		void *ctxt;
-#if DISPATCH_API_VERSION >= 20101011
-		dispatch_queue_set_specific(q, &ctxts[1], NULL, destructor);
-		ctxt = dispatch_queue_get_specific(q, &ctxts[1]);
-#else
-		dispatch_set_context_for_key(q, &ctxts[1], NULL, ttq, destructor);
-		ctxt = dispatch_get_context_for_key(q, &ctxts[1]);
-#endif
-		test_ptr("get context for key 1", ctxt, NULL);
-	});
-	void *ctxt = dispatch_get_context(q);
-	test_ptr("get context for app", ctxt, ctxts[0]);
-	dispatch_release(tq);
-	dispatch_release(q);
-	dispatch_group_wait(g, DISPATCH_TIME_FOREVER);
-	test_long("contexts destroyed", ctxts_destroyed, 5);
-	dispatch_release(g);
-}
-#endif
-
-int
-main(void)
-{
-	dispatch_test_start("Dispatch Queue Specific"); // rdar://problem/8429188
-
-	dispatch_async(dispatch_get_main_queue(), ^{
-#if DISPATCH_API_VERSION >= 20100825 && DISPATCH_API_VERSION != 20101110
-		test_context_for_key();
-#endif
-		test_stop();
-	});
-	dispatch_main();
-}
--- a/Telegram/ThirdParty/dispatch/tests/dispatch_data.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/dispatch_data.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,120 +0,0 @@
-/*
- * Copyright (c) 2009-2011 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-
-#include <dispatch/dispatch.h>
-#ifdef __APPLE__
-#include <TargetConditionals.h>
-#endif
-
-#include <bsdtests.h>
-#include "dispatch_test.h"
-
-#ifndef DISPATCHTEST_DATA
-#if DISPATCH_API_VERSION >= 20100226 && DISPATCH_API_VERSION != 20101110
-#define DISPATCHTEST_DATA 1
-#endif
-#endif
-
-dispatch_group_t g;
-
-#if DISPATCHTEST_DATA
-static void
-test_concat(void)
-{
-	dispatch_group_enter(g);
-	dispatch_async(dispatch_get_main_queue(), ^{
-		const char* buffer1 = "This is buffer1 ";
-		size_t size1 = 17;
-		const char* buffer2 = "This is buffer2 ";
-		size_t size2 = 17;
-		__block bool buffer2_destroyed = false;
-
-		dispatch_data_t data1 = dispatch_data_create(buffer1, size1, NULL, NULL);
-		dispatch_data_t data2 = dispatch_data_create(buffer2, size2,
-					dispatch_get_main_queue(), ^{
-			buffer2_destroyed = true;
-		});
-		dispatch_data_t concat = dispatch_data_create_concat(data1, data2);
-
-		dispatch_release(data1);
-		dispatch_release(data2);
-
-		test_long("Data size of concatenated dispatch data",
-				  (long)dispatch_data_get_size(concat), 34);
-
-		const void* contig;
-		size_t contig_size;
-		dispatch_data_t contig_data =
-			dispatch_data_create_map(concat, &contig, &contig_size);
-
-		dispatch_release(concat);
-		dispatch_release(contig_data);
-		test_long("Contiguous memory size", (long)contig_size, 34);
-		dispatch_async(dispatch_get_main_queue(), ^{
-			test_long("buffer2 destroyed", buffer2_destroyed, true);
-			dispatch_group_leave(g);
-		});
-	});
-}
-
-static void
-test_cleanup(void) // <rdar://problem/9843440>
-{
-	static char buffer4[16];
-	dispatch_group_enter(g);
-	dispatch_async(dispatch_get_main_queue(), ^{
-		void *buffer3 = malloc(1024);
-		dispatch_data_t data3 = dispatch_data_create(buffer3, 0,
-				dispatch_get_main_queue(), DISPATCH_DATA_DESTRUCTOR_FREE);
-		__block bool buffer4_destroyed = false;
-		dispatch_data_t data4 = dispatch_data_create(buffer4, 16,
-				dispatch_get_main_queue(), ^{
-			buffer4_destroyed = true;
-		});
-		dispatch_release(data3);
-		dispatch_release(data4);
-		dispatch_async(dispatch_get_main_queue(), ^{
-			test_long("buffer4 destroyed", buffer4_destroyed, true);
-			dispatch_group_leave(g);
-		});
-	});
-}
-#endif
-
-int
-main(void)
-{
-	dispatch_test_start("Dispatch Data");
-	g = dispatch_group_create();
-
-#if DISPATCHTEST_DATA
-	test_concat();
-	test_cleanup();
-#endif
-
-	dispatch_group_notify(g, dispatch_get_main_queue(), ^{
-		dispatch_release(g);
-		test_stop();
-	});
-	dispatch_main();
-}
--- a/Telegram/ThirdParty/dispatch/tests/dispatch_deadname.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/dispatch_deadname.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,466 +0,0 @@
-/*
- * Copyright (c) 2008-2011 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include <dispatch/dispatch.h>
-#include <dispatch/private.h>
-#ifdef __APPLE__
-#include <mach/mach.h>
-#endif
-#include <stdio.h>
-#if defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))
-#include <unistd.h>
-#endif
-#include <stdlib.h>
-#include <assert.h>
-
-#include <bsdtests.h>
-#include "dispatch_test.h"
-
-#if TEST_MACHPORT_DEBUG
-#define test_mach_assume_zero(x) ({kern_return_t _kr = (x); \
-		if (_kr) fprintf(stderr, "mach error 0x%x \"%s\": %s\n", \
-		_kr, mach_error_string(_kr), #x); (void)kr; })
-void
-test_mach_debug_port(mach_port_t name, const char *str, unsigned int line)
-{
-	mach_port_type_t type;
-	mach_msg_bits_t ns = 0, nr = 0, nso = 0, nd = 0;
-	unsigned int dnreqs = 0, dnrsiz;
-	kern_return_t kr = mach_port_type(mach_task_self(), name, &type);
-	if (kr) {
-		fprintf(stderr, "machport[0x%08x] = { error(0x%x) \"%s\" }: %s %u\n",
-				name, kr, mach_error_string(kr), str, line);
-		return;
-	}
-	if (type & MACH_PORT_TYPE_SEND) {
-		test_mach_assume_zero(mach_port_get_refs(mach_task_self(), name,
-				MACH_PORT_RIGHT_SEND, &ns));
-	}
-	if (type & MACH_PORT_TYPE_SEND_ONCE) {
-		test_mach_assume_zero(mach_port_get_refs(mach_task_self(), name,
-				MACH_PORT_RIGHT_SEND_ONCE, &nso));
-	}
-	if (type & MACH_PORT_TYPE_DEAD_NAME) {
-		test_mach_assume_zero(mach_port_get_refs(mach_task_self(), name,
-				MACH_PORT_RIGHT_DEAD_NAME, &nd));
-	}
-	if (type & (MACH_PORT_TYPE_RECEIVE|MACH_PORT_TYPE_SEND)) {
-		test_mach_assume_zero(mach_port_dnrequest_info(mach_task_self(), name,
-				&dnrsiz, &dnreqs));
-		}
-	if (type & MACH_PORT_TYPE_RECEIVE) {
-		mach_port_status_t status = { .mps_pset = 0, };
-		mach_msg_type_number_t cnt = MACH_PORT_RECEIVE_STATUS_COUNT;
-		test_mach_assume_zero(mach_port_get_refs(mach_task_self(), name,
-				MACH_PORT_RIGHT_RECEIVE, &nr));
-		test_mach_assume_zero(mach_port_get_attributes(mach_task_self(), name,
-				MACH_PORT_RECEIVE_STATUS, (void*)&status, &cnt));
-		fprintf(stderr, "machport[0x%08x] = { R(%03u) S(%03u) SO(%03u) D(%03u) "
-				"dnreqs(%03u) spreq(%s) nsreq(%s) pdreq(%s) srights(%s) "
-				"sorights(%03u) qlim(%03u) msgcount(%03u) mkscount(%03u) "
-				"seqno(%03u) }: %s %u\n", name, nr, ns, nso, nd, dnreqs,
-				type & MACH_PORT_TYPE_SPREQUEST ? "Y":"N",
-				status.mps_nsrequest ? "Y":"N", status.mps_pdrequest ? "Y":"N",
-				status.mps_srights ? "Y":"N", status.mps_sorights,
-				status.mps_qlimit, status.mps_msgcount, status.mps_mscount,
-				status.mps_seqno, str, line);
-	} else if (type & (MACH_PORT_TYPE_SEND|MACH_PORT_TYPE_SEND_ONCE|
-			MACH_PORT_TYPE_DEAD_NAME)) {
-		fprintf(stderr, "machport[0x%08x] = { R(%03u) S(%03u) SO(%03u) D(%03u) "
-				"dnreqs(%03u) spreq(%s) }: %s %u\n", name, nr, ns, nso, nd,
-				dnreqs, type & MACH_PORT_TYPE_SPREQUEST ? "Y":"N", str, line);
-	} else {
-		fprintf(stderr, "machport[0x%08x] = { type(0x%08x) }: %s %u\n", name,
-				type, str, line);
-	}
-	fflush(stderr);
-}
-#define test_mach_debug_port(x) test_mach_debug_port(x, __func__, __LINE__)
-#else
-#define test_mach_debug_port(x) (void)(x)
-#endif
-
-static dispatch_group_t g;
-static volatile long sent, received;
-
-void
-test_dead_name(void)
-{
-	dispatch_group_enter(g);
-	dispatch_async(dispatch_get_global_queue(0, 0), ^{
-		dispatch_source_t ds0;
-		kern_return_t kr;
-
-		mach_port_t mp = pthread_mach_thread_np(pthread_self());
-		assert(mp);
-		kr = mach_port_mod_refs(mach_task_self(), mp, MACH_PORT_RIGHT_SEND, 1);
-		test_mach_error("mach_port_mod_refs", kr, KERN_SUCCESS);
-		ds0 = dispatch_source_create(DISPATCH_SOURCE_TYPE_MACH_SEND, mp,
-				DISPATCH_MACH_SEND_DEAD, dispatch_get_main_queue());
-		test_ptr_notnull("DISPATCH_SOURCE_TYPE_MACH_SEND", ds0);
-		dispatch_source_set_event_handler(ds0, ^{
-			test_long("DISPATCH_MACH_SEND_DEAD",
-					dispatch_source_get_handle(ds0), mp);
-			dispatch_source_cancel(ds0);
-		});
-		dispatch_source_set_cancel_handler(ds0, ^{
-			kern_return_t kr = mach_port_deallocate(mach_task_self(), mp);
-			test_mach_error("mach_port_deallocate", kr, KERN_SUCCESS);
-			dispatch_release(ds0);
-			dispatch_group_leave(g);
-		});
-		dispatch_resume(ds0);
-
-		// give the mgr queue time to start, otherwise the mgr queue will run
-		// on this thread, thus defeating the test which assumes that this
-		// thread will die.
-		usleep(100000);
-	});
-	dispatch_group_wait(g, DISPATCH_TIME_FOREVER);
-}
-
-void
-test_register_already_dead_name(void)
-{
-	dispatch_source_t ds0;
-	kern_return_t kr;
-	mach_port_t mp;
-
-	dispatch_group_enter(g);
-	kr = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &mp);
-	test_mach_error("mach_port_allocate", kr, KERN_SUCCESS);
-	kr = mach_port_insert_right(mach_task_self(), mp, mp,
-			MACH_MSG_TYPE_MAKE_SEND);
-	test_mach_error("mach_port_insert_right", kr, KERN_SUCCESS);
-
-	kr = mach_port_mod_refs(mach_task_self(), mp,
-			MACH_PORT_RIGHT_RECEIVE, -1); // turn send right into dead name
-	test_mach_error("mach_port_mod_refs", kr, KERN_SUCCESS);
-
-	ds0 = dispatch_source_create(DISPATCH_SOURCE_TYPE_MACH_SEND, mp,
-			DISPATCH_MACH_SEND_DEAD, dispatch_get_global_queue(0, 0));
-	dispatch_source_set_event_handler(ds0, ^{
-		test_long("DISPATCH_MACH_SEND_DEAD",
-				dispatch_source_get_handle(ds0), mp);
-		dispatch_source_cancel(ds0);
-		dispatch_release(ds0);
-	});
-	dispatch_source_set_cancel_handler(ds0, ^{
-		kern_return_t kr = mach_port_deallocate(mach_task_self(), mp);
-		test_mach_error("mach_port_deallocate", kr, KERN_SUCCESS);
-		dispatch_group_leave(g);
-	});
-	dispatch_resume(ds0);
-	dispatch_group_wait(g, DISPATCH_TIME_FOREVER);
-}
-
-void
-test_receive_and_dead_name(void)
-{
-	dispatch_source_t ds0, ds;
-	kern_return_t kr;
-	mach_port_t mp;
-
-	received = 0;
-	dispatch_group_enter(g);
-	kr = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &mp);
-	test_mach_error("mach_port_allocate", kr, KERN_SUCCESS);
-	kr = mach_port_insert_right(mach_task_self(), mp, mp,
-			MACH_MSG_TYPE_MAKE_SEND);
-	test_mach_error("mach_port_insert_right", kr, KERN_SUCCESS);
-	ds0 = dispatch_source_create(DISPATCH_SOURCE_TYPE_MACH_SEND, mp,
-			DISPATCH_MACH_SEND_DEAD, dispatch_get_global_queue(0, 0));
-	dispatch_source_set_event_handler(ds0, ^{
-		test_long("DISPATCH_MACH_SEND_DEAD",
-				dispatch_source_get_handle(ds0), mp);
-		dispatch_source_cancel(ds0);
-		dispatch_release(ds0);
-	});
-	dispatch_source_set_cancel_handler(ds0, ^{
-		kern_return_t kr = mach_port_deallocate(mach_task_self(), mp);
-		test_mach_error("mach_port_deallocate", kr, KERN_SUCCESS);
-		dispatch_group_leave(g);
-	});
-	dispatch_resume(ds0);
-	ds = dispatch_source_create(DISPATCH_SOURCE_TYPE_MACH_RECV, mp, 0,
-			dispatch_get_global_queue(0, 0));
-	dispatch_source_set_event_handler(ds, ^{
-		__sync_add_and_fetch(&received, 1);
-		usleep(100000); // rdar://problem/7676437 race with send source re-arm
-		mach_msg_empty_rcv_t msg = { .header = {
-			.msgh_size = sizeof(mach_msg_empty_rcv_t),
-			.msgh_local_port = mp,
-		}};
-		kern_return_t kr = mach_msg_receive(&msg.header);
-		test_mach_error("mach_msg_receive", kr, KERN_SUCCESS);
-	});
-	dispatch_source_set_cancel_handler(ds, ^{
-		kern_return_t kr = mach_port_mod_refs(mach_task_self(), mp,
-				MACH_PORT_RIGHT_RECEIVE, -1); // turns send right into dead name
-		test_mach_error("mach_port_mod_refs", kr, KERN_SUCCESS);
-	});
-	dispatch_resume(ds);
-	mach_msg_empty_send_t msg = { .header = {
-		.msgh_bits = MACH_MSGH_BITS_REMOTE(MACH_MSG_TYPE_COPY_SEND),
-		.msgh_size = sizeof(mach_msg_empty_send_t),
-		.msgh_remote_port = mp,
-	}};
-	kr = mach_msg_send(&msg.header);
-	test_mach_error("mach_msg_send", kr, KERN_SUCCESS);
-	usleep(200000);
-	dispatch_source_cancel(ds);
-	dispatch_release(ds);
-	test_long("DISPATCH_SOURCE_TYPE_MACH_RECV", received, 1);
-	if (received > 1 ) {
-		test_stop();
-	}
-	dispatch_group_wait(g, DISPATCH_TIME_FOREVER);
-}
-
-#if DISPATCH_API_VERSION >= 20110201 && defined(MACH_NOTIFY_SEND_POSSIBLE) && \
-		defined(MACH_SEND_NOTIFY)
-
-#define TEST_SP_MSGCOUNT 11 // (2*qlim)+1
-
-static bool
-send_until_timeout(mach_port_t mp)
-{
-	kern_return_t kr;
-
-	do {
-		test_mach_debug_port(mp);
-		mach_msg_empty_send_t msg = { .header = {
-			.msgh_bits = MACH_MSGH_BITS_REMOTE(MACH_MSG_TYPE_COPY_SEND),
-			.msgh_size = sizeof(mach_msg_empty_send_t),
-			.msgh_remote_port = mp,
-		}};
-		kr = mach_msg(&msg.header,
-				MACH_SEND_MSG|MACH_SEND_NOTIFY|MACH_SEND_TIMEOUT,
-				msg.header.msgh_size, 0, MACH_PORT_NULL, MACH_MSG_TIMEOUT_NONE,
-				MACH_PORT_NULL);
-		if (kr == MACH_SEND_TIMED_OUT) {
-			mach_msg_destroy(&msg.header);
-			test_mach_error("mach_msg(MACH_SEND_MSG) timed out", kr,
-					MACH_SEND_TIMED_OUT);
-		} else {
-			test_mach_error("mach_msg(MACH_SEND_MSG)", kr, KERN_SUCCESS);
-			if (kr) test_stop();
-		}
-	} while (!kr && __sync_add_and_fetch(&sent, 1) < TEST_SP_MSGCOUNT);
-	test_mach_debug_port(mp);
-	return kr;
-}
-
-void
-test_send_possible(void) // rdar://problem/8758200
-{
-	dispatch_source_t ds0, ds, dsp;
-	kern_return_t kr;
-	mach_port_t mp;
-
-	sent = 0;
-	received = 0;
-	dispatch_group_enter(g);
-	kr = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &mp);
-	test_mach_error("mach_port_allocate", kr, KERN_SUCCESS);
-	test_mach_debug_port(mp);
-	kr = mach_port_insert_right(mach_task_self(), mp, mp,
-			MACH_MSG_TYPE_MAKE_SEND);
-	test_mach_error("mach_port_insert_right", kr, KERN_SUCCESS);
-	test_mach_debug_port(mp);
-	ds0 = dispatch_source_create(DISPATCH_SOURCE_TYPE_MACH_SEND, mp,
-			DISPATCH_MACH_SEND_DEAD, dispatch_get_global_queue(0, 0));
-	dispatch_source_set_registration_handler(ds0, ^{
-		test_long("DISPATCH_MACH_SEND_DEAD registered",
-				dispatch_source_get_handle(ds0), mp);
-		test_mach_debug_port(mp);
-	});
-	dispatch_source_set_event_handler(ds0, ^{
-		test_long("DISPATCH_MACH_SEND_DEAD delivered",
-				dispatch_source_get_handle(ds0), mp);
-		test_mach_debug_port(mp);
-		dispatch_source_cancel(ds0);
-		dispatch_release(ds0);
-	});
-	dispatch_source_set_cancel_handler(ds0, ^{
-		test_long("DISPATCH_MACH_SEND_DEAD canceled",
-				dispatch_source_get_handle(ds0), mp);
-		test_mach_debug_port(mp);
-		kern_return_t kr = mach_port_deallocate(mach_task_self(), mp);
-		test_mach_error("mach_port_deallocate", kr, KERN_SUCCESS);
-		test_mach_debug_port(mp);
-		dispatch_group_leave(g);
-	});
-	dispatch_resume(ds0);
-	ds = dispatch_source_create(DISPATCH_SOURCE_TYPE_MACH_RECV, mp, 0,
-			dispatch_get_global_queue(0, 0));
-	dispatch_source_set_registration_handler(ds, ^{
-		test_long("DISPATCH_SOURCE_TYPE_MACH_RECV registered",
-				dispatch_source_get_handle(ds), mp);
-		test_mach_debug_port(mp);
-	});
-	dispatch_source_set_event_handler(ds, ^{
-		test_long("DISPATCH_SOURCE_TYPE_MACH_RECV delivered",
-				dispatch_source_get_handle(ds), mp);
-		kern_return_t kr;
-		do {
-			test_mach_debug_port(mp);
-			usleep(10000); // simulate slow receiver
-			mach_msg_empty_rcv_t msg = { .header = {
-				.msgh_size = sizeof(mach_msg_empty_rcv_t),
-				.msgh_local_port = mp,
-			}};
-			kr = mach_msg(&msg.header,
-					MACH_RCV_MSG|MACH_RCV_TIMEOUT, 0, msg.header.msgh_size,
-					msg.header.msgh_local_port, MACH_MSG_TIMEOUT_NONE,
-					MACH_PORT_NULL);
-			if (kr == MACH_RCV_TIMED_OUT) {
-				test_mach_error("mach_msg(MACH_RCV_MSG) timed out", kr,
-						MACH_RCV_TIMED_OUT);
-			} else {
-				test_mach_error("mach_msg(MACH_RCV_MSG)", kr, KERN_SUCCESS);
-				if (kr) test_stop();
-			}
-		} while (!kr && __sync_add_and_fetch(&received, 1));
-		test_mach_debug_port(mp);
-	});
-	dispatch_source_set_cancel_handler(ds, ^{
-		test_long("DISPATCH_SOURCE_TYPE_MACH_RECV canceled",
-				dispatch_source_get_handle(ds), mp);
-		test_mach_debug_port(mp);
-		kern_return_t kr = mach_port_mod_refs(mach_task_self(), mp,
-				MACH_PORT_RIGHT_RECEIVE, -1); // trigger dead name notification
-		test_mach_error("mach_port_mod_refs", kr, KERN_SUCCESS);
-		test_mach_debug_port(mp);
-	});
-	dispatch_resume(ds);
-	dsp = dispatch_source_create(DISPATCH_SOURCE_TYPE_MACH_SEND, mp,
-			DISPATCH_MACH_SEND_POSSIBLE, dispatch_get_global_queue(0, 0));
-	dispatch_source_set_registration_handler(dsp, ^{
-		test_long("DISPATCH_MACH_SEND_POSSIBLE registered",
-				dispatch_source_get_handle(dsp), mp);
-		if (!send_until_timeout(mp)) {
-			dispatch_source_cancel(dsp); // stop sending
-			dispatch_release(dsp);
-		}
-	});
-	dispatch_source_set_event_handler(dsp, ^{
-		test_long("DISPATCH_MACH_SEND_POSSIBLE delivered",
-				dispatch_source_get_handle(dsp), mp);
-		if (!send_until_timeout(mp)) {
-			dispatch_source_cancel(dsp); // stop sending
-			dispatch_release(dsp);
-		}
-	});
-	dispatch_source_set_cancel_handler(dsp, ^{
-		test_long("DISPATCH_MACH_SEND_POSSIBLE canceled",
-				dispatch_source_get_handle(dsp), mp);
-		test_mach_debug_port(mp);
-		dispatch_source_cancel(ds); // stop receving
-		dispatch_release(ds);
-	});
-	dispatch_resume(dsp);
-	dispatch_group_wait(g, DISPATCH_TIME_FOREVER);
-	test_long("DISPATCH_SOURCE_TYPE_MACH_SEND", sent, TEST_SP_MSGCOUNT);
-	test_long("DISPATCH_SOURCE_TYPE_MACH_RECV", received, TEST_SP_MSGCOUNT);
-}
-
-#else
-#define test_send_possible()
-#endif
-
-static boolean_t
-test_mig_callback(mach_msg_header_t *message __attribute__((unused)),
-		mach_msg_header_t *reply)
-{
-	__sync_add_and_fetch(&received, 1);
-	reply->msgh_remote_port = 0;
-	return false;
-}
-
-void
-test_mig_server_large_msg(void) // rdar://problem/8422992
-{
-	dispatch_source_t ds;
-	kern_return_t kr;
-	mach_port_t mp;
-
-	received = 0;
-	dispatch_group_enter(g);
-	kr = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &mp);
-	test_mach_error("mach_port_allocate", kr, KERN_SUCCESS);
-	kr = mach_port_insert_right(mach_task_self(), mp, mp,
-			MACH_MSG_TYPE_MAKE_SEND);
-	test_mach_error("mach_port_insert_right", kr, KERN_SUCCESS);
-	ds = dispatch_source_create(DISPATCH_SOURCE_TYPE_MACH_RECV, mp, 0,
-			dispatch_get_global_queue(0, 0));
-	dispatch_source_set_event_handler(ds, ^{
-		mach_msg_return_t r = dispatch_mig_server(ds, sizeof(mach_msg_header_t),
-				test_mig_callback);
-		test_mach_error("dispatch_mig_server", r, MACH_RCV_TOO_LARGE);
-		dispatch_group_leave(g);
-	});
-	dispatch_source_set_cancel_handler(ds, ^{
-		kern_return_t kr = mach_port_mod_refs(mach_task_self(), mp,
-				MACH_PORT_RIGHT_RECEIVE, -1);
-		test_mach_error("mach_port_mod_refs", kr, KERN_SUCCESS);
-		kr = mach_port_deallocate(mach_task_self(), mp);
-		test_mach_error("mach_port_deallocate", kr, KERN_SUCCESS);
-		dispatch_group_leave(g);
-	});
-	dispatch_resume(ds);
-
-	struct { mach_msg_header_t header; char payload[4096]; } msg = {
-		.header = {
-			.msgh_bits = MACH_MSGH_BITS_REMOTE(MACH_MSG_TYPE_COPY_SEND),
-			.msgh_size = sizeof(mach_msg_header_t) + 4096,
-			.msgh_remote_port = mp,
-			.msgh_id = 0xfeedface,
-		}
-	};
-	kr = mach_msg_send(&msg.header);
-	test_mach_error("mach_msg_send", kr, KERN_SUCCESS);
-	dispatch_group_wait(g, DISPATCH_TIME_FOREVER);
-	dispatch_group_enter(g);
-	dispatch_source_cancel(ds);
-	dispatch_release(ds);
-	test_long("DISPATCH_SOURCE_TYPE_MACH_RECV", received, 0);
-	dispatch_group_wait(g, DISPATCH_TIME_FOREVER);
-}
-
-int
-main(void)
-{
-	dispatch_test_start("Dispatch dead-name and send-possible notifications");
-
-	dispatch_async(dispatch_get_global_queue(0, 0), ^{
-		g = dispatch_group_create();
-		test_dead_name();
-		test_register_already_dead_name();
-		test_receive_and_dead_name();
-		test_send_possible();
-		test_mig_server_large_msg();
-		test_stop();
-	});
-
-	dispatch_main();
-
-	return 0;
-}
--- a/Telegram/ThirdParty/dispatch/tests/dispatch_debug.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/dispatch_debug.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,55 +0,0 @@
-/*
- * Copyright (c) 2008-2011 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include <assert.h>
-#include <stdio.h>
-#include <string.h>
-#include <stdlib.h>
-
-#include <dispatch/dispatch.h>
-
-#include <bsdtests.h>
-#include "dispatch_test.h"
-
-int
-main(void)
-{
-#if defined(_WIN32)
-	_putenv_s("LIBDISPATCH_LOG", "stderr");
-#else
-	setenv("LIBDISPATCH_LOG", "stderr", 1); // rdar://problem/8493990
-#endif
-	dispatch_test_start("Dispatch Debug");
-
-	dispatch_queue_t main_q = dispatch_get_main_queue();
-	dispatch_debug(main_q, "dispatch_queue_t");
-
-	dispatch_queue_t default_q = dispatch_get_global_queue(0, 0);
-	dispatch_debug(default_q, "dispatch_queue_t");
-
-	dispatch_source_t s = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, main_q);
-	dispatch_source_set_timer(s, DISPATCH_TIME_FOREVER, 1000000000ull, 100);
-	dispatch_debug(s, "dispatch_source_t");
-
-	dispatch_group_t g = dispatch_group_create();
-	dispatch_debug(g, "dispatch_group_t");
-
-	return 0;
-}
--- a/Telegram/ThirdParty/dispatch/tests/dispatch_drift.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/dispatch_drift.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,102 +0,0 @@
-/*
- * Copyright (c) 2008-2011 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#ifdef __APPLE__
-#include <mach/mach_time.h>
-#endif
-#include <dispatch/dispatch.h>
-#if defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))
-#include <sys/time.h>
-#include <unistd.h>
-#endif
-#include <stdio.h>
-#include <stdlib.h>
-#ifdef __APPLE__
-#include <TargetConditionals.h>
-#endif
-#include <bsdtests.h>
-#include "dispatch_test.h"
-
-#if LENIENT_DEADLINES
-#define ACCEPTABLE_DRIFT 0.1
-#else
-#define ACCEPTABLE_DRIFT 0.001
-#endif
-
-int
-main(int argc __attribute__((unused)), char* argv[] __attribute__((unused)))
-{
-	__block uint32_t count = 0;
-	__block double last_jitter = 0;
-	__block double drift_sum = 0;
-#if defined(_WIN32)
-	// 25 times a second (Windows timer resolution is poor)
-	uint64_t interval = 1000000000 / 25;
-#else
-	// 100 times a second
-	uint64_t interval = 1000000000 / 100;
-#endif
-	double interval_d = interval / 1000000000.0;
-	// for 25 seconds
-	unsigned int target = (unsigned int)(25.0 / interval_d);
-
-	dispatch_test_start("Dispatch Timer Drift");
-
-	dispatch_source_t t = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());
-	test_ptr_notnull("dispatch_source_create", t);
-
-	dispatch_source_set_timer(t, dispatch_time(DISPATCH_TIME_NOW, (int64_t)interval), interval, 0);
-
-	dispatch_source_set_event_handler(t, ^{
-		struct timeval now_tv;
-		static double first = 0;
-		gettimeofday(&now_tv, NULL);
-		double now = now_tv.tv_sec + now_tv.tv_usec / 1000000.0;
-
-		if (count == 0) {
-			// Because this is taken at 1st timer fire,
-			// later jitter values may be negitave.
-			// This doesn't effect the drift calculation.
-			first = now;
-		}
-		double goal = first + interval_d * count;
-		double jitter = goal - now;
-		double drift = jitter - last_jitter;
-		drift_sum += drift;
-
-		printf("%4d: jitter %f, drift %f\n", count, jitter, drift);
-
-		if (target <= ++count) {
-			drift_sum /= count - 1;
-			if (drift_sum < 0) {
-				drift_sum = -drift_sum;
-			}
-			double acceptable_drift = ACCEPTABLE_DRIFT;
-			test_double_less_than("drift", drift_sum, acceptable_drift);
-			test_stop();
-		}
-		last_jitter = jitter;
-	});
-
-	dispatch_resume(t);
-
-	dispatch_main();
-	return 0;
-}
--- a/Telegram/ThirdParty/dispatch/tests/dispatch_group.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/dispatch_group.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,204 +0,0 @@
-/*
- * Copyright (c) 2008-2011 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include <dispatch/dispatch.h>
-#if defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))
-#include <unistd.h>
-#endif
-#include <stdarg.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <assert.h>
-#ifdef __APPLE__
-#include <libkern/OSAtomic.h>
-#endif
-#include <math.h>
-#include <bsdtests.h>
-#include "dispatch_test.h"
-
-#ifndef NSEC_PER_SEC
-#define NSEC_PER_SEC 1000000000
-#endif
-
-#if TARGET_OS_EMBEDDED
-#define LOOP_COUNT 50000
-#else
-#define LOOP_COUNT 200000
-#endif
-
-static void test_group_notify(void*);
-
-static dispatch_group_t
-create_group(size_t count, unsigned int delay)
-{
-	size_t i;
-
-	dispatch_group_t group = dispatch_group_create();
-
-	for (i = 0; i < count; ++i) {
-		dispatch_queue_t queue = dispatch_queue_create(NULL, NULL);
-		assert(queue);
-
-		dispatch_group_async(group, queue, ^{
-			if (delay) {
-				fprintf(stderr, "sleeping...\n");
-				sleep(delay);
-				fprintf(stderr, "done.\n");
-			}
-		});
-
-		dispatch_release(queue);
-		}
-	return group;
-}
-
-static void
-test_group(void *ctxt __attribute__((unused)))
-{
-	long res;
-	dispatch_group_t group;
-
-	group = create_group(100, 0);
-	test_ptr_notnull("dispatch_group_async", group);
-
-	dispatch_group_wait(group, DISPATCH_TIME_FOREVER);
-
-	// should be OK to re-use a group
-	dispatch_group_async(group, dispatch_get_global_queue(0, 0), ^{});
-	dispatch_group_wait(group, DISPATCH_TIME_FOREVER);
-
-	dispatch_release(group);
-	group = NULL;
-
-	group = create_group(3, 7);
-	test_ptr_notnull("dispatch_group_async", group);
-
-	res = dispatch_group_wait(group, dispatch_time(DISPATCH_TIME_NOW, 5ull * NSEC_PER_SEC));
-	test_long("dispatch_group_wait", !res, 0);
-
-	// retry after timeout (this time succeed)
-	res = dispatch_group_wait(group, dispatch_time(DISPATCH_TIME_NOW, 5ull * NSEC_PER_SEC));
-	test_long("dispatch_group_wait", res, 0);
-
-	dispatch_release(group);
-	group = NULL;
-
-	group = create_group(100, 0);
-	test_ptr_notnull("dispatch_group_async", group);
-
-	dispatch_group_notify(group, dispatch_get_main_queue(), ^{
-		dispatch_test_current("Notification Received", dispatch_get_main_queue());
-		dispatch_async_f(dispatch_get_main_queue(), NULL, test_group_notify);
-	});
-
-	dispatch_release(group);
-	group = NULL;
-}
-
-static long completed;
-
-static void
-test_group_notify2(long cycle, dispatch_group_t tested)
-{
-	static dispatch_queue_t rq, nq;
-	static dispatch_once_t once;
-	dispatch_once(&once, ^{
-		rq = dispatch_queue_create("release", 0);
-		dispatch_suspend(rq);
-		nq = dispatch_queue_create("notify", 0);
-	});
-	dispatch_resume(rq);
-
-	// n=4 works great for a 4CPU Mac Pro, this might work for a wider range of
-	// systems.
-#if HAVE_ARC4RANDOM
-	const int n = 1 + arc4random() % 8;
-#else
-    const int n = 1 + random() % 8;
-#endif
-	dispatch_group_t group = dispatch_group_create();
-	dispatch_queue_t qa[n];
-
-	dispatch_group_enter(group);
-	for (int i = 0; i < n; i++) {
-		char buf[48];
-		sprintf(buf, "T%ld-%d", cycle, i);
-		qa[i] = dispatch_queue_create(buf, 0);
-	}
-
-	__block float eh = 0;
-	for (int i = 0; i < n; i++) {
-		dispatch_queue_t q = qa[i];
-		dispatch_group_async(group, q, ^{
-			// Seems to trigger a little more reliably with some work being
-			// done in this block
-			assert(cycle && "cycle must be non-zero");
-			eh = (float)sin(M_1_PI / cycle);
-		});
-	}
-	dispatch_group_leave(group);
-
-	dispatch_group_notify(group, nq, ^{
-		completed = cycle;
-		dispatch_group_leave(tested);
-	});
-
-	// Releasing qa's queues here seems to avoid the race, so we are arranging
-	// for the current iteration's queues to be released on the next iteration.
-	dispatch_sync(rq, ^{});
-	dispatch_suspend(rq);
-	for (int i = 0; i < n; i++) {
-		dispatch_queue_t q = qa[i];
-		dispatch_async(rq, ^{ dispatch_release(q); });
-	}
-	dispatch_release(group);
-}
-
-static void
-test_group_notify(void *ctxt __attribute__((unused)))
-{
-	// <rdar://problem/11445820>
-	dispatch_group_t tested = dispatch_group_create();
-	test_ptr_notnull("dispatch_group_create", tested);
-	long i;
-	for (i = 1; i <= LOOP_COUNT; i++) {
-		if (!(i % (LOOP_COUNT/10))) {
-			fprintf(stderr, "#%ld\n", i);
-		}
-		dispatch_group_enter(tested);
-		test_group_notify2(i, tested);
-		if (dispatch_group_wait(tested, dispatch_time(DISPATCH_TIME_NOW,
-				NSEC_PER_SEC))) {
-			break;
-		}
-	}
-	test_long("dispatch_group_notify", i - 1, LOOP_COUNT);
-	test_stop();
-}
-
-int
-main(void)
-{
-	dispatch_test_start("Dispatch Group");
-	dispatch_async_f(dispatch_get_main_queue(), NULL, test_group);
-	dispatch_main();
-
-	return 0;
-}
--- a/Telegram/ThirdParty/dispatch/tests/dispatch_io.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/dispatch_io.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,849 +0,0 @@
-/*
- * Copyright (c) 2009-2011 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include <sys/stat.h>
-#include <sys/types.h>
-#include <assert.h>
-#include <fcntl.h>
-#include <stdatomic.h>
-#include <stdio.h>
-#include <stdlib.h>
-#if defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))
-#include <fts.h>
-#include <sys/param.h>
-#include <unistd.h>
-#endif
-#include <errno.h>
-#ifdef __APPLE__
-#include <mach/mach.h>
-#include <mach/mach_time.h>
-#include <libkern/OSAtomic.h>
-#include <TargetConditionals.h>
-#endif
-#ifdef __linux__
-#include <sys/resource.h>
-#endif
-
-#include <dispatch/dispatch.h>
-
-#include <bsdtests.h>
-#include "dispatch_test.h"
-
-#ifndef DISPATCHTEST_IO
-#if DISPATCH_API_VERSION >= 20100226 && DISPATCH_API_VERSION != 20101110
-#define DISPATCHTEST_IO 1
-#if DISPATCH_API_VERSION >= 20100723
-#define DISPATCHTEST_IO_PATH 1 // rdar://problem/7738093
-#endif
-#endif
-#endif
-
-static void
-test_fin(void *cxt)
-{
-	test_ptr("test_fin run", cxt, cxt);
-	test_stop();
-}
-
-#if DISPATCHTEST_IO
-
-#if TARGET_OS_EMBEDDED
-#define LARGE_FILE "/System/Library/Fonts/Cache/STHeiti-Light.ttc" // 29MB file
-#define maxopenfiles 768
-#else
-#define LARGE_FILE "/System/Library/Speech/Voices/Alex.SpeechVoice/Contents/Resources/PCMWave" // 417MB file
-#define maxopenfiles 4096
-#endif
-
-static void
-test_io_close(int with_timer, bool from_path)
-{
-	#define chunks 4
-	#define READSIZE (512*1024)
-	unsigned int i;
-	const char *path = LARGE_FILE;
-	dispatch_fd_t fd = dispatch_test_fd_open(path, O_RDONLY);
-	if (fd == -1) {
-		if (errno == ENOENT) {
-			test_skip("Large file not found");
-			return;
-		}
-		test_errno("open", errno, 0);
-		test_stop();
-	}
-#ifdef F_GLOBAL_NOCACHE
-	if (fcntl(fd, F_GLOBAL_NOCACHE, 1) == -1) {
-		test_errno("fcntl F_GLOBAL_NOCACHE", errno, 0);
-		test_stop();
-	}
-#endif
-	const size_t size = (size_t)dispatch_test_fd_lseek(fd, 0, SEEK_END) / chunks;
-	dispatch_test_fd_lseek(fd, 0, SEEK_SET);
-	const int expected_error = with_timer? ECANCELED : 0;
-	dispatch_source_t t = NULL;
-	dispatch_group_t g = dispatch_group_create();
-	dispatch_group_enter(g);
-	void (^cleanup_handler)(int error) = ^(int error) {
-		test_errno("create error", error, 0);
-		dispatch_group_leave(g);
-		dispatch_test_fd_close(fd);
-	};
-	dispatch_io_t io;
-	if (!from_path) {
-		io = dispatch_io_create(DISPATCH_IO_RANDOM, fd,
-				dispatch_get_global_queue(0, 0), cleanup_handler);
-	} else {
-#if DISPATCHTEST_IO_PATH
-		io = dispatch_io_create_with_path(DISPATCH_IO_RANDOM, path, O_RDONLY, 0,
-				dispatch_get_global_queue(0, 0), cleanup_handler);
-#endif
-	}
-	dispatch_io_set_high_water(io, READSIZE);
-	if (with_timer == 1) {
-		dispatch_io_set_low_water(io, READSIZE);
-		dispatch_io_set_interval(io,  2 * NSEC_PER_SEC,
-				DISPATCH_IO_STRICT_INTERVAL);
-	} else if (with_timer == 2) {
-		t = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0,
-				dispatch_get_global_queue(0,0));
-		dispatch_retain(io);
-		dispatch_source_set_event_handler(t, ^{
-			dispatch_io_close(io, DISPATCH_IO_STOP);
-			dispatch_source_cancel(t);
-		});
-		dispatch_source_set_cancel_handler(t, ^{
-			dispatch_release(io);
-		});
-		dispatch_source_set_timer(t, dispatch_time(DISPATCH_TIME_NOW,
-				2 * NSEC_PER_SEC), DISPATCH_TIME_FOREVER, 0);
-		dispatch_resume(t);
-	}
-
-	size_t chunk_sizes[chunks] = {}, *chunk_size = chunk_sizes, total = 0;
-	dispatch_data_t data_chunks[chunks], *data = data_chunks;
-	for (i = 0; i < chunks; i++) {
-		data[i] = dispatch_data_empty;
-		dispatch_group_enter(g);
-		dispatch_io_read(io, (off_t)(i * size), size, dispatch_get_global_queue(0,0),
-				^(bool done, dispatch_data_t d, int error) {
-			if (d) {
-				chunk_size[i] += dispatch_data_get_size(d);
-				dispatch_data_t concat = dispatch_data_create_concat(data[i], d);
-				dispatch_release(data[i]);
-				data[i] = concat;
-				if ((dispatch_data_get_size(d) < READSIZE && !error && !done)) {
-					// The timer must have fired
-					dispatch_io_close(io, DISPATCH_IO_STOP);
-					return;
-				}
-			}
-			if (done) {
-				test_errno("read error", error,
-						error == expected_error ? expected_error : 0);
-				dispatch_group_leave(g);
-				dispatch_release(data[i]);
-			}
-		});
-	}
-	dispatch_io_close(io, 0);
-	dispatch_io_close(io, 0);
-	dispatch_io_read(io, 0, 1, dispatch_get_global_queue(0,0),
-			^(bool done, dispatch_data_t d, int error) {
-		test_long("closed done", done, true);
-		test_errno("closed error", error, ECANCELED);
-		test_ptr_null("closed data", d);
-	});
-	dispatch_release(io);
-	test_group_wait(g);
-	dispatch_release(g);
-	if (t) {
-		dispatch_source_cancel(t);
-		dispatch_release(t);
-	}
-	for (i = 0; i < chunks; i++) {
-		if (with_timer) {
-			test_sizet_less_than("chunk size", chunk_size[i], size + 1);
-		} else {
-			test_sizet("chunk size", chunk_size[i], size);
-		}
-		total += chunk_size[i];
-	}
-	if (with_timer) {
-		test_sizet_less_than("total size", total, chunks * size + 1);
-	} else {
-		test_sizet("total size", total, chunks * size);
-	}
-}
-
-static void
-test_io_stop(void) // rdar://problem/8250057
-{
-	dispatch_fd_t fds[2], *fd = fds;
-#if defined(_WIN32)
-	if (!CreatePipe((PHANDLE)&fds[0], (PHANDLE)&fds[1], NULL, 0)) {
-		test_long("CreatePipe", GetLastError(), ERROR_SUCCESS);
-		test_stop();
-	}
-#else
-	if(pipe(fd) == -1) {
-		test_errno("pipe", errno, 0);
-		test_stop();
-	}
-#endif
-	dispatch_group_t g = dispatch_group_create();
-	dispatch_group_enter(g);
-	dispatch_io_t io = dispatch_io_create(DISPATCH_IO_STREAM, *fd,
-			dispatch_get_global_queue(0, 0), ^(int error) {
-		test_errno("create error", error, 0);
-		dispatch_test_fd_close(*fd);
-		dispatch_test_fd_close(*(fd+1));
-		dispatch_group_leave(g);
-	});
-	dispatch_group_enter(g);
-	dispatch_io_read(io, 0, 1, dispatch_get_global_queue(0, 0),
-			^(bool done, dispatch_data_t d __attribute__((unused)), int error) {
-		if (done) {
-			test_errno("read error", error, ECANCELED);
-			dispatch_group_leave(g);
-		}
-	});
-	dispatch_source_t t = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0,
-			0, dispatch_get_global_queue(0,0));
-	dispatch_retain(io);
-	dispatch_source_set_event_handler(t, ^{
-		dispatch_io_close(io, DISPATCH_IO_STOP);
-		dispatch_release(io);
-	});
-	dispatch_source_set_timer(t, dispatch_time(DISPATCH_TIME_NOW,
-			2 * NSEC_PER_SEC), DISPATCH_TIME_FOREVER, 0);
-	dispatch_resume(t);
-	dispatch_release(io);
-	test_group_wait(g);
-	dispatch_release(g);
-	dispatch_source_cancel(t);
-	dispatch_release(t);
-}
-
-static void
-test_io_read_write(void)
-{
-	char *path_in = dispatch_test_get_large_file();
-#if defined(_WIN32)
-	char *temp_dir = getenv("TMP");
-	if (!temp_dir) {
-		temp_dir = getenv("TEMP");
-	}
-	if (!temp_dir) {
-		test_ptr_notnull("temporary directory", temp_dir);
-		test_stop();
-	}
-	char *path_out = NULL;
-	asprintf(&path_out, "%s\\dispatchtest_io.XXXXXX", temp_dir);
-#else
-	char path_out[] = "/tmp/dispatchtest_io.XXXXXX";
-#endif
-
-	dispatch_fd_t in = dispatch_test_fd_open(path_in, O_RDONLY);
-	if (in == -1) {
-		test_errno("open", errno, 0);
-		test_stop();
-	}
-	dispatch_test_release_large_file(path_in);
-	free(path_in);
-	const size_t siz_in =
-			MIN(1024 * 1024, (size_t)dispatch_test_fd_lseek(in, 0, SEEK_END));
-	dispatch_test_fd_lseek(in, 0, SEEK_SET);
-
-	dispatch_fd_t out = mkstemp(path_out);
-	if (out == -1) {
-		test_errno("mkstemp", errno, 0);
-		test_stop();
-	}
-	if (unlink(path_out) == -1) {
-		test_errno("unlink", errno, 0);
-		test_stop();
-	}
-#if defined(_WIN32)
-	free(path_out);
-#endif
-	dispatch_queue_t q = dispatch_get_global_queue(0,0);
-	dispatch_group_t g = dispatch_group_create();
-	dispatch_group_enter(g);
-	dispatch_io_t io_in = dispatch_io_create(DISPATCH_IO_STREAM, in,
-			q, ^(int error) {
-		test_errno("dispatch_io_create", error, 0);
-		dispatch_test_fd_close(in);
-		dispatch_group_leave(g);
-	});
-	dispatch_io_set_high_water(io_in, siz_in/4);
-	dispatch_group_enter(g);
-	dispatch_io_t io_out = dispatch_io_create(DISPATCH_IO_STREAM, out,
-			q, ^(int error) {
-		test_errno("dispatch_io_create", error, 0);
-		dispatch_group_leave(g);
-	});
-	dispatch_io_set_high_water(io_out, siz_in/16);
-	__block dispatch_data_t data = dispatch_data_empty;
-	dispatch_group_enter(g);
-	dispatch_io_read(io_in, 0, siz_in, q,
-			^(bool done_in, dispatch_data_t data_in, int err_in) {
-		test_sizet_less_than("read size", dispatch_data_get_size(data_in),
-				siz_in);
-		if (data_in) {
-			dispatch_group_enter(g);
-			dispatch_io_write(io_out, 0, data_in, q,
-					^(bool done_out, dispatch_data_t data_out, int err_out) {
-				if (done_out) {
-					test_errno("dispatch_io_write", err_out, 0);
-					test_sizet("remaining write size",
-							data_out ? dispatch_data_get_size(data_out) : 0, 0);
-					dispatch_group_leave(g);
-				} else {
-					test_sizet_less_than("remaining write size",
-							dispatch_data_get_size(data_out), siz_in);
-				}
-			});
-			dispatch_data_t concat = dispatch_data_create_concat(data, data_in);
-			dispatch_release(data);
-			data = concat;
-		}
-		if (done_in) {
-			test_errno("dispatch_io_read", err_in, 0);
-			dispatch_release(io_out);
-			dispatch_group_leave(g);
-		}
-	});
-	dispatch_release(io_in);
-	test_group_wait(g);
-	dispatch_test_fd_lseek(out, 0, SEEK_SET);
-	dispatch_group_enter(g);
-	dispatch_read(out, siz_in, q,
-			^(dispatch_data_t cmp, int err_cmp) {
-		if (err_cmp) {
-			test_errno("dispatch_read", err_cmp, 0);
-			test_stop();
-		}
-		dispatch_test_fd_close(out);
-		size_t siz_cmp = dispatch_data_get_size(cmp);
-		test_sizet("readback size", siz_cmp, siz_in);
-		const void *data_buf, *cmp_buf;
-		dispatch_data_t data_map, cmp_map;
-		data_map = dispatch_data_create_map(data, &data_buf, NULL);
-		cmp_map = dispatch_data_create_map(cmp, &cmp_buf, NULL);
-		test_long("readback memcmp",
-				memcmp(data_buf, cmp_buf, MIN(siz_in, siz_cmp)), 0);
-		dispatch_release(cmp_map);
-		dispatch_release(data_map);
-		dispatch_release(data);
-		dispatch_group_leave(g);
-	});
-	test_group_wait(g);
-	dispatch_release(g);
-}
-
-enum {
-	DISPATCH_ASYNC_READ_ON_CONCURRENT_QUEUE = 0,
-	DISPATCH_ASYNC_READ_ON_SERIAL_QUEUE,
-	DISPATCH_READ_ON_CONCURRENT_QUEUE,
-	DISPATCH_IO_READ_ON_CONCURRENT_QUEUE,
-	DISPATCH_IO_READ_FROM_PATH_ON_CONCURRENT_QUEUE,
-};
-
-static void
-test_async_read(char *path, size_t size, int option, dispatch_queue_t queue,
-		void (^process_data)(size_t))
-{
-	dispatch_fd_t fd = dispatch_test_fd_open(path, O_RDONLY);
-	if (fd == -1) {
-		// Don't stop for access permission issues
-		if (errno == EACCES) {
-			process_data(size);
-			return;
-		}
-		test_errno("Failed to open file", errno, 0);
-		test_stop();
-	}
-#ifdef F_GLOBAL_NOCACHE
-	// disable caching also for extra fd opened by dispatch_io_create_with_path
-	if (fcntl(fd, F_GLOBAL_NOCACHE, 1) == -1) {
-		test_errno("fcntl F_GLOBAL_NOCACHE", errno, 0);
-		test_stop();
-	}
-#endif
-	switch (option) {
-		case DISPATCH_ASYNC_READ_ON_CONCURRENT_QUEUE:
-		case DISPATCH_ASYNC_READ_ON_SERIAL_QUEUE:
-			dispatch_async(queue, ^{
-				char* buffer = NULL;
-#if defined(_WIN32)
-				SYSTEM_INFO si;
-				GetSystemInfo(&si);
-				buffer = _aligned_malloc(size, si.dwPageSize);
-#else
-				size_t pagesize = (size_t)sysconf(_SC_PAGESIZE);
-				posix_memalign((void **)&buffer, pagesize, size);
-#endif
-				ssize_t r = dispatch_test_fd_read(fd, buffer, size);
-				if (r == -1) {
-					test_errno("async read error", errno, 0);
-					test_stop();
-				}
-#if defined(_WIN32)
-				_aligned_free(buffer);
-#else
-				free(buffer);
-#endif
-				dispatch_test_fd_close(fd);
-				process_data((size_t)r);
-			});
-			break;
-		case DISPATCH_READ_ON_CONCURRENT_QUEUE:
-			dispatch_read(fd, size, queue, ^(dispatch_data_t d, int error) {
-				if (error) {
-					test_errno("dispatch_read error", error, 0);
-					test_stop();
-				}
-				dispatch_test_fd_close(fd);
-				process_data(dispatch_data_get_size(d));
-			});
-			break;
-		case DISPATCH_IO_READ_ON_CONCURRENT_QUEUE:
-		case DISPATCH_IO_READ_FROM_PATH_ON_CONCURRENT_QUEUE: {
-			__block dispatch_data_t d = dispatch_data_empty;
-			void (^cleanup_handler)(int error) = ^(int error) {
-				if (error) {
-					test_errno("dispatch_io_create error", error, 0);
-					test_stop();
-				}
-				dispatch_test_fd_close(fd);
-				process_data(dispatch_data_get_size(d));
-				dispatch_release(d);
-			};
-			dispatch_io_t io = NULL;
-			if (option == DISPATCH_IO_READ_FROM_PATH_ON_CONCURRENT_QUEUE) {
-#if DISPATCHTEST_IO_PATH
-				io = dispatch_io_create_with_path(DISPATCH_IO_RANDOM, path,
-						O_RDONLY, 0, queue, cleanup_handler);
-#endif
-			} else {
-				io = dispatch_io_create(DISPATCH_IO_RANDOM, fd, queue,
-						cleanup_handler);
-			}
-			if (!io) {
-				test_ptr_notnull("dispatch_io_create", io);
-				test_stop();
-			}
-
-			// Timeout after 20 secs
-			dispatch_io_set_interval(io, 20 * NSEC_PER_SEC,
-					DISPATCH_IO_STRICT_INTERVAL);
-
-			dispatch_io_read(io, 0, size, queue,
-					^(bool done, dispatch_data_t data, int error) {
-				if (!done && !error && !dispatch_data_get_size(data)) {
-					// Timer fired, and no progress from last delivery
-					dispatch_io_close(io, DISPATCH_IO_STOP);
-				}
-				if (data) {
-					dispatch_data_t c = dispatch_data_create_concat(d, data);
-					dispatch_release(d);
-					d = c;
-				}
-				if (error) {
-					test_errno("dispatch_io_read error", error, 0);
-					if (error != ECANCELED) {
-						test_stop();
-					}
-				}
-			});
-			dispatch_release(io);
-			break;
-		}
-	}
-}
-
-static void
-test_enumerate_dir_trees(char **paths,
-		void (^process_file)(char *path, size_t size))
-{
-#if defined(_WIN32)
-	for (size_t i = 0; paths[i]; i++) {
-		char *search_path = NULL;
-		asprintf(&search_path, "%s\\*", paths[i]);
-		WIN32_FIND_DATAA node;
-		HANDLE find = FindFirstFileA(search_path, &node);
-		free(search_path);
-		if (find == INVALID_HANDLE_VALUE) {
-			if (GetLastError() == ERROR_ACCESS_DENIED) {
-				return;
-			}
-			test_ptr_not("FindFirstFile", find, INVALID_HANDLE_VALUE);
-			test_stop();
-		}
-		do {
-			if (strcmp(node.cFileName, ".") == 0 ||
-					strcmp(node.cFileName, "..") == 0) {
-				continue;
-			}
-			char *node_path = NULL;
-			asprintf(&node_path, "%s\\%s", paths[i], node.cFileName);
-			if (node.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
-				char *subdir_paths[] = {node_path, NULL};
-				test_enumerate_dir_trees(subdir_paths, process_file);
-			} else {
-				size_t size = (size_t)(((uint64_t)node.nFileSizeHigh << 32) |
-						node.nFileSizeLow);
-				process_file(node_path, size);
-			}
-			free(node_path);
-		} while (FindNextFileA(find, &node));
-		FindClose(find);
-	}
-#else
-	FTS *tree = fts_open(paths, FTS_PHYSICAL|FTS_XDEV, NULL);
-	if (!tree) {
-		test_ptr_notnull("fts_open failed", tree);
-		test_stop();
-	}
-	FTSENT *node;
-	while ((node = fts_read(tree)) &&
-			!(node->fts_info == FTS_ERR || node->fts_info == FTS_NS)) {
-		if (node->fts_level > 0 && node->fts_name[0] == '.') {
-			fts_set(tree, node, FTS_SKIP);
-		} else if (node->fts_info == FTS_F) {
-			size_t size = (size_t)node->fts_statp->st_size;
-			process_file(node->fts_path, size);
-		}
-	}
-	if ((!node && errno) || (node && (node->fts_info == FTS_ERR ||
-			node->fts_info == FTS_NS))) {
-		test_errno("fts_read failed", !node ? errno : node->fts_errno, 0);
-		test_stop();
-	}
-	if (fts_close(tree)) {
-		test_errno("fts_close failed", errno, 0);
-		test_stop();
-	}
-#endif
-}
-
-static int
-test_read_dirs(char **paths, dispatch_queue_t queue, dispatch_group_t g,
-		dispatch_semaphore_t s, _Atomic size_t *bytes, int option)
-{
-	__block int files_opened = 0;
-	__block size_t total_size = 0;
-	test_enumerate_dir_trees(paths, ^(char *path, size_t size){
-		dispatch_group_enter(g);
-		dispatch_semaphore_wait(s, DISPATCH_TIME_FOREVER);
-		total_size += size;
-		files_opened++;
-		test_async_read(path, size, option, queue, ^(size_t len){
-			atomic_fetch_add_explicit(bytes, len, memory_order_relaxed);
-			dispatch_semaphore_signal(s);
-			dispatch_group_leave(g);
-		});
-	});
-	test_group_wait(g);
-	test_sizet("total size", *bytes, total_size);
-	return files_opened;
-}
-
-#if defined(_WIN32)
-extern __declspec(dllimport)
-#else
-extern __attribute__((weak_import))
-#endif
-void
-_dispatch_iocntl(uint32_t param, uint64_t value);
-
-enum {
-	DISPATCH_IOCNTL_CHUNK_PAGES = 1,
-	DISPATCH_IOCNTL_LOW_WATER_CHUNKS,
-	DISPATCH_IOCNTL_INITIAL_DELIVERY,
-};
-
-static void
-test_read_many_files(void)
-{
-#if defined(_WIN32)
-	char *paths[] = {NULL, NULL};
-	char *system_root = getenv("SystemRoot");
-	if (!system_root) {
-		test_ptr_notnull("SystemRoot", system_root);
-		test_stop();
-	}
-	asprintf(&paths[0], "%s\\System32", system_root);
-#else
-	char *paths[] = {"/usr/lib", NULL};
-#endif
-
-	dispatch_group_t g = dispatch_group_create();
-	dispatch_semaphore_t s = dispatch_semaphore_create(maxopenfiles);
-	uint64_t start;
-	_Atomic size_t bytes;
-	int files_read, i;
-
-	const dispatch_queue_t queues[] = {
-		[DISPATCH_ASYNC_READ_ON_CONCURRENT_QUEUE] =
-				dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0),
-		[DISPATCH_ASYNC_READ_ON_SERIAL_QUEUE] =
-				dispatch_queue_create("read", NULL),
-		[DISPATCH_READ_ON_CONCURRENT_QUEUE] =
-				dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0),
-		[DISPATCH_IO_READ_ON_CONCURRENT_QUEUE] =
-				dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0),
-#if DISPATCHTEST_IO_PATH
-		[DISPATCH_IO_READ_FROM_PATH_ON_CONCURRENT_QUEUE] =
-				dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0),
-#endif
-	};
-	dispatch_set_target_queue(queues[DISPATCH_ASYNC_READ_ON_SERIAL_QUEUE],
-			dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0));
-	static const char *names[] = {
-		[DISPATCH_ASYNC_READ_ON_CONCURRENT_QUEUE] =
-			"dispatch_async(^{read();}) on concurrent queue",
-		[DISPATCH_ASYNC_READ_ON_SERIAL_QUEUE] =
-			"dispatch_async(^{read();}) on serial queue",
-		[DISPATCH_READ_ON_CONCURRENT_QUEUE] =
-			"dispatch_read() on concurrent queue",
-		[DISPATCH_IO_READ_ON_CONCURRENT_QUEUE] =
-			"dispatch_io_read() on concurrent queue",
-		[DISPATCH_IO_READ_FROM_PATH_ON_CONCURRENT_QUEUE] =
-			"dispatch_io_read() from path on concurrent queue",
-	};
-
-	if (&_dispatch_iocntl) {
-		const size_t chunk_pages = 3072;
-		_dispatch_iocntl(DISPATCH_IOCNTL_CHUNK_PAGES, (uint64_t)chunk_pages);
-	}
-#if !defined(_WIN32)
-	struct rlimit l;
-	if (!getrlimit(RLIMIT_NOFILE, &l) && l.rlim_cur < 2 * maxopenfiles + 256) {
-		l.rlim_cur = 2 * maxopenfiles + 256;
-		setrlimit(RLIMIT_NOFILE, &l);
-	}
-#endif
-	for (i = 0; i < (int)(sizeof(queues)/sizeof(dispatch_queue_t)); ++i) {
-		fprintf(stdout, "%s:\n", names[i]);
-		bytes = 0;
-		start = mach_absolute_time();
-		files_read = test_read_dirs(paths, queues[i], g, s, &bytes, i);
-		double elapsed = (double)(mach_absolute_time() - start) / NSEC_PER_SEC;
-		double throughput = ((double)bytes / elapsed)/(1024 * 1024);
-		fprintf(stdout, "Total Files read: %u, Total MBytes %g, "
-				"Total time: %g s, Throughput: %g MB/s\n", files_read,
-				(double)bytes / (1024 * 1024), elapsed, throughput);
-	}
-	dispatch_release(queues[DISPATCH_ASYNC_READ_ON_SERIAL_QUEUE]);
-	dispatch_release(s);
-	dispatch_release(g);
-#if defined(_WIN32)
-	free(paths[0]);
-#endif
-}
-
-static void
-test_io_from_io(void) // rdar://problem/8388909
-{
-#if DISPATCH_API_VERSION >= 20101012
-	const size_t siz_in = 10240;
-	dispatch_queue_t q = dispatch_get_global_queue(0, 0);
-	dispatch_group_t g = dispatch_group_create();
-	dispatch_io_t io = NULL;
-
-	// Windows does not easily support immutable directories
-#if !defined(_WIN32)
-	char path[] = "/tmp/dispatchtest_io.XXXXXX/file.name";
-	char *tmp = strrchr(path, '/');
-	*tmp = '\0';
-	if (!mkdtemp(path)) {
-		test_ptr_notnull("mkdtemp failed", path);
-		test_stop();
-	}
-#ifdef UF_IMMUTABLE
-	// Make the directory immutable
-	if (chflags(path, UF_IMMUTABLE) == -1) {
-		test_errno("chflags", errno, 0);
-		test_stop();
-	}
-#else
-	// Make the directory non-read/writeable
-	if (chmod(path, 0) == -1) {
-		test_errno("chmod", errno, 0);
-		test_stop();
-	}
-#endif
-	*tmp = '/';
-	io = dispatch_io_create_with_path(DISPATCH_IO_RANDOM, path,
-			O_CREAT|O_RDWR, 0600, q, ^(int error) {
-				if (error) {
-					test_errno("channel cleanup called with error", error, 0);
-					test_stop();
-				}
-				test_errno("channel cleanup called", error, 0);
-			});
-
-	char *foo = malloc(256);
-	dispatch_data_t tdata;
-	tdata = dispatch_data_create(foo, 256, NULL, DISPATCH_DATA_DESTRUCTOR_FREE);
-	dispatch_group_enter(g);
-	dispatch_io_write(io, 0, tdata, q, ^(bool done, dispatch_data_t data_out,
-			int err_out) {
-#ifdef UF_IMMUTABLE
-		test_errno("error from write to immutable directory", err_out, EPERM);
-#else
-		test_errno("error from write to write protected directory", err_out, EACCES);
-#endif
-		test_sizet("unwritten data", dispatch_data_get_size(data_out), 256);
-		if (!err_out && done) {
-			test_stop();
-		}
-		if (done) {
-			dispatch_group_leave(g);
-		}
-	});
-	dispatch_release(tdata);
-	dispatch_release(io);
-	test_group_wait(g);
-	*tmp = '\0';
-#ifdef UF_IMMUTABLE
-	// Change the directory to mutable
-	if (chflags(path, 0) == -1) {
-		test_errno("chflags", errno, 0);
-		test_stop();
-	}
-#else
-	// Change the directory to user read/write/execute
-	if (chmod(path, S_IRUSR | S_IWUSR | S_IXUSR) == -1) {
-		test_errno("chmod", errno, 0);
-		test_stop();
-	}
-#endif
-	*tmp = '/';
-#endif // !defined(_WIN32)
-
-#if defined(_WIN32)
-	char *path = dispatch_test_get_large_file();
-	char *path_in = dispatch_test_get_large_file();
-	dispatch_fd_t in = dispatch_test_fd_open(path_in, O_RDONLY);
-	if (in == -1) {
-		test_errno("open", errno, 0);
-		test_stop();
-	}
-	dispatch_test_release_large_file(path_in);
-	free(path_in);
-#else
-	const char *path_in = "/dev/urandom";
-	dispatch_fd_t in = dispatch_test_fd_open(path_in, O_RDONLY);
-	if (in == -1) {
-		test_errno("open", errno, 0);
-		test_stop();
-	}
-#endif
-	dispatch_group_enter(g);
-
-	io = dispatch_io_create_with_path(DISPATCH_IO_RANDOM, path,
-			O_CREAT|O_RDWR, 0600, q, ^(int error) {
-		if (error) {
-			test_errno("channel cleanup called with error", error, 0);
-			test_stop();
-		}
-		test_errno("channel cleanup called", error, 0);
-	});
-	dispatch_read(in, siz_in, q, ^(dispatch_data_t data_in, int err_in ) {
-		if (err_in) {
-			test_errno("dispatch_read", err_in, 0);
-			test_stop();
-		}
-		dispatch_io_write(io, 0, data_in, q,
-				^(bool done, dispatch_data_t data_out, int err_out) {
-			if (done) {
-				test_errno("dispatch_io_write", err_out, 0);
-				test_sizet("remaining write size",
-						data_out ? dispatch_data_get_size(data_out) : 0, 0);
-				dispatch_group_leave(g);
-			} else {
-				test_sizet_less_than("remaining write size",
-						dispatch_data_get_size(data_out), siz_in);
-			}
-		});
-	});
-	test_group_wait(g);
-	dispatch_io_t io2 = dispatch_io_create_with_io(DISPATCH_IO_STREAM, io, q,
-			^(int error) {
-		if (error) {
-			test_errno("dispatch_io_create_with_io", error, 0);
-			test_stop();
-		}
-	});
-	dispatch_release(io);
-	dispatch_group_enter(g);
-	__block dispatch_data_t data_out = dispatch_data_empty;
-	dispatch_io_read(io2, 0, siz_in, q,
-			^(bool done, dispatch_data_t d, int error) {
-		if (d) {
-			dispatch_data_t concat = dispatch_data_create_concat(data_out, d);
-			dispatch_release(data_out);
-			data_out = concat;
-		}
-		if (done) {
-			test_errno("read error from channel created_with_io", error, 0);
-			dispatch_group_leave(g);
-		}
-	});
-	dispatch_release(io2);
-	test_group_wait(g);
-	dispatch_release(g);
-	test_sizet("readback size", dispatch_data_get_size(data_out), siz_in);
-	dispatch_release(data_out);
-#if defined(_WIN32)
-	dispatch_test_release_large_file(path);
-	free(path);
-#endif
-#endif
-}
-
-#endif // DISPATCHTEST_IO
-
-int
-main(void)
-{
-	dispatch_test_start("Dispatch IO");
-	dispatch_async(dispatch_get_main_queue(), ^{
-#if DISPATCHTEST_IO
-		int i; bool from_path = false;
-		do {
-			for (i = 0; i < 3; i++) {
-				test_io_close(i, from_path);
-			}
-#if DISPATCHTEST_IO_PATH
-			from_path = !from_path;
-#endif
-		} while (from_path);
-		test_io_stop();
-		test_io_from_io();
-		test_io_read_write();
-		test_read_many_files();
-#endif
-		test_fin(NULL);
-	});
-	dispatch_main();
-}
--- a/Telegram/ThirdParty/dispatch/tests/dispatch_io_muxed.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/dispatch_io_muxed.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,280 +0,0 @@
-/*
- * Copyright (c) 2019 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *	 http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include <assert.h>
-#include <errno.h>
-#include <stdio.h>
-#include <stdlib.h>
-#if defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))
-#include <netinet/in.h>
-#include <sys/socket.h>
-#include <unistd.h>
-#elif defined(_WIN32)
-#include <WinSock2.h>
-#include <WS2tcpip.h>
-#include <Windows.h>
-#endif
-
-#include <dispatch/dispatch.h>
-
-#include <bsdtests.h>
-#include "dispatch_test.h"
-
-#if !defined(_WIN32)
-#define closesocket(x) close(x)
-#endif
-
-static void
-test_file_muxed(void)
-{
-	printf("\nFile Muxed\n");
-
-#if defined(_WIN32)
-	const char *temp_dir = getenv("TMP");
-	if (!temp_dir) {
-		temp_dir = getenv("TEMP");
-	}
-	if (!temp_dir) {
-		test_ptr_notnull("temporary directory", temp_dir);
-		test_stop();
-	}
-	const char *path_separator = "\\";
-#else
-	const char *temp_dir = getenv("TMPDIR");
-	if (!temp_dir) {
-		temp_dir = "/tmp";
-	}
-	const char *path_separator = "/";
-#endif
-	char *path = NULL;
-	(void)asprintf(&path, "%s%sdispatchtest_io.XXXXXX", temp_dir, path_separator);
-	dispatch_fd_t fd = mkstemp(path);
-	if (fd == -1) {
-		test_errno("mkstemp", errno, 0);
-		test_stop();
-	}
-	if (unlink(path) == -1) {
-		test_errno("unlink", errno, 0);
-		test_stop();
-	}
-#if defined(_WIN32)
-	free(path);
-#endif
-	dispatch_test_fd_write(fd, "test", 4);
-	dispatch_test_fd_lseek(fd, 0, SEEK_SET);
-
-	dispatch_group_t g = dispatch_group_create();
-	dispatch_group_enter(g);
-	dispatch_group_enter(g);
-
-	dispatch_source_t reader = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ,
-			(uintptr_t)fd, 0, dispatch_get_global_queue(0, 0));
-	test_ptr_notnull("dispatch_source_create", reader);
-	assert(reader);
-	dispatch_source_set_event_handler(reader, ^{
-		dispatch_source_cancel(reader);
-	});
-	dispatch_source_set_cancel_handler(reader, ^{
-		dispatch_release(reader);
-		dispatch_group_leave(g);
-	});
-
-	dispatch_source_t writer = dispatch_source_create(
-			DISPATCH_SOURCE_TYPE_WRITE, (uintptr_t)fd, 0,
-			dispatch_get_global_queue(0, 0));
-	test_ptr_notnull("dispatch_source_create", writer);
-	assert(writer);
-	dispatch_source_set_event_handler(writer, ^{
-		dispatch_source_cancel(writer);
-	});
-	dispatch_source_set_cancel_handler(writer, ^{
-		dispatch_release(writer);
-		dispatch_group_leave(g);
-	});
-
-	dispatch_resume(reader);
-	dispatch_resume(writer);
-
-	test_group_wait(g);
-	dispatch_release(g);
-	dispatch_test_fd_close(fd);
-}
-
-static void
-test_stream_muxed(dispatch_fd_t serverfd, dispatch_fd_t clientfd)
-{
-	dispatch_group_t g = dispatch_group_create();
-	dispatch_group_enter(g);
-	dispatch_group_enter(g);
-
-	dispatch_source_t reader = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ,
-			(uintptr_t)serverfd, 0, dispatch_get_global_queue(0, 0));
-	test_ptr_notnull("dispatch_source_create", reader);
-	assert(reader);
-	dispatch_source_set_event_handler(reader, ^{
-		dispatch_source_cancel(reader);
-	});
-	dispatch_source_set_cancel_handler(reader, ^{
-		dispatch_release(reader);
-		dispatch_group_leave(g);
-	});
-
-	dispatch_source_t writer = dispatch_source_create(
-			DISPATCH_SOURCE_TYPE_WRITE, (uintptr_t)serverfd, 0,
-			dispatch_get_global_queue(0, 0));
-	test_ptr_notnull("dispatch_source_create", writer);
-	assert(writer);
-	dispatch_source_set_event_handler(writer, ^{
-		dispatch_source_cancel(writer);
-	});
-	dispatch_source_set_cancel_handler(writer, ^{
-		dispatch_release(writer);
-		dispatch_group_leave(g);
-	});
-
-	dispatch_resume(reader);
-	dispatch_resume(writer);
-
-	dispatch_after(dispatch_time(DISPATCH_TIME_NOW, 500 * NSEC_PER_MSEC),
-			dispatch_get_global_queue(0, 0), ^{
-		dispatch_group_enter(g);
-		char buf[512] = {0};
-		ssize_t n = dispatch_test_fd_write(clientfd, buf, sizeof(buf));
-		if (n < 0) {
-			test_errno("write error", errno, 0);
-			test_stop();
-		}
-		test_sizet("num written", (size_t)n, sizeof(buf));
-		dispatch_group_leave(g);
-	});
-
-	test_group_wait(g);
-	dispatch_release(g);
-}
-
-static void
-test_socket_muxed(void)
-{
-	printf("\nSocket Muxed\n");
-
-	int listenfd = -1, serverfd = -1, clientfd = -1;
-	struct sockaddr_in addr;
-	socklen_t addrlen;
-
-	listenfd = socket(AF_INET, SOCK_STREAM, 0);
-	if (listenfd == -1) {
-		test_errno("socket()", errno, 0);
-		test_stop();
-	}
-	addr.sin_family = AF_INET;
-	addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
-	addr.sin_port = 0;
-	addrlen = sizeof(addr);
-	if (bind(listenfd, (struct sockaddr *)&addr, addrlen) == -1) {
-		test_errno("bind()", errno, 0);
-		test_stop();
-	}
-	if (listen(listenfd, 3) == -1) {
-		test_errno("listen()", errno, 0);
-		test_stop();
-	}
-	if (getsockname(listenfd, (struct sockaddr *)&addr, &addrlen) == -1) {
-		test_errno("getsockname()", errno, 0);
-		test_stop();
-	}
-
-	clientfd = socket(AF_INET, SOCK_STREAM, 0);
-	if (clientfd == -1) {
-		test_errno("socket()", errno, 0);
-		test_stop();
-	}
-	if (connect(clientfd, (struct sockaddr *)&addr, addrlen)) {
-		test_errno("connect()", errno, 0);
-		test_stop();
-	}
-
-	serverfd = accept(listenfd, (struct sockaddr *)&addr, &addrlen);
-	if (serverfd == -1) {
-		test_errno("accept()", errno, 0);
-		test_stop();
-	}
-
-	test_stream_muxed((dispatch_fd_t)serverfd, (dispatch_fd_t)clientfd);
-
-	closesocket(clientfd);
-	closesocket(serverfd);
-	closesocket(listenfd);
-}
-
-#if defined(_WIN32)
-static void
-test_pipe_muxed(void)
-{
-	printf("\nDuplex Pipe Muxed\n");
-
-	wchar_t name[64];
-	swprintf(name, sizeof(name), L"\\\\.\\pipe\\dispatch_io_muxed_%lu",
-			GetCurrentProcessId());
-	HANDLE server = CreateNamedPipeW(name,
-			PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE, PIPE_TYPE_BYTE,
-			/* nMaxInstances */ 1, /* nOutBufferSize */ 0x1000,
-			/* nInBufferSize */ 0x1000, /* nDefaultTimeOut */ 0,
-			/* lpSecurityAttributes */ NULL);
-	if (server == INVALID_HANDLE_VALUE) {
-		test_ptr_not("CreateNamedPipe", server, INVALID_HANDLE_VALUE);
-		test_stop();
-	}
-	HANDLE client = CreateFileW(name, GENERIC_READ | GENERIC_WRITE,
-			/* dwShareMode */ 0, /* lpSecurityAttributes */ NULL, OPEN_EXISTING,
-			/* dwFlagsAndAttributes */ 0, /* hTemplateFile */ NULL);
-	if (client == INVALID_HANDLE_VALUE) {
-		test_ptr_not("CreateFile", client, INVALID_HANDLE_VALUE);
-		test_stop();
-	}
-
-	test_stream_muxed((dispatch_fd_t)server, (dispatch_fd_t)client);
-
-	CloseHandle(client);
-	CloseHandle(server);
-}
-#endif
-
-int
-main(void)
-{
-	dispatch_test_start("Dispatch IO Muxed");
-#if defined(_WIN32)
-	WSADATA wsa;
-	int err = WSAStartup(MAKEWORD(2, 2), &wsa);
-	if (err != 0) {
-		fprintf(stderr, "WSAStartup failed with %d\n", err);
-		test_stop();
-	}
-#endif
-	dispatch_async(dispatch_get_main_queue(), ^{
-		test_file_muxed();
-		test_socket_muxed();
-#if defined(_WIN32)
-		test_pipe_muxed();
-#endif
-		test_stop();
-	});
-	dispatch_main();
-}
--- a/Telegram/ThirdParty/dispatch/tests/dispatch_io_net.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/dispatch_io_net.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,379 +0,0 @@
-/*
- * Copyright (c) 2010-2011 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#if defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))
-#include <netdb.h>
-#include <netinet/in.h>
-#include <spawn.h>
-#include <sys/socket.h>
-#include <sys/param.h>
-#include <unistd.h>
-#elif defined(_WIN32)
-#include <WinSock2.h>
-#include <WS2tcpip.h>
-#include <Windows.h>
-#endif
-#include <errno.h>
-#include <sys/types.h>
-#include <fcntl.h>
-#include <sys/stat.h>
-#ifdef __APPLE__
-#include <crt_externs.h>
-#include <mach-o/dyld.h>
-#endif
-#include <Block.h>
-#include <bsdtests.h>
-#include "dispatch_test.h"
-#include <dispatch/dispatch.h>
-
-#if !defined(_WIN32)
-extern char **environ;
-#endif
-
-#ifndef DISPATCHTEST_IO
-#if DISPATCH_API_VERSION >= 20100226 && DISPATCH_API_VERSION != 20101110
-#define DISPATCHTEST_IO 1
-#endif
-#endif
-
-#if defined(__linux__) || defined(__FreeBSD__) || defined(_WIN32) || defined(__OpenBSD__)
-#define _NSGetExecutablePath(ef,bs) (*(bs)=(size_t)snprintf(ef,*(bs),"%s",argv[0]),0)
-#endif
-
-#if defined(_WIN32)
-typedef USHORT in_port_t;
-#endif
-
-#if !defined(_WIN32)
-#define closesocket(x) close(x)
-#endif
-
-#if DISPATCHTEST_IO
-int
-main(int argc, char** argv)
-{
-	struct hostent *he;
-	int sockfd = -1, clientfd = -1;
-	dispatch_fd_t read_fd = -1, fd = -1;
-	struct sockaddr_in addr1, addr2, server;
-	socklen_t addr2len;
-	socklen_t addr1len;
-	pid_t clientid;
-
-#if defined(_WIN32)
-	WSADATA wsa;
-	int err = WSAStartup(MAKEWORD(2, 2), &wsa);
-	if (err != 0) {
-		fprintf(stderr, "WSAStartup failed with %d\n", err);
-		test_stop();
-	}
-#endif
-
-	if (argc == 3) {
-		// Client
-		dispatch_test_start(NULL);
-
-		if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
-			test_errno("Client-socket()", errno, 0);
-			test_stop();
-		}
-
-		if ((he = gethostbyname("localhost")) == NULL) {
-			fprintf(stderr, "Client-gethostbyname() failed\n");
-			test_stop();
-		}
-
-		memcpy(&server.sin_addr, he->h_addr_list[0], (size_t)he->h_length);
-		server.sin_family = AF_INET;
-		server.sin_port = (in_port_t)atoi(argv[1]);
-
-		fprintf(stderr, "Client-connecting on port ... %d\n", server.sin_port);
-
-		if (connect(sockfd, (struct sockaddr *)&server, sizeof(server))) {
-			test_errno("client-connect()", errno, 0);
-			test_stop();
-		}
-
-		// Read from the socket and compare the contents are what we expect
-
-		const char *path = argv[2];
-		fd = dispatch_test_fd_open(path, O_RDONLY);
-		if (fd == -1) {
-			test_errno("client-open", errno, 0);
-			test_stop();
-		}
-
-		// The reference file path given to us by the server was produced by
-		// dispatch_test_get_large_file(). It may point to a temporary file, and
-		// we are responsible for cleaning it up because we are the last to
-		// access it.
-		dispatch_test_release_large_file(path);
-
-#ifdef F_NOCACHE
-		if (fcntl(fd, F_NOCACHE, 1)) {
-			test_errno("client-fcntl F_NOCACHE", errno, 0);
-			test_stop();
-		}
-#else
-		// investigate what the impact of lack of file cache disabling has 
-		// for this test
-#endif
-		size_t size = (size_t)dispatch_test_fd_lseek(fd, 0, SEEK_END);
-		dispatch_test_fd_lseek(fd, 0, SEEK_SET);
-
-		__block dispatch_data_t g_d1 = dispatch_data_empty;
-		__block dispatch_data_t g_d2 = dispatch_data_empty;
-		__block int g_error = 0;
-
-		dispatch_group_t g = dispatch_group_create();
-		dispatch_group_enter(g);
-		dispatch_read(fd, size, dispatch_get_global_queue(0, 0),
-				^(dispatch_data_t d1, int error) {
-			test_errno("Client-dict-read error", error, 0);
-			test_long("Client-dict-dispatch data size",
-					  (long)dispatch_data_get_size(d1), (long)size);
-			dispatch_retain(d1);
-			g_d1 = d1;
-			dispatch_group_leave(g);
-		});
-
-		__block void (^b)(dispatch_data_t, int);
-		b = Block_copy(^(dispatch_data_t d2, int error) {
-			dispatch_data_t concat = dispatch_data_create_concat(g_d2, d2);
-			dispatch_release(g_d2);
-			g_d2 = concat;
-			if (!error && dispatch_data_get_size(d2)) {
-				dispatch_read(sockfd, SIZE_MAX,
-						dispatch_get_global_queue(0, 0), b);
-			} else {
-				g_error = error;
-				dispatch_group_leave(g);
-			}
-		});
-		dispatch_group_enter(g);
-		dispatch_read(sockfd, SIZE_MAX, dispatch_get_global_queue(0, 0), b);
-		test_group_wait(g);
-		test_errno("Client-read error", g_error, 0);
-		test_long("Client-dispatch data size", (long)dispatch_data_get_size(g_d2),
-				  (long)size);
-
-		size_t dict_contig_size, socket_contig_size;
-		const void *dict_contig_buf, *socket_contig_buf;
-		dispatch_data_t dict_data = dispatch_data_create_map(g_d1,
-				&dict_contig_buf, &dict_contig_size);
-		dispatch_data_t socket_data = dispatch_data_create_map(g_d2,
-				&socket_contig_buf, &socket_contig_size);
-		test_long("Client-dispatch data contents",
-				 memcmp(dict_contig_buf, socket_contig_buf,
-				 MIN(dict_contig_size, socket_contig_size)), 0);
-
-		dispatch_test_fd_close(fd);
-		closesocket(sockfd);
-		dispatch_release(g_d1);
-		dispatch_release(g_d2);
-		dispatch_release(dict_data);
-		dispatch_release(socket_data);
-		dispatch_release(g);
-		test_stop();
-	} else {
-		// Server
-		dispatch_test_start("Dispatch IO Network test");
-
-		if ((sockfd = socket(PF_INET, SOCK_STREAM, 0)) == -1) {
-			test_errno("Server-socket()", errno, 0);
-			test_stop();
-		}
-
-		addr1.sin_family = AF_INET;
-		addr1.sin_addr.s_addr = INADDR_ANY;
-		addr1.sin_port = 0;
-
-		if (bind(sockfd, (struct sockaddr *)&addr1, sizeof(struct sockaddr)) ==
-				-1) {
-			test_errno("Server-bind()", errno, 0);
-			test_stop();
-		}
-
-		addr1len = sizeof(struct sockaddr);
-		if (getsockname(sockfd, (struct sockaddr*)&addr1, &addr1len) == -1) {
-			test_errno("Server-getsockname()", errno, 0);
-			test_stop();
-		}
-
-		if(listen(sockfd, 3) == -1) {
-			test_errno("Server-listen()", errno, 0);
-			test_stop();
-		}
-
-		fprintf(stderr, "Server started and listening on port %d\n",
-				addr1.sin_port);
-
-		char exec_filename [256] = {};
-		size_t bufsize = 256;
-
-		if (_NSGetExecutablePath(exec_filename, &bufsize) == -1) {
-			fprintf(stderr, "Failed to get path name for running executable\n");
-			test_stop();
-		}
-
-		char port_str[10] = {};
-		snprintf(port_str, 10, " %d", addr1.sin_port);
-
-		// The client must read from the same test file as the server. It will
-		// unlink the file as soon as it can, so the server must open it before
-		// starting the client process.
-		char *path = dispatch_test_get_large_file();
-		read_fd = dispatch_test_fd_open(path, O_RDONLY);
-		if (read_fd == -1) {
-			test_errno("open", errno, 0);
-			goto stop_test;
-		}
-
-		char *arguments [4] = {};
-		arguments[0] = exec_filename;
-		arguments[1] = port_str;
-		arguments[2] = path;
-		arguments[3] = NULL;
-
-#ifdef HAVE_POSIX_SPAWNP
-		int error;
-		if ((error = posix_spawnp(&clientid, exec_filename, NULL, NULL,
-				arguments, environ)) != 0) {
-			test_errno("Server-posix_spawnp()", error, 0);
-			goto stop_test;
-		}
-#elif defined(_WIN32)
-		WCHAR *cmdline = argv_to_command_line(arguments);
-		if (!cmdline) {
-			fprintf(stderr, "argv_to_command_line() failed\n");
-			test_stop();
-		}
-		STARTUPINFOW si = {.cb = sizeof(si)};
-		PROCESS_INFORMATION pi;
-		BOOL created = CreateProcessW(NULL, cmdline, NULL, NULL, FALSE, 0, NULL,
-				NULL, &si, &pi);
-		DWORD error = GetLastError();
-		free(cmdline);
-		if (!created) {
-			print_winapi_error("CreateProcessW", error);
-			test_stop();
-		}
-		clientid = (pid_t)pi.dwProcessId;
-#elif defined(__unix__)
-		clientid = fork();
-		if (clientid == -1) {
-			test_errno("Server-fork()", errno, 0);
-			test_stop();
-		} else if (clientid == 0) {
-			// Child process
-			if (execve(exec_filename, arguments, environ) == -1) {
-				perror(exec_filename);
-				_Exit(EXIT_FAILURE);
-			}
-		}
-#else
-#error "dispatch_io_net not implemented on this platform"
-#endif
-
-		addr2len = sizeof(struct sockaddr_in);
-		clientfd = accept(sockfd, (struct sockaddr *)&addr2, &addr2len);
-		if(clientfd == -1) {
-			test_errno("Server-accept()", errno, 0);
-			goto stop_test;
-		}
-
-		fprintf(stderr, "Server accepted connection. Server now writing\n");
-#ifdef F_NOCACHE
-		if (fcntl(read_fd, F_NOCACHE, 1)) {
-			test_errno("fcntl F_NOCACHE", errno, 0);
-			goto stop_test;
-		}
-#else
-		// investigate what the impact of lack of file cache disabling has 
-		// for this test
-#endif
-		size_t size = (size_t)dispatch_test_fd_lseek(read_fd, 0, SEEK_END);
-		dispatch_test_fd_lseek(read_fd, 0, SEEK_SET);
-
-		dispatch_group_t g = dispatch_group_create();
-		dispatch_group_enter(g);
-		dispatch_read(read_fd, size, dispatch_get_global_queue(0, 0),
-				^(dispatch_data_t d, int r_err){
-			fprintf(stderr, "Server-dispatch_read()\n");
-			test_errno("Server-read error", r_err, 0);
-			test_long("Server-dispatch data size", (long)dispatch_data_get_size(d),
-					  (long)size);
-
-			// convenience method handlers should only be called once
-			if (dispatch_data_get_size(d)!= size) {
-				fprintf(stderr, "Reading of data didn't complete\n");
-				dispatch_test_fd_close(read_fd);
-				closesocket(clientfd);
-				closesocket(sockfd);
-				test_stop();
-			}
-			dispatch_group_enter(g);
-			dispatch_write(clientfd, d, dispatch_get_global_queue(0, 0),
-					^(dispatch_data_t remaining, int w_err) {
-				test_errno("Server-write error", w_err, 0);
-				test_ptr_null("Server-dispatch write remaining data",remaining);
-				// convenience method handlers should only be called once
-				if (remaining) {
-					fprintf(stderr, "Server-dispatch_write() incomplete .. "
-							"%zu bytes\n", dispatch_data_get_size(remaining));
-					dispatch_test_fd_close(read_fd);
-					closesocket(clientfd);
-					closesocket(sockfd);
-					test_stop();
-				}
-				closesocket(clientfd); // Sending the client EOF
-				dispatch_group_leave(g);
-			});
-			dispatch_test_fd_close(read_fd);
-			dispatch_group_leave(g);
-		});
-		test_group_wait(g);
-		dispatch_release(g);
-		fprintf(stderr, "Shutting down server\n");
-		closesocket(sockfd);
-		free(path);
-		test_stop();
-
-stop_test:
-		if (path != NULL) {
-			dispatch_test_release_large_file(path);
-			free(path);
-		}
-		dispatch_test_fd_close(read_fd);
-		closesocket(clientfd);
-		closesocket(sockfd);
-		test_stop();
-	}
-}
-#else
-int
-main()
-{
-	dispatch_test_start("Dispatch IO Network test - No Dispatch IO");
-	test_stop();
-}
-#endif
--- a/Telegram/ThirdParty/dispatch/tests/dispatch_io_pipe.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/dispatch_io_pipe.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,488 +0,0 @@
-/*
- * Copyright (c) 2019 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *	 http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include <sys/types.h>
-#include <assert.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <stdio.h>
-#include <stdlib.h>
-#if defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))
-#include <unistd.h>
-#endif
-
-#include <dispatch/dispatch.h>
-
-#include <bsdtests.h>
-#include "dispatch_test.h"
-
-enum {
-	DISPATCH_PIPE_KIND_ANONYMOUS,
-#if defined(_WIN32)
-	DISPATCH_PIPE_KIND_NAMED_INBOUND,
-	DISPATCH_PIPE_KIND_NAMED_OUTBOUND,
-	DISPATCH_PIPE_KIND_NAMED_INBOUND_OVERLAPPED,
-	DISPATCH_PIPE_KIND_NAMED_OUTBOUND_OVERLAPPED,
-#endif
-	DISPATCH_PIPE_KIND_COUNT,
-};
-
-enum {
-	DISPATCH_TEST_IMMEDIATE,
-	DISPATCH_TEST_DELAYED,
-};
-
-static const char *const pipe_names[] = {
-	[DISPATCH_PIPE_KIND_ANONYMOUS] = "anonymous",
-#if defined(_WIN32)
-	[DISPATCH_PIPE_KIND_NAMED_INBOUND] = "named, inbound",
-	[DISPATCH_PIPE_KIND_NAMED_OUTBOUND] = "named, outbound",
-	[DISPATCH_PIPE_KIND_NAMED_INBOUND_OVERLAPPED] = "named, inbound, overlapped",
-	[DISPATCH_PIPE_KIND_NAMED_OUTBOUND_OVERLAPPED] = "named, outbound, overlapped",
-#endif
-};
-
-static const char *const delay_names[] = {
-	[DISPATCH_TEST_IMMEDIATE] = "Immediate",
-	[DISPATCH_TEST_DELAYED] = "Delayed",
-};
-
-#if defined(_WIN32)
-enum {
-	NAMED_PIPE_BUFFER_SIZE = 0x1000,
-};
-#endif
-
-static size_t
-test_get_pipe_buffer_size(int kind)
-{
-#if defined(_WIN32)
-	if (kind != DISPATCH_PIPE_KIND_ANONYMOUS) {
-		return NAMED_PIPE_BUFFER_SIZE;
-	}
-	static dispatch_once_t once;
-	static DWORD size;
-	dispatch_once(&once, ^{
-		HANDLE read_handle, write_handle;
-		if (!CreatePipe(&read_handle, &write_handle, NULL, 0)) {
-			test_long("CreatePipe", GetLastError(), ERROR_SUCCESS);
-			test_stop();
-		}
-		GetNamedPipeInfo(write_handle, NULL, &size, NULL, NULL);
-		CloseHandle(read_handle);
-		CloseHandle(write_handle);
-	});
-	return size;
-#else
-	(void)kind;
-	static dispatch_once_t once;
-	static size_t size;
-	dispatch_once(&once, ^{
-		int fds[2];
-		if (pipe(fds) < 0) {
-			test_errno("pipe", errno, 0);
-			test_stop();
-		}
-		fcntl(fds[1], F_SETFL, O_NONBLOCK);
-		for (size = 0; write(fds[1], "", 1) > 0; size++) {}
-		close(fds[0]);
-		close(fds[1]);
-	});
-	return size;
-#endif
-}
-
-#if defined(_WIN32)
-static void
-test_make_named_pipe(DWORD flags, dispatch_fd_t *readfd, dispatch_fd_t *writefd)
-{
-	wchar_t name[64];
-	static int counter = 0;
-	swprintf(name, sizeof(name), L"\\\\.\\pipe\\dispatch_io_pipe_%lu_%d",
-			GetCurrentProcessId(), counter++);
-	HANDLE server = CreateNamedPipeW(name,
-			flags | FILE_FLAG_FIRST_PIPE_INSTANCE, PIPE_TYPE_BYTE,
-			/* nMaxInstances */ 1, NAMED_PIPE_BUFFER_SIZE,
-			NAMED_PIPE_BUFFER_SIZE, /* nDefaultTimeOut */ 0,
-			/* lpSecurityAttributes */ NULL);
-	if (server == INVALID_HANDLE_VALUE) {
-		test_ptr_not("CreateNamedPipe", server, INVALID_HANDLE_VALUE);
-		test_stop();
-	}
-	HANDLE client = CreateFileW(name,
-			(flags & PIPE_ACCESS_INBOUND) ? GENERIC_WRITE : GENERIC_READ,
-			/* dwShareMode */ 0, /* lpSecurityAttributes */ NULL, OPEN_EXISTING,
-			flags & FILE_FLAG_OVERLAPPED, /* hTemplateFile */ NULL);
-	if (client == INVALID_HANDLE_VALUE) {
-		test_ptr_not("CreateFile", client, INVALID_HANDLE_VALUE);
-		test_stop();
-	}
-	if (flags & PIPE_ACCESS_INBOUND) {
-		*readfd = (dispatch_fd_t)server;
-		*writefd = (dispatch_fd_t)client;
-	} else {
-		*readfd = (dispatch_fd_t)client;
-		*writefd = (dispatch_fd_t)server;
-	}
-}
-#endif
-
-static void
-test_make_pipe(int kind, dispatch_fd_t *readfd, dispatch_fd_t *writefd)
-{
-#if defined(_WIN32)
-	switch (kind) {
-	case DISPATCH_PIPE_KIND_ANONYMOUS:
-		if (!CreatePipe((PHANDLE)readfd, (PHANDLE)writefd, NULL, 0)) {
-			test_long("CreatePipe", GetLastError(), ERROR_SUCCESS);
-			test_stop();
-		}
-		break;
-	case DISPATCH_PIPE_KIND_NAMED_INBOUND:
-		test_make_named_pipe(PIPE_ACCESS_INBOUND, readfd, writefd);
-		break;
-	case DISPATCH_PIPE_KIND_NAMED_OUTBOUND:
-		test_make_named_pipe(PIPE_ACCESS_OUTBOUND, readfd, writefd);
-		break;
-	case DISPATCH_PIPE_KIND_NAMED_INBOUND_OVERLAPPED:
-		test_make_named_pipe(PIPE_ACCESS_INBOUND | FILE_FLAG_OVERLAPPED, readfd,
-				writefd);
-		break;
-	case DISPATCH_PIPE_KIND_NAMED_OUTBOUND_OVERLAPPED:
-		test_make_named_pipe(PIPE_ACCESS_OUTBOUND | FILE_FLAG_OVERLAPPED,
-				readfd, writefd);
-		break;
-	}
-#else
-	(void)kind;
-	int fds[2];
-	if (pipe(fds) < 0) {
-		test_errno("pipe", errno, 0);
-		test_stop();
-	}
-	*readfd = fds[0];
-	*writefd = fds[1];
-#endif
-}
-
-static void
-test_source_read(int kind, int delay)
-{
-	printf("\nSource Read %s: %s\n", delay_names[delay], pipe_names[kind]);
-
-	dispatch_fd_t readfd, writefd;
-	test_make_pipe(kind, &readfd, &writefd);
-
-	dispatch_group_t g = dispatch_group_create();
-	dispatch_group_enter(g);
-
-	void (^write_block)(void) = ^{
-		dispatch_group_enter(g);
-		char buf[512] = {0};
-		ssize_t n = dispatch_test_fd_write(writefd, buf, sizeof(buf));
-		if (n < 0) {
-			test_errno("write error", errno, 0);
-			test_stop();
-		}
-		test_sizet("num written", (size_t)n, sizeof(buf));
-		dispatch_group_leave(g);
-	};
-	if (delay == DISPATCH_TEST_IMMEDIATE) {
-		write_block();
-	}
-
-	dispatch_source_t reader = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ,
-			(uintptr_t)readfd, 0, dispatch_get_global_queue(0, 0));
-	test_ptr_notnull("dispatch_source_create", reader);
-	assert(reader);
-	dispatch_source_set_event_handler(reader, ^{
-		dispatch_group_enter(g);
-		char buf[512];
-		size_t available = dispatch_source_get_data(reader);
-		test_sizet("num available", available, sizeof(buf));
-		ssize_t n = dispatch_test_fd_read(readfd, buf, sizeof(buf));
-		if (n >= 0) {
-			test_sizet("num read", (size_t)n, sizeof(buf));
-		} else {
-			test_errno("read error", errno, 0);
-		}
-		dispatch_source_cancel(reader);
-		dispatch_group_leave(g);
-	});
-	dispatch_source_set_cancel_handler(reader, ^{
-		dispatch_release(reader);
-		dispatch_group_leave(g);
-	});
-	dispatch_resume(reader);
-
-	dispatch_source_t t = NULL;
-	if (delay == DISPATCH_TEST_DELAYED) {
-		t = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0,
-				dispatch_get_global_queue(0, 0));
-		dispatch_source_set_event_handler(t, write_block);
-		dispatch_source_set_timer(t,
-				dispatch_time(DISPATCH_TIME_NOW, 500 * NSEC_PER_MSEC),
-				DISPATCH_TIME_FOREVER, 0);
-		dispatch_resume(t);
-	}
-
-	test_group_wait(g);
-	dispatch_release(g);
-	if (t) {
-		dispatch_source_cancel(t);
-		dispatch_release(t);
-	}
-	dispatch_test_fd_close(readfd);
-	dispatch_test_fd_close(writefd);
-}
-
-static void
-test_source_write(int kind, int delay)
-{
-	printf("\nSource Write %s: %s\n", delay_names[delay], pipe_names[kind]);
-
-	dispatch_fd_t readfd, writefd;
-	test_make_pipe(kind, &readfd, &writefd);
-
-	dispatch_group_t g = dispatch_group_create();
-	dispatch_group_enter(g);
-
-	const size_t bufsize = test_get_pipe_buffer_size(kind);
-
-	void (^write_block)(void) = ^{
-		char *buf = calloc(bufsize, 1);
-		assert(buf);
-		ssize_t nw = dispatch_test_fd_write(writefd, buf, bufsize);
-		free(buf);
-		if (nw < 0) {
-			test_errno("write error", errno, 0);
-			test_stop();
-		}
-		test_sizet("num written", (size_t)nw, bufsize);
-	};
-	write_block();
-
-	void (^read_block)(void) = ^{
-		dispatch_group_enter(g);
-		char *buf = calloc(bufsize, 1);
-		assert(buf);
-		ssize_t nr = dispatch_test_fd_read(readfd, buf, bufsize);
-		free(buf);
-		if (nr < 0) {
-			test_errno("read error", errno, 0);
-			test_stop();
-		}
-		test_sizet("num read", (size_t)nr, bufsize);
-		dispatch_group_leave(g);
-	};
-	if (delay == DISPATCH_TEST_IMMEDIATE) {
-		read_block();
-	}
-
-	dispatch_source_t writer = dispatch_source_create(
-			DISPATCH_SOURCE_TYPE_WRITE, (uintptr_t)writefd, 0,
-			dispatch_get_global_queue(0, 0));
-	test_ptr_notnull("dispatch_source_create", writer);
-	assert(writer);
-	dispatch_source_set_event_handler(writer, ^{
-		dispatch_group_enter(g);
-		size_t available = dispatch_source_get_data(writer);
-		test_sizet_less_than("num available", 0, available);
-		write_block();
-		read_block();
-		dispatch_source_cancel(writer);
-		dispatch_group_leave(g);
-	});
-	dispatch_source_set_cancel_handler(writer, ^{
-		dispatch_release(writer);
-		dispatch_group_leave(g);
-	});
-	dispatch_resume(writer);
-
-	dispatch_source_t t = NULL;
-	if (delay == DISPATCH_TEST_DELAYED) {
-		t = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0,
-				dispatch_get_global_queue(0, 0));
-		dispatch_source_set_event_handler(t, read_block);
-		dispatch_source_set_timer(t,
-				dispatch_time(DISPATCH_TIME_NOW, 500 * NSEC_PER_MSEC),
-				DISPATCH_TIME_FOREVER, 0);
-		dispatch_resume(t);
-	}
-
-	test_group_wait(g);
-	dispatch_release(g);
-	if (t) {
-		dispatch_source_cancel(t);
-		dispatch_release(t);
-	}
-	dispatch_test_fd_close(readfd);
-	dispatch_test_fd_close(writefd);
-}
-
-static void
-test_dispatch_read(int kind, int delay)
-{
-	printf("\nDispatch Read %s: %s\n", delay_names[delay], pipe_names[kind]);
-
-	dispatch_fd_t readfd, writefd;
-	test_make_pipe(kind, &readfd, &writefd);
-
-	dispatch_group_t g = dispatch_group_create();
-	dispatch_group_enter(g);
-
-	char writebuf[512] = {0};
-	char *writebufp = writebuf;
-	void (^write_block)(void) = ^{
-		dispatch_group_enter(g);
-		ssize_t n =
-			dispatch_test_fd_write(writefd, writebufp, sizeof(writebuf));
-		if (n < 0) {
-			test_errno("write error", errno, 0);
-			test_stop();
-		}
-		test_sizet("num written", (size_t)n, sizeof(writebuf));
-		dispatch_group_leave(g);
-	};
-	if (delay == DISPATCH_TEST_IMMEDIATE) {
-		write_block();
-	}
-
-	dispatch_read(readfd, sizeof(writebuf), dispatch_get_global_queue(0, 0),
-			^(dispatch_data_t data, int err) {
-		test_errno("read error", err, 0);
-		test_sizet("num read", dispatch_data_get_size(data), sizeof(writebuf));
-		dispatch_group_leave(g);
-	});
-
-	dispatch_source_t t = NULL;
-	if (delay == DISPATCH_TEST_DELAYED) {
-		t = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0,
-				dispatch_get_global_queue(0, 0));
-		dispatch_source_set_event_handler(t, write_block);
-		dispatch_source_set_timer(t,
-				dispatch_time(DISPATCH_TIME_NOW, 500 * NSEC_PER_MSEC),
-				DISPATCH_TIME_FOREVER, 0);
-		dispatch_resume(t);
-	}
-
-	test_group_wait(g);
-	dispatch_release(g);
-	if (t) {
-		dispatch_source_cancel(t);
-		dispatch_release(t);
-	}
-	dispatch_test_fd_close(readfd);
-	dispatch_test_fd_close(writefd);
-}
-
-static void
-test_dispatch_write(int kind, int delay)
-{
-	printf("\nDispatch Write %s: %s\n", delay_names[delay], pipe_names[kind]);
-
-	dispatch_fd_t readfd, writefd;
-	test_make_pipe(kind, &readfd, &writefd);
-
-	dispatch_group_t g = dispatch_group_create();
-	dispatch_group_enter(g);
-
-	const size_t bufsize = test_get_pipe_buffer_size(kind);
-
-	char *buf = calloc(bufsize, 1);
-	assert(buf);
-	ssize_t nw = dispatch_test_fd_write(writefd, buf, bufsize);
-	free(buf);
-	if (nw < 0) {
-		test_errno("write error", errno, 0);
-		test_stop();
-	}
-	test_sizet("num written", (size_t)nw, bufsize);
-
-	void (^read_block)(void) = ^{
-		dispatch_group_enter(g);
-		char *readbuf = calloc(bufsize, 1);
-		assert(readbuf);
-		ssize_t nr = dispatch_test_fd_read(readfd, readbuf, bufsize);
-		free(readbuf);
-		if (nr < 0) {
-			test_errno("read error", errno, 0);
-			test_stop();
-		}
-		test_sizet("num read", (size_t)nr, bufsize);
-		dispatch_group_leave(g);
-	};
-	if (delay == DISPATCH_TEST_IMMEDIATE) {
-		read_block();
-	}
-
-	buf = calloc(bufsize, 1);
-	assert(buf);
-	dispatch_data_t wd = dispatch_data_create(buf, bufsize,
-			dispatch_get_global_queue(0, 0), DISPATCH_DATA_DESTRUCTOR_FREE);
-	dispatch_write(writefd, wd, dispatch_get_global_queue(0, 0),
-			^(dispatch_data_t data, int err) {
-		test_errno("write error", err, 0);
-		test_ptr_null("data written", data);
-		read_block();
-		dispatch_group_leave(g);
-	});
-
-	dispatch_source_t t = NULL;
-	if (delay == DISPATCH_TEST_DELAYED) {
-		t = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0,
-				dispatch_get_global_queue(0, 0));
-		dispatch_source_set_event_handler(t, read_block);
-		dispatch_source_set_timer(t,
-				dispatch_time(DISPATCH_TIME_NOW, 500 * NSEC_PER_MSEC),
-				DISPATCH_TIME_FOREVER, 0);
-		dispatch_resume(t);
-	}
-
-	test_group_wait(g);
-	dispatch_release(g);
-	dispatch_release(wd);
-	if (t) {
-		dispatch_source_cancel(t);
-		dispatch_release(t);
-	}
-	dispatch_test_fd_close(readfd);
-	dispatch_test_fd_close(writefd);
-}
-
-int
-main(void)
-{
-	dispatch_test_start("Dispatch IO Pipe");
-	dispatch_async(dispatch_get_main_queue(), ^{
-		for (int kind = 0; kind < DISPATCH_PIPE_KIND_COUNT; kind++) {
-			test_source_read(kind, DISPATCH_TEST_IMMEDIATE);
-			test_source_read(kind, DISPATCH_TEST_DELAYED);
-			test_source_write(kind, DISPATCH_TEST_IMMEDIATE);
-			test_source_write(kind, DISPATCH_TEST_DELAYED);
-			test_dispatch_read(kind, DISPATCH_TEST_IMMEDIATE);
-			test_dispatch_read(kind, DISPATCH_TEST_DELAYED);
-			test_dispatch_write(kind, DISPATCH_TEST_IMMEDIATE);
-			test_dispatch_write(kind, DISPATCH_TEST_DELAYED);
-		}
-		test_stop();
-	});
-	dispatch_main();
-}
--- a/Telegram/ThirdParty/dispatch/tests/dispatch_io_pipe_close.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/dispatch_io_pipe_close.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,84 +0,0 @@
-/*
- * Copyright (c) 2019 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <limits.h>
-#include <errno.h>
-#if defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))
-#include <unistd.h>
-#elif defined(_WIN32)
-#include <Windows.h>
-#endif
-
-#include <bsdtests.h>
-#include "dispatch_test.h"
-#include <dispatch/dispatch.h>
-
-int
-main() {
-    dispatch_test_start(NULL);
-
-#if defined(_WIN32)
-    dispatch_fd_t readFD, writeFD;
-    if (!CreatePipe((PHANDLE)&readFD, (PHANDLE)&writeFD, NULL, 0)) {
-        test_long("CreatePipe", GetLastError(), ERROR_SUCCESS);
-        test_stop();
-        _Exit(EXIT_FAILURE);
-    }
-#else
-    int pipe_fds[2] = { -1, -1 };
-    int pipe_err = pipe(pipe_fds);
-    int readFD = pipe_fds[0];
-    int writeFD = pipe_fds[1];
-    if (pipe_err) {
-        test_errno("pipe", errno, 0);
-        test_stop();
-        _Exit(EXIT_FAILURE);
-    }
-#endif
-
-    printf("readFD=%lld, writeFD=%lld\n", (long long)readFD, (long long)writeFD);
-    dispatch_queue_t q = dispatch_queue_create("q", NULL);
-    dispatch_io_t io = dispatch_io_create(DISPATCH_IO_STREAM, readFD, q, ^(int err) {
-        printf("cleanup, err=%d\n", err);
-        dispatch_test_fd_close(readFD);
-        printf("all done\n");
-        test_stop();
-        _Exit(EXIT_SUCCESS);
-    });
-    dispatch_io_set_low_water(io, 0);
-    dispatch_io_read(io, 0, UINT_MAX, q, ^(bool done, dispatch_data_t data, int err) {
-        printf("read: \%d, %zu, %d\n", done, data == NULL ? 0 : dispatch_data_get_size(data), err);
-        if (data != NULL && dispatch_data_get_size(data) > 0) {
-            // will only happen once
-            printf("closing writeFD\n");
-            dispatch_test_fd_close(writeFD);
-            dispatch_after(DISPATCH_TIME_NOW + 1, q, ^{
-                dispatch_io_close(io, 0);
-            });
-        }
-    });
-    dispatch_resume(io);
-    printf("writing\n");
-    dispatch_test_fd_write(writeFD, "x", 1);
-    printf("wrtten\n");
-    dispatch_main();
-}
--- a/Telegram/ThirdParty/dispatch/tests/dispatch_overcommit.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/dispatch_overcommit.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,72 +0,0 @@
-/*
- * Copyright (c) 2008-2011 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#ifdef __linux__
-// for asprintf
-#define _GNU_SOURCE 1
-#endif
-#include <dispatch/dispatch.h>
-#include <dispatch/private.h>
-#include <stdio.h>
-#if defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))
-#include <unistd.h>
-#endif
-#include <stdlib.h>
-#include <assert.h>
-#ifdef __APPLE__
-#include <libkern/OSAtomic.h>
-#endif
-
-#include <bsdtests.h>
-#include "dispatch_test.h"
-
-int32_t count = 0;
-const int32_t final = 32;
-
-int
-main(void)
-{
-	dispatch_test_start("Dispatch Overcommit");
-
-	int i;
-	for (i = 0; i < final; ++i) {
-		char* name;
-		(void)asprintf(&name, "test.overcommit.%d", i);
-
-		dispatch_queue_t queue = dispatch_queue_create(name, NULL);
-		test_ptr_notnull("dispatch_queue_create", queue);
-		free(name);
-		dispatch_set_target_queue(queue, dispatch_get_global_queue(0, DISPATCH_QUEUE_OVERCOMMIT));
-
-		dispatch_async(queue, ^{
-			OSAtomicIncrement32(&count);
-			if (count == final) {
-				test_long("count", count, final);
-				test_stop();
-			} else {
-				while (1); // spin
-			}
-		});
-	}
-
-	dispatch_main();
-
-	return 0;
-}
--- a/Telegram/ThirdParty/dispatch/tests/dispatch_pingpong.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/dispatch_pingpong.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,66 +0,0 @@
-/*
- * Copyright (c) 2008-2011 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include <dispatch/dispatch.h>
-#include <stdio.h>
-
-#include <bsdtests.h>
-#include "dispatch_test.h"
-
-uint32_t count = 0;
-const uint32_t final = 1000000; // 10M
-
-static void
-pingpongloop(dispatch_group_t group, dispatch_queue_t ping, dispatch_queue_t pong, size_t counter)
-{
-	//printf("[%p] %s: %lu\n", (void*)(uintptr_t)pthread_self(), dispatch_queue_get_label(dispatch_get_current_queue()), counter);
-	if (counter < final) {
-		dispatch_group_async(group, pong, ^{ pingpongloop(group, pong, ping, counter+1); });
-	} else {
-		count = (uint32_t)counter;
-	}
-}
-
-int
-main(void)
-{
-	dispatch_test_start("Dispatch Ping Pong");
-
-	dispatch_queue_t ping = dispatch_queue_create("ping", NULL);
-	test_ptr_notnull("dispatch_queue_create(ping)", ping);
-	dispatch_queue_t pong = dispatch_queue_create("pong", NULL);
-	test_ptr_notnull("dispatch_queue_create(pong)", pong);
-
-	dispatch_group_t group = dispatch_group_create();
-	test_ptr_notnull("dispatch_group_create", group);
-
-	pingpongloop(group, ping, pong, 0);
-	dispatch_group_wait(group, DISPATCH_TIME_FOREVER);
-
-	test_long("count", count, final);
-
-	dispatch_release(ping);
-	dispatch_release(pong);
-	dispatch_release(group);
-
-	test_stop();
-
-	return 0;
-}
--- a/Telegram/ThirdParty/dispatch/tests/dispatch_plusplus.cpp	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/dispatch_plusplus.cpp	1970-01-01 00:00:00.000000000 -0000
@@ -1,41 +0,0 @@
-/*
- * Copyright (c) 2008-2011 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include <dispatch/dispatch.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include <bsdtests.h>
-#include "dispatch_test.h"
-
-int
-main(void)
-{
-	dispatch_test_start("Dispatch C++");
-	dispatch_queue_t q = dispatch_get_main_queue();
-	test_ptr_notnull("dispatch_get_main_queue", q);
-
-	dispatch_async(dispatch_get_main_queue(), ^{
-		test_stop();
-		exit(0);
-	});
-	dispatch_main();
-	return 0;
-}
--- a/Telegram/ThirdParty/dispatch/tests/dispatch_priority.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/dispatch_priority.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,222 +0,0 @@
-/*
- * Copyright (c) 2008-2011 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include <stdio.h>
-#include <dispatch/dispatch.h>
-#include <dispatch/private.h>
-#if defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))
-#include <unistd.h>
-#ifdef __ANDROID__
-#include <linux/sysctl.h>
-#else
-#if !defined(__linux__)
-#include <sys/sysctl.h>
-#endif
-#endif /* __ANDROID__ */
-#endif
-#include <stdlib.h>
-#include <assert.h>
-#ifdef __APPLE__
-#include <TargetConditionals.h>
-#endif
-#include <sys/types.h>
-
-#include <bsdtests.h>
-#include "dispatch_test.h"
-
-static volatile int done;
-
-#ifdef DISPATCH_QUEUE_PRIORITY_BACKGROUND // <rdar://problem/7439794>
-#define USE_BACKGROUND_PRIORITY 1
-#else
-#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN
-#endif
-
-#define QUEUE_PRIORITY_PTHREAD INT_MAX
-
-#if DISPATCH_API_VERSION < 20100518 // <rdar://problem/7790099>
-#define DISPATCH_QUEUE_CONCURRENT NULL
-#endif
-
-#if TARGET_OS_EMBEDDED
-#define LOOP_COUNT 5000000
-const int importance = 24; // priority 55
-#else
-#define LOOP_COUNT 100000000
-const int importance = 4; // priority 35
-#endif
-
-char *labels[] = { "BACKGROUND", "LOW", "DEFAULT", "HIGH", };
-int levels[] = {
-	DISPATCH_QUEUE_PRIORITY_BACKGROUND, DISPATCH_QUEUE_PRIORITY_LOW,
-	DISPATCH_QUEUE_PRIORITY_DEFAULT, DISPATCH_QUEUE_PRIORITY_HIGH,
-};
-#define PRIORITIES (sizeof(levels)/sizeof(*levels))
-
-static union {
-	long count;
-	char padding[64];
-} counts[PRIORITIES];
-
-static volatile long iterations;
-static long total;
-static size_t prio0, priorities = PRIORITIES;
-
-static int
-n_blocks(void)
-{
-	static dispatch_once_t pred;
-	static int n;
-	dispatch_once(&pred, ^{
-#ifdef __linux__
-		n = (int)sysconf(_SC_NPROCESSORS_CONF);
-#elif defined(_WIN32)
-		SYSTEM_INFO si;
-		GetSystemInfo(&si);
-		n = (int)si.dwNumberOfProcessors;
-#else
-		size_t l = sizeof(n);
-		int rc = sysctlbyname("hw.ncpu", &n, &l, NULL, 0);
-		assert(rc == 0);
-#endif
-		n *= 32;
-	});
-	return n;
-}
-
-static void
-histogram(void)
-{
-	long completed = 0;
-	size_t x, y, i;
-	printf("\n");
-	for (y = prio0; y < prio0 + priorities; ++y) {
-		printf("%s: %ld\n", labels[y], counts[y].count);
-		completed += counts[y].count;
-
-		double fraction = (double)counts[y].count / (double)n_blocks();
-		double value = fraction * (double)80;
-		for (x = 0; x < 80; ++x) {
-			printf("%s", (value > x) ? "*" : " ");
-		}
-		printf("\n");
-	}
-
-	test_long("blocks completed", completed, total);
-	for (i = prio0; i < prio0 + priorities; i++) {
-		if (levels[i] == DISPATCH_QUEUE_PRIORITY_HIGH) {
-			test_long_less_than_or_equal("high priority precedence",
-					counts[i-2].count, counts[i].count);
-		}
-#if USE_BACKGROUND_PRIORITY
-		if (levels[i] == DISPATCH_QUEUE_PRIORITY_BACKGROUND) {
-			test_long_less_than_or_equal("background priority precedence",
-					counts[i].count, counts[i+2].count);
-		}
-#endif
-	}
-}
-
-static void
-cpubusy(void* context)
-{
-	if (done) return;
-	size_t idx;
-	for (idx = 0; idx < LOOP_COUNT; ++idx) {
-		if (done) break;
-	}
-
-	volatile long *count = context;
-	long iterdone = __sync_sub_and_fetch(&iterations, 1);
-
-	if (iterdone >= 0) {
-		__sync_add_and_fetch(count, 1);
-		if (!iterdone) {
-			__sync_add_and_fetch(&done, 1);
-			usleep(100000);
-			histogram();
-			dispatch_time_t delay = DISPATCH_TIME_NOW;
-			dispatch_after(delay, dispatch_get_main_queue(), ^{
-				test_stop();
-			});
-		}
-	}
-}
-
-static void
-submit_work(dispatch_queue_t queue, void* context)
-{
-	int i;
-
-	for (i = n_blocks(); i; --i) {
-		dispatch_async_f(queue, context, cpubusy);
-	}
-
-}
-
-int
-main(int argc __attribute__((unused)), char* argv[] __attribute__((unused)))
-{
-	dispatch_queue_t q[PRIORITIES];
-	size_t i;
-
-#if !USE_BACKGROUND_PRIORITY
-	prio0++;
-	priorities--;
-#endif
-
-	iterations = total = ((int)priorities * n_blocks()) / 2;
-
-#if USE_SET_TARGET_QUEUE
-	dispatch_test_start("Dispatch Priority (Set Target Queue)");
-#else
-	dispatch_test_start("Dispatch Priority");
-#endif
-
-	for (i = prio0; i < prio0 + priorities; i++) {
-		dispatch_queue_t rq = dispatch_get_global_queue(levels[i], 0);
-#if USE_SET_TARGET_QUEUE
-		q[i] = dispatch_queue_create(labels[i], DISPATCH_QUEUE_CONCURRENT);
-		test_ptr_notnull("q[i]", q[i]);
-		assert(q[i]);
-		dispatch_suspend(q[i]);
-		dispatch_set_target_queue(q[i], rq);
-		if (DISPATCH_QUEUE_CONCURRENT != NULL) {
-			dispatch_queue_set_width(q[i], LONG_MAX);
-		}
-		dispatch_release(rq);
-#else
-		q[i] = rq;
-#endif
-	}
-
-	for (i = prio0; i < prio0 + priorities; i++) {
-		submit_work(q[i], &counts[i].count);
-	}
-
-	for (i = prio0; i < prio0 + priorities; i++) {
-		dispatch_resume(q[i]);
-		dispatch_release(q[i]);
-	}
-
-	dispatch_main();
-
-	return 0;
-}
--- a/Telegram/ThirdParty/dispatch/tests/dispatch_proc.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/dispatch_proc.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,131 +0,0 @@
-/*
- * Copyright (c) 2008-2011 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include <dispatch/dispatch.h>
-#include <stdio.h>
-#if defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))
-#include <unistd.h>
-#endif
-#include <stdlib.h>
-#include <assert.h>
-#include <spawn.h>
-#include <signal.h>
-#ifdef __APPLE__
-#include <libkern/OSAtomic.h>
-#endif
-
-#include <bsdtests.h>
-#include "dispatch_test.h"
-
-#define PID_CNT 5
-
-static long event_cnt;
-
-void
-test_proc(pid_t bad_pid)
-{
-	dispatch_source_t proc_s[PID_CNT], proc;
-	int res;
-	pid_t pid, monitor_pid;
-
-	event_cnt = 0;
-	// Creates a process and register multiple observers.  Send a signal,
-	// exit the process, etc., and verify all observers were notified.
-
-	posix_spawnattr_t attr;
-	res = posix_spawnattr_init(&attr);
-	assert(res == 0);
-	res = posix_spawnattr_setflags(&attr, POSIX_SPAWN_START_SUSPENDED);
-	assert(res == 0);
-
-	char* args[] = {
-		"/bin/sleep", "2", NULL
-	};
-
-	res = posix_spawnp(&pid, args[0], NULL, &attr, args, NULL);
-	if (res < 0) {
-		perror(args[0]);
-		exit(127);
-	}
-
-	res = posix_spawnattr_destroy(&attr);
-	assert(res == 0);
-
-	dispatch_group_t group = dispatch_group_create();
-
-	assert(pid > 0);
-	monitor_pid = bad_pid ? bad_pid : pid; // rdar://problem/8090801
-
-	int i;
-	for (i = 0; i < PID_CNT; ++i) {
-		dispatch_group_enter(group);
-		proc = proc_s[i] = dispatch_source_create(DISPATCH_SOURCE_TYPE_PROC,
-				monitor_pid, DISPATCH_PROC_EXIT, dispatch_get_global_queue(0, 0));
-		test_ptr_notnull("dispatch_source_proc_create", proc);
-		dispatch_source_set_event_handler(proc, ^{
-			long flags = dispatch_source_get_data(proc);
-			test_long("DISPATCH_PROC_EXIT", flags, DISPATCH_PROC_EXIT);
-			event_cnt++;
-			dispatch_source_cancel(proc);
-		});
-		dispatch_source_set_cancel_handler(proc, ^{
-			dispatch_group_leave(group);
-		});
-		dispatch_resume(proc);
-	}
-	kill(pid, SIGCONT);
-	if (dispatch_group_wait(group, dispatch_time(DISPATCH_TIME_NOW, 10*NSEC_PER_SEC))) {
-		for (i = 0; i < PID_CNT; ++i) {
-			dispatch_source_cancel(proc_s[i]);
-		}
-		dispatch_group_wait(group, DISPATCH_TIME_FOREVER);
-	}
-	for (i = 0; i < PID_CNT; ++i) {
-		dispatch_release(proc_s[i]);
-	}
-	dispatch_release(group);
-	// delay 5 seconds to give a chance for any bugs that
-	// result in too many events to be noticed
-	dispatch_after(dispatch_time(DISPATCH_TIME_NOW, 5*NSEC_PER_SEC), dispatch_get_main_queue(), ^{
-		int status;
-		int res2 = waitpid(pid, &status, 0);
-		assert(res2 != -1);
-		//int passed = (WIFEXITED(status) && WEXITSTATUS(status) == 0);
-		test_long("Sub-process exited", WEXITSTATUS(status) | WTERMSIG(status), 0);
-		test_long("Event count", event_cnt, PID_CNT);
-		if (bad_pid) {
-			test_stop();
-		} else {
-			dispatch_async(dispatch_get_main_queue(), ^{
-				test_proc(pid);
-			});
-		}
-	});
-}
-
-int
-main(void)
-{
-	dispatch_test_start("Dispatch Proc");
-	test_proc(0);
-	dispatch_main();
-
-	return 0;
-}
--- a/Telegram/ThirdParty/dispatch/tests/dispatch_queue_finalizer.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/dispatch_queue_finalizer.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,95 +0,0 @@
-/*
- * Copyright (c) 2008-2011 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include <dispatch/dispatch.h>
-#if defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))
-#include <unistd.h>
-#endif
-#include <stdarg.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <assert.h>
-
-#include <bsdtests.h>
-#include "dispatch_test.h"
-
-void *ctxt_magic = NULL;
-
-static void
-finalize(void *ctxt)
-{
-	test_ptr_null("finalizer ran", NULL);
-	test_ptr("correct context", ctxt, ctxt_magic);
-	test_stop();
-}
-
-static void
-never_call(void *ctxt)
-{
-	test_ptr_notnull("never_call should not run", NULL);
-	test_ptr("correct context", ctxt, NULL);
-}
-
-int
-main(void)
-{
-	dispatch_test_start("Dispatch Queue Finalizer");
-
-#if HAS_ARC4RANDOM
-#if defined(__LP64__) || defined(_WIN64)
-	ctxt_magic = (void*)((uintptr_t)arc4random() << 32 | arc4random());
-#else
-	ctxt_magic = (void*)arc4random();
-#endif
-#else // that is, if !HAS_ARC4RANDOM
-    ctxt_magic = (void *)random();
-#endif
-
-	// we need a non-NULL value for the tests to work properly
-	if (ctxt_magic == NULL) {
-		ctxt_magic = &ctxt_magic;
-	}
-
-	dispatch_queue_t q = dispatch_queue_create("com.apple.testing.finalizer", NULL);
-	test_ptr_notnull("dispatch_queue_new", q);
-
-	dispatch_set_finalizer_f(q, finalize);
-
-	dispatch_queue_t q_null_context = dispatch_queue_create("com.apple.testing.finalizer.context_null", NULL);
-
-	dispatch_set_context(q_null_context, NULL);
-	dispatch_set_finalizer_f(q_null_context, never_call);
-	dispatch_release(q_null_context);
-
-	// Don't test k
-	dispatch_after(dispatch_time(DISPATCH_TIME_NOW, NSEC_PER_SEC), dispatch_get_main_queue(), ^{
-		// Usign async to set the context helps test that blocks are
-		// run before the release as opposed to just thrown away.
-		dispatch_async(q, ^{
-			dispatch_set_context(q, ctxt_magic);
-		});
-
-		dispatch_release(q);
-	});
-
-	dispatch_main();
-	
-	return 0;
-}
--- a/Telegram/ThirdParty/dispatch/tests/dispatch_read2.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/dispatch_read2.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,464 +0,0 @@
-/*
- * Copyright (c) 2010-2011 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include <sys/stat.h>
-#include <sys/types.h>
-#include <assert.h>
-#include <fcntl.h>
-#include <stdio.h>
-#include <stdlib.h>
-#if defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))
-#include <fts.h>
-#include <sys/param.h>
-#include <unistd.h>
-#endif
-#include <errno.h>
-#ifdef __APPLE__
-#include <mach/mach.h>
-#include <mach/mach_time.h>
-#include <libkern/OSAtomic.h>
-#include <TargetConditionals.h>
-#endif
-#include <Block.h>
-
-#include <dispatch/dispatch.h>
-
-#include <bsdtests.h>
-#include "dispatch_test.h"
-
-#ifndef DISPATCHTEST_IO
-#if DISPATCH_API_VERSION >= 20100226 && DISPATCH_API_VERSION != 20101110
-#define DISPATCHTEST_IO 1
-#endif
-#endif
-
-static void
-test_fin(void *cxt)
-{
-	test_ptr("test_fin run", cxt, cxt);
-	test_stop();
-}
-
-#if DISPATCHTEST_IO
-
-/*
- Basic way of implementing dispatch_io's dispatch_read without
- using dispatch channel api's
- */
-static void
-dispatch_read2(dispatch_fd_t fd,
-			  size_t length,
-			  dispatch_queue_t queue,
-			  void (^handler)(dispatch_data_t d, int error))
-{
-#if !defined(_WIN32)
-	if (fcntl(fd, F_SETFL, O_NONBLOCK) != 0) {
-		test_errno("fcntl O_NONBLOCK", errno, 0);
-		test_stop();
-	}
-#endif
-	dispatch_source_t reader = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ,
-			(uintptr_t)fd, 0, queue);
-	test_ptr_notnull("reader", reader);
-
-	__block size_t bytes_read = 0;
-	__block dispatch_data_t data = dispatch_data_empty;
-	__block int err = 0;
-	dispatch_source_set_event_handler(reader, ^{
-		const ssize_t bufsiz = 1024*512; // 512KB buffer
-		char *buffer = NULL;
-#if defined(_WIN32)
-		SYSTEM_INFO si;
-		GetSystemInfo(&si);
-		size_t pagesize = (size_t)si.dwPageSize;
-		buffer = _aligned_malloc(bufsiz, pagesize);
-#else
-		size_t pagesize = (size_t)sysconf(_SC_PAGESIZE);
-		posix_memalign((void **)&buffer, pagesize, bufsiz);
-#endif
-		ssize_t actual = dispatch_test_fd_read(fd, buffer, bufsiz);
-		if (actual == -1) {
-			err = errno;
-		}
-		if (actual > 0) {
-			bytes_read += (size_t)actual;
-#if defined(_WIN32)
-			dispatch_data_t tmp_data = dispatch_data_create(buffer, (size_t)actual,
-					NULL, ^{ _aligned_free(buffer); });
-#else
-			dispatch_data_t tmp_data = dispatch_data_create(buffer, (size_t)actual,
-					NULL, DISPATCH_DATA_DESTRUCTOR_FREE);
-#endif
-			dispatch_data_t concat = dispatch_data_create_concat(data,tmp_data);
-			dispatch_release(tmp_data);
-			dispatch_release(data);
-			data = concat;
-		}
-		// If we reached EOF or we read as much we were asked to.
-		if (actual < bufsiz || bytes_read >= length) {
-			char foo[2];
-			actual = dispatch_test_fd_read(fd, foo, 2);
-			bytes_read += (size_t)actual;
-			// confirm EOF condition
-			test_long("EOF", actual, 0);
-			dispatch_source_cancel(reader);
-		}
-	});
-
-	dispatch_source_set_cancel_handler(reader, ^{
-		dispatch_data_t d = dispatch_data_create_subrange(data, 0, length);
-		dispatch_release(data);
-		handler(d, err);
-		dispatch_release(d);
-		dispatch_release(reader);
-	});
-
-	dispatch_resume(reader);
-}
-
-static void
-test_read(void)
-{
-	char *path = dispatch_test_get_large_file();
-	dispatch_fd_t fd = dispatch_test_fd_open(path, O_RDONLY);
-	if (fd == -1) {
-		test_errno("open", errno, 0);
-		test_stop();
-	}
-	dispatch_test_release_large_file(path);
-	free(path);
-#ifdef F_NOCACHE
-	if (fcntl(fd, F_NOCACHE, 1)) {
-		test_errno("fcntl F_NOCACHE", errno, 0);
-		test_stop();
-	}
-#else
-	// investigate what the impact of lack of file cache disabling has 
-	// for this test
-#endif
-	size_t size = (size_t)dispatch_test_fd_lseek(fd, 0, SEEK_END);
-	dispatch_test_fd_lseek(fd, 0, SEEK_SET);
-	dispatch_group_t g = dispatch_group_create();
-	void (^b)(dispatch_data_t, int) = ^(dispatch_data_t d, int error) {
-		test_errno("read error", error, 0);
-		test_sizet("dispatch data size", d ? dispatch_data_get_size(d) : 0, size);
-		if (d) {
-			const void *contig_buf;
-			size_t contig_size;
-			dispatch_data_t tmp = dispatch_data_create_map(d, &contig_buf,
-					&contig_size);
-			test_sizet("dispatch data contig size", contig_size, size);
-			if (contig_size) {
-				// Validate the copied buffer is similar to what we expect
-				char *buf = (char*)malloc(size);
-				dispatch_test_fd_pread(fd, buf, size, 0);
-				test_long("dispatch data contents", memcmp(buf, contig_buf,
-						size), 0);
-				free(buf);
-			}
-			dispatch_release(tmp);
-		}
-		dispatch_group_leave(g);
-	};
-	dispatch_group_enter(g);
-	dispatch_read(fd, SIZE_MAX, dispatch_get_global_queue(0, 0), b); // rdar://problem/7795794
-	test_group_wait(g);
-	dispatch_test_fd_lseek(fd, 0, SEEK_SET);
-	if (dispatch_test_check_evfilt_read_for_fd(fd)) {
-		dispatch_group_enter(g);
-		dispatch_read2(fd, size, dispatch_get_global_queue(0,0), b);
-		test_group_wait(g);
-	} else {
-		test_skip("EVFILT_READ kevent not firing for test file");
-	}
-	dispatch_release(g);
-	dispatch_test_fd_close(fd);
-}
-
-static void
-test_read_write(void)
-{
-#if defined(_WIN32)
-	char *path_in = dispatch_test_get_large_file();
-	char path_out[] = "dispatchtest_io.XXXXXX";
-
-	dispatch_fd_t in = dispatch_test_fd_open(path_in, O_RDONLY);
-	if (in == -1) {
-		test_errno("open", errno, 0);
-		test_stop();
-	}
-	dispatch_test_release_large_file(path_in);
-	free(path_in);
-
-	size_t siz_in = (size_t)dispatch_test_fd_lseek(in, 0, SEEK_END);
-	dispatch_test_fd_lseek(in, 0, SEEK_SET);
-#else
-	const char *path_in = "/dev/urandom";
-	char path_out[] = "/tmp/dispatchtest_io.XXXXXX";
-	const size_t siz_in = 10240;
-
-	dispatch_fd_t in = dispatch_test_fd_open(path_in, O_RDONLY);
-	if (in == -1) {
-		test_errno("open", errno, 0);
-		test_stop();
-	}
-#endif
-
-	dispatch_fd_t out = mkstemp(path_out);
-	if (out == -1) {
-		test_errno("mkstemp", errno, 0);
-		test_stop();
-	}
-	if (unlink(path_out) == -1) {
-		test_errno("unlink", errno, 0);
-		test_stop();
-	}
-
-	dispatch_queue_t q = dispatch_get_global_queue(0,0);
-	dispatch_group_t g = dispatch_group_create();
-	dispatch_group_enter(g);
-	__block dispatch_data_t data;
-	dispatch_read(in, siz_in, q, ^(dispatch_data_t data_in, int err_in) {
-		if (err_in) {
-			test_errno("dispatch_read", err_in, 0);
-			test_stop();
-		}
-		dispatch_test_fd_close(in);
-		size_t siz_out = dispatch_data_get_size(data_in);
-		test_sizet("read size", siz_out, siz_in);
-		dispatch_retain(data_in);
-		data = data_in;
-		dispatch_write(out, data, q, ^(dispatch_data_t data_out, int err_out) {
-			if (err_out || data_out) {
-				test_errno("dispatch_write", err_out, 0);
-				test_stop();
-			}
-			dispatch_test_fd_lseek(out, 0, SEEK_SET);
-			dispatch_read(out, siz_out, q,
-					^(dispatch_data_t cmp, int err_cmp) {
-				if (err_cmp) {
-					test_errno("dispatch_read", err_cmp, 0);
-					test_stop();
-				}
-				dispatch_test_fd_close(out);
-				size_t siz_cmp = dispatch_data_get_size(cmp);
-				test_sizet("readback size", siz_cmp, siz_out);
-				const void *data_buf, *cmp_buf;
-				dispatch_data_t data_map, cmp_map;
-				data_map = dispatch_data_create_map(data, &data_buf, NULL);
-				cmp_map = dispatch_data_create_map(cmp, &cmp_buf, NULL);
-				test_long("readback memcmp",
-						memcmp(data_buf, cmp_buf, MIN(siz_out, siz_cmp)), 0);
-				dispatch_release(cmp_map);
-				dispatch_release(data_map);
-				dispatch_release(data);
-				dispatch_group_leave(g);
-			});
-		});
-	});
-	test_group_wait(g);
-	dispatch_release(g);
-}
-
-static void
-test_read_writes(void) // <rdar://problem/7785143>
-{
-	const size_t chunks_out = 320;
-	const size_t siz_chunk = 32, siz_in = siz_chunk * chunks_out;
-
-#if defined(_WIN32)
-	char *path_in = dispatch_test_get_large_file();
-	char path_out[] = "dispatchtest_io.XXXXXX";
-
-	dispatch_fd_t in = dispatch_test_fd_open(path_in, O_RDONLY);
-	if (in == -1) {
-		test_errno("open", errno, 0);
-		test_stop();
-	}
-	dispatch_test_release_large_file(path_in);
-	free(path_in);
-#else
-	const char *path_in = "/dev/urandom";
-	char path_out[] = "/tmp/dispatchtest_io.XXXXXX";
-
-	dispatch_fd_t in = dispatch_test_fd_open(path_in, O_RDONLY);
-	if (in == -1) {
-		test_errno("open", errno, 0);
-		test_stop();
-	}
-#endif
-
-	dispatch_fd_t out = mkstemp(path_out);
-	if (out == -1) {
-		test_errno("mkstemp", errno, 0);
-		test_stop();
-	}
-	if (unlink(path_out) == -1) {
-		test_errno("unlink", errno, 0);
-		test_stop();
-	}
-
-	dispatch_queue_t q = dispatch_get_global_queue(0,0);
-	dispatch_group_t g = dispatch_group_create();
-	dispatch_group_enter(g);
-	__block dispatch_data_t data;
-	__block size_t siz_out;
-	dispatch_read(in, siz_in, q, ^(dispatch_data_t data_in, int err_in) {
-		if (err_in) {
-			test_errno("dispatch_read", err_in, 0);
-			test_stop();
-		}
-		dispatch_test_fd_close(in);
-		siz_out = dispatch_data_get_size(data_in);
-		test_sizet("read size", siz_out, siz_in);
-		dispatch_retain(data_in);
-		data = data_in;
-		dispatch_data_t data_chunks[chunks_out];
-		size_t i;
-		for (i = 0; i < chunks_out; i++) {
-			data_chunks[i] = dispatch_data_create_subrange(data_in,
-					i * siz_chunk, siz_chunk);
-		}
-		for (i = 0; i < chunks_out; i++) {
-			dispatch_data_t d = data_chunks[i];
-			dispatch_group_enter(g);
-			dispatch_write(out, d, q, ^(dispatch_data_t data_out,
-					int err_out) {
-				if (err_out || data_out) {
-					test_errno("dispatch_write", err_out, 0);
-					test_stop();
-				}
-				dispatch_group_leave(g);
-			});
-		}
-		for (i = 0; i < chunks_out; i++) {
-			dispatch_release(data_chunks[i]);
-		}
-		dispatch_group_leave(g);
-	});
-	test_group_wait(g);
-	dispatch_group_enter(g);
-	dispatch_test_fd_lseek(out, 0, SEEK_SET);
-	dispatch_read(out, siz_in, q,
-			^(dispatch_data_t cmp, int err_cmp) {
-		if (err_cmp) {
-			test_errno("dispatch_read", err_cmp, 0);
-			test_stop();
-		}
-		dispatch_test_fd_close(out);
-		size_t siz_cmp = dispatch_data_get_size(cmp);
-		test_sizet("readback size", siz_cmp, siz_out);
-		const void *data_buf, *cmp_buf;
-		dispatch_data_t data_map, cmp_map;
-		data_map = dispatch_data_create_map(data, &data_buf, NULL);
-		cmp_map = dispatch_data_create_map(cmp, &cmp_buf, NULL);
-		test_long("readback memcmp",
-				memcmp(data_buf, cmp_buf, MIN(siz_out, siz_cmp)), 0);
-		dispatch_release(cmp_map);
-		dispatch_release(data_map);
-		dispatch_release(data);
-		dispatch_group_leave(g);
-	});
-	test_group_wait(g);
-	dispatch_release(g);
-}
-
-#if !defined(_WIN32)
-static void
-test_writes_reads_eagain(void) // rdar://problem/8333366
-{
-	int in = open("/dev/urandom", O_RDONLY);
-	if (in == -1) {
-		test_errno("open", errno, 0);
-		test_stop();
-	}
-	int fds[2], *fd = fds;
-	if(pipe(fd) == -1) {
-		test_errno("pipe", errno, 0);
-		test_stop();
-	}
-	const size_t chunks = 320;
-	const size_t siz_chunk = 32, siz = siz_chunk * chunks;
-
-	dispatch_queue_t q = dispatch_get_global_queue(0,0);
-	dispatch_group_t g = dispatch_group_create();
-	__block size_t siz_acc = 0, deliveries = 0;
-	__block void (^b)(dispatch_data_t, int);
-	b = Block_copy(^(dispatch_data_t data, int err) {
-		if (err) {
-			test_errno("dispatch_read", err, 0);
-			test_stop();
-		}
-		deliveries++;
-		siz_acc += dispatch_data_get_size(data);
-		if (siz_acc < siz) {
-			dispatch_group_enter(g);
-			dispatch_read(*fd, siz, q, b);
-		}
-		dispatch_group_leave(g);
-	});
-	dispatch_group_enter(g);
-	dispatch_read(*fd, siz, q, b);
-	char *buf[siz_chunk];
-	size_t i;
-	for (i = 0; i < chunks; i++) {
-		ssize_t s = read(in, buf, siz_chunk);
-		if (s < (ssize_t)siz_chunk) {
-			test_errno("read", errno, 0);
-			test_stop();
-		}
-		s = write(*(fd+1), buf, siz_chunk);
-		if (s < (ssize_t)siz_chunk) {
-			test_errno("write", errno, 0);
-			test_stop();
-		}
-		usleep(10000);
-	}
-	close(in);
-	close(*(fd+1));
-	test_group_wait(g);
-	test_sizet("dispatch_read deliveries", deliveries, chunks);
-	test_sizet("dispatch_read data size", siz_acc, siz);
-	close(*fd);
-	Block_release(b);
-	dispatch_release(g);
-}
-#endif
-
-#endif // DISPATCHTEST_IO
-
-int
-main(void)
-{
-	dispatch_test_start("Dispatch IO Convenience Read/Write");
-
-	dispatch_async(dispatch_get_main_queue(), ^{
-#if DISPATCHTEST_IO
-		test_read();
-		test_read_write();
-		test_read_writes();
-#if !defined(_WIN32)
-		test_writes_reads_eagain();
-#endif
-#endif
-		test_fin(NULL);
-	});
-	dispatch_main();
-}
--- a/Telegram/ThirdParty/dispatch/tests/dispatch_read.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/dispatch_read.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,114 +0,0 @@
-/*
- * Copyright (c) 2008-2011 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include <sys/types.h>
-#include <assert.h>
-#include <fcntl.h>
-#include <stdio.h>
-#include <stdlib.h>
-#if defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))
-#include <unistd.h>
-#endif
-#include <errno.h>
-
-#include <dispatch/dispatch.h>
-
-#include <bsdtests.h>
-#include "dispatch_test.h"
-
-static size_t bytes_total;
-static size_t bytes_read;
-
-static void
-test_fin(void *cxt)
-{
-	test_ptr("test_fin run", cxt, cxt);
-	test_stop();
-}
-
-int
-main(void)
-{
-	char *path = dispatch_test_get_large_file();
-
-	dispatch_test_start("Dispatch Source Read");
-
-	dispatch_fd_t infd = dispatch_test_fd_open(path, O_RDONLY);
-	if (infd == -1) {
-		perror(path);
-		exit(EXIT_FAILURE);
-	}
-	dispatch_test_release_large_file(path);
-	free(path);
-
-	bytes_total = (size_t)dispatch_test_fd_lseek(infd, 0, SEEK_END);
-	dispatch_test_fd_lseek(infd, 0, SEEK_SET);
-
-#if !defined(_WIN32)
-	if (fcntl(infd, F_SETFL, O_NONBLOCK) != 0) {
-		perror(path);
-		exit(EXIT_FAILURE);
-	}
-#endif
-
-	if (!dispatch_test_check_evfilt_read_for_fd(infd)) {
-		test_skip("EVFILT_READ kevent not firing for test file");
-		test_fin(NULL);
-	}
-
-	dispatch_queue_t main_q = dispatch_get_main_queue();
-	test_ptr_notnull("dispatch_get_main_queue", main_q);
-
-	dispatch_source_t reader = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ, (uintptr_t)infd, 0, main_q);
-	test_ptr_notnull("dispatch_source_create", reader);
-	assert(reader);
-
-	dispatch_source_set_event_handler(reader, ^{
-		size_t estimated = dispatch_source_get_data(reader);
-		fprintf(stderr, "bytes available: %zu\n", estimated);
-		test_double_less_than_or_equal("estimated", estimated, bytes_total - bytes_read);
-		const ssize_t bufsiz = 1024*500; // 500 KB buffer
-		static char buffer[1024*500];	// 500 KB buffer
-		ssize_t actual = dispatch_test_fd_read(infd, buffer, sizeof(buffer));
-		bytes_read += (size_t)actual;
-		printf("bytes read: %zd\n", actual);
-		if (actual < bufsiz) {
-			actual = dispatch_test_fd_read(infd, buffer, sizeof(buffer));
-			bytes_read += (size_t)actual;
-			// confirm EOF condition
-			test_long("EOF", actual, 0);
-			dispatch_source_cancel(reader);
-		}
-	});
-
-	dispatch_source_set_cancel_handler(reader, ^{
-		test_sizet("Bytes read", bytes_read, bytes_total);
-		int res = dispatch_test_fd_close(infd);
-		test_errno("close", res == -1 ? errno : 0, 0);
-		dispatch_release(reader);
-	});
-
-	dispatch_set_context(reader, reader);
-	dispatch_set_finalizer_f(reader, test_fin);
-
-	dispatch_resume(reader);
-
-	dispatch_main();
-}
--- a/Telegram/ThirdParty/dispatch/tests/dispatch_readsync.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/dispatch_readsync.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,189 +0,0 @@
-/*
- * Copyright (c) 2008-2011 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include <dispatch/dispatch.h>
-#include <dispatch/private.h>
-#include <stdlib.h>
-#if defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))
-#include <unistd.h>
-#ifdef __ANDROID__
-#include <linux/sysctl.h>
-#else
-#if !defined(__linux__)
-#include <sys/sysctl.h>
-#endif
-#endif /* __ANDROID__ */
-#endif
-#include <assert.h>
-
-#include <bsdtests.h>
-#include "dispatch_test.h"
-
-#define LAPS 10000
-#define INTERVAL 100
-
-#if TARGET_OS_EMBEDDED
-#define BUSY 10000
-#define NTHREADS 16
-#else
-#define BUSY 1000000
-#define NTHREADS 64
-#endif
-
-static dispatch_group_t g;
-static volatile size_t r_count, w_count, workers, readers, writers, crw, count, drain;
-
-static void
-writer(void *ctxt)
-{
-	size_t w = __sync_add_and_fetch(&writers, 1), *m = (size_t *)ctxt;
-	if (w > *m) *m = w;
-
-	usleep(10000);
-	size_t busy = BUSY;
-	while (busy--) if (readers) __sync_add_and_fetch(&crw, 1);
-
-	if (__sync_sub_and_fetch(&w_count, 1) == 0) {
-		if (r_count == 0) {
-			dispatch_async(dispatch_get_main_queue(), ^{test_stop();});
-		}
-	}
-	__sync_sub_and_fetch(&writers, 1);
-	dispatch_group_leave(g);
-}
-
-static void
-reader(void *ctxt)
-{
-	size_t r = __sync_add_and_fetch(&readers, 1), *m = (size_t *)ctxt;
-	if (r > *m) *m = r;
-
-	usleep(10000);
-	size_t busy = BUSY;
-	while (busy--) if (writers) __sync_add_and_fetch(&crw, 1);
-
-	if (__sync_sub_and_fetch(&r_count, 1) == 0) {
-		if (r_count == 0) {
-			dispatch_async(dispatch_get_main_queue(), ^{test_stop();});
-		}
-	}
-	__sync_sub_and_fetch(&readers, 1);
-}
-
-static void
-test_readsync(dispatch_queue_t rq, dispatch_queue_t wq, size_t n)
-{
-	size_t i, max_readers = 0, max_writers = 0;
-	size_t *mrs = calloc(n, sizeof(size_t)), *mr, *mw = &max_writers;
-
-	r_count = LAPS * 2;
-	w_count = LAPS / INTERVAL;
-	workers = readers = writers = crw = count = 0;
-
-	for (i = 0, mr = mrs; i < n; i++, mr++) {
-		dispatch_group_async(g,
-				dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH,
-				DISPATCH_QUEUE_OVERCOMMIT), ^{
-			__sync_add_and_fetch(&workers, 1);
-			do {
-				usleep(100000);
-			} while (workers < n);
-			for (;;) {
-				size_t idx = __sync_add_and_fetch(&count, 1);
-				if (idx > LAPS) break;
-				dispatch_sync_f(rq, mr, reader);
-				if (!(idx % INTERVAL)) {
-					dispatch_group_enter(g);
-					dispatch_barrier_async_f(wq, mw, writer);
-				}
-				dispatch_sync_f(rq, mr, reader);
-				if (!(idx % (INTERVAL*10))) {
-					// Let the queue drain
-					__sync_add_and_fetch(&drain, 1);
-					usleep(10000);
-					dispatch_barrier_sync(wq, ^{});
-					__sync_sub_and_fetch(&drain, 1);
-				} else while (drain) usleep(1000);
-			}
-		});
-	}
-	dispatch_group_wait(g, DISPATCH_TIME_FOREVER);
-	for (i = 0, mr = mrs; i < n; i++, mr++) {
-		if (*mr > max_readers) max_readers = *mr;
-	}
-	free(mrs);
-
-	test_sizet("max readers", max_readers, n);
-	test_sizet("max writers", max_writers, 1);
-	test_sizet("concurrent readers & writers", crw, 0);
-}
-
-int
-main(void)
-{
-	dispatch_test_start("Dispatch Reader/Writer Queues");
-
-	uint32_t activecpu, wq_max_threads;
-#ifdef __linux__
-	activecpu = (uint32_t)sysconf(_SC_NPROCESSORS_ONLN);
-	// don't want to parse /proc/sys/kernel/threads-max
-	wq_max_threads = activecpu * NTHREADS + 2;
-#elif defined(_WIN32)
-	SYSTEM_INFO si;
-	GetSystemInfo(&si);
-	activecpu = si.dwNumberOfProcessors;
-	wq_max_threads = activecpu * NTHREADS + 2;
-#else
-	size_t s = sizeof(uint32_t);
-	sysctlbyname("hw.activecpu", &activecpu, &s, NULL, 0);
-	s = sizeof(uint32_t);
-	sysctlbyname("kern.wq_max_threads", &wq_max_threads, &s, NULL, 0);
-#endif
-
-	// cap at wq_max_threads - one wq thread for dq - one wq thread for manager
-	size_t n = MIN(activecpu * NTHREADS, wq_max_threads - 2);
-
-	g = dispatch_group_create();
-	dispatch_queue_attr_t qattr = NULL;
-#if DISPATCH_API_VERSION >= 20100518 // rdar://problem/7790099
-	qattr = DISPATCH_QUEUE_CONCURRENT;
-#endif
-	dispatch_queue_t dq = dispatch_queue_create("readsync", qattr);
-	assert(dq);
-	if (!qattr) {
-		dispatch_queue_set_width(dq, LONG_MAX); // rdar://problem/7919264
-		dispatch_barrier_sync(dq, ^{}); // wait for changes to take effect
-	}
-	test_readsync(dq, dq, n);
-
-	dispatch_queue_t tq = dispatch_queue_create("writebarrierasync", qattr);
-	assert(tq);
-	if (!qattr) {
-		dispatch_queue_set_width(tq, LONG_MAX);
-	}
-	dispatch_set_target_queue(dq, tq);
-	dispatch_barrier_sync(tq, ^{}); // wait for changes to take effect
-	test_readsync(dq, tq, n); // rdar://problem/8186485
-	dispatch_release(tq);
-
-	dispatch_release(dq);
-	dispatch_release(g);
-	dispatch_main();
-}
--- a/Telegram/ThirdParty/dispatch/tests/dispatch_select.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/dispatch_select.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,174 +0,0 @@
-/*
- * Copyright (c) 2010-2011 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include <stdio.h>
-#include <fcntl.h>
-#include <stdlib.h>
-#if defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))
-#include <unistd.h>
-#endif
-#include <sys/stat.h>
-#include <dispatch/dispatch.h>
-
-#include "dispatch_test.h"
-#include <bsdtests.h>
-
-static ssize_t actual;
-
-void stage1(int stage);
-void stage2(void);
-void finish(void* cxt);
-
-void
-stage1(int stage)
-{
-#if defined(_WIN32)
-	char *path = dispatch_test_get_large_file();
-	dispatch_fd_t fd = dispatch_test_fd_open(path, O_RDONLY);
-	if (fd == -1)
-	{
-		perror(path);
-		exit(EXIT_FAILURE);
-	}
-	dispatch_test_release_large_file(path);
-	free(path);
-#else
-	const char *path = "/dev/random";
-	int fd = open(path, O_RDONLY);
-	if (fd == -1)
-	{
-		perror(path);
-		exit(EXIT_FAILURE);
-	}
-#endif
-
-	dispatch_queue_t main_q = dispatch_get_main_queue();
-	test_ptr_notnull("main_q", main_q);
-
-	dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ, (uintptr_t)fd, 0, main_q);
-	test_ptr_notnull("select source", source);
-
-	dispatch_source_set_event_handler(source, ^{
-		size_t buffer_size = 500*1024;
-		char buffer[500*1024];
-		ssize_t sz = dispatch_test_fd_read(fd, buffer, buffer_size);
-		test_sizet_less_than_or_equal("kevent read 1", sz, buffer_size+1);
-		dispatch_source_cancel(source);
-	});
-
-	dispatch_source_set_cancel_handler(source, ^{
-		int res = dispatch_test_fd_close(fd);
-		test_errno("close", res ==  -1 ? errno : 0, 0);
-		dispatch_release(source);
-		if (stage == 1)
-		{
-			dispatch_async(dispatch_get_main_queue(), ^{
-				stage2();
-			});
-		}
-	});
-
-	if (stage == 3)
-	{
-		dispatch_set_context(source, source);
-		dispatch_set_finalizer_f(source, finish);
-	}
-
-	dispatch_resume(source);
-}
-
-void
-stage2(void)
-{
-	char *path = dispatch_test_get_large_file();
-	dispatch_fd_t fd = dispatch_test_fd_open(path, O_RDONLY);
-	if (fd == -1)
-	{
-		perror(path);
-		exit(EXIT_FAILURE);
-	}
-	dispatch_test_release_large_file(path);
-	free(path);
-
-	if (!dispatch_test_check_evfilt_read_for_fd(fd)) {
-		test_skip("EVFILT_READ kevent not firing for test file");
-		dispatch_test_fd_close(fd);
-		dispatch_async(dispatch_get_main_queue(), ^{
-			stage1(3);
-		});
-		return;
-	}
-
-	ssize_t expected = dispatch_test_fd_lseek(fd, 0, SEEK_END);
-	dispatch_test_fd_lseek(fd, 0, SEEK_SET);
-	actual = 0;
-
-	dispatch_queue_t main_q = dispatch_get_main_queue();
-	test_ptr_notnull("main_q", main_q);
-
-	dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ, (uintptr_t)fd, 0, main_q);
-	test_ptr_notnull("kevent source", source);
-
-	dispatch_source_set_event_handler(source, ^{
-		size_t est = dispatch_source_get_data(source);
-		test_sizet_less_than_or_equal("estimated", est, expected - actual);
-		char buffer[500*1024];
-		ssize_t sz = dispatch_test_fd_read(fd, buffer, sizeof(buffer));
-		actual += sz;
-		if (sz < (ssize_t)sizeof(buffer))
-		{
-			sz = dispatch_test_fd_read(fd, buffer, sizeof(buffer));
-			actual += sz;
-			test_long("EOF", sz, 0);
-			dispatch_source_cancel(source);
-		}
-	});
-
-	dispatch_source_set_cancel_handler(source, ^{
-		test_long("bytes read", actual, expected);
-		int res = dispatch_test_fd_close(fd);
-		test_errno("close", res ==  -1 ? errno : 0, 0);
-		dispatch_release(source);
-		dispatch_async(dispatch_get_main_queue(), ^{
-			stage1(3);
-		});
-	});
-
-	dispatch_resume(source);
-}
-
-void
-finish(void* cxt)
-{
-	test_ptr("finish", cxt, cxt);
-	test_stop();
-}
-
-int
-main(void)
-{
-	dispatch_test_start("Dispatch select workaround test"); // <rdar://problem/7678012>
-
-	dispatch_async(dispatch_get_main_queue(), ^{
-		stage1(1);
-	});
-
-	dispatch_main();
-}
--- a/Telegram/ThirdParty/dispatch/tests/dispatch_sema.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/dispatch_sema.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,56 +0,0 @@
-/*
- * Copyright (c) 2008-2011 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include <dispatch/dispatch.h>
-#if !USE_WIN32_SEM
-#include <pthread.h>
-#endif
-#include <stdio.h>
-#include <assert.h>
-
-#include <bsdtests.h>
-#include "dispatch_test.h"
-
-#define LAPS 10000
-
-int
-main(void)
-{
-	static long total;
-	dispatch_semaphore_t dsema;
-
-	dispatch_test_start("Dispatch Semaphore");
-
-	dsema = dispatch_semaphore_create(1);
-	assert(dsema);
-
-	dispatch_apply(LAPS, dispatch_get_global_queue(0, 0), ^(size_t idx __attribute__((unused))) {
-		dispatch_semaphore_wait(dsema, DISPATCH_TIME_FOREVER);
-		total++;
-		dispatch_semaphore_signal(dsema);
-	});
-
-	dispatch_release(dsema);
-
-	test_long("count", total, LAPS);
-	test_stop();
-
-	return 0;
-}
--- a/Telegram/ThirdParty/dispatch/tests/dispatch_starfish.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/dispatch_starfish.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,172 +0,0 @@
-/*
- * Copyright (c) 2008-2011 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-
-#ifdef __APPLE__
-#include <mach/mach.h>
-#include <mach/mach_time.h>
-#endif
-#include <dispatch/dispatch.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <assert.h>
-#ifdef __APPLE__
-#include <TargetConditionals.h>
-#endif
-
-#include <bsdtests.h>
-#include "dispatch_test.h"
-
-#define COUNT	1000ul
-#define LAPS	10ul
-
-#if LENIENT_DEADLINES
-#define ACCEPTABLE_LATENCY 10000
-#elif TARGET_OS_EMBEDDED
-#define ACCEPTABLE_LATENCY 3000
-#else
-#define ACCEPTABLE_LATENCY 1000
-#endif
-
-static dispatch_queue_t queues[COUNT];
-static size_t lap_count_down = LAPS;
-static size_t count_down;
-static uint64_t start;
-static mach_timebase_info_data_t tbi;
-
-static void do_test(void);
-
-static void
-collect(void *context __attribute__((unused)))
-{
-	uint64_t delta;
-	long double math;
-	size_t i;
-
-	if (--count_down) {
-		return;
-	}
-
-	delta = mach_absolute_time() - start;
-	delta *= tbi.numer;
-	delta /= tbi.denom;
-	math = delta;
-	math /= COUNT * COUNT * 2ul + COUNT * 2ul;
-
-	printf("lap: %zd\n", lap_count_down);
-	printf("count: %lu\n", COUNT);
-	printf("delta: %lu ns\n", (unsigned long)delta);
-	printf("math: %Lf ns / lap\n", math);
-
-	for (i = 0; i < COUNT; i++) {
-		dispatch_release(queues[i]);
-	}
-
-	// our malloc could be a lot better,
-	// this result is really a malloc torture test
-	test_long_less_than("Latency" , (long)math, ACCEPTABLE_LATENCY);
-
-	if (--lap_count_down) {
-		return do_test();
-	}
-
-	// give the threads some time to settle before test_stop() runs "leaks"
-	// ...also note, this is a total cheat.   dispatch_after lets this
-	// thread go idle, so dispatch cleans up the continuations cache.
-	// Doign the "old style" sleep left that stuff around and leaks
-	// took a LONG TIME to complete.   Long enough that the test harness
-	// decided to kill us.
-	dispatch_after_f(dispatch_time(DISPATCH_TIME_NOW, 5 * NSEC_PER_SEC), dispatch_get_main_queue(), NULL, test_stop_after_delay);
-}
-
-static void
-pong(void *context)
-{
-	dispatch_queue_t this_q = context;
-	size_t replies = (size_t)dispatch_get_context(this_q);
-
-	dispatch_set_context(this_q, (void *)--replies);
-	if (!replies) {
-		//printf("collect from: %s\n", dispatch_queue_get_label(dispatch_get_current_queue()));
-		dispatch_async_f(dispatch_get_main_queue(), NULL, collect);
-	}
-}
-
-static void
-ping(void *context)
-{
-	dispatch_queue_t reply_q = context;
-
-	dispatch_async_f(reply_q, reply_q, pong);
-}
-
-static void
-start_node(void *context)
-{
-	dispatch_queue_t this_q = context;
-	size_t i;
-
-	dispatch_set_context(this_q, (void *)COUNT);
-
-	for (i = 0; i < COUNT; i++) {
-		dispatch_async_f(queues[i], this_q, ping);
-	}
-}
-
-void
-do_test(void)
-{
-	dispatch_queue_t soup = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0);
-	kern_return_t kr;
-	char buf[1000];
-	size_t i;
-
-	count_down = COUNT;
-
-	kr = mach_timebase_info(&tbi);
-	assert(kr == 0);
-
-	start = mach_absolute_time();
-
-	for (i = 0; i < COUNT; i++) {
-		snprintf(buf, sizeof(buf), "com.example.starfish-node#%zd", i);
-		queues[i] = dispatch_queue_create(buf, NULL);
-		dispatch_suspend(queues[i]);
-		dispatch_set_target_queue(queues[i], soup);
-	}
-
-	for (i = 0; i < COUNT; i++) {
-		dispatch_async_f(queues[i], queues[i], start_node);
-	}
-
-	for (i = 0; i < COUNT; i++) {
-		dispatch_resume(queues[i]);
-	}
-}
-
-int
-main(void)
-{
-	dispatch_test_start("Dispatch Starfish");
-
-	do_test();
-
-	dispatch_main();
-}
--- a/Telegram/ThirdParty/dispatch/tests/dispatch_suspend_timer.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/dispatch_suspend_timer.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,115 +0,0 @@
-/*
- * Copyright (c) 2008-2011 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include <assert.h>
-#include <stdio.h>
-#include <string.h>
-
-#include <dispatch/dispatch.h>
-
-#include <bsdtests.h>
-#include "dispatch_test.h"
-
-dispatch_source_t tweedledee;
-dispatch_source_t tweedledum;
-
-static void
-fini(void *cxt)
-{
-	test_ptr_notnull("finalizer ran", cxt);
-	if (cxt == tweedledum) {
-		test_stop();
-	}
-}
-
-static void
-test_timer(void)
-{
-	dispatch_test_start("Dispatch Suspend Timer");
-
-	dispatch_queue_t main_q = dispatch_get_main_queue();
-	//test_ptr("dispatch_get_main_queue", main_q, dispatch_get_current_queue());
-
-	__block int i = 0, i_prime = 0;
-	__block int j = 0;
-
-	tweedledee = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, main_q);
-	test_ptr_notnull("dispatch_source_timer_create", tweedledee);
-
-	dispatch_source_set_timer(tweedledee, dispatch_time(DISPATCH_TIME_NOW, NSEC_PER_SEC), NSEC_PER_SEC, 0);
-
-	dispatch_source_set_cancel_handler(tweedledee, ^{
-		dispatch_release(tweedledee);
-	});
-
-	dispatch_source_set_event_handler(tweedledee, ^{
-		i_prime += dispatch_source_get_data(tweedledee);
-		fprintf(stderr, "tweedledee %d (%d)\n", ++i, i_prime);
-		if (i == 10) {
-			dispatch_source_cancel(tweedledee);
-		}
-	});
-
-	dispatch_set_context(tweedledee, tweedledee);
-	dispatch_set_finalizer_f(tweedledee, fini);
-	dispatch_resume(tweedledee);
-
-	tweedledum = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, main_q);
-	test_ptr_notnull("dispatch_source_timer_create", tweedledum);
-
-	dispatch_source_set_timer(tweedledum, dispatch_time(DISPATCH_TIME_NOW, 3 * NSEC_PER_SEC + NSEC_PER_SEC / 2), 3 * NSEC_PER_SEC, 0);
-
-	dispatch_source_set_cancel_handler(tweedledum, ^{
-		dispatch_release(tweedledum);
-	});
-
-	dispatch_source_set_event_handler(tweedledum, ^{
-		switch(++j) {
-			case 1:
-				fprintf(stderr, "suspending timer for 3 seconds\n");
-				dispatch_suspend(tweedledee);
-				break;
-			case 2:
-				fprintf(stderr, "resuming timer\n");
-				test_long("tweedledee tick count", i, 3);
-				test_long("tweedledee virtual tick count", i_prime, 3);
-				dispatch_resume(tweedledee);
-				break;
-			default:
-				test_long("tweedledee tick count", i, 7);
-				test_long("tweedledee virtual tick count", i_prime, 9);
-				dispatch_source_cancel(tweedledum);
-				break;
-		}
-	});
-
-	dispatch_set_context(tweedledum, tweedledum);
-	dispatch_set_finalizer_f(tweedledum, fini);
-	dispatch_resume(tweedledum);
-}
-
-int
-main(void)
-{
-	test_timer();
-	dispatch_main();
-
-	return 0;
-}
--- a/Telegram/ThirdParty/dispatch/tests/dispatch_sync_on_main.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/dispatch_sync_on_main.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,72 +0,0 @@
-/*
- * Copyright (c) 2009-2011 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include <dispatch/dispatch.h>
-#include <dispatch/private.h>
-#include <stdlib.h>
-#include <stdio.h>
-#if defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))
-#include <unistd.h>
-#endif
-#include <CoreFoundation/CoreFoundation.h>
-
-#include <bsdtests.h>
-#include "dispatch_test.h"
-
-const int32_t final = 10;
-int global_count = 0;
-
-static void
-work(void* ctxt __attribute__((unused)))
-{
-	if (global_count == INT_MAX) {
-		test_stop();
-	}
-	printf("Firing timer on main %d\n", ++global_count);
-	dispatch_after_f(dispatch_time(0, 100000*NSEC_PER_USEC),
-			dispatch_get_main_queue(), NULL, work);
-}
-
-int
-main(void)
-{
-	dispatch_test_start("Dispatch Sync on main"); // <rdar://problem/7181849>
-
-	dispatch_queue_t dq = dispatch_queue_create("foo.bar", NULL);
-	dispatch_async(dq, ^{
-		dispatch_async_f(dispatch_get_main_queue(), NULL, work);
-		int i;
-		for (i=0; i<final; ++i) {
-			dispatch_sync(dispatch_get_main_queue(), ^{
-				printf("Calling sync %d\n", i);
-				test_long("sync on main", pthread_main_np(), 1);
-				if (i == final-1) {
-					global_count = INT_MAX;
-				}
-			});
-			const struct timespec t = {.tv_nsec = 50000*NSEC_PER_USEC};
-			nanosleep(&t, NULL);
-		}
-	});
-	dispatch_release(dq);
-
-	CFRunLoopRun();
-	return 0;
-}
--- a/Telegram/ThirdParty/dispatch/tests/dispatch_test.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/dispatch_test.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,396 +0,0 @@
-/*
- * Copyright (c) 2008-2011 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include "dispatch_test.h"
-#include "bsdtests.h"
-
-#ifdef __OBJC_GC__
-#include <objc/objc-auto.h>
-#endif
-
-#include <fcntl.h>
-#include <stdlib.h>
-#include <stdio.h>
-#if defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))
-#include <unistd.h>
-#if __has_include(<sys/event.h>)
-#define HAS_SYS_EVENT_H 1
-#include <sys/event.h>
-#else
-#include <sys/poll.h>
-#endif
-#elif defined(_WIN32)
-#include <Windows.h>
-#include <bcrypt.h>
-#endif
-#include <assert.h>
-
-#include <dispatch/dispatch.h>
-
-void test_start(const char* desc);
-
-void
-dispatch_test_start(const char* desc)
-{
-#if defined(__OBJC_GC__) && MAC_OS_X_VERSION_MIN_REQUIRED < 1070
-	objc_startCollectorThread();
-#endif
-	test_start(desc);
-}
-
-bool
-dispatch_test_check_evfilt_read_for_fd(dispatch_fd_t fd)
-{
-#if HAS_SYS_EVENT_H
-	int kq = kqueue();
-	assert(kq != -1);
-	struct kevent ke = {
-		.ident = (uintptr_t)fd,
-		.filter = EVFILT_READ,
-		.flags = EV_ADD|EV_ENABLE,
-	};
-	struct timespec t = {
-		.tv_sec = 1,
-	};
-	int r = kevent(kq, &ke, 1, &ke, 1, &t);
-	close(kq);
-	return r > 0;
-#elif defined(_WIN32)
-	HANDLE handle = (HANDLE)fd;
-	// A zero-distance move retrieves the file pointer
-	LARGE_INTEGER currentPosition;
-	LARGE_INTEGER distance = {.QuadPart = 0};
-	if (!SetFilePointerEx(handle, distance, &currentPosition, FILE_CURRENT)) {
-		return false;
-	}
-	// If we are not at the end, assume the file is readable
-	LARGE_INTEGER fileSize;
-	if (GetFileSizeEx(handle, &fileSize) == 0) {
-		return false;
-	}
-	return currentPosition.QuadPart < fileSize.QuadPart;
-#else
-	struct pollfd pfd = {
-		.fd = fd,
-		.events = POLLIN,
-	};
-	int rc;
-	do {
-		rc = poll(&pfd, 1, 0);
-	} while (rc == -1 && errno == EINTR);
-	assert(rc != -1);
-	return rc == 1;
-#endif
-}
-
-char *
-dispatch_test_get_large_file(void)
-{
-#if defined(__APPLE__)
-	return strdup("/usr/bin/vi");
-#elif defined(__unix__) || defined(_WIN32)
-	// Depending on /usr/bin/vi being present is unreliable (especially on
-	// Android), so fill up a large-enough temp file with random bytes
-
-#if defined(_WIN32)
-	char temp_dir_buf[MAX_PATH];
-	const char *temp_dir = getenv("TEMP") ?: getenv("TMP");
-	if (!temp_dir) {
-		DWORD len = GetTempPathA(sizeof(temp_dir_buf), temp_dir_buf);
-		if (len > 0 && len < sizeof(temp_dir_buf)) {
-			temp_dir = temp_dir_buf;
-		} else {
-			temp_dir = ".";
-		}
-	}
-#else
-	const char *temp_dir = getenv("TMPDIR");
-	if (temp_dir == NULL || temp_dir[0] == '\0') {
-		temp_dir = "/tmp";
-	}
-#endif
-
-	const char *const suffix = "/dispatch_test.XXXXXX";
-	size_t temp_dir_len = strlen(temp_dir);
-	size_t suffix_len = strlen(suffix);
-	char *path = malloc(temp_dir_len + suffix_len + 1);
-	assert(path != NULL);
-	memcpy(path, temp_dir, temp_dir_len);
-	memcpy(&path[temp_dir_len], suffix, suffix_len + 1);
-	dispatch_fd_t temp_fd = mkstemp(path);
-	if (temp_fd == -1) {
-		perror("mkstemp");
-		exit(EXIT_FAILURE);
-	}
-
-	const size_t file_size = 2 * 1024 * 1024;
-	char *file_buf = malloc(file_size);
-	assert(file_buf != NULL);
-
-	ssize_t num;
-#if defined(_WIN32)
-	NTSTATUS status = BCryptGenRandom(NULL, (PUCHAR)file_buf, file_size,
-			BCRYPT_USE_SYSTEM_PREFERRED_RNG);
-	if (status < 0) {
-		fprintf(stderr, "BCryptGenRandom failed with %ld\n", status);
-		dispatch_test_release_large_file(path);
-		exit(EXIT_FAILURE);
-	}
-#else
-	int urandom_fd = open("/dev/urandom", O_RDONLY);
-	if (urandom_fd == -1) {
-		perror("/dev/urandom");
-		dispatch_test_release_large_file(path);
-		exit(EXIT_FAILURE);
-	}
-	size_t pos = 0;
-	while (pos < file_size) {
-		num = read(urandom_fd, &file_buf[pos], file_size - pos);
-		if (num > 0) {
-			pos += (size_t)num;
-		} else if (num == -1 && errno != EINTR) {
-			perror("read");
-			dispatch_test_release_large_file(path);
-			exit(EXIT_FAILURE);
-		}
-	}
-	close(urandom_fd);
-#endif
-
-	do {
-		num = dispatch_test_fd_write(temp_fd, file_buf, file_size);
-	} while (num == -1 && errno == EINTR);
-	if (num == -1) {
-		perror("write");
-		dispatch_test_release_large_file(path);
-		exit(EXIT_FAILURE);
-	}
-	assert(num == file_size);
-	dispatch_test_fd_close(temp_fd);
-	free(file_buf);
-	return path;
-#else
-#error "dispatch_test_get_large_file not implemented on this platform"
-#endif
-}
-
-void
-dispatch_test_release_large_file(const char *path)
-{
-#if defined(__APPLE__)
-	// The path is fixed to a system file - do nothing
-	(void)path;
-#elif defined(__unix__) || defined(_WIN32)
-	if (unlink(path) < 0) {
-		perror("unlink");
-	}
-#else
-#error "dispatch_test_release_large_file not implemented on this platform"
-#endif
-}
-
-void
-_dispatch_test_current(const char* file, long line, const char* desc, dispatch_queue_t expected)
-{
-	dispatch_queue_t actual = dispatch_get_current_queue();
-	_test_ptr(file, line, desc, actual, expected);
-}
-
-dispatch_fd_t
-dispatch_test_fd_open(const char *path, int flags)
-{
-#if defined(_WIN32)
-	DWORD desired_access = 0;
-	DWORD creation_disposition = OPEN_EXISTING;
-	switch (flags & (O_RDONLY | O_WRONLY | O_RDWR)) {
-		case O_RDONLY:
-			desired_access = GENERIC_READ;
-			break;
-		case O_WRONLY:
-			desired_access = GENERIC_WRITE;
-			break;
-		case O_RDWR:
-			desired_access = GENERIC_READ | GENERIC_WRITE;
-			break;
-	}
-	if (flags & O_CREAT) {
-		creation_disposition = OPEN_ALWAYS;
-		if (flags & O_EXCL) {
-			creation_disposition = CREATE_NEW;
-		}
-	}
-	// FILE_SHARE_DELETE is important here because tests must be able to delete
-	// temporary files after opening them
-	HANDLE handle = CreateFileA(path, desired_access,
-			FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
-			/* lpSecurityAttributes */ NULL, creation_disposition,
-			/* dwFlagsAndAttributes */ 0, /* hTemplateFile */ NULL);
-	if (handle == INVALID_HANDLE_VALUE) {
-		DWORD error = GetLastError();
-		switch (error) {
-			case ERROR_ACCESS_DENIED:
-				errno = EACCES;
-				break;
-			case ERROR_FILE_EXISTS:
-				errno = EEXIST;
-				break;
-			case ERROR_FILE_NOT_FOUND:
-			case ERROR_PATH_NOT_FOUND:
-				errno = ENOENT;
-				break;
-			default:
-				print_winapi_error("CreateFileA", GetLastError());
-				errno = EIO;
-				break;
-		}
-		return -1;
-	}
-	return (dispatch_fd_t)handle;
-#else
-	return open(path, flags);
-#endif
-}
-
-int
-dispatch_test_fd_close(dispatch_fd_t fd)
-{
-#if defined(_WIN32)
-	if (!CloseHandle((HANDLE)fd)) {
-		errno = EBADF;
-		return -1;
-	}
-	return 0;
-#else
-	return close(fd);
-#endif
-}
-
-off_t
-dispatch_test_fd_lseek(dispatch_fd_t fd, off_t offset, int whence)
-{
-#if defined(_WIN32)
-	DWORD method;
-	switch (whence) {
-		case SEEK_CUR:
-			method = FILE_CURRENT;
-			break;
-		case SEEK_END:
-			method = FILE_END;
-			break;
-        case SEEK_SET:
-        default:
-            method = FILE_BEGIN;
-            break;
-	}
-	LARGE_INTEGER distance = {.QuadPart = offset};
-	LARGE_INTEGER new_pos;
-	if (!SetFilePointerEx((HANDLE)fd, distance, &new_pos, method)) {
-		print_winapi_error("SetFilePointerEx", GetLastError());
-		errno = EINVAL;
-		return -1;
-	}
-	return (off_t)new_pos.QuadPart;
-#else
-	return lseek(fd, offset, whence);
-#endif
-}
-
-ssize_t
-dispatch_test_fd_pread(dispatch_fd_t fd, void *buf, size_t count, off_t offset)
-{
-#if defined(_WIN32)
-	OVERLAPPED overlapped;
-	memset(&overlapped, 0, sizeof(overlapped));
-	LARGE_INTEGER lioffset = {.QuadPart = offset};
-	overlapped.Offset = lioffset.LowPart;
-	overlapped.OffsetHigh = lioffset.HighPart;
-	DWORD num_read;
-	if (!ReadFile((HANDLE)fd, buf, count, &num_read, &overlapped)) {
-		print_winapi_error("ReadFile", GetLastError());
-		errno = EIO;
-		return -1;
-	}
-	return (ssize_t)num_read;
-#else
-	return pread(fd, buf, count, offset);
-#endif
-}
-
-ssize_t
-dispatch_test_fd_read(dispatch_fd_t fd, void *buf, size_t count)
-{
-#if defined(_WIN32)
-	if (GetFileType((HANDLE)fd) == FILE_TYPE_PIPE) {
-		OVERLAPPED ov = {0};
-		DWORD num_read;
-		BOOL success = ReadFile((HANDLE)fd, buf, count, &num_read, &ov);
-		if (!success && GetLastError() == ERROR_IO_PENDING) {
-			success = GetOverlappedResult((HANDLE)fd, &ov, &num_read,
-					/* bWait */ TRUE);
-		}
-		if (!success) {
-			print_winapi_error("ReadFile", GetLastError());
-			errno = EIO;
-			return -1;
-		}
-		return (ssize_t)num_read;
-	}
-	DWORD num_read;
-	if (!ReadFile((HANDLE)fd, buf, count, &num_read, NULL)) {
-		print_winapi_error("ReadFile", GetLastError());
-		errno = EIO;
-		return -1;
-	}
-	return (ssize_t)num_read;
-#else
-	return read(fd, buf, count);
-#endif
-}
-
-ssize_t
-dispatch_test_fd_write(dispatch_fd_t fd, const void *buf, size_t count)
-{
-#if defined(_WIN32)
-	if (GetFileType((HANDLE)fd) == FILE_TYPE_PIPE) {
-		OVERLAPPED ov = {0};
-		DWORD num_written;
-		BOOL success = WriteFile((HANDLE)fd, buf, count, &num_written, &ov);
-		if (!success && GetLastError() == ERROR_IO_PENDING) {
-			success = GetOverlappedResult((HANDLE)fd, &ov, &num_written,
-					/* bWait */ TRUE);
-		}
-		if (!success) {
-			print_winapi_error("WriteFile", GetLastError());
-			errno = EIO;
-			return -1;
-		}
-		return (ssize_t)num_written;
-	}
-	DWORD num_written;
-	if (!WriteFile((HANDLE)fd, buf, count, &num_written, NULL)) {
-		print_winapi_error("WriteFile", GetLastError());
-		errno = EIO;
-		return -1;
-	}
-	return (ssize_t)num_written;
-#else
-	return write(fd, buf, count);
-#endif
-}
--- a/Telegram/ThirdParty/dispatch/tests/dispatch_test.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/dispatch_test.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,65 +0,0 @@
-/*
- * Copyright (c) 2008-2011 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include <stdbool.h>
-#include <dispatch/dispatch.h>
-
-#if defined(__linux__) || defined(__FreeBSD__) || defined(__OpenBSD__)
-#include <generic_unix_port.h>
-#elif defined(_WIN32)
-#include <generic_win_port.h>
-#endif
-
-#define test_group_wait(g) do { \
-	if (dispatch_group_wait(g, dispatch_time(DISPATCH_TIME_NOW, \
-			25ull * NSEC_PER_SEC))) { \
-		test_long("group wait timed out", 1, 0); \
-		test_stop(); \
-	} } while (0)
-
-#if defined(__cplusplus)
-extern "C" {
-#endif
-
-void dispatch_test_start(const char* desc);
-
-bool dispatch_test_check_evfilt_read_for_fd(dispatch_fd_t fd);
-
-char *dispatch_test_get_large_file(void);
-void dispatch_test_release_large_file(const char *path);
-
-void _dispatch_test_current(const char* file, long line, const char* desc, dispatch_queue_t expected);
-#define dispatch_test_current(a,b) _dispatch_test_current(__SOURCE_FILE__, __LINE__, a, b)
-
-#if __APPLE__
-int sysctlbyname(const char *name, void *oldp, size_t *oldlenp, void *newp,
-		size_t *newpl);
-#endif
-
-dispatch_fd_t dispatch_test_fd_open(const char *path, int flags);
-int dispatch_test_fd_close(dispatch_fd_t fd);
-off_t dispatch_test_fd_lseek(dispatch_fd_t fd, off_t offset, int whence);
-ssize_t dispatch_test_fd_pread(dispatch_fd_t fd, void *buf, size_t count, off_t offset);
-ssize_t dispatch_test_fd_read(dispatch_fd_t fd, void *buf, size_t count);
-ssize_t dispatch_test_fd_write(dispatch_fd_t fd, const void *buf, size_t count);
-
-#if defined(__cplusplus)
-} /* extern "C" */
-#endif
--- a/Telegram/ThirdParty/dispatch/tests/dispatch_timer_bit31.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/dispatch_timer_bit31.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,74 +0,0 @@
-/*
- * Copyright (c) 2008-2011 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include <assert.h>
-#include <stdio.h>
-#include <string.h>
-#if defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))
-#include <sys/time.h>
-#endif
-
-#include <dispatch/dispatch.h>
-
-#include <bsdtests.h>
-#include "dispatch_test.h"
-
-static void
-test_timer(void)
-{
-	dispatch_test_start("Dispatch Source Timer, bit 31");
-
-	dispatch_queue_t main_q = dispatch_get_main_queue();
-	//test_ptr("dispatch_get_main_queue", main_q, dispatch_get_current_queue());
-
-	struct timeval start_time;
-
-	static dispatch_source_t s;
-	s = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, main_q);
-	test_ptr_notnull("dispatch_source_create", s);
-	dispatch_source_set_timer(s, dispatch_time(DISPATCH_TIME_NOW, 0x80000000ull), 0x80000000ull, 0);
-	gettimeofday(&start_time, NULL);
-
-	dispatch_source_set_event_handler(s, ^{
-		dispatch_source_cancel(s);
-	});
-
-	dispatch_source_set_cancel_handler(s, ^{
-		struct timeval end_time;
-		gettimeofday(&end_time, NULL);
-		// check, s/b 2.0799... seconds, which is <4 seconds
-		// when it could end on a bad boundry.
-		test_long_less_than("needs to finish faster than 4 seconds", end_time.tv_sec - start_time.tv_sec, 4);
-		// And it has to take at least two seconds...
-		test_long_less_than("can't finish faster than 2 seconds", 1, end_time.tv_sec - start_time.tv_sec);
-		test_stop();
-	});
-
-	dispatch_resume(s);
-}
-
-int
-main(void)
-{
-	test_timer();
-	dispatch_main();
-
-	return 0;
-}
--- a/Telegram/ThirdParty/dispatch/tests/dispatch_timer_bit63.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/dispatch_timer_bit63.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,71 +0,0 @@
-/*
- * Copyright (c) 2008-2011 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include <assert.h>
-#include <stdio.h>
-#include <string.h>
-#if defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))
-#include <sys/time.h>
-#endif
-
-#include <dispatch/dispatch.h>
-
-#include <bsdtests.h>
-#include "dispatch_test.h"
-
-static void
-test_timer(void)
-{
-	dispatch_test_start("Dispatch Source Timer, bit 63");
-
-	//uint64_t interval = 0xffffffffffffffffull;
-	uint64_t interval = 0x8000000000000001ull;
-
-	dispatch_queue_t mainq = dispatch_get_main_queue();
-
-	__block int i = 0;
-	struct timeval start_time;
-
-	gettimeofday(&start_time, NULL);
-
-	static dispatch_source_t ds;
-	ds = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, mainq);
-	assert(ds);
-	dispatch_source_set_event_handler(ds, ^{
-		assert(i < 1);
-		printf("%d\n", i++);
-	});
-	dispatch_source_set_timer(ds, DISPATCH_TIME_NOW, interval, 0);
-	dispatch_resume(ds);
-
-	dispatch_after(dispatch_time(DISPATCH_TIME_NOW, 1*NSEC_PER_SEC),
-		dispatch_get_main_queue(), ^{
-		test_stop();
-	});
-}
-
-int
-main(void)
-{
-	test_timer();
-	dispatch_main();
-
-	return 0;
-}
--- a/Telegram/ThirdParty/dispatch/tests/dispatch_timer.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/dispatch_timer.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,109 +0,0 @@
-/*
- * Copyright (c) 2008-2011 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include <stdlib.h>
-#include <assert.h>
-#include <stdio.h>
-#include <string.h>
-
-#include <dispatch/dispatch.h>
-
-#include <bsdtests.h>
-#include "dispatch_test.h"
-
-static bool finalized = false;
-
-static void
-test_fin(void *cxt)
-{
-	test_ptr("finalizer ran", cxt, cxt);
-	finalized = true;
-	test_stop();
-}
-
-static void
-test_timer(void)
-{
-	dispatch_test_start("Dispatch Source Timer");
-
-	const int stop_at = 3;
-
-	dispatch_queue_t main_q = dispatch_get_main_queue();
-	//test_ptr("dispatch_get_main_queue", main_q, dispatch_get_current_queue());
-
-	int64_t j;
-
-	// create timers in two classes:
-	//  * ones that should trigger before the test ends
-	//  * ones that shouldn't trigger before the test ends
-	for (j = 1; j <= 5; ++j)
-	{
-		dispatch_source_t s = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_global_queue(0, 0));
-		test_ptr_notnull("dispatch_source_create", s);
-
-		int64_t delta = (int64_t)((uint64_t)j * NSEC_PER_SEC + NSEC_PER_SEC / 10);
-		dispatch_source_set_timer(s, dispatch_time(DISPATCH_TIME_NOW, delta), DISPATCH_TIME_FOREVER, 0);
-
-		dispatch_source_set_event_handler(s, ^{
-			if (!finalized) {
-				test_long_less_than("timer number", (long)j, stop_at);
-				fprintf(stderr, "timer[%lu]\n", (unsigned long)j);
-			}
-			dispatch_release(s);
-		});
-		dispatch_resume(s);
-	}
-
-	__block int i = 0;
-
-	dispatch_source_t s = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, main_q);
-	test_ptr_notnull("dispatch_source_create", s);
-
-	dispatch_source_set_timer(s, dispatch_time(DISPATCH_TIME_NOW, 0), NSEC_PER_SEC, 0);
-
-	dispatch_source_set_cancel_handler(s, ^{
-		test_ptr_notnull("cancel handler run", s);
-		dispatch_release(s);
-	});
-
-	dispatch_source_set_event_handler(s, ^{
-		fprintf(stderr, "%d\n", ++i);
-		if (i >= stop_at) {
-			test_long("i", i, stop_at);
-			dispatch_source_set_timer(s, dispatch_time(DISPATCH_TIME_NOW, 0),
-					DISPATCH_TIME_FOREVER, 0);
-			dispatch_source_cancel(s);
-		}
-	});
-
-	dispatch_set_context(s, s);
-	dispatch_set_finalizer_f(s, test_fin);
-
-	dispatch_resume(s);
-}
-
-int
-main(void)
-{
-	test_timer();
-	dispatch_main();
-
-	return 0;
-}
--- a/Telegram/ThirdParty/dispatch/tests/dispatch_timer_set_time.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/dispatch_timer_set_time.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,82 +0,0 @@
-/*
- * Copyright (c) 2008-2011 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include <assert.h>
-#include <stdio.h>
-#include <string.h>
-#if defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))
-#include <sys/time.h>
-#endif
-
-#include <dispatch/dispatch.h>
-
-#include <bsdtests.h>
-#include "dispatch_test.h"
-
-static void
-test_timer(void)
-{
-	dispatch_test_start("Dispatch Update Timer");
-
-	dispatch_queue_t main_q = dispatch_get_main_queue();
-	//test_ptr("dispatch_get_main_queue", main_q, dispatch_get_current_queue());
-
-	__block int i = 0;
-	struct timeval start_time;
-
-	gettimeofday(&start_time, NULL);
-
-	dispatch_source_t s = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, main_q);
-	test_ptr_notnull("dispatch_source_create", s);
-
-	dispatch_source_set_timer(s, dispatch_time(DISPATCH_TIME_NOW, NSEC_PER_SEC), NSEC_PER_SEC, 0);
-
-	dispatch_source_set_cancel_handler(s, ^{
-		struct timeval end_time;
-		gettimeofday(&end_time, NULL);
-		// Make sure we actually managed to adjust the interval
-		// duration.  Fifteen one second ticks would blow past
-		// this.
-		test_long_less_than("total duration", end_time.tv_sec - start_time.tv_sec, 10);
-		test_stop();
-
-		dispatch_release(s);
-	});
-
-	dispatch_source_set_event_handler(s, ^{
-		fprintf(stderr, "%d\n", ++i);
-		if (i >= 15) {
-			dispatch_source_cancel(s);
-		} else if (i == 1) {
-			dispatch_source_set_timer(s, dispatch_time(DISPATCH_TIME_NOW, 0), NSEC_PER_SEC / 10, 0);
-		}
-	});
-	test_ptr_notnull("dispatch_source_timer_create", s);
-
-	dispatch_resume(s);
-}
-
-int
-main(void) {
-	test_timer();
-	dispatch_main();
-
-	return 0;
-}
--- a/Telegram/ThirdParty/dispatch/tests/dispatch_timer_short.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/dispatch_timer_short.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,135 +0,0 @@
-/*
- * Copyright (c) 2010-2011 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include <stdlib.h>
-#include <assert.h>
-#include <stdio.h>
-#include <string.h>
-#include <math.h>
-#ifdef __APPLE__
-#include <mach/mach_time.h>
-#include <libkern/OSAtomic.h>
-#endif
-
-#include <dispatch/dispatch.h>
-
-#include <bsdtests.h>
-#include "dispatch_test.h"
-
-#define delay (1ull * NSEC_PER_SEC)
-#define interval (5ull * NSEC_PER_USEC)
-
-#define N 25000
-
-static dispatch_source_t t[N];
-static dispatch_queue_t q;
-static dispatch_group_t g;
-
-static volatile int32_t count;
-static mach_timebase_info_data_t tbi;
-static uint64_t start, last;
-
-#define elapsed_ms(x) (((now-(x))*tbi.numer/tbi.denom)/(1000ull*NSEC_PER_USEC))
-
-static
-void
-test_fin(void *cxt)
-{
-	uint32_t finalCount = (uint32_t)count;
-	fprintf(stderr, "Called back every %llu us on average\n",
-			(delay/finalCount)/NSEC_PER_USEC);
-	test_long_less_than("Frequency", 1,
-		(long)ceil((double)delay/(double)(finalCount*interval)));
-	int i;
-	for (i = 0; i < N; i++) {
-		dispatch_source_cancel(t[i]);
-		dispatch_release(t[i]);
-	}
-	dispatch_resume(q);
-	dispatch_release(q);
-	dispatch_release(g);
-	test_ptr("finalizer ran", cxt, cxt);
-	test_stop();
-}
-
-static
-void
-test_short_timer(void)
-{
-	// Add a large number of timers with suspended target queue in front of
-	// the timer being measured <rdar://problem/7401353>
-	g = dispatch_group_create();
-	q = dispatch_queue_create("q", NULL);
-	int i;
-	for (i = 0; i < N; i++) {
-		t[i] = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, q);
-		dispatch_source_set_timer(t[i], DISPATCH_TIME_NOW, interval, 0);
-		dispatch_group_enter(g);
-		dispatch_source_set_registration_handler(t[i], ^{
-			dispatch_suspend(t[i]);
-			dispatch_group_leave(g);
-		});
-		dispatch_resume(t[i]);
-	}
-	// Wait for registration & configuration of all timers
-	dispatch_group_wait(g, DISPATCH_TIME_FOREVER);
-	dispatch_suspend(q);
-	for (i = 0; i < N; i++) {
-		dispatch_resume(t[i]);
-	}
-
-	dispatch_source_t s = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER,
-			0, 0, dispatch_get_global_queue(0, 0));
-	test_ptr_notnull("dispatch_source_create", s);
-	dispatch_source_set_timer(s, DISPATCH_TIME_NOW, interval, 0);
-	dispatch_source_set_event_handler(s, ^{
-		uint64_t now = mach_absolute_time();
-		if (!count) {
-			dispatch_after(dispatch_time(DISPATCH_TIME_NOW, delay),
-					dispatch_get_global_queue(0, 0), ^{
-				dispatch_source_cancel(s);
-				dispatch_release(s);
-			});
-			fprintf(stderr, "First timer callback  (after %4llu ms)\n",
-					elapsed_ms(start));
-		}
-		OSAtomicIncrement32(&count);
-		if (elapsed_ms(last) >= 100) {
-			fprintf(stderr, "%5d timer callbacks (after %4llu ms)\n", count,
-					elapsed_ms(start));
-			last = now;
-		}
-	});
-	dispatch_set_context(s, s);
-	dispatch_set_finalizer_f(s, test_fin);
-	fprintf(stderr, "Scheduling %llu us timer\n", interval/NSEC_PER_USEC);
-	start = last = mach_absolute_time();
-	dispatch_resume(s);
-}
-
-int
-main(void)
-{
-	dispatch_test_start("Dispatch Short Timer"); // <rdar://problem/7765184>
-	mach_timebase_info(&tbi);
-	test_short_timer();
-	dispatch_main();
-	return 0;
-}
--- a/Telegram/ThirdParty/dispatch/tests/dispatch_timer_timeout.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/dispatch_timer_timeout.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,77 +0,0 @@
-/*
- * Copyright (c) 2010-2011 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include <assert.h>
-#include <stdio.h>
-#include <string.h>
-#if defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))
-#include <sys/time.h>
-#endif
-
-#include <dispatch/dispatch.h>
-
-#include <bsdtests.h>
-#include "dispatch_test.h"
-
-int
-main(void)
-{
-	dispatch_test_start("Dispatch Source Timeout"); // <rdar://problem/8015967>
-
-	uint64_t mini_interval = 100ull; // 100 ns
-	uint64_t long_interval = 2000000000ull; // 2 secs
-
-	dispatch_queue_t timer_queue = dispatch_queue_create("timer_queue", NULL);
-
-	__block int value_to_be_changed = 5;
-	__block int fired = 0;
-
-	dispatch_source_t mini_timer, long_timer;
-	mini_timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, timer_queue);
-	dispatch_source_set_event_handler(mini_timer, ^{
-		printf("Firing mini-timer %d\n", ++fired);
-		printf("Suspending mini-timer queue\n");
-		dispatch_suspend(timer_queue);
-	});
-	dispatch_source_set_timer(mini_timer, DISPATCH_TIME_NOW, mini_interval, 0);
-
-	long_timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_global_queue(0, 0));
-	dispatch_source_set_event_handler(long_timer, ^{
-		printf("Firing long timer\n");
-		value_to_be_changed = 10;
-		dispatch_source_cancel(long_timer);
-	});
-	dispatch_source_set_timer(long_timer,
-		dispatch_time(DISPATCH_TIME_NOW, NSEC_PER_SEC) ,
-		long_interval, 0);
-
-	dispatch_resume(mini_timer);
-	dispatch_resume(long_timer);
-	sleep(6);
-	test_long("Checking final value", value_to_be_changed, 10);
-	test_long("Mini-timer fired", fired, 1);
-	dispatch_source_cancel(mini_timer);
-	dispatch_release(mini_timer);
-	dispatch_resume(timer_queue);
-	dispatch_release(timer_queue);
-	dispatch_release(long_timer);
-	test_stop();
-	return 0;
-}
--- a/Telegram/ThirdParty/dispatch/tests/dispatch_transform.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/dispatch_transform.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,875 +0,0 @@
-/*
- * Copyright (c) 2011-2012 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include <bsdtests.h>
-
-#if DISPATCH_API_VERSION >= 20111008 && !TARGET_OS_EMBEDDED
-
-#include <Security/Security.h>
-
-#include <dispatch/dispatch.h>
-#include <dispatch/private.h>
-#include <fcntl.h>
-
-#define printf_data(p, s) ({ \
-	__typeof__(s) _i; \
-	for (_i=0; _i<s; _i++) { \
-		printf("%c", ((uint8_t *)p)[_i]); \
-	} \
-	printf("\n"); \
-})
-
-#define test_data_equal(a, b, c)	({ \
-	const void * ptr, * ptr2; \
-	size_t size, size2; \
-	dispatch_data_t map = dispatch_data_create_map(b, &ptr, &size); \
-	assert(map); \
-	dispatch_data_t map2 = dispatch_data_create_map(c, &ptr2, &size2); \
-	assert(map); \
-	test_long(a ": length", size, size2); \
-	test_long(a ": memcmp", memcmp(ptr, ptr2, size), 0); \
-	if (size != size2 || (memcmp(ptr, ptr2, size) != 0)) { \
-		printf_data(ptr, size); \
-		printf_data(ptr2, size2); \
-	} \
-	dispatch_release(map); \
-	dispatch_release(map2); \
-})
-
-static bool
-dispatch_data_equal(dispatch_data_t a, dispatch_data_t b)
-{
-	const void * ptr, * ptr2;
-	size_t size, size2;
-	bool equal = true;
-
-	dispatch_data_t map = dispatch_data_create_map(a, &ptr, &size); \
-	assert(map);
-	dispatch_data_t map2 = dispatch_data_create_map(b, &ptr2, &size2); \
-	assert(map2);
-
-	if (size == size2) {
-		if (memcmp(ptr, ptr2, size) != 0) {
-			equal = false;
-		}
-	} else {
-		equal = false;
-	}
-	dispatch_release(map);
-	dispatch_release(map2);
-	return equal;
-}
-
-static dispatch_data_t
-execute_sectransform(SecTransformRef transformRef, dispatch_data_t data)
-{
-	const void * bytes;
-	size_t size;
-
-	dispatch_data_t map = dispatch_data_create_map(data, &bytes, &size);
-	assert(map);
-
-	CFDataRef dataRef = CFDataCreate(kCFAllocatorDefault, bytes, size);
-	assert(dataRef);
-
-	dispatch_release(map);
-
-	SecTransformSetAttribute(transformRef, kSecTransformInputAttributeName, dataRef, NULL);
-
-	CFDataRef transformedDataRef = SecTransformExecute(transformRef, NULL);
-	assert(transformedDataRef);
-
-	CFRelease(dataRef);
-
-	dispatch_data_t output = dispatch_data_create(CFDataGetBytePtr(transformedDataRef), CFDataGetLength(transformedDataRef), dispatch_get_main_queue(), DISPATCH_DATA_DESTRUCTOR_DEFAULT);
-	CFRelease(transformedDataRef);
-
-	return output;
-}
-
-#pragma mark - UTF tests
-
-static uint8_t utf8[] = {
-	0x53, 0x6f, 0x20, 0x6c, 0x6f, 0x6e, 0x67, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x74, 0x68, 0x61, 0x6e, 0x6b, 0x73, 0x20, 0x66, 0x6f,
-	0x72, 0x20, 0x61, 0x6c, 0x6c, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x73, 0x68, 0x2e, 0x20, 0xeb, 0x84, 0x88, 0xeb, 0xac,
-	0xb4, 0x20, 0xec, 0x98, 0xa4, 0xeb, 0x9e, 0x98, 0x20, 0xea, 0xb7, 0xb8, 0xeb, 0xa6, 0xac, 0xea, 0xb3, 0xa0, 0x20, 0xea, 0xb7,
-	0xb8, 0x20, 0xeb, 0x8f, 0x99, 0xec, 0x95, 0x88, 0x20, 0xeb, 0xa7, 0x9b, 0xec, 0x9e, 0x88, 0xeb, 0x8a, 0x94, 0x20, 0xec, 0x83,
-	0x9d, 0xec, 0x84, 0xa0, 0xec, 0x9d, 0x80, 0x20, 0xea, 0xb3, 0xa0, 0xeb, 0xa7, 0x88, 0xec, 0x9b, 0xa0, 0xec, 0x96, 0xb4, 0x2e,
-	0x20, 0xf0, 0x9f, 0x98, 0x84, 0xf0, 0x9f, 0x98, 0x8a, 0xf0, 0x9f, 0x98, 0x83, 0xe2, 0x98, 0xba, 0xf0, 0x9f, 0x98, 0x89, 0xf0,
-	0x9f, 0x98, 0x8d, 0xf0, 0x9f, 0x92, 0xa8, 0xf0, 0x9f, 0x92, 0xa9, 0xf0, 0x9f, 0x91, 0x8e, 0x2e,
-};
-
-static uint16_t utf16[] = {
-	0xfeff, 0x53, 0x6f, 0x20, 0x6c, 0x6f, 0x6e, 0x67, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x74, 0x68, 0x61, 0x6e, 0x6b, 0x73, 0x20, 0x66,
-	0x6f, 0x72, 0x20, 0x61, 0x6c, 0x6c, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x73, 0x68, 0x2e, 0x20, 0xb108, 0xbb34, 0x20,
-	0xc624, 0xb798, 0x20, 0xadf8, 0xb9ac, 0xace0, 0x20, 0xadf8, 0x20, 0xb3d9, 0xc548, 0x20, 0xb9db, 0xc788, 0xb294, 0x20, 0xc0dd,
-	0xc120, 0xc740, 0x20, 0xace0, 0xb9c8, 0xc6e0, 0xc5b4, 0x2e, 0x20, 0xd83d, 0xde04, 0xd83d, 0xde0a, 0xd83d, 0xde03, 0x263a, 0xd83d,
-	0xde09, 0xd83d, 0xde0d, 0xd83d, 0xdca8, 0xd83d, 0xdca9, 0xd83d, 0xdc4e, 0x2e,
-};
-
-static uint16_t utf16be[] = {
-	0xfffe, 0x5300, 0x6f00, 0x2000, 0x6c00, 0x6f00, 0x6e00, 0x6700, 0x2000, 0x6100, 0x6e00, 0x6400, 0x2000, 0x7400, 0x6800, 0x6100,
-	0x6e00, 0x6b00, 0x7300, 0x2000, 0x6600, 0x6f00, 0x7200, 0x2000, 0x6100, 0x6c00, 0x6c00, 0x2000, 0x7400, 0x6800, 0x6500, 0x2000,
-	0x6600, 0x6900, 0x7300, 0x6800, 0x2e00, 0x2000, 0x8b1, 0x34bb, 0x2000, 0x24c6, 0x98b7, 0x2000, 0xf8ad, 0xacb9, 0xe0ac, 0x2000,
-	0xf8ad, 0x2000, 0xd9b3, 0x48c5, 0x2000, 0xdbb9, 0x88c7, 0x94b2, 0x2000, 0xddc0, 0x20c1, 0x40c7, 0x2000, 0xe0ac, 0xc8b9, 0xe0c6,
-	0xb4c5, 0x2e00, 0x2000, 0x3dd8, 0x4de, 0x3dd8, 0xade, 0x3dd8, 0x3de, 0x3a26, 0x3dd8, 0x9de, 0x3dd8, 0xdde, 0x3dd8, 0xa8dc,
-	0x3dd8, 0xa9dc, 0x3dd8, 0x4edc, 0x2e00,
-};
-
-// Invalid due to half missing surrogate
-static uint16_t utf16le_invalid[] = {
-	0xfeff, 0x53, 0x6f, 0x20, 0x6c, 0x6f, 0x6e, 0x67, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x74, 0x68, 0x61, 0x6e, 0x6b, 0x73, 0x20, 0x66,
-	0x6f, 0x72, 0x20, 0x61, 0x6c, 0x6c, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x73, 0x68, 0x2e, 0x20, 0xb108, 0xbb34, 0x20,
-	0xc624, 0xb798, 0x20, 0xadf8, 0xb9ac, 0xace0, 0x20, 0xadf8, 0x20, 0xb3d9, 0xc548, 0x20, 0xb9db, 0xc788, 0xb294, 0x20, 0xc0dd,
-	0xc120, 0xc740, 0x20, 0xace0, 0xb9c8, 0xc6e0, 0xc5b4, 0x2e, 0x20, 0xd83d, 0xde04, 0xd83d, 0xde0a, 0xd83d, 0xde03, 0x263a, 0xd83d,
-	0xde09, 0xd83d, 0xde0d, 0xd83d, 0xdca8, 0xd83d, 0xd83d, 0xdc4e, 0x2e,
-};
-
-void
-invalid_utf8_test(void * context)
-{
-	dispatch_data_t utf8_data = dispatch_data_create(utf8 + sizeof(utf8) - 8, 8, NULL, ^{});
-
-	dispatch_data_t transformed = dispatch_data_create_with_transform(utf8_data, DISPATCH_DATA_FORMAT_TYPE_UTF8, DISPATCH_DATA_FORMAT_TYPE_UTF16LE);
-	test_ptr_null("dispatch_data_create_with_transform (UTF8 (invalid start) -> UTF16LE)", transformed);
-
-	dispatch_release(utf8_data);
-
-	(void)context;
-}
-
-void
-truncated_utf8_test(void * context)
-{
-	dispatch_data_t utf8_data = dispatch_data_create(utf8, sizeof(utf8) - 3, NULL, ^{});
-
-	dispatch_data_t transformed = dispatch_data_create_with_transform(utf8_data, DISPATCH_DATA_FORMAT_TYPE_UTF8, DISPATCH_DATA_FORMAT_TYPE_UTF16LE);
-	test_ptr_null("dispatch_data_create_with_transform (UTF8 (truncated) -> UTF16LE)", transformed);
-
-	dispatch_release(utf8_data);
-
-	dispatch_group_async_f(context, dispatch_get_main_queue(), context, invalid_utf8_test);
-}
-
-void
-invalid_utf16le_surrogate_test(void * context)
-{
-	dispatch_data_t utf8_data = dispatch_data_create(utf8, sizeof(utf8), NULL, ^{});
-	dispatch_data_t utf16_data = dispatch_data_create(utf16le_invalid, sizeof(utf16le_invalid), NULL, ^{});
-
-	dispatch_data_t transformed = dispatch_data_create_with_transform(utf16_data, DISPATCH_DATA_FORMAT_TYPE_UTF16LE, DISPATCH_DATA_FORMAT_TYPE_UTF8);
-	test_ptr_null("dispatch_data_create_with_transform (UTF16LE (missing surrogate) -> UTF8)", transformed);
-
-	dispatch_release(utf16_data);
-	dispatch_release(utf8_data);
-
-	dispatch_group_async_f(context, dispatch_get_main_queue(), context, truncated_utf8_test);
-}
-
-void
-invalid_utf16le_test(void * context)
-{
-	dispatch_data_t utf8_data = dispatch_data_create(utf8, sizeof(utf8), NULL, ^{});
-	dispatch_data_t utf16_data = dispatch_data_create(utf16, (sizeof(utf16) % 2) + 1, NULL, ^{});
-
-	dispatch_data_t transformed = dispatch_data_create_with_transform(utf16_data, DISPATCH_DATA_FORMAT_TYPE_UTF16LE, DISPATCH_DATA_FORMAT_TYPE_UTF8);
-	test_ptr_null("dispatch_data_create_with_transform (UTF16LE (invalid) -> UTF8)", transformed);
-
-	dispatch_release(utf16_data);
-	dispatch_release(utf8_data);
-
-	dispatch_group_async_f(context, dispatch_get_main_queue(), context, invalid_utf16le_surrogate_test);
-}
-
-void
-utf16le_bytes_to_utf8_test(void * context)
-{
-	dispatch_data_t utf16_data = dispatch_data_empty;
-	dispatch_data_t utf8_data = dispatch_data_create(utf8, sizeof(utf8), NULL, ^{});
-
-	size_t i;
-	for (i=0; i<sizeof(utf16); i++) {
-		dispatch_data_t new = dispatch_data_create((char*)utf16 + i, 1, NULL, ^{});
-		dispatch_data_t concat = dispatch_data_create_concat(utf16_data, new);
-		dispatch_release(new);
-		dispatch_release(utf16_data);
-		utf16_data = concat;
-	}
-
-	dispatch_data_t transformed = dispatch_data_create_with_transform(utf16_data, DISPATCH_DATA_FORMAT_TYPE_UTF_ANY, DISPATCH_DATA_FORMAT_TYPE_UTF8);
-	test_ptr_notnull("dispatch_data_create_with_transform (UTF16LE (any, single bytes) -> UTF8)", transformed);
-	test_data_equal("utf16le_bytes_to_utf8_test", transformed, utf8_data);
-
-	dispatch_release(transformed);
-	dispatch_release(utf8_data);
-	dispatch_release(utf16_data);
-
-	dispatch_group_async_f(context, dispatch_get_main_queue(), context, invalid_utf16le_test);
-}
-
-void
-utf8_bytes_to_utf16le_test(void * context)
-{
-	dispatch_data_t utf8_data = dispatch_data_empty;
-	dispatch_data_t utf16_data = dispatch_data_create(utf16, sizeof(utf16), NULL, ^{});
-
-	size_t i;
-	for (i=0; i<sizeof(utf8); i++) {
-		dispatch_data_t new = dispatch_data_create(utf8 + i, 1, NULL, ^{});
-		dispatch_data_t concat = dispatch_data_create_concat(utf8_data, new);
-		dispatch_release(new);
-		dispatch_release(utf8_data);
-		utf8_data = concat;
-	}
-
-	dispatch_data_t transformed = dispatch_data_create_with_transform(utf8_data, DISPATCH_DATA_FORMAT_TYPE_UTF_ANY, DISPATCH_DATA_FORMAT_TYPE_UTF16LE);
-	test_ptr_notnull("dispatch_data_create_with_transform (UTF8 (any, single bytes) -> UTF16LE)", transformed);
-	test_data_equal("utf8_bytes_to_utf16le_test", transformed, utf16_data);
-
-	dispatch_release(transformed);
-	dispatch_release(utf8_data);
-	dispatch_release(utf16_data);
-
-	dispatch_group_async_f(context, dispatch_get_main_queue(), context, utf16le_bytes_to_utf8_test);
-}
-
-void
-utf16be_detect_to_utf16le_test(void * context)
-{
-	dispatch_data_t utf16be_data = dispatch_data_create(utf16be, sizeof(utf16be), NULL, ^{});
-	dispatch_data_t utf16_data = dispatch_data_create(utf16, sizeof(utf16), NULL, ^{});
-
-	dispatch_data_t transformed = dispatch_data_create_with_transform(utf16be_data, DISPATCH_DATA_FORMAT_TYPE_UTF_ANY, DISPATCH_DATA_FORMAT_TYPE_UTF16LE);
-	test_ptr_notnull("dispatch_data_create_with_transform (UTF16BE (any) -> UTF16LE)", transformed);
-	test_data_equal("utf16be_detect_to_utf16le_test", transformed, utf16_data);
-
-	dispatch_release(transformed);
-	dispatch_release(utf16be_data);
-	dispatch_release(utf16_data);
-
-	dispatch_group_async_f(context, dispatch_get_main_queue(), context, utf8_bytes_to_utf16le_test);
-}
-
-void
-utf16be_detect_to_utf8_test(void * context)
-{
-	dispatch_data_t utf8_data = dispatch_data_create(utf8, sizeof(utf8), NULL, ^{});
-	dispatch_data_t utf16_data = dispatch_data_create(utf16be, sizeof(utf16be), NULL, ^{});
-
-	dispatch_data_t transformed = dispatch_data_create_with_transform(utf16_data, DISPATCH_DATA_FORMAT_TYPE_UTF_ANY, DISPATCH_DATA_FORMAT_TYPE_UTF8);
-	test_ptr_notnull("dispatch_data_create_with_transform (UTF16BE (any) -> UTF8)", transformed);
-	test_data_equal("utf16be_detect_to_utf8_test", transformed, utf8_data);
-
-	dispatch_release(transformed);
-	dispatch_release(utf16_data);
-	dispatch_release(utf8_data);
-
-	dispatch_group_async_f(context, dispatch_get_main_queue(), context, utf16be_detect_to_utf16le_test);
-}
-
-void
-utf16le_detect_to_utf8_test(void * context)
-{
-	dispatch_data_t utf8_data = dispatch_data_create(utf8, sizeof(utf8), NULL, ^{});
-	dispatch_data_t utf16_data = dispatch_data_create(utf16, sizeof(utf16), NULL, ^{});
-
-	dispatch_data_t transformed = dispatch_data_create_with_transform(utf16_data, DISPATCH_DATA_FORMAT_TYPE_UTF_ANY, DISPATCH_DATA_FORMAT_TYPE_UTF8);
-	test_ptr_notnull("dispatch_data_create_with_transform (UTF16LE (any) -> UTF8)", transformed);
-	test_data_equal("utf16le_detect_to_utf8_test", transformed, utf8_data);
-
-	dispatch_release(transformed);
-	dispatch_release(utf16_data);
-	dispatch_release(utf8_data);
-
-	dispatch_group_async_f(context, dispatch_get_main_queue(), context, utf16be_detect_to_utf8_test);
-}
-
-void
-utf16be_to_utf8_test(void * context)
-{
-	dispatch_data_t utf8_data = dispatch_data_create(utf8, sizeof(utf8), NULL, ^{});
-	dispatch_data_t utf16_data = dispatch_data_create(utf16be, sizeof(utf16be), NULL, ^{});
-
-	dispatch_data_t transformed = dispatch_data_create_with_transform(utf16_data, DISPATCH_DATA_FORMAT_TYPE_UTF16BE, DISPATCH_DATA_FORMAT_TYPE_UTF8);
-	test_ptr_notnull("dispatch_data_create_with_transform (UTF16BE -> UTF8)", transformed);
-	test_data_equal("utf16be_to_utf8_test", transformed, utf8_data);
-
-	dispatch_release(transformed);
-	dispatch_release(utf16_data);
-	dispatch_release(utf8_data);
-
-	dispatch_group_async_f(context, dispatch_get_main_queue(), context, utf16le_detect_to_utf8_test);
-}
-
-void
-utf16le_to_utf8_test(void * context)
-{
-	dispatch_data_t utf8_data = dispatch_data_create(utf8, sizeof(utf8), NULL, ^{});
-	dispatch_data_t utf16_data = dispatch_data_create(utf16, sizeof(utf16), NULL, ^{});
-
-	dispatch_data_t transformed = dispatch_data_create_with_transform(utf16_data, DISPATCH_DATA_FORMAT_TYPE_UTF16LE, DISPATCH_DATA_FORMAT_TYPE_UTF8);
-	test_ptr_notnull("dispatch_data_create_with_transform (UTF16LE -> UTF8)", transformed);
-	test_data_equal("utf16le_to_utf8_test", transformed, utf8_data);
-
-	dispatch_release(transformed);
-	dispatch_release(utf16_data);
-	dispatch_release(utf8_data);
-
-	dispatch_group_async_f(context, dispatch_get_main_queue(), context, utf16be_to_utf8_test);
-}
-
-void
-utf8_to_utf16be_test(void * context)
-{
-	dispatch_data_t utf8_data = dispatch_data_create(utf8, sizeof(utf8), NULL, ^{});
-	dispatch_data_t utf16_data = dispatch_data_create(utf16be, sizeof(utf16be), NULL, ^{});
-
-	dispatch_data_t transformed = dispatch_data_create_with_transform(utf8_data, DISPATCH_DATA_FORMAT_TYPE_UTF8, DISPATCH_DATA_FORMAT_TYPE_UTF16BE);
-	test_ptr_notnull("dispatch_data_create_with_transform (UTF8 -> UTF16BE)", transformed);
-	test_data_equal("utf8_to_utf16be_test", transformed, utf16_data);
-
-	dispatch_release(transformed);
-	dispatch_release(utf16_data);
-	dispatch_release(utf8_data);
-
-	dispatch_group_async_f(context, dispatch_get_main_queue(), context, utf16le_to_utf8_test);
-}
-
-void
-utf8_to_utf16le_test(void * context)
-{
-	dispatch_data_t utf8_data = dispatch_data_create(utf8, sizeof(utf8), NULL, ^{});
-	dispatch_data_t utf16_data = dispatch_data_create(utf16, sizeof(utf16), NULL, ^{});
-
-	dispatch_data_t transformed = dispatch_data_create_with_transform(utf8_data, DISPATCH_DATA_FORMAT_TYPE_UTF8, DISPATCH_DATA_FORMAT_TYPE_UTF16LE);
-	test_ptr_notnull("dispatch_data_create_with_transform (UTF8 -> UTF16LE)", transformed);
-	test_data_equal("utf8_to_utf16le_test", transformed, utf16_data);
-
-	dispatch_release(transformed);
-	dispatch_release(utf16_data);
-	dispatch_release(utf8_data);
-
-	dispatch_group_async_f(context, dispatch_get_main_queue(), context, utf8_to_utf16be_test);
-}
-
-#pragma mark - base32 tests
-
-void
-decode32_corrupt_test(void * context)
-{
-	dispatch_group_enter((dispatch_group_t)context);
-
-	int fd = open("/dev/random", O_RDONLY);
-	assert(fd >= 0);
-
-	dispatch_read(fd, 4096, dispatch_get_main_queue(), ^(dispatch_data_t data, int error) {
-		assert(error == 0);
-
-		SecTransformRef transformRef = SecEncodeTransformCreate(kSecBase32Encoding, NULL);
-		assert(transformRef);
-
-		dispatch_data_t sectransform_data = execute_sectransform(transformRef, data);
-		assert(sectransform_data);
-		CFRelease(transformRef);
-
-		void * corrupt_buffer = malloc(dispatch_data_get_size(sectransform_data));
-		const void * source;
-		size_t size;
-
-		dispatch_data_t map = dispatch_data_create_map(sectransform_data, &source, &size);
-		memcpy(corrupt_buffer, source, size);
-
-		size_t i;
-		for (i=0; i<size; i += (arc4random() % (int)(size * 0.05))) {
-			char x = arc4random() & 0xff;
-			while ((x >= 'A' && x <= 'Z') || (x >= 'a' && x <= 'z') || (x >= '0' && x <= '9') || x == '/' || x == '+' || x == '=') {
-				x = arc4random() & 0xff;
-			}
-
-			((char*)corrupt_buffer)[i] = x;
-		}
-
-		dispatch_release(map);
-		dispatch_release(sectransform_data);
-
-		dispatch_data_t corrupt_data = dispatch_data_create(corrupt_buffer, size, dispatch_get_main_queue(), DISPATCH_DATA_DESTRUCTOR_FREE);
-
-		dispatch_data_t transform_data = dispatch_data_create_with_transform(corrupt_data, DISPATCH_DATA_FORMAT_TYPE_BASE32, DISPATCH_DATA_FORMAT_TYPE_NONE);
-		test_ptr_null("decode32_corrupt_test: dispatch_data_create_with_transform", transform_data);
-
-		dispatch_release(corrupt_data);
-
-		close(fd);
-
-		dispatch_group_async_f(context, dispatch_get_main_queue(), context, utf8_to_utf16le_test);
-		dispatch_group_leave((dispatch_group_t)context);
-	});
-}
-
-void
-chunking_decode32_test(void * context)
-{
-	(void)context;
-
-	int fd = open("/dev/random", O_RDONLY);
-	assert(fd >= 0);
-
-	dispatch_data_t __block data = dispatch_data_empty;
-
-	int i;
-	dispatch_group_t group = dispatch_group_create();
-	dispatch_queue_t queue = dispatch_queue_create("read", 0);
-	for (i=0; i<4096; i++) {
-		dispatch_group_enter(group);
-
-		dispatch_read(fd, 1, queue, ^(dispatch_data_t d, int error) {
-			assert(error == 0);
-
-			dispatch_data_t concat = dispatch_data_create_concat(data, d);
-			dispatch_release(data);
-			data = concat;
-			dispatch_group_leave(group);
-		});
-	}
-	dispatch_group_wait(group, DISPATCH_TIME_FOREVER);
-	dispatch_release(queue);
-	dispatch_release(group);
-
-	SecTransformRef transformRef = SecEncodeTransformCreate(kSecBase32Encoding, NULL);
-	assert(transformRef);
-
-	dispatch_data_t sectransform_data = execute_sectransform(transformRef, data);
-	assert(sectransform_data);
-	CFRelease(transformRef);
-
-	dispatch_data_t transformed_data = dispatch_data_create_with_transform(sectransform_data, DISPATCH_DATA_FORMAT_TYPE_BASE32, DISPATCH_DATA_FORMAT_TYPE_NONE);
-	test_ptr_notnull("chunking_decode32_test: dispatch_data_create_with_transform", transformed_data);
-	test_data_equal("chunking_decode32_test", transformed_data, data);
-
-	dispatch_release(sectransform_data);
-	dispatch_release(transformed_data);
-	dispatch_release(data);
-
-	close(fd);
-
-	dispatch_group_async_f(context, dispatch_get_main_queue(), context, decode32_corrupt_test);
-}
-
-void
-chunking_encode32_test(void * context)
-{
-	(void)context;
-
-	int fd = open("/dev/random", O_RDONLY);
-	assert(fd >= 0);
-
-	dispatch_data_t __block data = dispatch_data_empty;
-
-	int i;
-	dispatch_group_t group = dispatch_group_create();
-	dispatch_queue_t queue = dispatch_queue_create("read", 0);
-	for (i=0; i<4096; i++) {
-		dispatch_group_enter(group);
-
-		dispatch_read(fd, 1, queue, ^(dispatch_data_t d, int error) {
-			assert(error == 0);
-
-			dispatch_data_t concat = dispatch_data_create_concat(data, d);
-			dispatch_release(data);
-			data = concat;
-			dispatch_group_leave(group);
-		});
-	}
-	dispatch_group_wait(group, DISPATCH_TIME_FOREVER);
-	dispatch_release(queue);
-	dispatch_release(group);
-
-	SecTransformRef transformRef = SecEncodeTransformCreate(kSecBase32Encoding, NULL);
-	assert(transformRef);
-
-	dispatch_data_t sectransform_data = execute_sectransform(transformRef, data);
-	assert(sectransform_data);
-	CFRelease(transformRef);
-
-	dispatch_data_t transformed_data = dispatch_data_create_with_transform(data, DISPATCH_DATA_FORMAT_TYPE_NONE, DISPATCH_DATA_FORMAT_TYPE_BASE32);
-	test_ptr_notnull("chunking_encode32_test: dispatch_data_create_with_transform", transformed_data);
-	test_data_equal("chunking_encode32_test", transformed_data, sectransform_data);
-
-	dispatch_release(sectransform_data);
-	dispatch_release(transformed_data);
-	dispatch_release(data);
-
-	close(fd);
-
-	dispatch_group_async_f(context, dispatch_get_main_queue(), context, chunking_decode32_test);
-}
-
-void
-decode32_test(void * context)
-{
-	dispatch_group_enter((dispatch_group_t)context);
-
-	int fd = open("/dev/random", O_RDONLY);
-	assert(fd >= 0);
-
-	dispatch_read(fd, 4096, dispatch_get_main_queue(), ^(dispatch_data_t data, int error) {
-		assert(error == 0);
-
-		SecTransformRef transformRef = SecEncodeTransformCreate(kSecBase32Encoding, NULL);
-		assert(transformRef);
-
-		dispatch_data_t sectransform_data = execute_sectransform(transformRef, data);
-		assert(sectransform_data);
-		CFRelease(transformRef);
-
-		dispatch_data_t transform_data = dispatch_data_create_with_transform(sectransform_data, DISPATCH_DATA_FORMAT_TYPE_BASE32, DISPATCH_DATA_FORMAT_TYPE_NONE);
-		test_ptr_notnull("decode32_test: dispatch_data_create_with_transform", transform_data);
-		test_data_equal("decode32_test", transform_data, data);
-
-		dispatch_release(sectransform_data);
-		dispatch_release(transform_data);
-
-		close(fd);
-
-		dispatch_group_async_f((dispatch_group_t)context, dispatch_get_main_queue(), context, chunking_encode32_test);
-		dispatch_group_leave((dispatch_group_t)context);
-	});
-}
-
-void
-encode32_test(void * context)
-{
-	dispatch_group_enter((dispatch_group_t)context);
-
-	int fd = open("/dev/random", O_RDONLY);
-	assert(fd >= 0);
-
-	dispatch_read(fd, 4096, dispatch_get_main_queue(), ^(dispatch_data_t data, int error) {
-		assert(error == 0);
-
-		SecTransformRef transformRef = SecEncodeTransformCreate(kSecBase32Encoding, NULL);
-		assert(transformRef);
-
-		dispatch_data_t sectransform_data = execute_sectransform(transformRef, data);
-		assert(sectransform_data);
-		CFRelease(transformRef);
-
-		dispatch_data_t transformed_data = dispatch_data_create_with_transform(data, DISPATCH_DATA_FORMAT_TYPE_NONE, DISPATCH_DATA_FORMAT_TYPE_BASE32);
-		test_ptr_notnull("encode32_test: dispatch_data_create_with_transform", transformed_data);
-		test_data_equal("encode32_test", transformed_data, sectransform_data);
-
-		dispatch_release(sectransform_data);
-		dispatch_release(transformed_data);
-
-		close(fd);
-
-		dispatch_group_async_f((dispatch_group_t)context, dispatch_get_main_queue(), context, decode32_test);
-		dispatch_group_leave((dispatch_group_t)context);
-	});
-}
-
-#pragma mark - base64 tests
-
-void
-decode64_loop_test(void * context)
-{
-	if (getenv("LOOP_SKIP") == NULL)
-	{
-		int fd = open("/dev/random", O_RDONLY);
-		assert(fd >= 0);
-
-		dispatch_semaphore_t sema = dispatch_semaphore_create(0);
-		size_t i, __block tests = 0;
-
-		for (i=1; i<4097; i++) {
-			dispatch_read(fd, i, dispatch_get_global_queue(0, 0), ^(dispatch_data_t data, int error) {
-				assert(error == 0);
-
-				SecTransformRef transformRef = SecEncodeTransformCreate(kSecBase64Encoding, NULL);
-				assert(transformRef);
-
-				dispatch_data_t sectransform_data = execute_sectransform(transformRef, data);
-				assert(sectransform_data);
-				CFRelease(transformRef);
-
-				dispatch_data_t transform_data = dispatch_data_create_with_transform(sectransform_data, DISPATCH_DATA_FORMAT_TYPE_BASE64, DISPATCH_DATA_FORMAT_TYPE_NONE);
-				if (dispatch_data_equal(transform_data, data)) {
-					tests++;
-				}
-
-				dispatch_release(sectransform_data);
-				dispatch_release(transform_data);
-
-				dispatch_semaphore_signal(sema);
-			});
-			dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);
-		}
-		dispatch_release(sema);
-		close(fd);
-		test_long("decode64_loop_test", tests, 4096);
-	}
-	dispatch_group_async_f((dispatch_group_t)context, dispatch_get_main_queue(), context, encode32_test);
-}
-
-void
-decode64_corrupt_test(void * context)
-{
-	dispatch_group_enter((dispatch_group_t)context);
-
-	int fd = open("/dev/random", O_RDONLY);
-	assert(fd >= 0);
-
-	dispatch_read(fd, 4096, dispatch_get_main_queue(), ^(dispatch_data_t data, int error) {
-		assert(error == 0);
-
-		SecTransformRef transformRef = SecEncodeTransformCreate(kSecBase64Encoding, NULL);
-		assert(transformRef);
-
-		dispatch_data_t sectransform_data = execute_sectransform(transformRef, data);
-		assert(sectransform_data);
-		CFRelease(transformRef);
-
-		void * corrupt_buffer = malloc(dispatch_data_get_size(sectransform_data));
-		const void * source;
-		size_t size;
-
-		dispatch_data_t map = dispatch_data_create_map(sectransform_data, &source, &size);
-		memcpy(corrupt_buffer, source, size);
-
-		size_t i;
-		for (i=0; i<size; i += (arc4random() % (int)(size * 0.05))) {
-			char x = arc4random() & 0xff;
-			while ((x >= 'A' && x <= 'Z') || (x >= 'a' && x <= 'z') || (x >= '0' && x <= '9') || x == '/' || x == '+' || x == '=') {
-				x = arc4random() & 0xff;
-			}
-
-			((char*)corrupt_buffer)[i] = x;
-		}
-
-		dispatch_release(map);
-		dispatch_release(sectransform_data);
-
-		dispatch_data_t corrupt_data = dispatch_data_create(corrupt_buffer, size, dispatch_get_main_queue(), DISPATCH_DATA_DESTRUCTOR_FREE);
-
-		dispatch_data_t transform_data = dispatch_data_create_with_transform(corrupt_data, DISPATCH_DATA_FORMAT_TYPE_BASE64, DISPATCH_DATA_FORMAT_TYPE_NONE);
-		test_ptr_null("decode64_corrupt_test: dispatch_data_create_with_transform", transform_data);
-
-		dispatch_release(corrupt_data);
-
-		close(fd);
-
-		dispatch_group_async_f((dispatch_group_t)context, dispatch_get_main_queue(), context, decode64_loop_test);
-		dispatch_group_leave((dispatch_group_t)context);
-	});
-}
-
-void
-chunking_decode64_test(void * context)
-{
-	(void)context;
-
-	int fd = open("/dev/random", O_RDONLY);
-	assert(fd >= 0);
-
-	dispatch_data_t __block data = dispatch_data_empty;
-
-	int i;
-	dispatch_group_t group = dispatch_group_create();
-	dispatch_queue_t queue = dispatch_queue_create("read", 0);
-	for (i=0; i<4096; i++) {
-		dispatch_group_enter(group);
-
-		dispatch_read(fd, 1, queue, ^(dispatch_data_t d, int error) {
-			assert(error == 0);
-
-			dispatch_data_t concat = dispatch_data_create_concat(data, d);
-			dispatch_release(data);
-			data = concat;
-			dispatch_group_leave(group);
-		});
-	}
-	dispatch_group_wait(group, DISPATCH_TIME_FOREVER);
-	dispatch_release(queue);
-	dispatch_release(group);
-
-	SecTransformRef transformRef = SecEncodeTransformCreate(kSecBase64Encoding, NULL);
-	assert(transformRef);
-
-	dispatch_data_t sectransform_data = execute_sectransform(transformRef, data);
-	assert(sectransform_data);
-	CFRelease(transformRef);
-
-	dispatch_data_t transformed_data = dispatch_data_create_with_transform(sectransform_data, DISPATCH_DATA_FORMAT_TYPE_BASE64, DISPATCH_DATA_FORMAT_TYPE_NONE);
-	test_ptr_notnull("chunking_decode64_test: dispatch_data_create_with_transform", transformed_data);
-	test_data_equal("chunking_decode64_test", transformed_data, data);
-
-	dispatch_release(sectransform_data);
-	dispatch_release(transformed_data);
-	dispatch_release(data);
-
-	close(fd);
-
-	dispatch_group_async_f(context, dispatch_get_main_queue(), context, decode64_corrupt_test);
-}
-
-void
-chunking_encode64_test(void * context)
-{
-	(void)context;
-
-	int fd = open("/dev/random", O_RDONLY);
-	assert(fd >= 0);
-
-	dispatch_data_t __block data = dispatch_data_empty;
-
-	int i;
-	dispatch_group_t group = dispatch_group_create();
-	dispatch_queue_t queue = dispatch_queue_create("read", 0);
-	for (i=0; i<4097; i++) {
-		dispatch_group_enter(group);
-
-		dispatch_read(fd, 1, queue, ^(dispatch_data_t d, int error) {
-			assert(error == 0);
-
-			dispatch_data_t concat = dispatch_data_create_concat(data, d);
-			dispatch_release(data);
-			data = concat;
-			dispatch_group_leave(group);
-		});
-	}
-	dispatch_group_wait(group, DISPATCH_TIME_FOREVER);
-	dispatch_release(queue);
-	dispatch_release(group);
-
-	SecTransformRef transformRef = SecEncodeTransformCreate(kSecBase64Encoding, NULL);
-	assert(transformRef);
-
-	dispatch_data_t sectransform_data = execute_sectransform(transformRef, data);
-	assert(sectransform_data);
-	CFRelease(transformRef);
-
-	dispatch_data_t transformed_data = dispatch_data_create_with_transform(data, DISPATCH_DATA_FORMAT_TYPE_NONE, DISPATCH_DATA_FORMAT_TYPE_BASE64);
-	test_ptr_notnull("chunking_encode64_test: dispatch_data_create_with_transform", transformed_data);
-	test_data_equal("chunking_encode64_test", transformed_data, sectransform_data);
-
-	dispatch_release(sectransform_data);
-	dispatch_release(transformed_data);
-	dispatch_release(data);
-
-	close(fd);
-
-	dispatch_group_async_f(context, dispatch_get_main_queue(), context, chunking_decode64_test);
-}
-
-void
-decode64_test(void * context)
-{
-	dispatch_group_enter((dispatch_group_t)context);
-
-	int fd = open("/dev/random", O_RDONLY);
-	assert(fd >= 0);
-
-	dispatch_read(fd, 4096, dispatch_get_main_queue(), ^(dispatch_data_t data, int error) {
-		assert(error == 0);
-
-		SecTransformRef transformRef = SecEncodeTransformCreate(kSecBase64Encoding, NULL);
-		assert(transformRef);
-
-		dispatch_data_t sectransform_data = execute_sectransform(transformRef, data);
-		assert(sectransform_data);
-		CFRelease(transformRef);
-
-		dispatch_data_t transform_data = dispatch_data_create_with_transform(sectransform_data, DISPATCH_DATA_FORMAT_TYPE_BASE64, DISPATCH_DATA_FORMAT_TYPE_NONE);
-		test_ptr_notnull("decode64_test: dispatch_data_create_with_transform", transform_data);
-		test_data_equal("decode64_test", transform_data, data);
-
-		dispatch_release(sectransform_data);
-		dispatch_release(transform_data);
-
-		close(fd);
-
-		dispatch_group_async_f((dispatch_group_t)context, dispatch_get_main_queue(), context, chunking_encode64_test);
-		dispatch_group_leave((dispatch_group_t)context);
-	});
-}
-
-void
-encode64_test(void * context)
-{
-	dispatch_group_enter((dispatch_group_t)context);
-
-	int fd = open("/dev/random", O_RDONLY);
-	assert(fd >= 0);
-
-	dispatch_read(fd, 4096, dispatch_get_main_queue(), ^(dispatch_data_t data, int error) {
-		assert(error == 0);
-
-		SecTransformRef transformRef = SecEncodeTransformCreate(kSecBase64Encoding, NULL);
-		assert(transformRef);
-
-		dispatch_data_t sectransform_data = execute_sectransform(transformRef, data);
-		assert(sectransform_data);
-		CFRelease(transformRef);
-
-		dispatch_data_t transformed_data = dispatch_data_create_with_transform(data, DISPATCH_DATA_FORMAT_TYPE_NONE, DISPATCH_DATA_FORMAT_TYPE_BASE64);
-		test_ptr_notnull("encode64_test: dispatch_data_create_with_transform", transformed_data);
-		test_data_equal("encode64_test", transformed_data, sectransform_data);
-
-		dispatch_release(sectransform_data);
-		dispatch_release(transformed_data);
-
-		close(fd);
-
-		dispatch_group_async_f((dispatch_group_t)context, dispatch_get_main_queue(), context, decode64_test);
-		dispatch_group_leave((dispatch_group_t)context);
-	});
-}
-
-#pragma mark - main
-
-int
-main(void)
-{
-	test_start("Dispatch data transforms test");
-
-	dispatch_group_t group = dispatch_group_create();
-	dispatch_group_async_f(group, dispatch_get_main_queue(), group, encode64_test);
-
-	dispatch_group_notify(group, dispatch_get_main_queue(), ^{
-		dispatch_release(group);
-		test_stop();
-		exit(0);
-	});
-
-	dispatch_main();
-	return 0;
-}
-
-#else
-
-int
-main(void)
-{
-  test_skip("Dispatch data transforms test");
-  return 0;
-}
-
-#endif
-
--- a/Telegram/ThirdParty/dispatch/tests/dispatch_vm.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/dispatch_vm.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,203 +0,0 @@
-/*
- * Copyright (c) 2010-2011 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include <sys/event.h>
-#include <stdio.h>
-#include <stdlib.h>
-#if defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))
-#include <unistd.h>
-#endif
-#ifdef __APPLE__
-#include <libkern/OSAtomic.h>
-#endif
-#include <assert.h>
-#ifdef __ANDROID__
-#include <linux/sysctl.h>
-#else
-#if !defined(__linux__)
-#include <sys/sysctl.h>
-#endif
-#endif /* __ANDROID__ */
-#include <stdarg.h>
-#include <time.h>
-
-#include <dispatch/dispatch.h>
-#include <dispatch/private.h>
-
-#include <bsdtests.h>
-#include "dispatch_test.h"
-
-#if defined(DISPATCH_SOURCE_TYPE_VM) && defined(NOTE_VM_PRESSURE)
-
-#if TARGET_OS_EMBEDDED
-#define ALLOC_SIZE ((size_t)(1024*1024*1ul))	// 1MB
-#define NOTIFICATIONS 1
-#else
-#define ALLOC_SIZE ((size_t)(1024*1024*20ul))	// 20MB
-#define NOTIFICATIONS 2
-#endif
-#define pg2mb(p) ((p) * ALLOC_SIZE/(1024*1024))
-#ifdef __LP64__
-#define MAXMEM ((size_t)SIZE_MAX)
-#else
-#define MAXMEM ((size_t)(3200ul*1024*1024))		// 3200MB
-#endif
-
-static char **pages;
-static volatile int32_t handler_call_count;
-static volatile int32_t page_count;
-static int32_t max_page_count;
-static dispatch_source_t vm_source;
-static dispatch_queue_t vm_queue;
-static time_t initial;
-static int interval = 16;
-
-#define log_msg(msg, ...) \
-do { \
-	fprintf(stderr, "[%2ds] " msg, (int)(time(NULL) - initial), ##__VA_ARGS__);\
-} while (0)
-
-static bool
-dispatch_test_check_evfilt_vm(void)
-{
-	int kq = kqueue();
-	assert(kq != -1);
-	struct kevent ke = {
-		.filter = EVFILT_VM,
-		.flags = EV_ADD|EV_ENABLE|EV_RECEIPT,
-		.fflags = NOTE_VM_PRESSURE,
-	};
-	int r = kevent(kq, &ke, 1, &ke, 1, NULL);
-	close(kq);
-	return !(r > 0 && ke.flags & EV_ERROR && ke.data == ENOTSUP);
-}
-
-static void
-cleanup(void)
-{
-	dispatch_source_cancel(vm_source);
-	dispatch_release(vm_source);
-	dispatch_release(vm_queue);
-
-	int32_t pc = 0, i;
-	for (i = 0; i < max_page_count; ++i) {
-	   if (pages[i]) {
-		   pc++;
-		   free(pages[i]);
-	   }
-	}
-	if (pc) {
-		log_msg("Freed %ldMB\n", pg2mb(pc));
-	}
-	free(pages);
-	test_stop();
-}
-
-int
-main(void)
-{
-	dispatch_test_start("Dispatch VM Pressure test"); // rdar://problem/7000945
-	if (!dispatch_test_check_evfilt_vm()) {
-		test_skip("EVFILT_VM not supported");
-		test_stop();
-		return 0;
-	}
-	initial = time(NULL);
-	uint64_t memsize;
-#ifdef __linux__
-	memsize = sysconf(_SC_PAGESIZE) * sysconf(_SC_PHYS_PAGES);
-#else
-	size_t s = sizeof(memsize);
-	int rc = sysctlbyname("hw.memsize", &memsize, &s, NULL, 0);
-	assert(rc == 0);
-#endif
-	max_page_count = MIN(memsize, MAXMEM) / ALLOC_SIZE;
-	pages = calloc(max_page_count, sizeof(char*));
-
-	vm_queue = dispatch_queue_create("VM Pressure", NULL);
-	vm_source = dispatch_source_create(DISPATCH_SOURCE_TYPE_VM, 0,
-			DISPATCH_VM_PRESSURE, vm_queue);
-	dispatch_source_set_event_handler(vm_source, ^{
-		if (!page_count) {
-			// Too much memory pressure already to start the test
-			test_skip("Memory pressure at start of test");
-			cleanup();
-		}
-		if (OSAtomicIncrement32Barrier(&handler_call_count) != NOTIFICATIONS) {
-			log_msg("Ignoring vm pressure notification\n");
-			interval = 1;
-			return;
-		}
-		test_long("dispatch_source_get_data()",
-				dispatch_source_get_data(vm_source), NOTE_VM_PRESSURE);
-		int32_t i, pc = page_count + 1;
-		for (i = 0; i < pc && pages[i]; ++i) {
-				free(pages[i]);
-				pages[i] = NULL;
-		}
-		log_msg("Freed %ldMB\n", pg2mb(i));
-	});
-	dispatch_resume(vm_source);
-	dispatch_after(dispatch_time(DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC),
-			dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
-		while (handler_call_count < NOTIFICATIONS &&
-				page_count < max_page_count) {
-			void *p = valloc(ALLOC_SIZE);
-			if (!p) {
-				break;
-			}
-			bzero(p, ALLOC_SIZE);
-			pages[page_count] = p;
-			if (!(OSAtomicIncrement32Barrier(&page_count) % interval)) {
-				log_msg("Allocated %ldMB\n", pg2mb(page_count));
-				usleep(200000);
-			}
-		}
-		if (page_count % interval) {
-			log_msg("Allocated %ldMB\n", pg2mb(page_count));
-		}
-		if (handler_call_count < NOTIFICATIONS) {
-			// Cannot allocate enough memory for test (e.g. on 32 bit)
-			test_skip("Cannot allocate enough memory for test");
-			dispatch_async(vm_queue, ^{cleanup();});
-			return;
-		}
-		dispatch_after(dispatch_time(DISPATCH_TIME_NOW, 2 * NSEC_PER_SEC),
-				vm_queue, ^{
-			test_long_greater_than_or_equal("VM Pressure fired",
-					handler_call_count, NOTIFICATIONS);
-			test_long_less_than("VM Pressure stopped firing",
-					handler_call_count, 4);
-			cleanup();
-		});
-	});
-	dispatch_main();
-	return 0;
-}
-#else //DISPATCH_SOURCE_TYPE_VM
-int
-main(void)
-{
-	dispatch_test_start("Dispatch VM Pressure test"
-			" - No DISPATCH_SOURCE_TYPE_VM");
-	test_stop();
-	return 0;
-}
-#endif //DISPATCH_SOURCE_TYPE_VM
--- a/Telegram/ThirdParty/dispatch/tests/dispatch_vnode.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/dispatch_vnode.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,113 +0,0 @@
-/*
- * Copyright (c) 2010-2011 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include <stdio.h>
-#include <fcntl.h>
-#include <stdlib.h>
-#if defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))
-#include <unistd.h>
-#endif
-
-#include <dispatch/dispatch.h>
-
-#include <bsdtests.h>
-#include "dispatch_test.h"
-
-#define ITERATIONS 1000
-long iterations, notifications;
-
-int
-main(void)
-{
-	dispatch_test_start("Dispatch VNODE RENAME");
-
-	char path1[] = "/tmp/dispatchtest_vnode.XXXXXX";
-	char path2[] = "/tmp/dispatchtest_vnode.XXXXXX";
-	int fd1 = mkstemp(path1);
-	if (fd1 == -1) {
-		test_errno("mkstemp", errno, 0);
-		test_stop();
-	}
-	close(fd1);
-	if (!mktemp(path2)) {
-		test_errno("mktemp", errno, 0);
-		test_stop();
-	}
-	char *currentName = path1;
-	char *renameDest = path2;
-	dispatch_semaphore_t renamedSemaphore = dispatch_semaphore_create(0);
-	dispatch_group_t g = dispatch_group_create();
-
-	while (iterations++ < ITERATIONS) {
-		int fd = open(currentName, O_EVTONLY);
-		if (fd == -1) {
-			test_errno("open", errno, 0);
-			test_stop();
-		}
-
-		dispatch_source_t monitorSource = dispatch_source_create(
-				DISPATCH_SOURCE_TYPE_VNODE, fd, DISPATCH_VNODE_RENAME,
-				dispatch_get_global_queue(0, 0));
-		dispatch_source_set_event_handler(monitorSource, ^{
-			dispatch_semaphore_signal(renamedSemaphore);
-		});
-		dispatch_source_set_cancel_handler(monitorSource, ^{
-			close(fd);
-		});
-#if DISPATCH_API_VERSION >= 20100818 // <rdar://problem/7731284>
-		dispatch_group_enter(g);
-		dispatch_source_set_registration_handler(monitorSource, ^{
-			dispatch_group_leave(g);
-		});
-#endif
-		dispatch_resume(monitorSource);
-		dispatch_group_wait(g, DISPATCH_TIME_FOREVER);
-
-		if(rename(currentName, renameDest)) {
-			test_errno("rename", errno, 0);
-			test_stop();
-		}
-		char *tmp = currentName;
-		currentName = renameDest;
-		renameDest = tmp;
-
-		if(!dispatch_semaphore_wait(renamedSemaphore,
-				dispatch_time(DISPATCH_TIME_NOW, 10 * 1000 * NSEC_PER_USEC))) {
-			fprintf(stderr, ".");
-			notifications++;
-			dispatch_source_cancel(monitorSource);
-		} else {
-			fprintf(stderr, "!");
-			dispatch_source_cancel(monitorSource);
-			dispatch_semaphore_signal(renamedSemaphore);
-		}
-		if (!(iterations % 80)) {
-			fprintf(stderr, "\n");
-		}
-		dispatch_release(monitorSource);
-	}
-	fprintf(stderr, "\n");
-	unlink(currentName);
-	dispatch_release(g);
-	dispatch_release(renamedSemaphore);
-	test_long("VNODE RENAME notifications", notifications, ITERATIONS);
-	test_stop();
-	return 0;
-}
--- a/Telegram/ThirdParty/dispatch/tests/Foundation/bench.mm	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/Foundation/bench.mm	1970-01-01 00:00:00.000000000 -0000
@@ -1,728 +0,0 @@
-/*
- * Copyright (c) 2008-2011 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include <Foundation/Foundation.h>
-#include <libkern/OSAtomic.h>
-#ifdef __ANDROID__
-#include <linux/sysctl.h>
-#else
-#if !defined(__linux__)
-#include <sys/sysctl.h>
-#endif
-#endif /* __ANDROID__ */
-#include <mach/mach.h>
-#include <mach/mach_time.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <stdint.h>
-#include <stdbool.h>
-#if defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))
-#include <unistd.h>
-#endif
-#include <assert.h>
-#include <errno.h>
-#include <pthread.h>
-#include <math.h>
-#ifdef __BLOCKS__
-#include <Block.h>
-#endif
-#include <dispatch/dispatch.h>
-#include <dispatch/private.h>
-
-//#define BENCH_SLOW 1
-
-extern "C" {
-__private_extern__ void func(void);
-#ifdef __BLOCKS__
-__private_extern__ void (^block)(void);
-#endif
-static void backflip(void *ctxt);
-static void backflip_done(void);
-}
-
-@interface BasicObject : NSObject
-{
-}
-- (void) method;
-@end
-
-@implementation BasicObject
-- (void) method
-{
-}
-@end
-
-class BasicClass {
-public:
-	virtual void virtfunc(void) {
-	};
-};
-
-static void *
-force_a_thread(void *arg)
-{
-	pause();
-	abort();
-	return arg;
-}
-
-static volatile int32_t global;
-static volatile int64_t w_global;
-
-#if TARGET_OS_EMBEDDED
-static const size_t cnt = 5000000;
-#else
-static const size_t cnt = 200000000;
-#endif
-static const size_t cnt2 = cnt/100;
-
-static uint64_t bfs;
-static long double loop_cost;
-static long double cycles_per_nanosecond;
-static mach_timebase_info_data_t tbi;
-
-static void __attribute__((noinline))
-print_result(uint64_t s, const char *str)
-{
-	uint64_t d, e = mach_absolute_time();
-	long double dd;
-
-	d = e - s;
-
-	if (tbi.numer != tbi.denom) {
-		d *= tbi.numer;
-		d /= tbi.denom;
-	}
-
-	dd = (__typeof__(dd))d / (__typeof__(dd))cnt;
-
-	dd -= loop_cost;
-
-	if (loop_cost == 0.0) {
-		loop_cost = dd;
-	}
-
-	dd *= cycles_per_nanosecond;
-	dd = roundl(dd * 200.0)/200.0;
-
-	printf("%-45s%15.3Lf cycles\n", str, dd);
-}
-
-#if BENCH_SLOW || !TARGET_OS_EMBEDDED
-static void __attribute__((noinline))
-print_result2(uint64_t s, const char *str)
-{
-	uint64_t d, e = mach_absolute_time();
-	long double dd;
-
-	d = e - s;
-
-	if (tbi.numer != tbi.denom) {
-		d *= tbi.numer;
-		d /= tbi.denom;
-	}
-
-	dd = (__typeof__(dd))d / (__typeof__(dd))cnt2;
-
-	dd -= loop_cost;
-	dd *= cycles_per_nanosecond;
-
-	printf("%-45s%15.3Lf cycles\n", str, dd);
-}
-#endif
-
-#if defined(__i386__) || defined(__x86_64__)
-static inline uint64_t
-rdtsc(void)
-{
-	uint32_t lo, hi;
-
-	__asm__ __volatile__ ("rdtsc" : "=a" (lo), "=d" (hi));
-
-	return (uint64_t)hi << 32 | lo;
-}
-#endif
-
-static struct fml {
-	struct fml *fml_next;
-} *fixed_malloc_lifo_head;
-
-struct fml *fixed_malloc_lifo(void);// __attribute__((noinline));
-void fixed_free_lifo(struct fml *fml);// __attribute__((noinline));
-
-struct fml *
-fixed_malloc_lifo(void)
-{
-	struct fml *fml_r = fixed_malloc_lifo_head;
-
-	if (fml_r) {
-		fixed_malloc_lifo_head = fml_r->fml_next;
-		return fml_r;
-	} else {
-		return (struct fml *)malloc(32);
-	}
-}
-
-void
-fixed_free_lifo(struct fml *fml)
-{
-	fml->fml_next = fixed_malloc_lifo_head;
-	fixed_malloc_lifo_head = fml;
-}
-
-int
-main(void)
-{
-	pthread_mutex_t plock = PTHREAD_MUTEX_INITIALIZER;
-	OSSpinLock slock = OS_SPINLOCK_INIT;
-	BasicObject *bo;
-	BasicClass *bc;
-	pthread_t pthr_pause;
-	dispatch_queue_t q, mq;
-	kern_return_t kr;
-#if BENCH_SLOW
-	semaphore_t sem;
-#endif
-	uint64_t freq;
-	uint64_t s;
-	size_t freq_len = sizeof(freq);
-	size_t bf_cnt = cnt;
-	unsigned i;
-	int r;
-
-	printf("\n====================================================================\n");
-	printf("[TEST] dispatch benchmark\n");
-	printf("[PID] %d\n", getpid());
-	printf("====================================================================\n\n");
-
-	r = sysctlbyname("hw.cpufrequency", &freq, &freq_len, NULL, 0);
-	assert(r != -1);
-	assert(freq_len == sizeof(freq));
-
-	cycles_per_nanosecond = (long double)freq / (long double)NSEC_PER_SEC;
-
-#if BENCH_SLOW
-	NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
-	assert(pool);
-#endif
-
-	/* Malloc has different logic for threaded apps. */
-	r = pthread_create(&pthr_pause, NULL, force_a_thread, NULL);
-	assert(r == 0);
-
-	kr = mach_timebase_info(&tbi);
-	assert(kr == 0);
-#if defined(__i386__) || defined(__x86_64__)
-	assert(tbi.numer == tbi.denom); /* This will fail on PowerPC. */
-#endif
-
-	bo = [[BasicObject alloc] init];
-	assert(bo);
-
-	bc = new BasicClass();
-	assert(bc);
-
-	q = dispatch_queue_create("com.apple.bench-dispatch", NULL);
-	assert(q);
-
-	mq = dispatch_get_main_queue();
-	assert(mq);
-
-	printf("%-45s%15Lf\n\n", "Cycles per nanosecond:", cycles_per_nanosecond);
-
-	s = mach_absolute_time();
-	for (i = cnt; i; i--) {
-		__asm__ __volatile__ ("");
-	}
-	print_result(s, "Empty loop:");
-
-	printf("\nLoop cost subtracted from the following:\n\n");
-
-#if TARGET_OS_EMBEDDED
-	s = mach_absolute_time();
-	for (i = cnt; i; i--) {
-		mach_absolute_time();
-	}
-	print_result(s, "mach_absolute_time():");
-#else
-	s = mach_absolute_time();
-	for (i = cnt2; i; i--) {
-		mach_absolute_time();
-	}
-	print_result2(s, "mach_absolute_time():");
-#endif
-
-#if defined(__i386__) || defined(__x86_64__)
-	s = mach_absolute_time();
-	for (i = cnt; i; i--) {
-		rdtsc();
-	}
-	print_result(s, "rdtsc():");
-#endif
-
-#if BENCH_SLOW
-	s = mach_absolute_time();
-	for (i = cnt2; i; i--) {
-		pthread_t pthr;
-		void *pr;
-
-		r = pthread_create(&pthr, NULL, (void *(*)(void *))func, NULL);
-		assert(r == 0);
-		r = pthread_join(pthr, &pr);
-		assert(r == 0);
-	}
-	print_result2(s, "pthread create+join:");
-
-	s = mach_absolute_time();
-	for (i = cnt2; i; i--) {
-		kr = semaphore_create(mach_task_self(), &sem, SYNC_POLICY_FIFO, 0);
-		assert(kr == 0);
-		kr = semaphore_destroy(mach_task_self(), sem);
-		assert(kr == 0);
-	}
-	print_result2(s, "Mach semaphore create/destroy:");
-
-	kr = semaphore_create(mach_task_self(), &sem, SYNC_POLICY_FIFO, 0);
-	assert(kr == 0);
-	s = mach_absolute_time();
-	for (i = cnt2; i; i--) {
-		kr = semaphore_signal(sem);
-		assert(kr == 0);
-	}
-	print_result2(s, "Mach semaphore signal:");
-	kr = semaphore_destroy(mach_task_self(), sem);
-	assert(kr == 0);
-
-	s = mach_absolute_time();
-	for (i = cnt; i; i--) {
-		free(malloc(32));
-	}
-	print_result(s, "free(malloc(32)):");
-
-	s = mach_absolute_time();
-	for (i = cnt / 2; i; i--) {
-		void *m1 = malloc(32);
-		void *m2 = malloc(32);
-		free(m1);
-		free(m2);
-	}
-	print_result(s, "Avoiding the MRU cache of free(malloc(32)):");
-
-	s = mach_absolute_time();
-	for (i = cnt; i; i--) {
-		fixed_free_lifo(fixed_malloc_lifo());
-	}
-	print_result(s, "per-thread/fixed free(malloc(32)):");
-
-	s = mach_absolute_time();
-	for (i = cnt; i; i--) {
-		assert(strtoull("18446744073709551615", NULL, 0) == ~0ull);
-	}
-	print_result(s, "strtoull(\"18446744073709551615\") == ~0ull:");
-#endif
-
-	s = mach_absolute_time();
-	for (i = cnt; i; i--) {
-		func();
-	}
-	print_result(s, "Empty function call:");
-
-#ifdef __BLOCKS__
-	s = mach_absolute_time();
-	for (i = cnt; i; i--) {
-		block();
-	}
-	print_result(s, "Empty block call:");
-#endif
-
-	s = mach_absolute_time();
-	for (i = cnt; i; i--) {
-		bc->virtfunc();
-	}
-	print_result(s, "Empty C++ virtual call:");
-
-	s = mach_absolute_time();
-	for (i = cnt; i; i--) {
-		[bo method];
-	}
-	print_result(s, "Empty ObjC call:");
-
-#if BENCH_SLOW
-	s = mach_absolute_time();
-	for (i = cnt2; i; i--) {
-		[bo description];
-	}
-	print_result2(s, "\"description\" ObjC call:");
-
-	[pool release];
-
-	pool = NULL;
-#endif
-
-	s = mach_absolute_time();
-	for (i = cnt; i; i--) {
-		__asm__ __volatile__ ("nop");
-	}
-	print_result(s, "raw 'nop':");
-
-#if defined(__i386__) || defined(__x86_64__)
-	s = mach_absolute_time();
-	for (i = cnt; i; i--) {
-		__asm__ __volatile__ ("pause");
-	}
-	print_result(s, "raw 'pause':");
-
-	s = mach_absolute_time();
-	for (i = cnt; i; i--) {
-		__asm__ __volatile__ ("mfence");
-	}
-	print_result(s, "Atomic mfence:");
-
-	s = mach_absolute_time();
-	for (i = cnt; i; i--) {
-		__asm__ __volatile__ ("lfence");
-	}
-	print_result(s, "Atomic lfence:");
-
-	s = mach_absolute_time();
-	for (i = cnt; i; i--) {
-		__asm__ __volatile__ ("sfence");
-	}
-	print_result(s, "Atomic sfence:");
-
-	s = mach_absolute_time();
-	for (i = cnt; i; i--) {
-		uint64_t sidt_rval;
-		__asm__ __volatile__ ("sidt %0" : "=m" (sidt_rval));
-	}
-	print_result(s, "'sidt' instruction:");
-
-	s = mach_absolute_time();
-	for (i = cnt; i; i--) {
-		long prev;
-		__asm__ __volatile__ ("cmpxchg %1,%2"
-				: "=a" (prev) : "r" (0l), "m" (global), "0" (1l));
-	}
-	print_result(s, "'cmpxchg' without the 'lock' prefix:");
-
-	s = mach_absolute_time();
-	for (i = cnt; i; i--) {
-		global = 0;
-		__asm__ __volatile__ ("mfence" ::: "memory");
-	}
-	print_result(s, "Store + mfence:");
-
-	s = mach_absolute_time();
-	for (i = cnt; i; i--) {
-		unsigned long _clbr;
-#ifdef __LP64__
-		__asm__ __volatile__ ("cpuid" : "=a" (_clbr)
-				: "0" (0) : "rbx", "rcx", "rdx", "cc", "memory");
-#else
-#ifdef __llvm__
-		__asm__ __volatile__ ("cpuid" : "=a" (_clbr) : "0" (0)
-				: "ebx", "ecx", "edx", "cc", "memory" );
-#else // gcc does not allow inline i386 asm to clobber ebx
-		__asm__ __volatile__ ("pushl %%ebx\n\tcpuid\n\tpopl %%ebx"
-				: "=a" (_clbr) : "0" (0) : "ecx", "edx", "cc", "memory" );
-#endif
-#endif
-	}
-	print_result(s, "'cpuid' instruction:");
-
-#elif defined(__arm__)
-
-#include <arm/arch.h>
-
-#if !defined(_ARM_ARCH_7) && defined(__thumb__)
-#error "GCD requires instructions unvailable in ARMv6 Thumb1"
-#endif
-
-#ifdef _ARM_ARCH_7
-	s = mach_absolute_time();
-	for (i = cnt; i; i--) {
-		__asm__ __volatile__ ("yield");
-	}
-	print_result(s, "raw 'yield':");
-#endif
-
-	s = mach_absolute_time();
-	for (i = cnt; i; i--) {
-#ifdef _ARM_ARCH_7
-		__asm__ __volatile__ ("dmb ish" : : : "memory");
-#else
-		__asm__ __volatile__ ("mcr	p15, 0, %0, c7, c10, 5" : : "r" (0) : "memory");
-#endif
-	}
-	print_result(s, "'dmb ish' instruction:");
-
-#ifdef _ARM_ARCH_7
-	s = mach_absolute_time();
-	for (i = cnt; i; i--) {
-		__asm__ __volatile__ ("dmb ishst" : : : "memory");
-	}
-	print_result(s, "'dmb ishst' instruction:");
-#endif
-
-#ifdef _ARM_ARCH_7
-	s = mach_absolute_time();
-	for (i = cnt; i; i--) {
-		__asm__ __volatile__ ("str	%[_r], [%[_p], %[_o]]" :
-				: [_p] "p" (&global), [_o] "M" (0), [_r] "r" (0) : "memory");
-		__asm__ __volatile__ ("dmb ishst" : : : "memory");
-	}
-	print_result(s, "'str + dmb ishst' instructions:");
-#endif
-
-#ifdef _ARM_ARCH_7
-	s = mach_absolute_time();
-	for (i = cnt; i; i--) {
-		uintptr_t prev;
-		uint32_t t;
-		do {
-		__asm__ __volatile__ ("ldrex	%[_r], [%[_p], %[_o]]"
-				: [_r] "=&r" (prev) \
-				: [_p] "p" (&global), [_o] "M" (0) : "memory");
-		__asm__ __volatile__ ("strex	%[_t], %[_r], [%[_p], %[_o]]"
-				: [_t] "=&r" (t) \
-				: [_p] "p" (&global), [_o] "M" (0), [_r] "r" (0) : "memory");
-		} while (t);
-	}
-	print_result(s, "'ldrex + strex' instructions:");
-#endif
-
-	s = mach_absolute_time();
-	for (i = cnt; i; i--) {
-#ifdef _ARM_ARCH_7
-		__asm__ __volatile__ ("dsb ish" : : : "memory");
-#else
-		__asm__ __volatile__ ("mcr	p15, 0, %0, c7, c10, 4" : : "r" (0) : "memory");
-#endif
-	}
-	print_result(s, "'dsb ish' instruction:");
-
-#if BENCH_SLOW
-	s = mach_absolute_time();
-	for (i = cnt; i; i--) {
-		register long _swtch_pri __asm__("ip") = -59;
-		__asm__ __volatile__ ("svc	0x80" : : "r" (_swtch_pri) : "r0", "memory");
-	}
-	print_result(s, "swtch_pri syscall:");
-
-	s = mach_absolute_time();
-	for (i = cnt; i; i--) {
-		register long _r0 __asm__("r0") = 0, _r1 __asm__("r1") = 1, _r2 __asm__("r2") = 1;
-		register long _thread_switch __asm__("ip") = -61;
-		__asm__ __volatile__ ("svc	0x80" : "+r" (_r0)
-				: "r" (_r1), "r" (_r2), "r" (_thread_switch): "memory");
-	}
-	print_result(s, "thread_switch syscall:");
-#endif
-
-#endif // __arm__
-
-#if BENCH_SLOW
-	s = mach_absolute_time();
-	for (i = cnt; i; i--) {
-		pthread_yield_np();
-	}
-	print_result(s, "pthread_yield_np():");
-
-	s = mach_absolute_time();
-	for (i = cnt2; i; i--) {
-		usleep(0);
-	}
-	print_result2(s, "usleep(0):");
-#endif
-
-	s = mach_absolute_time();
-	for (i = cnt; i; i--) {
-		__sync_lock_test_and_set(&global, 0);
-	}
-	print_result(s, "Atomic xchg:");
-
-	s = mach_absolute_time();
-	for (i = cnt; i; i--) {
-		__sync_val_compare_and_swap(&global, 1, 0);
-	}
-	print_result(s, "Atomic cmpxchg:");
-
-	s = mach_absolute_time();
-	for (i = cnt; i; i--) {
-		__sync_fetch_and_add(&global, 1);
-	}
-	print_result(s, "Atomic increment:");
-
-	{
-		global = 0;
-		volatile int32_t *g = &global;
-
-		s = mach_absolute_time();
-		for (i = cnt; i; i--) {
-			uint32_t result;
-			__sync_and_and_fetch(g, 1);
-			result = *g;
-			if (result) {
-				abort();
-			}
-		}
-		print_result(s, "Atomic and-and-fetch, reloading result:");
-	}
-
-	{
-		global = 0;
-		volatile int32_t *g = &global;
-
-		s = mach_absolute_time();
-		for (i = cnt; i; i--) {
-			uint32_t result;
-			result = __sync_and_and_fetch(g, 1);
-			if (result) {
-				abort();
-			}
-		}
-		print_result(s, "Atomic and-and-fetch, using result:");
-	}
-
-	global = 0;
-
-	s = mach_absolute_time();
-	for (i = cnt; i; i--) {
-		OSAtomicIncrement32Barrier(&global);
-	}
-	print_result(s, "OSAtomicIncrement32Barrier:");
-
-	global = 0;
-
-	s = mach_absolute_time();
-	for (i = cnt; i; i--) {
-		OSAtomicIncrement32(&global);
-	}
-	print_result(s, "OSAtomicIncrement32:");
-
-	w_global = 0;
-
-	s = mach_absolute_time();
-	for (i = cnt; i; i--) {
-		OSAtomicIncrement64Barrier(&w_global);
-	}
-	print_result(s, "OSAtomicIncrement64Barrier:");
-
-	w_global = 0;
-
-	s = mach_absolute_time();
-	for (i = cnt; i; i--) {
-		OSAtomicIncrement64(&w_global);
-	}
-	print_result(s, "OSAtomicIncrement64:");
-
-	global = 0;
-
-	s = mach_absolute_time();
-	for (i = cnt; i; i--) {
-		while (!__sync_bool_compare_and_swap(&global, 0, 1)) {
-			do {
-#if defined(__i386__) || defined(__x86_64__)
-				__asm__ __volatile__ ("pause");
-#elif defined(__arm__) && defined _ARM_ARCH_7
-				__asm__ __volatile__ ("yield");
-#endif
-			} while (global);
-		}
-		global = 0;
-	}
-	print_result(s, "Inlined spin lock/unlock:");
-
-	s = mach_absolute_time();
-	for (i = cnt; i; i--) {
-		OSSpinLockLock(&slock);
-		OSSpinLockUnlock(&slock);
-	}
-	print_result(s, "OSSpinLock/Unlock:");
-
-	s = mach_absolute_time();
-	for (i = cnt; i; i--) {
-		r = pthread_mutex_lock(&plock);
-		assert(r == 0);
-		r = pthread_mutex_unlock(&plock);
-		assert(r == 0);
-	}
-	print_result(s, "pthread lock/unlock:");
-
-#ifdef __BLOCKS__
-	s = mach_absolute_time();
-	for (i = cnt; i; i--) {
-		dispatch_sync(q, ^{ });
-	}
-	print_result(s, "dispatch_sync:");
-#endif
-
-	s = mach_absolute_time();
-	for (i = cnt; i; i--) {
-		dispatch_sync_f(q, NULL, (void (*)(void *))func);
-	}
-	print_result(s, "dispatch_sync_f:");
-
-#ifdef __BLOCKS__
-	s = mach_absolute_time();
-	for (i = cnt; i; i--) {
-		dispatch_barrier_sync(q, ^{ });
-	}
-	print_result(s, "dispatch_barrier_sync:");
-#endif
-
-	s = mach_absolute_time();
-	for (i = cnt; i; i--) {
-		dispatch_barrier_sync_f(q, NULL, (void (*)(void *))func);
-	}
-	print_result(s, "dispatch_barrier_sync_f:");
-
-	s = mach_absolute_time();
-	dispatch_apply_f(cnt,
-			dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0),
-			NULL, (void (*)(void *, size_t))func);
-	s += loop_cost; // cancel out the implicit subtraction done by the next line
-	print_result(s, "dispatch_apply_f():");
-
-	// do a "double backflip" to hit the fast-path of the enqueue/dequeue logic
-	bfs = mach_absolute_time();
-	dispatch_async_f(dispatch_get_main_queue(), &bf_cnt, backflip);
-	dispatch_async_f(dispatch_get_main_queue(), &bf_cnt, backflip);
-
-	dispatch_main();
-}
-
-__attribute__((noinline))
-void
-backflip_done(void)
-{
-	print_result(bfs, "dispatch_async_f():");
-	exit(EXIT_SUCCESS);
-}
-
-void
-backflip(void *ctxt)
-{
-	size_t *bf_cnt = (size_t *)ctxt;
-	if (--(*bf_cnt)) {
-		return dispatch_async_f(dispatch_get_main_queue(), ctxt, backflip);
-	}
-	backflip_done();
-}
--- a/Telegram/ThirdParty/dispatch/tests/Foundation/dispatch_apply_gc.m	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/Foundation/dispatch_apply_gc.m	1970-01-01 00:00:00.000000000 -0000
@@ -1,63 +0,0 @@
-/*
- * Copyright (c) 2009-2011 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include <dispatch/dispatch.h>
-#import <Foundation/Foundation.h>
-#include <libkern/OSAtomic.h>
-
-#include <bsdtests.h>
-#include "dispatch_test.h"
-
-#if __OBJC_GC__
-const size_t final = 50000, desclen = 538892;
-#else
-const size_t final = 1000, desclen = 8892;
-#endif
-NSAutoreleasePool *pool = nil;
-
-static void
-work(void* ctxt __attribute__((unused)))
-{
-	pool = [[NSAutoreleasePool alloc] init];
-	NSMutableArray *a = [NSMutableArray array];
-	OSSpinLock sl = OS_SPINLOCK_INIT, *l = &sl;
-
-	dispatch_apply(final, dispatch_get_global_queue(0, 0), ^(size_t i){
-		NSDecimalNumber *n = [NSDecimalNumber decimalNumberWithDecimal:
-				[[NSNumber numberWithInteger:i] decimalValue]];
-		OSSpinLockLock(l);
-		[a addObject:n];
-		OSSpinLockUnlock(l);
-	});
-	test_long("count", [a count], final);
-	test_long("description length", [[a description] length], desclen);
-	a = nil;
-	[pool drain];
-	test_stop_after_delay((void*)(intptr_t)1);
-}
-
-int
-main(void)
-{
-	dispatch_test_start("Dispatch Apply GC"); // <rdar://problem/7455071>
-	dispatch_async_f(dispatch_get_main_queue(), (void*)(intptr_t)1, work);
-	CFRunLoopRun();
-	return 0;
-}
--- a/Telegram/ThirdParty/dispatch/tests/Foundation/dispatch_sync_gc.m	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/Foundation/dispatch_sync_gc.m	1970-01-01 00:00:00.000000000 -0000
@@ -1,67 +0,0 @@
-/*
- * Copyright (c) 2009-2011 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include <dispatch/dispatch.h>
-#import <Foundation/Foundation.h>
-
-#include <bsdtests.h>
-#include "dispatch_test.h"
-
-#if __OBJC_GC__
-const size_t final = 50000, desclen = 538892;
-#else
-const size_t final = 1000, desclen = 8892;
-#endif
-NSAutoreleasePool *pool = nil;
-
-static void
-work(void* ctxt __attribute__((unused)))
-{
-	pool = [[NSAutoreleasePool alloc] init];
-	NSMutableArray *a = [NSMutableArray array];
-	dispatch_group_t g = dispatch_group_create();
-
-	dispatch_group_async(g, dispatch_get_global_queue(0, 0), ^{
-		NSUInteger i;
-		for (i = 0; i < final; i++) {
-			NSDecimalNumber *n = [NSDecimalNumber decimalNumberWithDecimal:
-				   [[NSNumber numberWithInteger:i] decimalValue]];
-			dispatch_sync(dispatch_get_main_queue(), ^{
-				[a addObject:n];
-			});
-		}
-	});
-	dispatch_group_notify(g, dispatch_get_main_queue(), ^{
-		test_long("count", [a count], final);
-		test_long("description length", [[a description] length], desclen);
-		[pool drain];
-		test_stop_after_delay((void*)(intptr_t)1);
-	});
-	dispatch_release(g);
-}
-
-int
-main(void)
-{
-	dispatch_test_start("Dispatch Sync GC"); // <rdar://problem/7458685>
-	dispatch_async_f(dispatch_get_main_queue(), NULL, work);
-	CFRunLoopRun();
-	return 0;
-}
--- a/Telegram/ThirdParty/dispatch/tests/Foundation/nsoperation.m	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/Foundation/nsoperation.m	1970-01-01 00:00:00.000000000 -0000
@@ -1,73 +0,0 @@
-/*
- * Copyright (c) 2008-2011 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#include <stdlib.h>
-#include <assert.h>
-#include <stdio.h>
-#include <string.h>
-
-#include <Foundation/Foundation.h>
-#include <dispatch/dispatch.h>
-
-#include <bsdtests.h>
-#include "dispatch_test.h"
-
-@interface MYOperation : NSOperation
-{
-}
-@end
-
-@implementation MYOperation
-
-- (id) init
-{
-	self = [super init];
-	return self;
-}
-
-- (void)main
-{
-	test_stop();
-}
-
-@end
-
-int
-main(void)
-{
-	dispatch_test_start("NSOperation");
-
-	NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
-
-	NSOperationQueue *queue = [[[NSOperationQueue alloc] init] autorelease];
-	test_ptr_notnull("NSOperationQueue", queue);
-
-	MYOperation *operation = [[MYOperation alloc] init];
-	test_ptr_notnull("NSOperation", operation);
-
-	[queue addOperation:operation];
-	[operation release];
-
-	[[NSRunLoop mainRunLoop] run];
-
-	[pool release];
-
-	return 0;
-}
--- a/Telegram/ThirdParty/dispatch/tests/func.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/func.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,33 +0,0 @@
-/*
- * Copyright (c) 2008-2011 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-void
-func(void)
-{
-}
-#ifdef __BLOCKS__
-void (^block)(void) = ^{ };
-#endif
-#ifdef __cplusplus
-};
-#endif
--- a/Telegram/ThirdParty/dispatch/tests/generic_unix_port.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/generic_unix_port.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,54 +0,0 @@
-#include <limits.h>
-#include <sys/param.h>
-
-static inline int32_t
-OSAtomicIncrement32(volatile int32_t *var)
-{
-  return __c11_atomic_fetch_add((_Atomic(int)*)var, 1, __ATOMIC_RELAXED)+1;
-}
-
-static inline int32_t
-OSAtomicIncrement32Barrier(volatile int32_t *var)
-{
-    return __c11_atomic_fetch_add((_Atomic(int)*)var, 1, __ATOMIC_SEQ_CST)+1;
-}
-
-static inline int32_t
-OSAtomicAdd32(int32_t val, volatile int32_t *var)
-{
-    return __c11_atomic_fetch_add((_Atomic(int)*)var, val, __ATOMIC_RELAXED)+val;
-}
-
-// Simulation of mach_absolute_time related infrastructure
-// For now, use gettimeofday.
-// Consider using clockgettime(CLOCK_MONOTONIC) instead.
-
-#include <sys/time.h>
-
-struct mach_timebase_info {
-  uint32_t numer;
-  uint32_t denom;
-};
-
-typedef struct mach_timebase_info *mach_timebase_info_t;
-typedef struct mach_timebase_info mach_timebase_info_data_t;
-
-typedef int kern_return_t;
-
-static inline
-uint64_t
-mach_absolute_time()
-{
-	struct timeval tv;
-	gettimeofday(&tv,NULL);
-	return (1000ull)*((unsigned long long)tv.tv_sec*(1000000ull) + (unsigned long long)tv.tv_usec);
-}
-
-static inline
-int
-mach_timebase_info(mach_timebase_info_t tbi)
-{
-	tbi->numer = 1;
-	tbi->denom = 1;
-	return 0;
-}
--- a/Telegram/ThirdParty/dispatch/tests/generic_win_port.c	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/generic_win_port.c	1970-01-01 00:00:00.000000000 -0000
@@ -1,297 +0,0 @@
-#define _CRT_RAND_S
-#include <generic_win_port.h>
-#include <dispatch_test.h>
-#include <stdarg.h>
-#include <stdbool.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <time.h>
-#include <wchar.h>
-#include <Windows.h>
-
-static bool
-expand_wstr(WCHAR **str, size_t *capacity, size_t needed)
-{
-	if (*capacity >= needed) {
-		return true;
-	}
-	if (needed > UNICODE_STRING_MAX_CHARS) {
-		return false;
-	}
-	size_t new_capacity = *capacity ?: needed;
-	while (new_capacity < needed) {
-		new_capacity *= 2;
-	}
-	WCHAR *new_str = realloc(*str, new_capacity * sizeof(WCHAR));
-	if (!new_str) {
-		return false;
-	}
-	*str = new_str;
-	*capacity = new_capacity;
-	return true;
-}
-
-static bool
-append_wstr(WCHAR **str, size_t *capacity, size_t *len, WCHAR *suffix)
-{
-	size_t suffix_len = wcslen(suffix);
-	if (!expand_wstr(str, capacity, *len + suffix_len)) {
-		return false;
-	}
-	memcpy(*str + *len, suffix, suffix_len * sizeof(WCHAR));
-	*len += suffix_len;
-	return true;
-}
-
-WCHAR *
-argv_to_command_line(char **argv)
-{
-	// This is basically the reverse of CommandLineToArgvW(). We want to convert
-	// an argv array into a command-line compatible with CreateProcessW().
-	//
-	// See also:
-	// <https://docs.microsoft.com/en-us/windows/desktop/api/shellapi/nf-shellapi-commandlinetoargvw>
-	// <https://blogs.msdn.microsoft.com/twistylittlepassagesallalike/2011/04/23/everyone-quotes-command-line-arguments-the-wrong-way/>
-	size_t len = 0, capacity = 0;
-	WCHAR *cmdline = NULL;
-	if (!expand_wstr(&cmdline, &capacity, 256)) {
-		goto error;
-	}
-	for (size_t i = 0; argv[i]; i++) {
-		// Separate arguments with spaces.
-		if (i > 0 && !append_wstr(&cmdline, &capacity, &len, L" ")) {
-			goto error;
-		}
-		// Surround the argument with quotes if it's empty or contains special
-		// characters.
-		char *cur = argv[i];
-		bool quoted = (*cur == '\0' || cur[strcspn(cur, " \t\n\v\"")] != '\0');
-		if (quoted && !append_wstr(&cmdline, &capacity, &len, L"\"")) {
-			goto error;
-		}
-		while (*cur != '\0') {
-			if (*cur == '"') {
-				// Quotes must be escaped with a backslash.
-				if (!append_wstr(&cmdline, &capacity, &len, L"\\\"")) {
-					goto error;
-				}
-				cur++;
-			} else if (*cur == '\\') {
-				// Windows treats backslashes differently depending on whether
-				// they're followed by a quote. If the backslashes aren't
-				// followed by a quote, then all slashes are copied into the
-				// argument string. Otherwise, only n/2 slashes are included.
-				// Count the number of slashes and double them if they're
-				// followed by a quote.
-				size_t backslashes = strspn(cur, "\\");
-				cur += backslashes;
-				// If the argument needs to be surrounded with quotes, we must
-				// also check if the backslashes are at the end of the argument
-				// because the added quote will follow them.
-				if (*cur == '"' || (quoted && *cur == '\0')) {
-					backslashes *= 2;
-				}
-				if (!expand_wstr(&cmdline, &capacity, len + backslashes)) {
-					goto error;
-				}
-				wmemset(&cmdline[len], L'\\', backslashes);
-				len += backslashes;
-			} else {
-				// Widen as many characters as possible.
-				size_t mb_len = strcspn(cur, "\"\\");
-				int wide_len = MultiByteToWideChar(CP_UTF8, 0, cur, mb_len,
-						NULL, 0);
-				if (wide_len == 0) {
-					goto error;
-				}
-				if (!expand_wstr(&cmdline, &capacity, len + wide_len)) {
-					goto error;
-				}
-				wide_len = MultiByteToWideChar(CP_UTF8, 0, cur, mb_len,
-						&cmdline[len], wide_len);
-				if (wide_len == 0) {
-					goto error;
-				}
-				cur += mb_len;
-				len += wide_len;
-			}
-		}
-		if (quoted && !append_wstr(&cmdline, &capacity, &len, L"\"")) {
-			goto error;
-		}
-	}
-	if (!expand_wstr(&cmdline, &capacity, len + 1)) {
-		goto error;
-	}
-	cmdline[len] = L'\0';
-	return cmdline;
-error:
-	free(cmdline);
-	return NULL;
-}
-
-int
-asprintf(char **strp, const char *format, ...)
-{
-	va_list arg1;
-	va_start(arg1, format);
-	int len = vsnprintf(NULL, 0, format, arg1);
-	va_end(arg1);
-	if (len >= 0) {
-		size_t size = (size_t)len + 1;
-		*strp = malloc(size);
-		if (!*strp) {
-			return -1;
-		}
-		va_list arg2;
-		va_start(arg2, format);
-		len = vsnprintf(*strp, size, format, arg2);
-		va_end(arg2);
-	}
-	return len;
-}
-
-void
-filetime_to_timeval(struct timeval *tp, const FILETIME *ft)
-{
-	int64_t ticks = ft->dwLowDateTime | (((int64_t)ft->dwHighDateTime) << 32);
-	static const int64_t ticks_per_sec = 10LL * 1000LL * 1000LL;
-	static const int64_t ticks_per_usec = 10LL;
-	if (ticks >= 0) {
-		tp->tv_sec = (long)(ticks / ticks_per_sec);
-		tp->tv_usec = (long)((ticks % ticks_per_sec) / ticks_per_usec);
-	} else {
-		tp->tv_sec = (long)((ticks + 1) / ticks_per_sec - 1);
-		tp->tv_usec = (long)((ticks_per_sec - 1 + (ticks + 1) % ticks_per_sec) / ticks_per_usec);
-	}
-}
-
-pid_t
-getpid(void)
-{
-	return (pid_t)GetCurrentProcessId();
-}
-
-int
-gettimeofday(struct timeval *tp, void *tzp)
-{
-	(void)tzp;
-	FILETIME ft;
-	GetSystemTimePreciseAsFileTime(&ft);
-	int64_t ticks = ft.dwLowDateTime | (((int64_t)ft.dwHighDateTime) << 32);
-	ticks -= 116444736000000000LL;  // Convert to Unix time
-	FILETIME unix_ft = {.dwLowDateTime = (DWORD)ticks, .dwHighDateTime = ticks >> 32};
-	filetime_to_timeval(tp, &unix_ft);
-	return 0;
-}
-
-typedef void (WINAPI *QueryUnbiasedInterruptTimePreciseT)(PULONGLONG);
-static QueryUnbiasedInterruptTimePreciseT QueryUnbiasedInterruptTimePrecisePtr;
-
-static BOOL
-mach_absolute_time_init(PINIT_ONCE InitOnce, PVOID Parameter, PVOID *lpContext)
-{
-	// QueryUnbiasedInterruptTimePrecise() is declared in the Windows headers
-	// but it isn't available in any import libraries. We must manually load it
-	// from KernelBase.dll.
-	HMODULE kernelbase = LoadLibraryW(L"KernelBase.dll");
-	if (!kernelbase) {
-		print_winapi_error("LoadLibraryW", GetLastError());
-		abort();
-	}
-	QueryUnbiasedInterruptTimePrecisePtr =
-			(QueryUnbiasedInterruptTimePreciseT)GetProcAddress(kernelbase,
-					"QueryUnbiasedInterruptTimePrecise");
-	if (!QueryUnbiasedInterruptTimePrecisePtr) {
-		fprintf(stderr, "QueryUnbiasedInterruptTimePrecise is not available\n");
-		abort();
-	}
-	return TRUE;
-}
-
-uint64_t
-mach_absolute_time(void)
-{
-	static INIT_ONCE init_once = INIT_ONCE_STATIC_INIT;
-	if (!InitOnceExecuteOnce(&init_once, mach_absolute_time_init, NULL, NULL)) {
-		print_winapi_error("InitOnceExecuteOnce", GetLastError());
-		abort();
-	}
-	ULONGLONG result = 0;
-	QueryUnbiasedInterruptTimePrecisePtr(&result);
-	return result * 100;  // Convert from 100ns units
-}
-
-static void
-randomize_name(char *out)
-{
-	static const char chars[] =
-			"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz._-";
-	const size_t num_chars = sizeof(chars) - 1;
-	unsigned int lo, hi;
-	rand_s(&lo);
-	rand_s(&hi);
-	uint64_t val = ((uint64_t)hi << 32) | lo;
-	for (int j = 0; j < 6; j++) {
-		out[j] = chars[val % num_chars];
-		val /= num_chars;
-	}
-}
-
-dispatch_fd_t
-mkstemp(char *tmpl)
-{
-	size_t len = strlen(tmpl);
-	if (len < 6) {
-		errno = EINVAL;
-		return -1;
-	}
-	char *replace = &tmpl[len - 6];
-	for (int i = 0; i < 100; i++) {
-		randomize_name(replace);
-		dispatch_fd_t fd = dispatch_test_fd_open(tmpl, O_RDWR | O_CREAT | O_EXCL);
-		if (fd != -1) {
-			return fd;
-		}
-	}
-	errno = EEXIST;
-	return -1;
-}
-
-void
-print_winapi_error(const char *function_name, DWORD error)
-{
-	char *message = NULL;
-	DWORD len = FormatMessageA(
-			FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL,
-			error, 0, (LPSTR)&message, 0, NULL);
-	if (len > 0) {
-		// Note: FormatMessage includes a newline at the end of the message
-		fprintf(stderr, "%s: %s", function_name, message);
-		LocalFree(message);
-	} else {
-		fprintf(stderr, "%s: error %lu\n", function_name, error);
-	}
-}
-
-intptr_t
-random(void)
-{
-	unsigned int x;
-	rand_s(&x);
-	return x & INT_MAX;
-}
-
-unsigned int
-sleep(unsigned int seconds)
-{
-	Sleep(seconds * 1000);
-	return 0;
-}
-
-int
-usleep(unsigned int usec)
-{
-	Sleep((usec + 999) / 1000);
-	return 0;
-}
--- a/Telegram/ThirdParty/dispatch/tests/generic_win_port.h	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/generic_win_port.h	1970-01-01 00:00:00.000000000 -0000
@@ -1,84 +0,0 @@
-#pragma once
-
-#include <dispatch/dispatch.h>
-#include <fcntl.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <Windows.h>
-
-typedef int kern_return_t;
-typedef int pid_t;
-
-#if defined(_WIN64)
-typedef long long ssize_t;
-#else
-typedef long ssize_t;
-#endif
-
-struct mach_timebase_info {
-	uint32_t numer;
-	uint32_t denom;
-};
-
-typedef struct mach_timebase_info *mach_timebase_info_t;
-typedef struct mach_timebase_info mach_timebase_info_data_t;
-
-static inline int32_t
-OSAtomicIncrement32(volatile int32_t *var)
-{
-	return __c11_atomic_fetch_add((_Atomic(int)*)var, 1, __ATOMIC_RELAXED)+1;
-}
-
-static inline int32_t
-OSAtomicIncrement32Barrier(volatile int32_t *var)
-{
-	return __c11_atomic_fetch_add((_Atomic(int)*)var, 1, __ATOMIC_SEQ_CST)+1;
-}
-
-static inline int32_t
-OSAtomicAdd32(int32_t val, volatile int32_t *var)
-{
-	return __c11_atomic_fetch_add((_Atomic(int)*)var, val, __ATOMIC_RELAXED)+val;
-}
-
-WCHAR *
-argv_to_command_line(char **argv);
-
-int
-asprintf(char **strp, const char *format, ...);
-
-void
-filetime_to_timeval(struct timeval *tp, const FILETIME *ft);
-
-pid_t
-getpid(void);
-
-int
-gettimeofday(struct timeval *tp, void *tzp);
-
-uint64_t
-mach_absolute_time(void);
-
-static inline
-int
-mach_timebase_info(mach_timebase_info_t tbi)
-{
-	tbi->numer = 1;
-	tbi->denom = 1;
-	return 0;
-}
-
-dispatch_fd_t
-mkstemp(char *tmpl);
-
-void
-print_winapi_error(const char *function_name, DWORD error);
-
-intptr_t
-random(void);
-
-unsigned int
-sleep(unsigned int seconds);
-
-int
-usleep(unsigned int usec);
--- a/Telegram/ThirdParty/dispatch/tests/.gitignore	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/.gitignore	1970-01-01 00:00:00.000000000 -0000
@@ -1,44 +0,0 @@
-*.o
-*.lo
-*.la
-*.log
-*.trs
-.libs
-bsdtestharness
-bsdtestsummarize
-dispatch
-dispatch_after
-dispatch_api
-dispatch_apply
-dispatch_c99
-dispatch_cascade
-dispatch_concur
-dispatch_context_for_key
-dispatch_data
-dispatch_debug
-dispatch_drift
-dispatch_group
-dispatch_io
-dispatch_io_net
-dispatch_overcommit
-dispatch_pingpong
-dispatch_plusplus
-dispatch_priority
-dispatch_priority2
-dispatch_queue_finalizer
-dispatch_read
-dispatch_read2
-dispatch_readsync
-dispatch_select
-dispatch_sema
-dispatch_starfish
-dispatch_suspend_timer
-dispatch_timer
-dispatch_timer_bit31
-dispatch_timer_bit63
-dispatch_timer_set_time
-dispatch_timer_short
-dispatch_timer_timeout
-dispatch_vnode
-leaks-wrapper
-
--- a/Telegram/ThirdParty/dispatch/tests/leaks-wrapper.sh	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tests/leaks-wrapper.sh	1970-01-01 00:00:00.000000000 -0000
@@ -1,10 +0,0 @@
-#!/bin/sh
-
-/usr/bin/leaks "$@" 2>&1 | tee "${TMPDIR}$*.leakslog" | grep -q " 0 leaks for 0 total leaked bytes"
-
-if [ $? -eq 0 ]; then
-    rm "${TMPDIR}$*.leakslog"
-    exit 0
-else
-    exit $?
-fi
--- a/Telegram/ThirdParty/dispatch/tools/dispatch_timers.d	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tools/dispatch_timers.d	1970-01-01 00:00:00.000000000 -0000
@@ -1,89 +0,0 @@
-#!/usr/sbin/dtrace -s
-
-/*
- * Copyright (c) 2012-2013 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-/*
- * Usage: dispatch_timers.d -p [pid]
- *        traced process must have been executed with
- *        DYLD_LIBRARY_PATH=/usr/lib/system/introspection or with
- *        DYLD_IMAGE_SUFFIX=_profile or DYLD_IMAGE_SUFFIX=_debug
- */
-
-#pragma D option quiet
-#pragma D option zdefs
-
-typedef struct dispatch_trace_timer_params_s {
-	int64_t deadline, interval, leeway;
-} *dispatch_trace_timer_params_t;
-
-dispatch$target:libdispatch*.dylib::timer-configure,
-dispatch$target:libdispatch*.dylib::timer-program,
-dispatch$target:libdispatch*.dylib::timer-wake,
-dispatch$target:libdispatch*.dylib::timer-fire /!start/ {
-	start = walltimestamp;
-}
-
-/*
- * Trace dispatch timer configuration and programming:
- * Timer configuration indicates that dispatch_source_set_timer() was called.
- * Timer programming indicates that the dispatch manager is about to sleep
- * for 'deadline' ns (but may wake up earlier if non-timer events occur).
- * Time parameters are in nanoseconds, a value of -1 means "forever".
- *
- * probe timer-configure/-program(dispatch_source_t source,
- *         dispatch_function_t function, dispatch_trace_timer_params_t params)
- */
-dispatch$target:libdispatch*.dylib::timer-configure,
-dispatch$target:libdispatch*.dylib::timer-program {
-	this->p = (dispatch_trace_timer_params_t)copyin(arg2,
-			sizeof(struct dispatch_trace_timer_params_s));
-	printf("%8dus %-15s: 0x%0?p deadline: %11dns interval: %11dns leeway: %11dns",
-			(walltimestamp-start)/1000, probename, arg0,
-			this->p ? this->p->deadline : 0, this->p ? this->p->interval : 0,
-			this->p ? this->p->leeway : 0);
-	usym(arg1);
-	printf("\n");
-}
-dispatch$target:libdispatch*.dylib::timer-configure {
-	printf("              / --- Begin ustack");
-	ustack();
-	printf("              \ --- End ustack\n");
-}
-
-/*
- * Trace dispatch timer wakes and fires:
- * Timer wakes indicate that the dispatch manager woke up due to expiry of the
- * deadline for the specified timer.
- * Timer fires indicate that that the dispatch manager scheduled the event
- * handler of the specified timer for asynchronous execution (may occur without
- * a corresponding timer wake if the manager was awake processing other events
- * when the timer deadline expired).
- *
- * probe timer-wake/-fire(dispatch_source_t source,
- *         dispatch_function_t function)
- */
-dispatch$target:libdispatch*.dylib::timer-wake,
-dispatch$target:libdispatch*.dylib::timer-fire {
-	printf("%8dus %-15s: 0x%0?p%-70s", (walltimestamp-start)/1000, probename,
-			arg0, "");
-	usym(arg1);
-	printf("\n");
-}
--- a/Telegram/ThirdParty/dispatch/tools/dispatch_trace.d	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tools/dispatch_trace.d	1970-01-01 00:00:00.000000000 -0000
@@ -1,76 +0,0 @@
-#!/usr/sbin/dtrace -s
-
-/*
- * Copyright (c) 2010-2013 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-/* 
- * Usage: dispatch_trace.d -p [pid]
- *        traced process must have been executed with
- *        DYLD_LIBRARY_PATH=/usr/lib/system/introspection or with
- *        DYLD_IMAGE_SUFFIX=_profile or DYLD_IMAGE_SUFFIX=_debug
- */
-
-#pragma D option quiet
-#pragma D option zdefs
-#pragma D option bufsize=16m
-
-BEGIN {
-	printf("%-8s %-3s %-8s   %-35s%-15s%-?s   %-43s%-?s   %-14s%-?s    %s\n",
-		"Time us", "CPU", "Thread", "Function", "Probe", "Queue", "Label",
-		"Item", "Kind", "Context", "Symbol");
-}
-
-dispatch$target:libdispatch*.dylib::queue-push,
-dispatch$target:libdispatch*.dylib::queue-pop,
-dispatch$target:libdispatch*.dylib::callout-entry,
-dispatch$target:libdispatch*.dylib::callout-return /!start/ {
-	start = walltimestamp;
-}
-
-/*
- * Trace queue push and pop operations:
- *
- * probe queue-push/-pop(dispatch_queue_t queue, const char *label,
- *         dispatch_object_t item, const char *kind,
- *         dispatch_function_t function, void *context)
- */
-dispatch$target:libdispatch*.dylib::queue-push,
-dispatch$target:libdispatch*.dylib::queue-pop {
-	printf("%-8d %-3d 0x%08p %-35s%-15s0x%0?p %-43s0x%0?p %-14s0x%0?p",
-		(walltimestamp-start)/1000, cpu, tid, probefunc, probename, arg0,
-		copyinstr(arg1, 42), arg2, copyinstr(arg3, 13), arg5);
-	usym(arg4);
-	printf("\n");
-}
-
-/*
- * Trace callouts to client functions:
- *
- * probe callout-entry/-return(dispatch_queue_t queue, const char *label,
- *         dispatch_function_t function, void *context)
- */
-dispatch$target:libdispatch*.dylib::callout-entry,
-dispatch$target:libdispatch*.dylib::callout-return {
-	printf("%-8d %-3d 0x%08p %-35s%-15s0x%0?p %-43s%-?s   %-14s0x%0?p",
-		(walltimestamp-start)/1000, cpu, tid, probefunc, probename, arg0,
-		copyinstr(arg1, 42), "", "", arg3);
-	usym(arg2);
-	printf("\n");
-}
--- a/Telegram/ThirdParty/dispatch/tools/voucher_trace.d	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/tools/voucher_trace.d	1970-01-01 00:00:00.000000000 -0000
@@ -1,78 +0,0 @@
-#!/usr/sbin/dtrace -s
-
-/*
- * Copyright (c) 2017 Apple Inc. All rights reserved.
- *
- * @APPLE_APACHE_LICENSE_HEADER_START@
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @APPLE_APACHE_LICENSE_HEADER_END@
- */
-
-/*
- * Usage: voucher_trace.d -p [pid]
- *        traced process must have been executed with
- *        DYLD_LIBRARY_PATH=/usr/lib/system/introspection or with
- *        DYLD_IMAGE_SUFFIX=_profile or DYLD_IMAGE_SUFFIX=_debug
- */
-
-#pragma D option quiet
-#pragma D option zdefs
-#pragma D option bufsize=16m
-
-BEGIN {
-	printf("Starting to trace voucher operations...\n");
-}
-
-voucher$target:libdispatch*.dylib::create
-{
-	printf("ALLOC   voucher 0x%p, thread %#llx, ref 1, port %#x, aid %#llx", arg0, tid, arg1, arg2);
-	ustack(10);
-	printf("\n")
-}
-
-voucher$target:libdispatch*.dylib::dispose
-{
-	printf("FREE    voucher 0x%p, thread %#llx, ref 0", arg0, tid);
-	ustack(10);
-	printf("\n")
-}
-
-voucher$target:libdispatch*.dylib::retain
-{
-	printf("RETAIN  voucher 0x%p, thread %#llx, ref %d", arg0, tid, arg1);
-	ustack(10);
-	printf("\n")
-}
-
-voucher$target:libdispatch*.dylib::release
-{
-	printf("RELEASE voucher 0x%p, thread %#llx, ref %d", arg0, tid, arg1);
-	ustack(10);
-	printf("\n")
-}
-
-voucher$target:libdispatch*.dylib::adopt
-{
-	printf("ADOPT   voucher 0x%p, thread %#llx", arg0, tid);
-	ustack(10);
-	printf("\n")
-}
-
-voucher$target:libdispatch*.dylib::orphan
-{
-	printf("ORPHAN  voucher 0x%p, thread %#llx", arg0, tid);
-	ustack(10);
-	printf("\n")
-}
--- a/Telegram/ThirdParty/dispatch/xcodeconfig/libdispatch.aliases	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/xcodeconfig/libdispatch.aliases	1970-01-01 00:00:00.000000000 -0000
@@ -1,27 +0,0 @@
-#
-# Copyright (c) 2013-2014 Apple Inc. All rights reserved.
-#
-# @APPLE_APACHE_LICENSE_HEADER_START@
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-# @APPLE_APACHE_LICENSE_HEADER_END@
-#
-
-__dispatch_data_destructor_vm_deallocate __dispatch_data_destructor_munmap
-__dispatch_queue_attrs __dispatch_queue_attr_concurrent
-__dispatch_source_type_memorypressure __dispatch_source_type_memorystatus
-_dispatch_assert_queue$V2 _dispatch_assert_queue
-_dispatch_assert_queue_not$V2 _dispatch_assert_queue_not
-_dispatch_queue_create_with_target$V2 _dispatch_queue_create_with_target
-_dispatch_source_set_timer __dispatch_source_set_runloop_timer_4CF
--- a/Telegram/ThirdParty/dispatch/xcodeconfig/libdispatch.clean	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/xcodeconfig/libdispatch.clean	1970-01-01 00:00:00.000000000 -0000
@@ -1,48 +0,0 @@
-#
-# Copyright (c) 2018 Apple Inc. All rights reserved.
-#
-# @APPLE_APACHE_LICENSE_HEADER_START@
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-# @APPLE_APACHE_LICENSE_HEADER_END@
-#
-
-__dispatch_bug.last_seen
-__dispatch_bug_deprecated.last_seen
-__dispatch_bug_kevent_client.last_seen
-__dispatch_bug_kevent_client.last_seen.37
-__dispatch_bug_kevent_client.last_seen.39
-__dispatch_bug_kevent_vanished.last_seen
-__dispatch_bug_mach_client.last_seen
-
-__dispatch_build_pred
-__dispatch_build
-
-__dispatch_child_of_unsafe_fork
-__dispatch_continuation_cache_limit
-__dispatch_data_empty
-__dispatch_host_time_data.0
-__dispatch_host_time_data.1
-__dispatch_host_time_mach2nano
-__dispatch_host_time_nano2mach
-__dispatch_source_timer_use_telemetry
-__dispatch_timers_force_max_leeway
-__os_object_debug_missing_pools
-_dispatch_benchmark_f.bdata
-_dispatch_benchmark_f.pred
-_dispatch_io_defaults
-_dispatch_log_disabled
-_dispatch_logfile
-
-__dyld_private
--- a/Telegram/ThirdParty/dispatch/xcodeconfig/libdispatch.dirty	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/xcodeconfig/libdispatch.dirty	1970-01-01 00:00:00.000000000 -0000
@@ -1,153 +0,0 @@
-#
-# Copyright (c) 2013 Apple Inc. All rights reserved.
-#
-# @APPLE_APACHE_LICENSE_HEADER_START@
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-# @APPLE_APACHE_LICENSE_HEADER_END@
-#
-
-# Must be kept in sync with ObjC TFB checks in object_internal.h
-
-# dispatch_object_t classes
-_OBJC_CLASS_$_OS_dispatch_object
-_OBJC_CLASS_$_OS_dispatch_semaphore
-__OS_dispatch_semaphore_vtable
-_OBJC_CLASS_$_OS_dispatch_group
-__OS_dispatch_group_vtable
-_OBJC_CLASS_$_OS_dispatch_queue
-__OS_dispatch_queue_vtable
-_OBJC_CLASS_$_OS_dispatch_workloop
-__OS_dispatch_workloop_vtable
-_OBJC_CLASS_$_OS_dispatch_queue_serial
-__OS_dispatch_queue_serial_vtable
-_OBJC_CLASS_$_OS_dispatch_queue_concurrent
-__OS_dispatch_queue_concurrent_vtable
-_OBJC_CLASS_$_OS_dispatch_queue_global
-__OS_dispatch_queue_global_vtable
-_OBJC_CLASS_$_OS_dispatch_queue_pthread_root
-__OS_dispatch_queue_pthread_root_vtable
-_OBJC_CLASS_$_OS_dispatch_queue_main
-__OS_dispatch_queue_main_vtable
-_OBJC_CLASS_$_OS_dispatch_queue_runloop
-__OS_dispatch_queue_runloop_vtable
-_OBJC_CLASS_$_OS_dispatch_queue_mgr
-__OS_dispatch_queue_mgr_vtable
-_OBJC_CLASS_$_OS_dispatch_queue_attr
-__OS_dispatch_queue_attr_vtable
-_OBJC_CLASS_$_OS_dispatch_source
-__OS_dispatch_source_vtable
-_OBJC_CLASS_$_OS_dispatch_mach
-__OS_dispatch_mach_vtable
-_OBJC_CLASS_$_OS_dispatch_mach_msg
-__OS_dispatch_mach_msg_vtable
-_OBJC_CLASS_$_OS_dispatch_io
-__OS_dispatch_io_vtable
-_OBJC_CLASS_$_OS_dispatch_operation
-__OS_dispatch_operation_vtable
-_OBJC_CLASS_$_OS_dispatch_disk
-__OS_dispatch_disk_vtable
-# os_object_t classes
-_OBJC_CLASS_$_OS_object
-_OBJC_CLASS_$_OS_voucher
-#_OBJC_CLASS_$_OS_voucher_recipe
-# non-os_object_t classes
-_OBJC_CLASS_$_OS_dispatch_data
-_OBJC_CLASS_$_OS_dispatch_data_empty
-# metaclasses
-_OBJC_METACLASS_$_OS_dispatch_object
-_OBJC_METACLASS_$_OS_dispatch_semaphore
-_OBJC_METACLASS_$_OS_dispatch_group
-_OBJC_METACLASS_$_OS_dispatch_queue
-_OBJC_METACLASS_$_OS_dispatch_workloop
-_OBJC_METACLASS_$_OS_dispatch_queue_serial
-_OBJC_METACLASS_$_OS_dispatch_queue_concurrent
-_OBJC_METACLASS_$_OS_dispatch_queue_global
-_OBJC_METACLASS_$_OS_dispatch_queue_pthread_root
-_OBJC_METACLASS_$_OS_dispatch_queue_main
-_OBJC_METACLASS_$_OS_dispatch_queue_runloop
-_OBJC_METACLASS_$_OS_dispatch_queue_mgr
-_OBJC_METACLASS_$_OS_dispatch_queue_attr
-_OBJC_METACLASS_$_OS_dispatch_source
-_OBJC_METACLASS_$_OS_dispatch_mach
-_OBJC_METACLASS_$_OS_dispatch_mach_msg
-_OBJC_METACLASS_$_OS_dispatch_io
-_OBJC_METACLASS_$_OS_dispatch_operation
-_OBJC_METACLASS_$_OS_dispatch_disk
-_OBJC_METACLASS_$_OS_object
-_OBJC_METACLASS_$_OS_voucher
-#_OBJC_METACLASS_$_OS_voucher_recipe
-_OBJC_METACLASS_$_OS_dispatch_data
-_OBJC_METACLASS_$_OS_dispatch_data_empty
-
-# Other dirty symbols
-# large structs / hashes
-__dispatch_main_q
-__dispatch_mgr_q
-__dispatch_mgr_sched
-__dispatch_root_queues
-__dispatch_sources
-__dispatch_timers_heap
-__dispatch_trace_next_timer
-__voucher_hash
-
-# 64 bits
-__dispatch_narrow_check_interval_cache
-__dispatch_narrowing_deadlines
-__voucher_aid_next
-__voucher_unique_pid
-
-# pointer sized
-__dispatch_begin_NSAutoReleasePool
-__dispatch_continuation_alloc_init_pred
-__dispatch_end_NSAutoReleasePool
-__dispatch_is_daemon_pred
-__dispatch_kq_poll_pred
-__dispatch_logv_pred
-__dispatch_mach_calendar_pred
-__dispatch_mach_host_port_pred
-__dispatch_mach_notify_port_pred
-__dispatch_mach_xpc_hooks
-__dispatch_main_heap
-__dispatch_main_q_handle_pred
-__dispatch_mgr_sched_pred
-__dispatch_queue_serial_numbers
-__dispatch_root_queues_pred
-__dispatch_source_timer_telemetry_pred
-__firehose_task_buffer
-__firehose_task_buffer_pred
-__voucher_activity_debug_channel
-__voucher_libtrace_hooks
-__voucher_task_mach_voucher_pred
-
-# 32bits
-__dispatch_mach_host_port
-__dispatch_mach_notify_port
-__voucher_default_task_mach_voucher
-__voucher_hash_lock
-__voucher_task_mach_voucher
-
-# byte-sized
-__dispatch_is_daemon
-__dispatch_memory_warn
-__dispatch_mode
-__dispatch_program_is_probably_callback_driven
-__dispatch_unsafe_fork
-__dispatch_use_dispatch_alloc
-
-__dispatch_io_devs
-__dispatch_io_fds
-__dispatch_io_devs_lockq
-__dispatch_io_fds_lockq
-__dispatch_io_init_pred
--- a/Telegram/ThirdParty/dispatch/xcodeconfig/libdispatch-dyld-stub.xcconfig	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/xcodeconfig/libdispatch-dyld-stub.xcconfig	1970-01-01 00:00:00.000000000 -0000
@@ -1,28 +0,0 @@
-//
-// Copyright (c) 2016 Apple Inc. All rights reserved.
-//
-// @APPLE_APACHE_LICENSE_HEADER_START@
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-// @APPLE_APACHE_LICENSE_HEADER_END@
-//
-
-PRODUCT_NAME = libdispatch_dyld_stub
-INSTALL_PATH = /usr/local/lib/dyld_stub
-BUILD_VARIANTS = normal
-GCC_PREPROCESSOR_DEFINITIONS = $(GCC_PREPROCESSOR_DEFINITIONS) DISPATCH_VARIANT_DYLD_STUB=1 $(STATICLIB_PREPROCESSOR_DEFINITIONS)
-OTHER_LDFLAGS =
-VERSIONING_SYSTEM =
-EXCLUDED_SOURCE_FILE_NAMES = *
-INCLUDED_SOURCE_FILE_NAMES = voucher.c // minimal with DISPATCH_VARIANT_DYLD_STUB
--- a/Telegram/ThirdParty/dispatch/xcodeconfig/libdispatch.interposable	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/xcodeconfig/libdispatch.interposable	1970-01-01 00:00:00.000000000 -0000
@@ -1,29 +0,0 @@
-#
-# Copyright (c) 2013 Apple Inc. All rights reserved.
-#
-# @APPLE_APACHE_LICENSE_HEADER_START@
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-# @APPLE_APACHE_LICENSE_HEADER_END@
-#
-
-# Interposable API hooks in the introspection library
-
-_dispatch_introspection_hook_queue_create
-_dispatch_introspection_hook_queue_destroy
-_dispatch_introspection_hook_queue_item_enqueue
-_dispatch_introspection_hook_queue_item_dequeue
-_dispatch_introspection_hook_queue_item_complete
-_dispatch_introspection_hook_queue_callout_begin
-_dispatch_introspection_hook_queue_callout_end
--- a/Telegram/ThirdParty/dispatch/xcodeconfig/libdispatch-introspection.xcconfig	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/xcodeconfig/libdispatch-introspection.xcconfig	1970-01-01 00:00:00.000000000 -0000
@@ -1,26 +0,0 @@
-//
-// Copyright (c) 2012-2013 Apple Inc. All rights reserved.
-//
-// @APPLE_APACHE_LICENSE_HEADER_START@
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-// @APPLE_APACHE_LICENSE_HEADER_END@
-//
-
-BUILD_VARIANTS = normal
-INSTALL_PATH = /usr/lib/system/introspection
-
-GCC_PREPROCESSOR_DEFINITIONS = $(GCC_PREPROCESSOR_DEFINITIONS) DISPATCH_INTROSPECTION=1
-CONFIGURATION_BUILD_DIR = $(BUILD_DIR)/introspection
-OTHER_LDFLAGS = $(OTHER_LDFLAGS) -Wl,-interposable_list,$(SRCROOT)/xcodeconfig/libdispatch.interposable
--- a/Telegram/ThirdParty/dispatch/xcodeconfig/libdispatch-mp-static.xcconfig	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/xcodeconfig/libdispatch-mp-static.xcconfig	1970-01-01 00:00:00.000000000 -0000
@@ -1,29 +0,0 @@
-//
-// Copyright (c) 2012-2013 Apple Inc. All rights reserved.
-//
-// @APPLE_APACHE_LICENSE_HEADER_START@
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-// @APPLE_APACHE_LICENSE_HEADER_END@
-//
-
-// skip simulator
-SUPPORTED_PLATFORMS = macosx iphoneos appletvos watchos
-PRODUCT_NAME = libdispatch
-INSTALL_PATH = /usr/local/lib/system
-BUILD_VARIANTS = normal debug
-GCC_PREPROCESSOR_DEFINITIONS = $(GCC_PREPROCESSOR_DEFINITIONS) $(STATICLIB_PREPROCESSOR_DEFINITIONS)
-OTHER_LDFLAGS =
-SKIP_INSTALL[sdk=*simulator*] = YES
-EXCLUDED_SOURCE_FILE_NAMES[sdk=*simulator*] = *
--- a/Telegram/ThirdParty/dispatch/xcodeconfig/libdispatch.order	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/xcodeconfig/libdispatch.order	1970-01-01 00:00:00.000000000 -0000
@@ -1,92 +0,0 @@
-#
-# Copyright (c) 2013 Apple Inc. All rights reserved.
-#
-# @APPLE_APACHE_LICENSE_HEADER_START@
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-# @APPLE_APACHE_LICENSE_HEADER_END@
-#
-
-# Must be kept in sync with ObjC TFB checks in object_internal.h
-
-# dispatch_object_t classes
-_OBJC_CLASS_$_OS_dispatch_object
-_OBJC_CLASS_$_OS_dispatch_semaphore
-__OS_dispatch_semaphore_vtable
-_OBJC_CLASS_$_OS_dispatch_group
-__OS_dispatch_group_vtable
-_OBJC_CLASS_$_OS_dispatch_queue
-__OS_dispatch_queue_vtable
-_OBJC_CLASS_$_OS_dispatch_workloop
-__OS_dispatch_workloop_vtable
-_OBJC_CLASS_$_OS_dispatch_queue_serial
-__OS_dispatch_queue_serial_vtable
-_OBJC_CLASS_$_OS_dispatch_queue_concurrent
-__OS_dispatch_queue_concurrent_vtable
-_OBJC_CLASS_$_OS_dispatch_queue_global
-__OS_dispatch_queue_global_vtable
-_OBJC_CLASS_$_OS_dispatch_queue_pthread_root
-__OS_dispatch_queue_pthread_root_vtable
-_OBJC_CLASS_$_OS_dispatch_queue_main
-__OS_dispatch_queue_main_vtable
-_OBJC_CLASS_$_OS_dispatch_queue_runloop
-__OS_dispatch_queue_runloop_vtable
-_OBJC_CLASS_$_OS_dispatch_queue_mgr
-__OS_dispatch_queue_mgr_vtable
-_OBJC_CLASS_$_OS_dispatch_queue_attr
-__OS_dispatch_queue_attr_vtable
-_OBJC_CLASS_$_OS_dispatch_source
-__OS_dispatch_source_vtable
-_OBJC_CLASS_$_OS_dispatch_mach
-__OS_dispatch_mach_vtable
-_OBJC_CLASS_$_OS_dispatch_mach_msg
-__OS_dispatch_mach_msg_vtable
-_OBJC_CLASS_$_OS_dispatch_io
-__OS_dispatch_io_vtable
-_OBJC_CLASS_$_OS_dispatch_operation
-__OS_dispatch_operation_vtable
-_OBJC_CLASS_$_OS_dispatch_disk
-__OS_dispatch_disk_vtable
-# os_object_t classes
-_OBJC_CLASS_$_OS_object
-_OBJC_CLASS_$_OS_voucher
-#_OBJC_CLASS_$_OS_voucher_recipe
-# non-os_object_t classes
-_OBJC_CLASS_$_OS_dispatch_data
-_OBJC_CLASS_$_OS_dispatch_data_empty
-# metaclasses
-_OBJC_METACLASS_$_OS_dispatch_object
-_OBJC_METACLASS_$_OS_dispatch_semaphore
-_OBJC_METACLASS_$_OS_dispatch_group
-_OBJC_METACLASS_$_OS_dispatch_queue
-_OBJC_METACLASS_$_OS_dispatch_workloop
-_OBJC_METACLASS_$_OS_dispatch_queue_serial
-_OBJC_METACLASS_$_OS_dispatch_queue_concurrent
-_OBJC_METACLASS_$_OS_dispatch_queue_global
-_OBJC_METACLASS_$_OS_dispatch_queue_pthread_root
-_OBJC_METACLASS_$_OS_dispatch_queue_main
-_OBJC_METACLASS_$_OS_dispatch_queue_runloop
-_OBJC_METACLASS_$_OS_dispatch_queue_mgr
-_OBJC_METACLASS_$_OS_dispatch_queue_attr
-_OBJC_METACLASS_$_OS_dispatch_source
-_OBJC_METACLASS_$_OS_dispatch_mach
-_OBJC_METACLASS_$_OS_dispatch_mach_msg
-_OBJC_METACLASS_$_OS_dispatch_io
-_OBJC_METACLASS_$_OS_dispatch_operation
-_OBJC_METACLASS_$_OS_dispatch_disk
-_OBJC_METACLASS_$_OS_object
-_OBJC_METACLASS_$_OS_voucher
-#_OBJC_METACLASS_$_OS_voucher_recipe
-_OBJC_METACLASS_$_OS_dispatch_data
-_OBJC_METACLASS_$_OS_dispatch_data_empty
--- a/Telegram/ThirdParty/dispatch/xcodeconfig/libdispatch-resolved.xcconfig	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/xcodeconfig/libdispatch-resolved.xcconfig	1970-01-01 00:00:00.000000000 -0000
@@ -1,26 +0,0 @@
-//
-// Copyright (c) 2010-2011 Apple Inc. All rights reserved.
-//
-// @APPLE_APACHE_LICENSE_HEADER_START@
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-// @APPLE_APACHE_LICENSE_HEADER_END@
-//
-
-SUPPORTED_PLATFORMS = iphoneos
-PRODUCT_NAME = libdispatch_$(DISPATCH_RESOLVED_VARIANT)
-OTHER_LDFLAGS =
-SKIP_INSTALL = YES
-VERSIONING_SYSTEM =
-EXCLUDED_SOURCE_FILE_NAMES = *
--- a/Telegram/ThirdParty/dispatch/xcodeconfig/libdispatch-resolver.xcconfig	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/xcodeconfig/libdispatch-resolver.xcconfig	1970-01-01 00:00:00.000000000 -0000
@@ -1,20 +0,0 @@
-//
-// Copyright (c) 2010-2011 Apple Inc. All rights reserved.
-//
-// @APPLE_APACHE_LICENSE_HEADER_START@
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-// @APPLE_APACHE_LICENSE_HEADER_END@
-//
-
--- a/Telegram/ThirdParty/dispatch/xcodeconfig/libdispatch.xcconfig	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/xcodeconfig/libdispatch.xcconfig	1970-01-01 00:00:00.000000000 -0000
@@ -1,103 +0,0 @@
-//
-// Copyright (c) 2010-2013 Apple Inc. All rights reserved.
-//
-// @APPLE_APACHE_LICENSE_HEADER_START@
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-// @APPLE_APACHE_LICENSE_HEADER_END@
-//
-
-#include "<DEVELOPER_DIR>/Makefiles/CoreOS/Xcode/BSD.xcconfig"
-#include "<DEVELOPER_DIR>/AppleInternal/XcodeConfig/PlatformSupport.xcconfig"
-
-SDKROOT = macosx.internal
-SUPPORTED_PLATFORMS = macosx iphoneos iphonesimulator appletvos appletvsimulator watchos watchsimulator
-PRODUCT_NAME = libdispatch
-EXECUTABLE_PREFIX =
-INSTALL_PATH = /usr/lib/system
-PUBLIC_HEADERS_FOLDER_PATH = /usr/include/dispatch
-PRIVATE_HEADERS_FOLDER_PATH = /usr/local/include/dispatch
-OS_PUBLIC_HEADERS_FOLDER_PATH = /usr/include/os
-OS_PRIVATE_HEADERS_FOLDER_PATH = /usr/local/include/os
-HEADER_SEARCH_PATHS = $(PROJECT_DIR) $(PROJECT_DIR)/private $(PROJECT_DIR)/src
-LIBRARY_SEARCH_PATHS = $(SDKROOT)/usr/lib/system $(SDKROOT)/usr/local/lib
-INSTALLHDRS_SCRIPT_PHASE = YES
-ALWAYS_SEARCH_USER_PATHS = NO
-USE_HEADERMAP = NO
-BUILD_VARIANTS = normal debug profile
-ONLY_ACTIVE_ARCH = NO
-CLANG_LINK_OBJC_RUNTIME = NO
-GCC_C_LANGUAGE_STANDARD = gnu11
-CLANG_CXX_LANGUAGE_STANDARD = gnu++11
-ENABLE_STRICT_OBJC_MSGSEND = YES
-GCC_ENABLE_CPP_EXCEPTIONS = NO
-GCC_STRICT_ALIASING = YES
-GCC_SYMBOLS_PRIVATE_EXTERN = YES
-GCC_ENABLE_PASCAL_STRINGS = NO
-GCC_WARN_SHADOW = YES
-GCC_WARN_64_TO_32_BIT_CONVERSION = YES
-GCC_WARN_ABOUT_RETURN_TYPE = YES
-GCC_WARN_ABOUT_MISSING_PROTOTYPES = YES
-GCC_WARN_ABOUT_MISSING_NEWLINE = YES
-GCC_WARN_ABOUT_MISSING_FIELD_INITIALIZERS = YES
-GCC_WARN_INITIALIZER_NOT_FULLY_BRACKETED = YES
-GCC_WARN_SIGN_COMPARE = YES
-GCC_WARN_STRICT_SELECTOR_MATCH = YES
-GCC_WARN_UNDECLARED_SELECTOR = YES
-GCC_WARN_UNINITIALIZED_AUTOS = YES
-GCC_WARN_UNKNOWN_PRAGMAS = YES
-GCC_WARN_UNUSED_FUNCTION = YES
-GCC_WARN_UNUSED_LABEL = YES
-GCC_WARN_UNUSED_PARAMETER = YES
-GCC_WARN_UNUSED_VARIABLE = YES
-CLANG_WARN_ASSIGN_ENUM = YES
-CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES
-CLANG_WARN_DOCUMENTATION_COMMENTS = YES
-CLANG_WARN__DUPLICATE_METHOD_MATCH = YES
-CLANG_WARN_EMPTY_BODY = YES
-CLANG_WARN_IMPLICIT_SIGN_CONVERSION = YES
-CLANG_WARN_INFINITE_RECURSION = YES
-CLANG_WARN_OBJC_IMPLICIT_ATOMIC_PROPERTIES = YES
-CLANG_WARN_OBJC_MISSING_PROPERTY_SYNTHESIS = YES
-CLANG_WARN_SUSPICIOUS_IMPLICIT_CONVERSION = YES
-CLANG_WARN_SUSPICIOUS_MOVE = YES
-CLANG_WARN_UNREACHABLE_CODE = YES
-CLANG_WARN_UNGUARDED_AVAILABILITY = YES
-GCC_TREAT_WARNINGS_AS_ERRORS = YES
-GCC_OPTIMIZATION_LEVEL = s
-GCC_NO_COMMON_BLOCKS = YES
-GCC_PREPROCESSOR_DEFINITIONS = __DARWIN_NON_CANCELABLE=1
-STATICLIB_PREPROCESSOR_DEFINITIONS = DISPATCH_VARIANT_STATIC=1 USE_OBJC=0 DISPATCH_USE_DTRACE=0
-WARNING_CFLAGS = -Wall -Wextra -Warray-bounds-pointer-arithmetic -Watomic-properties -Wcomma -Wconditional-uninitialized -Wcovered-switch-default -Wdate-time -Wdeprecated -Wdouble-promotion -Wduplicate-enum -Wexpansion-to-defined -Wfloat-equal -Widiomatic-parentheses -Wignored-qualifiers -Wnullable-to-nonnull-conversion -Wobjc-interface-ivars -Wover-aligned -Wpacked -Wpointer-arith -Wselector -Wstatic-in-inline -Wsuper-class-method-mismatch -Wswitch-enum -Wtautological-compare -Wunused -Wno-unknown-warning-option $(NO_WARNING_CFLAGS)
-NO_WARNING_CFLAGS = -Wno-pedantic -Wno-bad-function-cast -Wno-c++-compat -Wno-c++98-compat -Wno-c++98-compat-pedantic -Wno-cast-align -Wno-cast-qual -Wno-disabled-macro-expansion -Wno-documentation-unknown-command -Wno-format-nonliteral -Wno-missing-variable-declarations -Wno-old-style-cast -Wno-padded -Wno-reserved-id-macro -Wno-shift-sign-overflow -Wno-undef -Wno-unreachable-code-aggressive -Wno-unused-macros -Wno-used-but-marked-unused -Wno-vla -Wno-unguarded-availability-new
-OTHER_CFLAGS = -fverbose-asm -isystem $(SDKROOT)/System/Library/Frameworks/System.framework/PrivateHeaders $(PLATFORM_CFLAGS)
-OTHER_CFLAGS[arch=i386][sdk=macosx*] = $(OTHER_CFLAGS) -fno-unwind-tables -fno-asynchronous-unwind-tables -fno-exceptions
-OTHER_CFLAGS_normal = -momit-leaf-frame-pointer
-OTHER_CFLAGS_profile = $(OTHER_CFLAGS_normal) -DDISPATCH_PROFILE=1 -DDISPATCH_PERF_MON=1
-OTHER_CFLAGS_debug = -fstack-protector -fno-inline -O0 -DDISPATCH_DEBUG=1 -DOS_DEBUG=1
-GENERATE_PROFILING_CODE = NO
-DYLIB_CURRENT_VERSION = $(CURRENT_PROJECT_VERSION)
-SIM_SUFFIX[sdk=*simulator*] = _sim
-DYLIB_LDFLAGS = -umbrella System -nodefaultlibs -ldyld -lcompiler_rt -lsystem$(SIM_SUFFIX)_kernel -lsystem$(SIM_SUFFIX)_platform -lsystem$(SIM_SUFFIX)_pthread -lsystem_malloc -lsystem_c -lsystem_blocks -lunwind
-OBJC_LDFLAGS = -Wl,-upward-lobjc
-LIBDARWIN_LDFLAGS = -Wl,-upward-lsystem_darwin
-LIBDARWIN_LDFLAGS[sdk=*simulator*] =
-ORDER_LDFLAGS = -Wl,-order_file,$(SRCROOT)/xcodeconfig/libdispatch.order -Wl,-dirty_data_list,$(SRCROOT)/xcodeconfig/libdispatch.dirty
-ORDER_LDFLAGS[sdk=macosx*] = -Wl,-order_file,$(SRCROOT)/xcodeconfig/libdispatch.order
-ALIASES_LDFLAGS = -Wl,-alias_list,$(SRCROOT)/xcodeconfig/libdispatch.aliases
-OTHER_LDFLAGS = $(OTHER_LDFLAGS) $(LIBDARWIN_LDFLAGS) $(DYLIB_LDFLAGS) $(CR_LDFLAGS) $(OBJC_LDFLAGS) $(ALIASES_LDFLAGS) $(PLATFORM_LDFLAGS) $(ORDER_LDFLAGS)
-OTHER_MIGFLAGS = -novouchers
-
-COPY_HEADERS_RUN_UNIFDEF = YES
-COPY_HEADERS_UNIFDEF_FLAGS = -U__DISPATCH_BUILDING_DISPATCH__ -U__linux__ -DTARGET_OS_WIN32=0 -U__ANDROID__
--- a/Telegram/ThirdParty/dispatch/xcodeconfig/libfirehose_kernel.xcconfig	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/xcodeconfig/libfirehose_kernel.xcconfig	1970-01-01 00:00:00.000000000 -0000
@@ -1,37 +0,0 @@
-//
-// Copyright (c) 2015 Apple Inc. All rights reserved.
-//
-// @APPLE_APACHE_LICENSE_HEADER_START@
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-// @APPLE_APACHE_LICENSE_HEADER_END@
-//
-
-SUPPORTED_PLATFORMS = macosx iphoneos appletvos watchos
-PRODUCT_NAME = $(TARGET_NAME)
-INSTALL_PATH = /usr/local/lib/kernel/
-GCC_PREPROCESSOR_DEFINITIONS = $(GCC_PREPROCESSOR_DEFINITIONS) KERNEL=1 DISPATCH_USE_DTRACE=0
-OTHER_MIGFLAGS = -novouchers
-OTHER_LDFLAGS =
-OTHER_CFLAGS = -mkernel -nostdinc -Wno-packed
-PUBLIC_HEADERS_FOLDER_PATH = /usr/include/os
-PRIVATE_HEADERS_FOLDER_PATH = /usr/local/include/kernel/os
-HEADER_SEARCH_PATHS = $(PROJECT_DIR) $(SDKROOT)/System/Library/Frameworks/Kernel.framework/PrivateHeaders $(SDKROOT)/System/Library/Frameworks/Kernel.framework/Headers $(SDKROOT)/usr/local/include/os $(SDKROOT)/usr/local/include/firehose
-STRIP_INSTALLED_PRODUCT = NO
-COPY_PHASE_STRIP = NO
-SEPARATE_STRIP = NO
-VALID_ARCHS[sdk=macosx*] = $(NATIVE_ARCH_ACTUAL)
-
-COPY_HEADERS_RUN_UNIFDEF = YES
-COPY_HEADERS_UNIFDEF_FLAGS = -DKERNEL=1 -DOS_FIREHOSE_SPI=1 -DOS_VOUCHER_ACTIVITY_SPI_TYPES=1 -UOS_VOUCHER_ACTIVITY_SPI
--- a/Telegram/ThirdParty/dispatch/xcodeconfig/libfirehose.xcconfig	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/xcodeconfig/libfirehose.xcconfig	1970-01-01 00:00:00.000000000 -0000
@@ -1,35 +0,0 @@
-//
-// Copyright (c) 2015 Apple Inc. All rights reserved.
-//
-// @APPLE_APACHE_LICENSE_HEADER_START@
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-// @APPLE_APACHE_LICENSE_HEADER_END@
-//
-
-SUPPORTED_PLATFORMS = macosx iphoneos iphonesimulator appletvos appletvsimulator watchos watchsimulator
-PRODUCT_NAME = $(TARGET_NAME)
-INSTALL_PATH = /usr/local/lib/
-GCC_PREPROCESSOR_DEFINITIONS = $(GCC_PREPROCESSOR_DEFINITIONS) FIREHOSE_SERVER=1 DISPATCH_USE_DTRACE=0
-OTHER_MIGFLAGS = -novouchers
-OTHER_LDFLAGS =
-PUBLIC_HEADERS_FOLDER_PATH = /usr/include/os
-PRIVATE_HEADERS_FOLDER_PATH = /usr/local/include/os
-STRIP_INSTALLED_PRODUCT = NO
-COPY_PHASE_STRIP = NO
-SEPARATE_STRIP = NO
-VALID_ARCHS[sdk=macosx*] = $(NATIVE_ARCH_ACTUAL)
-
-COPY_HEADERS_RUN_UNIFDEF = YES
-COPY_HEADERS_UNIFDEF_FLAGS = -UKERNEL
--- a/Telegram/ThirdParty/dispatch/xcodescripts/check-order.sh	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/xcodescripts/check-order.sh	1970-01-01 00:00:00.000000000 -0000
@@ -1,90 +0,0 @@
-#!/bin/bash -e
-#
-# Copyright (c) 2018 Apple Inc. All rights reserved.
-#
-# @APPLE_APACHE_LICENSE_HEADER_START@
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-# @APPLE_APACHE_LICENSE_HEADER_END@
-#
-
-test "$ACTION" = install || exit 0
-
-list_objc_syms ()
-{
-    nm -arch $1 -nU ${DSTROOT}/usr/lib/system/libdispatch.dylib | grep _OBJC | cut -d' ' -f3
-}
-
-list_mutable_data_syms ()
-{
-    nm -arch $1 -m ${DSTROOT}/usr/lib/system/libdispatch.dylib |grep __DATA|egrep -v '(__const|__crash_info)'|sed 's/^.* //'
-}
-
-list_objc_order ()
-{
-    grep '^_OBJC' "${SCRIPT_INPUT_FILE_0}"
-}
-
-list_dirty_order ()
-{
-    grep '^[^#]' "${SCRIPT_INPUT_FILE_1}"
-}
-
-list_clean_order ()
-{
-    grep '^[^#]' "${SCRIPT_INPUT_FILE_2}"
-}
-
-fail=
-
-case "$PLATFORM_NAME" in
-    *simulator) exit 0;;
-    *) ;;
-esac
-
-if comm -12 <(list_dirty_order | sort) <(list_clean_order | sort) | grep .; then
-    echo 1>&2 "error: *** SYMBOLS CAN'T BE BOTH CLEAN AND DIRTY ***"
-    comm 1>&2 -12 <(list_dirty_order | sort) <(list_clean_order | sort)
-    fail=t
-fi
-
-for arch in $ARCHS; do
-    if test "$PLATFORM_NAME" = macosx -a "$arch" = i386; then
-        continue
-    fi
-
-    if list_mutable_data_syms $arch | sort | uniq -c | grep -qvw 1; then
-        echo 1>&2 "error: *** DUPLICATED SYMBOL NAMES FOR SLICE $arch ***"
-        list_mutable_data_syms $arch | sort | uniq -c | grep -qw 1 1>&2
-        fail=t
-    fi
-
-    if comm -23 <(list_mutable_data_syms $arch | sort) <((list_dirty_order; list_clean_order) | sort) | grep -q .; then
-        echo 1>&2 "error: *** SYMBOLS NOT MARKED CLEAN OR DIRTY FOR SLICE $arch ***"
-        comm 1>&2 -23 <(list_mutable_data_syms $arch | sort) <((list_dirty_order; list_clean_order) | sort)
-        fail=t
-    fi
-
-    if comm -13 <(list_mutable_data_syms $arch | sort) <((list_dirty_order; list_clean_order) | sort) | grep -q .; then
-        echo 1>&2 "warning: *** Found unknown symbols in dirty/clean files for slice $arch ***"
-        comm 1>&2 -13 <(list_mutable_data_syms $arch | sort) <((list_dirty_order; list_clean_order) | sort)
-    fi
-
-    if ! cmp -s <(list_objc_syms $arch) <(list_objc_order); then
-        echo 1>&2 "error: *** SYMBOL ORDER IS NOT WHAT IS EXPECTED FOR SLICE $arch ***"
-        diff 1>&2 -U100 <(list_objc_syms $arch) <(list_objc_order) || fail=t
-    fi
-done
-
-test -z "$fail"
--- a/Telegram/ThirdParty/dispatch/xcodescripts/install-dtrace.sh	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/xcodescripts/install-dtrace.sh	1970-01-01 00:00:00.000000000 -0000
@@ -1,31 +0,0 @@
-#!/bin/bash -e
-#
-# Copyright (c) 2013 Apple Inc. All rights reserved.
-#
-# @APPLE_APACHE_LICENSE_HEADER_START@
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-# @APPLE_APACHE_LICENSE_HEADER_END@
-#
-
-# This check equates to "is macosx or a simulator platform"
-if [ "${PLATFORM_NAME}" == "${DEVICE_PLATFORM_NAME}" ]; then exit 0; fi
-
-if [ "${DEPLOYMENT_LOCATION}" != YES ]; then
-	DSTROOT="${CONFIGURATION_BUILD_DIR}"
-fi
-
-mkdir -p "${DSTROOT}${PUBLIC_HEADERS_FOLDER_PATH}" || true
-cp -X "${SCRIPT_INPUT_FILE_1}" \
-		"${DSTROOT}${PUBLIC_HEADERS_FOLDER_PATH}/${SCRIPT_OUTPUT_FILE_0##/*/}"
--- a/Telegram/ThirdParty/dispatch/xcodescripts/install-headers.sh	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/xcodescripts/install-headers.sh	1970-01-01 00:00:00.000000000 -0000
@@ -1,32 +0,0 @@
-#!/bin/bash -e
-#
-# Copyright (c) 2012 Apple Inc. All rights reserved.
-#
-# @APPLE_APACHE_LICENSE_HEADER_START@
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-# @APPLE_APACHE_LICENSE_HEADER_END@
-#
-
-if [ "${DEPLOYMENT_LOCATION}" != YES ]; then
-	DSTROOT="${CONFIGURATION_BUILD_DIR}"
-fi
-
-mkdir -p "${DSTROOT}${OS_PUBLIC_HEADERS_FOLDER_PATH}" || true
-mkdir -p "${DSTROOT}${OS_PRIVATE_HEADERS_FOLDER_PATH}" || true
-cp -X "${SCRIPT_INPUT_FILE_1}" "${DSTROOT}${OS_PUBLIC_HEADERS_FOLDER_PATH}"
-cp -X "${SCRIPT_INPUT_FILE_2}" "${DSTROOT}${OS_PRIVATE_HEADERS_FOLDER_PATH}"
-cp -X "${SCRIPT_INPUT_FILE_3}" "${DSTROOT}${OS_PRIVATE_HEADERS_FOLDER_PATH}"
-cp -X "${SCRIPT_INPUT_FILE_4}" "${DSTROOT}${OS_PRIVATE_HEADERS_FOLDER_PATH}"
-cp -X "${SCRIPT_INPUT_FILE_5}" "${DSTROOT}${OS_PRIVATE_HEADERS_FOLDER_PATH}"
--- a/Telegram/ThirdParty/dispatch/xcodescripts/install-manpages.sh	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/xcodescripts/install-manpages.sh	1970-01-01 00:00:00.000000000 -0000
@@ -1,108 +0,0 @@
-#!/bin/bash -e
-#
-# Copyright (c) 2010-2012 Apple Inc. All rights reserved.
-#
-# @APPLE_APACHE_LICENSE_HEADER_START@
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-# @APPLE_APACHE_LICENSE_HEADER_END@
-#
-
-if [ "$ACTION" = installhdrs ]; then exit 0; fi
-if [ "${RC_ProjectName%_Sim}" != "${RC_ProjectName}" ]; then exit 0; fi
-
-mkdir -p "$DSTROOT"/usr/share/man/man3 || true
-mkdir -p "$DSTROOT"/usr/local/share/man/man3 || true
-
-# Copy man pages
-cd "$SRCROOT"/man
-BASE_PAGES="dispatch.3 dispatch_after.3 dispatch_api.3 dispatch_apply.3 \
-		dispatch_async.3 dispatch_group_create.3 dispatch_object.3 \
-		dispatch_once.3 dispatch_queue_create.3 dispatch_semaphore_create.3 \
-		dispatch_source_create.3 dispatch_time.3 dispatch_data_create.3 \
-		dispatch_io_create.3 dispatch_io_read.3 dispatch_read.3"
-
-PRIVATE_PAGES="dispatch_benchmark.3"
-
-cp ${BASE_PAGES} "$DSTROOT"/usr/share/man/man3
-cp ${PRIVATE_PAGES} "$DSTROOT"/usr/local/share/man/man3
-
-# Make hard links (lots of hard links)
-
-cd "$DSTROOT"/usr/local/share/man/man3
-ln -f dispatch_benchmark.3 dispatch_benchmark_f.3
-chown ${INSTALL_OWNER}:${INSTALL_GROUP} $PRIVATE_PAGES
-chmod $INSTALL_MODE_FLAG $PRIVATE_PAGES
-
-cd $DSTROOT/usr/share/man/man3
-
-chown ${INSTALL_OWNER}:${INSTALL_GROUP} $BASE_PAGES
-chmod $INSTALL_MODE_FLAG $BASE_PAGES
-
-ln -f dispatch_after.3 dispatch_after_f.3
-ln -f dispatch_apply.3 dispatch_apply_f.3
-ln -f dispatch_once.3 dispatch_once_f.3
-
-for m in dispatch_async_f dispatch_sync dispatch_sync_f; do
-	ln -f dispatch_async.3 ${m}.3
-done
-
-for m in dispatch_group_enter dispatch_group_leave dispatch_group_wait \
-		dispatch_group_async dispatch_group_async_f dispatch_group_notify \
-		dispatch_group_notify_f; do
-	ln -f dispatch_group_create.3 ${m}.3
-done
-
-for m in dispatch_retain dispatch_release dispatch_suspend dispatch_resume dispatch_activate \
-		dispatch_get_context dispatch_set_context dispatch_set_finalizer_f; do
-	ln -f dispatch_object.3 ${m}.3
-done
-
-for m in dispatch_semaphore_signal dispatch_semaphore_wait; do
-	ln -f dispatch_semaphore_create.3 ${m}.3
-done
-
-for m in dispatch_get_current_queue dispatch_main dispatch_get_main_queue \
-		dispatch_get_global_queue dispatch_queue_get_label \
-		dispatch_set_target_queue; do
-	ln -f dispatch_queue_create.3 ${m}.3
-done
-
-for m in dispatch_source_set_event_handler dispatch_source_set_event_handler_f \
-		dispatch_source_set_registration_handler dispatch_source_set_registration_handler_f \
-		dispatch_source_set_cancel_handler dispatch_source_set_cancel_handler_f \
-		dispatch_source_cancel dispatch_source_testcancel \
-		dispatch_source_get_handle dispatch_source_get_mask \
-		dispatch_source_get_data dispatch_source_merge_data \
-		dispatch_source_set_timer; do
-	ln -f dispatch_source_create.3 ${m}.3
-done
-
-ln -f dispatch_time.3 dispatch_walltime.3
-
-for m in dispatch_data_create_concat dispatch_data_create_subrange \
-		dispatch_data_create_map dispatch_data_apply \
-		dispatch_data_copy_region dispatch_data_get_size; do
-	ln -f dispatch_data_create.3 ${m}.3
-done
-
-for m in dispatch_io_create_with_path dispatch_io_set_high_water \
-		dispatch_io_set_low_water dispatch_io_set_interval \
-		dispatch_io_close dispatch_io_barrier; do
-	ln -f dispatch_io_create.3 ${m}.3
-done
-
-ln -f dispatch_io_read.3 dispatch_io_write.3
-
-ln -f dispatch_read.3 dispatch_write.3
--- a/Telegram/ThirdParty/dispatch/xcodescripts/mig-headers.sh	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/xcodescripts/mig-headers.sh	1970-01-01 00:00:00.000000000 -0000
@@ -1,40 +0,0 @@
-#!/bin/bash -e
-#
-# Copyright (c) 2010-2011 Apple Inc. All rights reserved.
-#
-# @APPLE_APACHE_LICENSE_HEADER_START@
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-# @APPLE_APACHE_LICENSE_HEADER_END@
-#
-
-export MIGCC="$(xcrun -find cc)"
-export MIGCOM="$(xcrun -find migcom)"
-export PATH="${PLATFORM_DEVELOPER_BIN_DIR}:${DEVELOPER_BIN_DIR}:${PATH}"
-
-for p in ${HEADER_SEARCH_PATHS}; do
-	OTHER_MIGFLAGS="${OTHER_MIGFLAGS} -I${p}"
-done
-
-for a in ${ARCHS}; do
-	xcrun mig ${OTHER_MIGFLAGS} -arch $a -header "${SCRIPT_OUTPUT_FILE_0}" \
-			-sheader "${SCRIPT_OUTPUT_FILE_1}" -user /dev/null \
-			-server /dev/null "${SCRIPT_INPUT_FILE_0}"
-	xcrun mig ${OTHER_MIGFLAGS} -arch $a -header "${SCRIPT_OUTPUT_FILE_2}" \
-			-sheader "${SCRIPT_OUTPUT_FILE_3}" -user /dev/null \
-			-server /dev/null "${SCRIPT_INPUT_FILE_1}"
-	xcrun mig ${OTHER_MIGFLAGS} -arch $a -header "${SCRIPT_OUTPUT_FILE_4}" \
-			-sheader "${SCRIPT_OUTPUT_FILE_5}" -user /dev/null \
-			-server /dev/null "${SCRIPT_INPUT_FILE_2}"
-done
--- a/Telegram/ThirdParty/dispatch/xcodescripts/postprocess-headers.sh	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/xcodescripts/postprocess-headers.sh	1970-01-01 00:00:00.000000000 -0000
@@ -1,21 +0,0 @@
-#!/bin/bash -e
-#
-# Copyright (c) 2010-2011 Apple Inc. All rights reserved.
-#
-# @APPLE_APACHE_LICENSE_HEADER_START@
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-# @APPLE_APACHE_LICENSE_HEADER_END@
-#
-
--- a/Telegram/ThirdParty/dispatch/xcodescripts/run-on-install.sh	2022-06-06 20:33:13.000000000 -0000
+++ b/Telegram/ThirdParty/dispatch/xcodescripts/run-on-install.sh	1970-01-01 00:00:00.000000000 -0000
@@ -1,26 +0,0 @@
-#!/bin/bash -e
-#
-# Copyright (c) 2016 Apple Inc. All rights reserved.
-#
-# @APPLE_APACHE_LICENSE_HEADER_START@
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-# @APPLE_APACHE_LICENSE_HEADER_END@
-#
-
-if [[ "x${ACTION}" == "xinstall" && "x${SKIP_INSTALL}" == "xNO" ]]; then
-	$@
-else
-	exit 0
-fi
